(self.webpackChunk_ibm_aiops_ui_extension_template=self.webpackChunk_ibm_aiops_ui_extension_template||[]).push([[804],{1804:function(__unused_webpack_module,exports){eval("(function (global, factory) {\n   true ? factory(exports) : 0;\n})(this, function (exports) {\n  'use strict';\n\n  function tokenToString(token) {\n    if (token.text !== undefined && token.text !== '') {\n      return `'${token.type}' with value '${token.text}'`;\n    } else {\n      return `'${token.type}'`;\n    }\n  }\n  class NoParsletFoundError extends Error {\n    constructor(token) {\n      super(`No parslet found for token: ${tokenToString(token)}`);\n      this.token = token;\n      Object.setPrototypeOf(this, NoParsletFoundError.prototype);\n    }\n    getToken() {\n      return this.token;\n    }\n  }\n  class EarlyEndOfParseError extends Error {\n    constructor(token) {\n      super(`The parsing ended early. The next token was: ${tokenToString(token)}`);\n      this.token = token;\n      Object.setPrototypeOf(this, EarlyEndOfParseError.prototype);\n    }\n    getToken() {\n      return this.token;\n    }\n  }\n  class UnexpectedTypeError extends Error {\n    constructor(result, message) {\n      let error = `Unexpected type: '${result.type}'.`;\n      if (message !== undefined) {\n        error += ` Message: ${message}`;\n      }\n      super(error);\n      Object.setPrototypeOf(this, UnexpectedTypeError.prototype);\n    }\n  }\n  // export class UnexpectedTokenError extends Error {\n  //   private expected: Token\n  //   private found: Token\n  //\n  //   constructor (expected: Token, found: Token) {\n  //     super(`The parsing ended early. The next token was: ${tokenToString(token)}`)\n  //\n  //     this.token = token\n  //\n  //     Object.setPrototypeOf(this, EarlyEndOfParseError.prototype)\n  //   }\n  //\n  //   getToken() {\n  //     return this.token\n  //   }\n  // }\n\n  function makePunctuationRule(type) {\n    return text => {\n      if (text.startsWith(type)) {\n        return {\n          type,\n          text: type\n        };\n      } else {\n        return null;\n      }\n    };\n  }\n  function getQuoted(text) {\n    let position = 0;\n    let char;\n    const mark = text[0];\n    let escaped = false;\n    if (mark !== '\\'' && mark !== '\"') {\n      return null;\n    }\n    while (position < text.length) {\n      position++;\n      char = text[position];\n      if (!escaped && char === mark) {\n        position++;\n        break;\n      }\n      escaped = !escaped && char === '\\\\';\n    }\n    if (char !== mark) {\n      throw new Error('Unterminated String');\n    }\n    return text.slice(0, position);\n  }\n  const identifierStartRegex = /[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u;\n  // A hyphen is not technically allowed, but to keep it liberal for now,\n  //  adding it here\n  const identifierContinueRegex = /[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u;\n  function getIdentifier(text) {\n    let char = text[0];\n    if (!identifierStartRegex.test(char)) {\n      return null;\n    }\n    let position = 1;\n    do {\n      char = text[position];\n      if (!identifierContinueRegex.test(char)) {\n        break;\n      }\n      position++;\n    } while (position < text.length);\n    return text.slice(0, position);\n  }\n  // we are a bit more liberal than TypeScript here and allow `NaN`, `Infinity` and `-Infinity`\n  const numberRegex = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))/;\n  function getNumber(text) {\n    var _a, _b;\n    return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n  }\n  const identifierRule = text => {\n    const value = getIdentifier(text);\n    if (value == null) {\n      return null;\n    }\n    return {\n      type: 'Identifier',\n      text: value\n    };\n  };\n  function makeKeyWordRule(type) {\n    return text => {\n      if (!text.startsWith(type)) {\n        return null;\n      }\n      const prepends = text[type.length];\n      if (prepends !== undefined && identifierContinueRegex.test(prepends)) {\n        return null;\n      }\n      return {\n        type,\n        text: type\n      };\n    };\n  }\n  const stringValueRule = text => {\n    const value = getQuoted(text);\n    if (value == null) {\n      return null;\n    }\n    return {\n      type: 'StringValue',\n      text: value\n    };\n  };\n  const eofRule = text => {\n    if (text.length > 0) {\n      return null;\n    }\n    return {\n      type: 'EOF',\n      text: ''\n    };\n  };\n  const numberRule = text => {\n    const value = getNumber(text);\n    if (value === null) {\n      return null;\n    }\n    return {\n      type: 'Number',\n      text: value\n    };\n  };\n  const rules = [eofRule, makePunctuationRule('=>'), makePunctuationRule('('), makePunctuationRule(')'), makePunctuationRule('{'), makePunctuationRule('}'), makePunctuationRule('['), makePunctuationRule(']'), makePunctuationRule('|'), makePunctuationRule('&'), makePunctuationRule('<'), makePunctuationRule('>'), makePunctuationRule(','), makePunctuationRule(';'), makePunctuationRule('*'), makePunctuationRule('?'), makePunctuationRule('!'), makePunctuationRule('='), makePunctuationRule(':'), makePunctuationRule('...'), makePunctuationRule('.'), makePunctuationRule('#'), makePunctuationRule('~'), makePunctuationRule('/'), makePunctuationRule('@'), makeKeyWordRule('undefined'), makeKeyWordRule('null'), makeKeyWordRule('function'), makeKeyWordRule('this'), makeKeyWordRule('new'), makeKeyWordRule('module'), makeKeyWordRule('event'), makeKeyWordRule('external'), makeKeyWordRule('typeof'), makeKeyWordRule('keyof'), makeKeyWordRule('readonly'), makeKeyWordRule('import'), makeKeyWordRule('is'), makeKeyWordRule('in'), makeKeyWordRule('asserts'), numberRule, identifierRule, stringValueRule];\n  const breakingWhitespaceRegex = /^\\s*\\n\\s*/;\n  class Lexer {\n    static create(text) {\n      const current = this.read(text);\n      text = current.text;\n      const next = this.read(text);\n      text = next.text;\n      return new Lexer(text, undefined, current.token, next.token);\n    }\n    constructor(text, previous, current, next) {\n      this.text = '';\n      this.text = text;\n      this.previous = previous;\n      this.current = current;\n      this.next = next;\n    }\n    static read(text) {\n      let startOfLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      startOfLine = startOfLine || breakingWhitespaceRegex.test(text);\n      text = text.trim();\n      for (const rule of rules) {\n        const partial = rule(text);\n        if (partial !== null) {\n          const token = Object.assign(Object.assign({}, partial), {\n            startOfLine\n          });\n          text = text.slice(token.text.length);\n          return {\n            text,\n            token\n          };\n        }\n      }\n      throw new Error('Unexpected Token ' + text);\n    }\n    advance() {\n      const next = Lexer.read(this.text);\n      return new Lexer(next.text, this.current, this.next, next.token);\n    }\n  }\n\n  /**\n   * Throws an error if the provided result is not a {@link RootResult}\n   */\n  function assertRootResult(result) {\n    if (result === undefined) {\n      throw new Error('Unexpected undefined');\n    }\n    if (result.type === 'JsdocTypeKeyValue' || result.type === 'JsdocTypeParameterList' || result.type === 'JsdocTypeProperty' || result.type === 'JsdocTypeReadonlyProperty' || result.type === 'JsdocTypeObjectField' || result.type === 'JsdocTypeJsdocObjectField' || result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType') {\n      throw new UnexpectedTypeError(result);\n    }\n    return result;\n  }\n  function assertPlainKeyValueOrRootResult(result) {\n    if (result.type === 'JsdocTypeKeyValue') {\n      return assertPlainKeyValueResult(result);\n    }\n    return assertRootResult(result);\n  }\n  function assertPlainKeyValueOrNameResult(result) {\n    if (result.type === 'JsdocTypeName') {\n      return result;\n    }\n    return assertPlainKeyValueResult(result);\n  }\n  function assertPlainKeyValueResult(result) {\n    if (result.type !== 'JsdocTypeKeyValue') {\n      throw new UnexpectedTypeError(result);\n    }\n    return result;\n  }\n  function assertNumberOrVariadicNameResult(result) {\n    var _a;\n    if (result.type === 'JsdocTypeVariadic') {\n      if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === 'JsdocTypeName') {\n        return result;\n      }\n      throw new UnexpectedTypeError(result);\n    }\n    if (result.type !== 'JsdocTypeNumber' && result.type !== 'JsdocTypeName') {\n      throw new UnexpectedTypeError(result);\n    }\n    return result;\n  }\n  function isSquaredProperty(result) {\n    return result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType';\n  }\n\n  // higher precedence = higher importance\n  var Precedence;\n  (function (Precedence) {\n    Precedence[Precedence[\"ALL\"] = 0] = \"ALL\";\n    Precedence[Precedence[\"PARAMETER_LIST\"] = 1] = \"PARAMETER_LIST\";\n    Precedence[Precedence[\"OBJECT\"] = 2] = \"OBJECT\";\n    Precedence[Precedence[\"KEY_VALUE\"] = 3] = \"KEY_VALUE\";\n    Precedence[Precedence[\"INDEX_BRACKETS\"] = 4] = \"INDEX_BRACKETS\";\n    Precedence[Precedence[\"UNION\"] = 5] = \"UNION\";\n    Precedence[Precedence[\"INTERSECTION\"] = 6] = \"INTERSECTION\";\n    Precedence[Precedence[\"PREFIX\"] = 7] = \"PREFIX\";\n    Precedence[Precedence[\"INFIX\"] = 8] = \"INFIX\";\n    Precedence[Precedence[\"TUPLE\"] = 9] = \"TUPLE\";\n    Precedence[Precedence[\"SYMBOL\"] = 10] = \"SYMBOL\";\n    Precedence[Precedence[\"OPTIONAL\"] = 11] = \"OPTIONAL\";\n    Precedence[Precedence[\"NULLABLE\"] = 12] = \"NULLABLE\";\n    Precedence[Precedence[\"KEY_OF_TYPE_OF\"] = 13] = \"KEY_OF_TYPE_OF\";\n    Precedence[Precedence[\"FUNCTION\"] = 14] = \"FUNCTION\";\n    Precedence[Precedence[\"ARROW\"] = 15] = \"ARROW\";\n    Precedence[Precedence[\"ARRAY_BRACKETS\"] = 16] = \"ARRAY_BRACKETS\";\n    Precedence[Precedence[\"GENERIC\"] = 17] = \"GENERIC\";\n    Precedence[Precedence[\"NAME_PATH\"] = 18] = \"NAME_PATH\";\n    Precedence[Precedence[\"PARENTHESIS\"] = 19] = \"PARENTHESIS\";\n    Precedence[Precedence[\"SPECIAL_TYPES\"] = 20] = \"SPECIAL_TYPES\";\n  })(Precedence || (Precedence = {}));\n  class Parser {\n    constructor(grammar, textOrLexer, baseParser) {\n      this.grammar = grammar;\n      if (typeof textOrLexer === 'string') {\n        this._lexer = Lexer.create(textOrLexer);\n      } else {\n        this._lexer = textOrLexer;\n      }\n      this.baseParser = baseParser;\n    }\n    get lexer() {\n      return this._lexer;\n    }\n    /**\n     * Parses a given string and throws an error if the parse ended before the end of the string.\n     */\n    parse() {\n      const result = this.parseType(Precedence.ALL);\n      if (this.lexer.current.type !== 'EOF') {\n        throw new EarlyEndOfParseError(this.lexer.current);\n      }\n      return result;\n    }\n    /**\n     * Parses with the current lexer and asserts that the result is a {@link RootResult}.\n     */\n    parseType(precedence) {\n      return assertRootResult(this.parseIntermediateType(precedence));\n    }\n    /**\n     * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues\n     * to parse the state in the infix step.\n     */\n    parseIntermediateType(precedence) {\n      const result = this.tryParslets(null, precedence);\n      if (result === null) {\n        throw new NoParsletFoundError(this.lexer.current);\n      }\n      return this.parseInfixIntermediateType(result, precedence);\n    }\n    /**\n     * In the infix parsing step the parser continues to parse the current state with all parslets until none returns\n     * a result.\n     */\n    parseInfixIntermediateType(left, precedence) {\n      let result = this.tryParslets(left, precedence);\n      while (result !== null) {\n        left = result;\n        result = this.tryParslets(left, precedence);\n      }\n      return left;\n    }\n    /**\n     * Tries to parse the current state with all parslets in the grammar and returns the first non null result.\n     */\n    tryParslets(left, precedence) {\n      for (const parslet of this.grammar) {\n        const result = parslet(this, precedence, left);\n        if (result !== null) {\n          return result;\n        }\n      }\n      return null;\n    }\n    /**\n     * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was\n     * advanced.\n     */\n    consume(types) {\n      if (!Array.isArray(types)) {\n        types = [types];\n      }\n      if (types.includes(this.lexer.current.type)) {\n        this._lexer = this.lexer.advance();\n        return true;\n      } else {\n        return false;\n      }\n    }\n    acceptLexerState(parser) {\n      this._lexer = parser.lexer;\n    }\n  }\n  function isQuestionMarkUnknownType(next) {\n    return next === 'EOF' || next === '|' || next === ',' || next === ')' || next === '>';\n  }\n  const nullableParslet = (parser, precedence, left) => {\n    const type = parser.lexer.current.type;\n    const next = parser.lexer.next.type;\n    const accept = left == null && type === '?' && !isQuestionMarkUnknownType(next) || left != null && type === '?';\n    if (!accept) {\n      return null;\n    }\n    parser.consume('?');\n    if (left == null) {\n      return {\n        type: 'JsdocTypeNullable',\n        element: parser.parseType(Precedence.NULLABLE),\n        meta: {\n          position: 'prefix'\n        }\n      };\n    } else {\n      return {\n        type: 'JsdocTypeNullable',\n        element: assertRootResult(left),\n        meta: {\n          position: 'suffix'\n        }\n      };\n    }\n  };\n  function composeParslet(options) {\n    const parslet = (parser, curPrecedence, left) => {\n      const type = parser.lexer.current.type;\n      const next = parser.lexer.next.type;\n      if (left === null) {\n        if ('parsePrefix' in options) {\n          if (options.accept(type, next)) {\n            return options.parsePrefix(parser);\n          }\n        }\n      } else {\n        if ('parseInfix' in options) {\n          if (options.precedence > curPrecedence && options.accept(type, next)) {\n            return options.parseInfix(parser, left);\n          }\n        }\n      }\n      return null;\n    };\n    // for debugging\n    Object.defineProperty(parslet, 'name', {\n      value: options.name\n    });\n    return parslet;\n  }\n  const optionalParslet = composeParslet({\n    name: 'optionalParslet',\n    accept: type => type === '=',\n    precedence: Precedence.OPTIONAL,\n    parsePrefix: parser => {\n      parser.consume('=');\n      return {\n        type: 'JsdocTypeOptional',\n        element: parser.parseType(Precedence.OPTIONAL),\n        meta: {\n          position: 'prefix'\n        }\n      };\n    },\n    parseInfix: (parser, left) => {\n      parser.consume('=');\n      return {\n        type: 'JsdocTypeOptional',\n        element: assertRootResult(left),\n        meta: {\n          position: 'suffix'\n        }\n      };\n    }\n  });\n  const numberParslet = composeParslet({\n    name: 'numberParslet',\n    accept: type => type === 'Number',\n    parsePrefix: parser => {\n      const value = parseFloat(parser.lexer.current.text);\n      parser.consume('Number');\n      return {\n        type: 'JsdocTypeNumber',\n        value\n      };\n    }\n  });\n  const parenthesisParslet = composeParslet({\n    name: 'parenthesisParslet',\n    accept: type => type === '(',\n    parsePrefix: parser => {\n      parser.consume('(');\n      if (parser.consume(')')) {\n        return {\n          type: 'JsdocTypeParameterList',\n          elements: []\n        };\n      }\n      const result = parser.parseIntermediateType(Precedence.ALL);\n      if (!parser.consume(')')) {\n        throw new Error('Unterminated parenthesis');\n      }\n      if (result.type === 'JsdocTypeParameterList') {\n        return result;\n      } else if (result.type === 'JsdocTypeKeyValue') {\n        return {\n          type: 'JsdocTypeParameterList',\n          elements: [result]\n        };\n      }\n      return {\n        type: 'JsdocTypeParenthesis',\n        element: assertRootResult(result)\n      };\n    }\n  });\n  const specialTypesParslet = composeParslet({\n    name: 'specialTypesParslet',\n    accept: (type, next) => type === '?' && isQuestionMarkUnknownType(next) || type === 'null' || type === 'undefined' || type === '*',\n    parsePrefix: parser => {\n      if (parser.consume('null')) {\n        return {\n          type: 'JsdocTypeNull'\n        };\n      }\n      if (parser.consume('undefined')) {\n        return {\n          type: 'JsdocTypeUndefined'\n        };\n      }\n      if (parser.consume('*')) {\n        return {\n          type: 'JsdocTypeAny'\n        };\n      }\n      if (parser.consume('?')) {\n        return {\n          type: 'JsdocTypeUnknown'\n        };\n      }\n      throw new Error('Unacceptable token: ' + parser.lexer.current.text);\n    }\n  });\n  const notNullableParslet = composeParslet({\n    name: 'notNullableParslet',\n    accept: type => type === '!',\n    precedence: Precedence.NULLABLE,\n    parsePrefix: parser => {\n      parser.consume('!');\n      return {\n        type: 'JsdocTypeNotNullable',\n        element: parser.parseType(Precedence.NULLABLE),\n        meta: {\n          position: 'prefix'\n        }\n      };\n    },\n    parseInfix: (parser, left) => {\n      parser.consume('!');\n      return {\n        type: 'JsdocTypeNotNullable',\n        element: assertRootResult(left),\n        meta: {\n          position: 'suffix'\n        }\n      };\n    }\n  });\n  function createParameterListParslet(_ref) {\n    let {\n      allowTrailingComma\n    } = _ref;\n    return composeParslet({\n      name: 'parameterListParslet',\n      accept: type => type === ',',\n      precedence: Precedence.PARAMETER_LIST,\n      parseInfix: (parser, left) => {\n        const elements = [assertPlainKeyValueOrRootResult(left)];\n        parser.consume(',');\n        do {\n          try {\n            const next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);\n            elements.push(assertPlainKeyValueOrRootResult(next));\n          } catch (e) {\n            if (allowTrailingComma && e instanceof NoParsletFoundError) {\n              break;\n            } else {\n              throw e;\n            }\n          }\n        } while (parser.consume(','));\n        if (elements.length > 0 && elements.slice(0, -1).some(e => e.type === 'JsdocTypeVariadic')) {\n          throw new Error('Only the last parameter may be a rest parameter');\n        }\n        return {\n          type: 'JsdocTypeParameterList',\n          elements\n        };\n      }\n    });\n  }\n  const genericParslet = composeParslet({\n    name: 'genericParslet',\n    accept: (type, next) => type === '<' || type === '.' && next === '<',\n    precedence: Precedence.GENERIC,\n    parseInfix: (parser, left) => {\n      const dot = parser.consume('.');\n      parser.consume('<');\n      const objects = [];\n      do {\n        objects.push(parser.parseType(Precedence.PARAMETER_LIST));\n      } while (parser.consume(','));\n      if (!parser.consume('>')) {\n        throw new Error('Unterminated generic parameter list');\n      }\n      return {\n        type: 'JsdocTypeGeneric',\n        left: assertRootResult(left),\n        elements: objects,\n        meta: {\n          brackets: 'angle',\n          dot\n        }\n      };\n    }\n  });\n  const unionParslet = composeParslet({\n    name: 'unionParslet',\n    accept: type => type === '|',\n    precedence: Precedence.UNION,\n    parseInfix: (parser, left) => {\n      parser.consume('|');\n      const elements = [];\n      do {\n        elements.push(parser.parseType(Precedence.UNION));\n      } while (parser.consume('|'));\n      return {\n        type: 'JsdocTypeUnion',\n        elements: [assertRootResult(left), ...elements]\n      };\n    }\n  });\n  const baseGrammar = [nullableParslet, optionalParslet, numberParslet, parenthesisParslet, specialTypesParslet, notNullableParslet, createParameterListParslet({\n    allowTrailingComma: true\n  }), genericParslet, unionParslet, optionalParslet];\n  function createNamePathParslet(_ref2) {\n    let {\n      allowSquareBracketsOnAnyType,\n      allowJsdocNamePaths,\n      pathGrammar\n    } = _ref2;\n    return function namePathParslet(parser, precedence, left) {\n      if (left == null || precedence >= Precedence.NAME_PATH) {\n        return null;\n      }\n      const type = parser.lexer.current.type;\n      const next = parser.lexer.next.type;\n      const accept = type === '.' && next !== '<' || type === '[' && (allowSquareBracketsOnAnyType || left.type === 'JsdocTypeName') || allowJsdocNamePaths && (type === '~' || type === '#');\n      if (!accept) {\n        return null;\n      }\n      let pathType;\n      let brackets = false;\n      if (parser.consume('.')) {\n        pathType = 'property';\n      } else if (parser.consume('[')) {\n        pathType = 'property-brackets';\n        brackets = true;\n      } else if (parser.consume('~')) {\n        pathType = 'inner';\n      } else {\n        parser.consume('#');\n        pathType = 'instance';\n      }\n      const pathParser = pathGrammar !== null ? new Parser(pathGrammar, parser.lexer, parser) : parser;\n      const parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);\n      parser.acceptLexerState(pathParser);\n      let right;\n      switch (parsed.type) {\n        case 'JsdocTypeName':\n          right = {\n            type: 'JsdocTypeProperty',\n            value: parsed.value,\n            meta: {\n              quote: undefined\n            }\n          };\n          break;\n        case 'JsdocTypeNumber':\n          right = {\n            type: 'JsdocTypeProperty',\n            value: parsed.value.toString(10),\n            meta: {\n              quote: undefined\n            }\n          };\n          break;\n        case 'JsdocTypeStringValue':\n          right = {\n            type: 'JsdocTypeProperty',\n            value: parsed.value,\n            meta: {\n              quote: parsed.meta.quote\n            }\n          };\n          break;\n        case 'JsdocTypeSpecialNamePath':\n          if (parsed.specialType === 'event') {\n            right = parsed;\n          } else {\n            throw new UnexpectedTypeError(parsed, 'Type \\'JsdocTypeSpecialNamePath\\' is only allowed with specialType \\'event\\'');\n          }\n          break;\n        default:\n          throw new UnexpectedTypeError(parsed, 'Expecting \\'JsdocTypeName\\', \\'JsdocTypeNumber\\', \\'JsdocStringValue\\' or \\'JsdocTypeSpecialNamePath\\'');\n      }\n      if (brackets && !parser.consume(']')) {\n        const token = parser.lexer.current;\n        throw new Error(`Unterminated square brackets. Next token is '${token.type}' ` + `with text '${token.text}'`);\n      }\n      return {\n        type: 'JsdocTypeNamePath',\n        left: assertRootResult(left),\n        right,\n        pathType\n      };\n    };\n  }\n  function createNameParslet(_ref3) {\n    let {\n      allowedAdditionalTokens\n    } = _ref3;\n    return composeParslet({\n      name: 'nameParslet',\n      accept: type => type === 'Identifier' || type === 'this' || type === 'new' || allowedAdditionalTokens.includes(type),\n      parsePrefix: parser => {\n        const {\n          type,\n          text\n        } = parser.lexer.current;\n        parser.consume(type);\n        return {\n          type: 'JsdocTypeName',\n          value: text\n        };\n      }\n    });\n  }\n  const stringValueParslet = composeParslet({\n    name: 'stringValueParslet',\n    accept: type => type === 'StringValue',\n    parsePrefix: parser => {\n      const text = parser.lexer.current.text;\n      parser.consume('StringValue');\n      return {\n        type: 'JsdocTypeStringValue',\n        value: text.slice(1, -1),\n        meta: {\n          quote: text[0] === '\\'' ? 'single' : 'double'\n        }\n      };\n    }\n  });\n  function createSpecialNamePathParslet(_ref4) {\n    let {\n      pathGrammar,\n      allowedTypes\n    } = _ref4;\n    return composeParslet({\n      name: 'specialNamePathParslet',\n      accept: type => allowedTypes.includes(type),\n      parsePrefix: parser => {\n        const type = parser.lexer.current.type;\n        parser.consume(type);\n        if (!parser.consume(':')) {\n          return {\n            type: 'JsdocTypeName',\n            value: type\n          };\n        }\n        let result;\n        let token = parser.lexer.current;\n        if (parser.consume('StringValue')) {\n          result = {\n            type: 'JsdocTypeSpecialNamePath',\n            value: token.text.slice(1, -1),\n            specialType: type,\n            meta: {\n              quote: token.text[0] === '\\'' ? 'single' : 'double'\n            }\n          };\n        } else {\n          let value = '';\n          const allowed = ['Identifier', '@', '/'];\n          while (allowed.some(type => parser.consume(type))) {\n            value += token.text;\n            token = parser.lexer.current;\n          }\n          result = {\n            type: 'JsdocTypeSpecialNamePath',\n            value,\n            specialType: type,\n            meta: {\n              quote: undefined\n            }\n          };\n        }\n        const moduleParser = new Parser(pathGrammar, parser.lexer, parser);\n        const moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);\n        parser.acceptLexerState(moduleParser);\n        return assertRootResult(moduleResult);\n      }\n    });\n  }\n  const basePathGrammar = [createNameParslet({\n    allowedAdditionalTokens: ['external', 'module']\n  }), stringValueParslet, numberParslet, createNamePathParslet({\n    allowSquareBracketsOnAnyType: false,\n    allowJsdocNamePaths: true,\n    pathGrammar: null\n  })];\n  const pathGrammar = [...basePathGrammar, createSpecialNamePathParslet({\n    allowedTypes: ['event'],\n    pathGrammar: basePathGrammar\n  })];\n  function getParameters(value) {\n    let parameters;\n    if (value.type === 'JsdocTypeParameterList') {\n      parameters = value.elements;\n    } else if (value.type === 'JsdocTypeParenthesis') {\n      parameters = [value.element];\n    } else {\n      throw new UnexpectedTypeError(value);\n    }\n    return parameters.map(p => assertPlainKeyValueOrRootResult(p));\n  }\n  function getUnnamedParameters(value) {\n    const parameters = getParameters(value);\n    if (parameters.some(p => p.type === 'JsdocTypeKeyValue')) {\n      throw new Error('No parameter should be named');\n    }\n    return parameters;\n  }\n  function createFunctionParslet(_ref5) {\n    let {\n      allowNamedParameters,\n      allowNoReturnType,\n      allowWithoutParenthesis,\n      allowNewAsFunctionKeyword\n    } = _ref5;\n    return composeParslet({\n      name: 'functionParslet',\n      accept: (type, next) => type === 'function' || allowNewAsFunctionKeyword && type === 'new' && next === '(',\n      parsePrefix: parser => {\n        const newKeyword = parser.consume('new');\n        parser.consume('function');\n        const hasParenthesis = parser.lexer.current.type === '(';\n        if (!hasParenthesis) {\n          if (!allowWithoutParenthesis) {\n            throw new Error('function is missing parameter list');\n          }\n          return {\n            type: 'JsdocTypeName',\n            value: 'function'\n          };\n        }\n        let result = {\n          type: 'JsdocTypeFunction',\n          parameters: [],\n          arrow: false,\n          constructor: newKeyword,\n          parenthesis: hasParenthesis\n        };\n        const value = parser.parseIntermediateType(Precedence.FUNCTION);\n        if (allowNamedParameters === undefined) {\n          result.parameters = getUnnamedParameters(value);\n        } else if (newKeyword && value.type === 'JsdocTypeFunction' && value.arrow) {\n          result = value;\n          result.constructor = true;\n          return result;\n        } else {\n          result.parameters = getParameters(value);\n          for (const p of result.parameters) {\n            if (p.type === 'JsdocTypeKeyValue' && !allowNamedParameters.includes(p.key)) {\n              throw new Error(`only allowed named parameters are ${allowNamedParameters.join(', ')} but got ${p.type}`);\n            }\n          }\n        }\n        if (parser.consume(':')) {\n          result.returnType = parser.parseType(Precedence.PREFIX);\n        } else {\n          if (!allowNoReturnType) {\n            throw new Error('function is missing return type');\n          }\n        }\n        return result;\n      }\n    });\n  }\n  function createVariadicParslet(_ref6) {\n    let {\n      allowPostfix,\n      allowEnclosingBrackets\n    } = _ref6;\n    return composeParslet({\n      name: 'variadicParslet',\n      accept: type => type === '...',\n      precedence: Precedence.PREFIX,\n      parsePrefix: parser => {\n        parser.consume('...');\n        const brackets = allowEnclosingBrackets && parser.consume('[');\n        try {\n          const element = parser.parseType(Precedence.PREFIX);\n          if (brackets && !parser.consume(']')) {\n            throw new Error('Unterminated variadic type. Missing \\']\\'');\n          }\n          return {\n            type: 'JsdocTypeVariadic',\n            element: assertRootResult(element),\n            meta: {\n              position: 'prefix',\n              squareBrackets: brackets\n            }\n          };\n        } catch (e) {\n          if (e instanceof NoParsletFoundError) {\n            if (brackets) {\n              throw new Error('Empty square brackets for variadic are not allowed.');\n            }\n            return {\n              type: 'JsdocTypeVariadic',\n              meta: {\n                position: undefined,\n                squareBrackets: false\n              }\n            };\n          } else {\n            throw e;\n          }\n        }\n      },\n      parseInfix: allowPostfix ? (parser, left) => {\n        parser.consume('...');\n        return {\n          type: 'JsdocTypeVariadic',\n          element: assertRootResult(left),\n          meta: {\n            position: 'suffix',\n            squareBrackets: false\n          }\n        };\n      } : undefined\n    });\n  }\n  const symbolParslet = composeParslet({\n    name: 'symbolParslet',\n    accept: type => type === '(',\n    precedence: Precedence.SYMBOL,\n    parseInfix: (parser, left) => {\n      if (left.type !== 'JsdocTypeName') {\n        throw new Error('Symbol expects a name on the left side. (Reacting on \\'(\\')');\n      }\n      parser.consume('(');\n      const result = {\n        type: 'JsdocTypeSymbol',\n        value: left.value\n      };\n      if (!parser.consume(')')) {\n        const next = parser.parseIntermediateType(Precedence.SYMBOL);\n        result.element = assertNumberOrVariadicNameResult(next);\n        if (!parser.consume(')')) {\n          throw new Error('Symbol does not end after value');\n        }\n      }\n      return result;\n    }\n  });\n  const arrayBracketsParslet = composeParslet({\n    name: 'arrayBracketsParslet',\n    precedence: Precedence.ARRAY_BRACKETS,\n    accept: (type, next) => type === '[' && next === ']',\n    parseInfix: (parser, left) => {\n      parser.consume('[');\n      parser.consume(']');\n      return {\n        type: 'JsdocTypeGeneric',\n        left: {\n          type: 'JsdocTypeName',\n          value: 'Array'\n        },\n        elements: [assertRootResult(left)],\n        meta: {\n          brackets: 'square',\n          dot: false\n        }\n      };\n    }\n  });\n  function createObjectParslet(_ref7) {\n    let {\n      objectFieldGrammar,\n      allowKeyTypes\n    } = _ref7;\n    return composeParslet({\n      name: 'objectParslet',\n      accept: type => type === '{',\n      parsePrefix: parser => {\n        parser.consume('{');\n        const result = {\n          type: 'JsdocTypeObject',\n          meta: {\n            separator: 'comma'\n          },\n          elements: []\n        };\n        if (!parser.consume('}')) {\n          let separator;\n          const fieldParser = new Parser(objectFieldGrammar, parser.lexer, parser);\n          while (true) {\n            fieldParser.acceptLexerState(parser);\n            let field = fieldParser.parseIntermediateType(Precedence.OBJECT);\n            parser.acceptLexerState(fieldParser);\n            if (field === undefined && allowKeyTypes) {\n              field = parser.parseIntermediateType(Precedence.OBJECT);\n            }\n            let optional = false;\n            if (field.type === 'JsdocTypeNullable') {\n              optional = true;\n              field = field.element;\n            }\n            if (field.type === 'JsdocTypeNumber' || field.type === 'JsdocTypeName' || field.type === 'JsdocTypeStringValue') {\n              let quote;\n              if (field.type === 'JsdocTypeStringValue') {\n                quote = field.meta.quote;\n              }\n              result.elements.push({\n                type: 'JsdocTypeObjectField',\n                key: field.value.toString(),\n                right: undefined,\n                optional,\n                readonly: false,\n                meta: {\n                  quote\n                }\n              });\n            } else if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {\n              result.elements.push(field);\n            } else {\n              throw new UnexpectedTypeError(field);\n            }\n            if (parser.lexer.current.startOfLine) {\n              separator = 'linebreak';\n            } else if (parser.consume(',')) {\n              separator = 'comma';\n            } else if (parser.consume(';')) {\n              separator = 'semicolon';\n            } else {\n              break;\n            }\n            const type = parser.lexer.current.type;\n            if (type === '}') {\n              break;\n            }\n          }\n          result.meta.separator = separator !== null && separator !== void 0 ? separator : 'comma'; // TODO: use undefined here\n          if (!parser.consume('}')) {\n            throw new Error('Unterminated record type. Missing \\'}\\'');\n          }\n        }\n        return result;\n      }\n    });\n  }\n  function createObjectFieldParslet(_ref8) {\n    let {\n      allowSquaredProperties,\n      allowKeyTypes,\n      allowReadonly,\n      allowOptional\n    } = _ref8;\n    return composeParslet({\n      name: 'objectFieldParslet',\n      precedence: Precedence.KEY_VALUE,\n      accept: type => type === ':',\n      parseInfix: (parser, left) => {\n        var _a;\n        let optional = false;\n        let readonlyProperty = false;\n        if (allowOptional && left.type === 'JsdocTypeNullable') {\n          optional = true;\n          left = left.element;\n        }\n        if (allowReadonly && left.type === 'JsdocTypeReadonlyProperty') {\n          readonlyProperty = true;\n          left = left.element;\n        }\n        // object parslet uses a special grammar and for the value we want to switch back to the parent\n        const parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;\n        parentParser.acceptLexerState(parser);\n        if (left.type === 'JsdocTypeNumber' || left.type === 'JsdocTypeName' || left.type === 'JsdocTypeStringValue' || isSquaredProperty(left)) {\n          if (isSquaredProperty(left) && !allowSquaredProperties) {\n            throw new UnexpectedTypeError(left);\n          }\n          parentParser.consume(':');\n          let quote;\n          if (left.type === 'JsdocTypeStringValue') {\n            quote = left.meta.quote;\n          }\n          const right = parentParser.parseType(Precedence.KEY_VALUE);\n          parser.acceptLexerState(parentParser);\n          return {\n            type: 'JsdocTypeObjectField',\n            key: isSquaredProperty(left) ? left : left.value.toString(),\n            right,\n            optional,\n            readonly: readonlyProperty,\n            meta: {\n              quote\n            }\n          };\n        } else {\n          if (!allowKeyTypes) {\n            throw new UnexpectedTypeError(left);\n          }\n          parentParser.consume(':');\n          const right = parentParser.parseType(Precedence.KEY_VALUE);\n          parser.acceptLexerState(parentParser);\n          return {\n            type: 'JsdocTypeJsdocObjectField',\n            left: assertRootResult(left),\n            right\n          };\n        }\n      }\n    });\n  }\n  function createKeyValueParslet(_ref9) {\n    let {\n      allowOptional,\n      allowVariadic\n    } = _ref9;\n    return composeParslet({\n      name: 'keyValueParslet',\n      precedence: Precedence.KEY_VALUE,\n      accept: type => type === ':',\n      parseInfix: (parser, left) => {\n        let optional = false;\n        let variadic = false;\n        if (allowOptional && left.type === 'JsdocTypeNullable') {\n          optional = true;\n          left = left.element;\n        }\n        if (allowVariadic && left.type === 'JsdocTypeVariadic' && left.element !== undefined) {\n          variadic = true;\n          left = left.element;\n        }\n        if (left.type !== 'JsdocTypeName') {\n          throw new UnexpectedTypeError(left);\n        }\n        parser.consume(':');\n        const right = parser.parseType(Precedence.KEY_VALUE);\n        return {\n          type: 'JsdocTypeKeyValue',\n          key: left.value,\n          right,\n          optional,\n          variadic\n        };\n      }\n    });\n  }\n  const jsdocBaseGrammar = [...baseGrammar, createFunctionParslet({\n    allowWithoutParenthesis: true,\n    allowNamedParameters: ['this', 'new'],\n    allowNoReturnType: true,\n    allowNewAsFunctionKeyword: false\n  }), stringValueParslet, createSpecialNamePathParslet({\n    allowedTypes: ['module', 'external', 'event'],\n    pathGrammar\n  }), createVariadicParslet({\n    allowEnclosingBrackets: true,\n    allowPostfix: true\n  }), createNameParslet({\n    allowedAdditionalTokens: ['keyof']\n  }), symbolParslet, arrayBracketsParslet, createNamePathParslet({\n    allowSquareBracketsOnAnyType: false,\n    allowJsdocNamePaths: true,\n    pathGrammar\n  })];\n  const jsdocGrammar = [...jsdocBaseGrammar, createObjectParslet({\n    // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here\n    // we leave out the object type deliberately\n    objectFieldGrammar: [createNameParslet({\n      allowedAdditionalTokens: ['module', 'in']\n    }), createObjectFieldParslet({\n      allowSquaredProperties: false,\n      allowKeyTypes: true,\n      allowOptional: false,\n      allowReadonly: false\n    }), ...jsdocBaseGrammar],\n    allowKeyTypes: true\n  }), createKeyValueParslet({\n    allowOptional: true,\n    allowVariadic: true\n  })];\n  const typeOfParslet = composeParslet({\n    name: 'typeOfParslet',\n    accept: type => type === 'typeof',\n    parsePrefix: parser => {\n      parser.consume('typeof');\n      return {\n        type: 'JsdocTypeTypeof',\n        element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n      };\n    }\n  });\n  const objectFieldGrammar$1 = [createNameParslet({\n    allowedAdditionalTokens: ['module', 'keyof', 'event', 'external', 'in']\n  }), nullableParslet, optionalParslet, stringValueParslet, numberParslet, createObjectFieldParslet({\n    allowSquaredProperties: false,\n    allowKeyTypes: false,\n    allowOptional: false,\n    allowReadonly: false\n  })];\n  const closureGrammar = [...baseGrammar, createObjectParslet({\n    allowKeyTypes: false,\n    objectFieldGrammar: objectFieldGrammar$1\n  }), createNameParslet({\n    allowedAdditionalTokens: ['event', 'external', 'in']\n  }), typeOfParslet, createFunctionParslet({\n    allowWithoutParenthesis: false,\n    allowNamedParameters: ['this', 'new'],\n    allowNoReturnType: true,\n    allowNewAsFunctionKeyword: false\n  }), createVariadicParslet({\n    allowEnclosingBrackets: false,\n    allowPostfix: false\n  }),\n  // additional name parslet is needed for some special cases\n  createNameParslet({\n    allowedAdditionalTokens: ['keyof']\n  }), createSpecialNamePathParslet({\n    allowedTypes: ['module'],\n    pathGrammar\n  }), createNamePathParslet({\n    allowSquareBracketsOnAnyType: false,\n    allowJsdocNamePaths: true,\n    pathGrammar\n  }), createKeyValueParslet({\n    allowOptional: false,\n    allowVariadic: false\n  }), symbolParslet];\n  const assertsParslet = composeParslet({\n    name: 'assertsParslet',\n    accept: type => type === 'asserts',\n    parsePrefix: parser => {\n      parser.consume('asserts');\n      const left = parser.parseIntermediateType(Precedence.SYMBOL);\n      if (left.type !== 'JsdocTypeName') {\n        throw new UnexpectedTypeError(left, 'A typescript asserts always has to have a name on the left side.');\n      }\n      parser.consume('is');\n      return {\n        type: 'JsdocTypeAsserts',\n        left,\n        right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n      };\n    }\n  });\n  function createTupleParslet(_ref10) {\n    let {\n      allowQuestionMark\n    } = _ref10;\n    return composeParslet({\n      name: 'tupleParslet',\n      accept: type => type === '[',\n      parsePrefix: parser => {\n        parser.consume('[');\n        const result = {\n          type: 'JsdocTypeTuple',\n          elements: []\n        };\n        if (parser.consume(']')) {\n          return result;\n        }\n        const typeList = parser.parseIntermediateType(Precedence.ALL);\n        if (typeList.type === 'JsdocTypeParameterList') {\n          if (typeList.elements[0].type === 'JsdocTypeKeyValue') {\n            result.elements = typeList.elements.map(assertPlainKeyValueResult);\n          } else {\n            result.elements = typeList.elements.map(assertRootResult);\n          }\n        } else {\n          if (typeList.type === 'JsdocTypeKeyValue') {\n            result.elements = [assertPlainKeyValueResult(typeList)];\n          } else {\n            result.elements = [assertRootResult(typeList)];\n          }\n        }\n        if (!parser.consume(']')) {\n          throw new Error('Unterminated \\'[\\'');\n        }\n        if (!allowQuestionMark && result.elements.some(e => e.type === 'JsdocTypeUnknown')) {\n          throw new Error('Question mark in tuple not allowed');\n        }\n        return result;\n      }\n    });\n  }\n  const keyOfParslet = composeParslet({\n    name: 'keyOfParslet',\n    accept: type => type === 'keyof',\n    parsePrefix: parser => {\n      parser.consume('keyof');\n      return {\n        type: 'JsdocTypeKeyof',\n        element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n      };\n    }\n  });\n  const importParslet = composeParslet({\n    name: 'importParslet',\n    accept: type => type === 'import',\n    parsePrefix: parser => {\n      parser.consume('import');\n      if (!parser.consume('(')) {\n        throw new Error('Missing parenthesis after import keyword');\n      }\n      const path = parser.parseType(Precedence.PREFIX);\n      if (path.type !== 'JsdocTypeStringValue') {\n        throw new Error('Only string values are allowed as paths for imports');\n      }\n      if (!parser.consume(')')) {\n        throw new Error('Missing closing parenthesis after import keyword');\n      }\n      return {\n        type: 'JsdocTypeImport',\n        element: path\n      };\n    }\n  });\n  const readonlyPropertyParslet = composeParslet({\n    name: 'readonlyPropertyParslet',\n    accept: type => type === 'readonly',\n    parsePrefix: parser => {\n      parser.consume('readonly');\n      return {\n        type: 'JsdocTypeReadonlyProperty',\n        element: parser.parseType(Precedence.KEY_VALUE)\n      };\n    }\n  });\n  const arrowFunctionParslet = composeParslet({\n    name: 'arrowFunctionParslet',\n    precedence: Precedence.ARROW,\n    accept: type => type === '=>',\n    parseInfix: (parser, left) => {\n      parser.consume('=>');\n      return {\n        type: 'JsdocTypeFunction',\n        parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),\n        arrow: true,\n        constructor: false,\n        parenthesis: true,\n        returnType: parser.parseType(Precedence.OBJECT)\n      };\n    }\n  });\n  const intersectionParslet = composeParslet({\n    name: 'intersectionParslet',\n    accept: type => type === '&',\n    precedence: Precedence.INTERSECTION,\n    parseInfix: (parser, left) => {\n      parser.consume('&');\n      const elements = [];\n      do {\n        elements.push(parser.parseType(Precedence.INTERSECTION));\n      } while (parser.consume('&'));\n      return {\n        type: 'JsdocTypeIntersection',\n        elements: [assertRootResult(left), ...elements]\n      };\n    }\n  });\n  const predicateParslet = composeParslet({\n    name: 'predicateParslet',\n    precedence: Precedence.INFIX,\n    accept: type => type === 'is',\n    parseInfix: (parser, left) => {\n      if (left.type !== 'JsdocTypeName') {\n        throw new UnexpectedTypeError(left, 'A typescript predicate always has to have a name on the left side.');\n      }\n      parser.consume('is');\n      return {\n        type: 'JsdocTypePredicate',\n        left,\n        right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n      };\n    }\n  });\n  const objectSquaredPropertyParslet = composeParslet({\n    name: 'objectSquareBracketPropertyParslet',\n    accept: type => type === '[',\n    parsePrefix: parser => {\n      if (parser.baseParser === undefined) {\n        throw new Error('Only allowed inside object grammar');\n      }\n      parser.consume('[');\n      const key = parser.lexer.current.text;\n      parser.consume('Identifier');\n      let result;\n      if (parser.consume(':')) {\n        const parentParser = parser.baseParser;\n        parentParser.acceptLexerState(parser);\n        result = {\n          type: 'JsdocTypeIndexSignature',\n          key,\n          right: parentParser.parseType(Precedence.INDEX_BRACKETS)\n        };\n        parser.acceptLexerState(parentParser);\n      } else if (parser.consume('in')) {\n        const parentParser = parser.baseParser;\n        parentParser.acceptLexerState(parser);\n        result = {\n          type: 'JsdocTypeMappedType',\n          key,\n          right: parentParser.parseType(Precedence.ARRAY_BRACKETS)\n        };\n        parser.acceptLexerState(parentParser);\n      } else {\n        throw new Error('Missing \\':\\' or \\'in\\' inside square bracketed property.');\n      }\n      if (!parser.consume(']')) {\n        throw new Error('Unterminated square brackets');\n      }\n      return result;\n    }\n  });\n  const objectFieldGrammar = [readonlyPropertyParslet, createNameParslet({\n    allowedAdditionalTokens: ['module', 'event', 'keyof', 'event', 'external', 'in']\n  }), nullableParslet, optionalParslet, stringValueParslet, numberParslet, createObjectFieldParslet({\n    allowSquaredProperties: true,\n    allowKeyTypes: false,\n    allowOptional: true,\n    allowReadonly: true\n  }), objectSquaredPropertyParslet];\n  const typescriptGrammar = [...baseGrammar, createObjectParslet({\n    allowKeyTypes: false,\n    objectFieldGrammar\n  }), typeOfParslet, keyOfParslet, importParslet, stringValueParslet, createFunctionParslet({\n    allowWithoutParenthesis: true,\n    allowNoReturnType: false,\n    allowNamedParameters: ['this', 'new', 'args'],\n    allowNewAsFunctionKeyword: true\n  }), createTupleParslet({\n    allowQuestionMark: false\n  }), createVariadicParslet({\n    allowEnclosingBrackets: false,\n    allowPostfix: false\n  }), assertsParslet, createNameParslet({\n    allowedAdditionalTokens: ['event', 'external', 'in']\n  }), createSpecialNamePathParslet({\n    allowedTypes: ['module'],\n    pathGrammar\n  }), arrayBracketsParslet, arrowFunctionParslet, createNamePathParslet({\n    allowSquareBracketsOnAnyType: true,\n    allowJsdocNamePaths: false,\n    pathGrammar\n  }), intersectionParslet, predicateParslet, createKeyValueParslet({\n    allowVariadic: true,\n    allowOptional: true\n  })];\n\n  /**\n   * This function parses the given expression in the given mode and produces a {@link RootResult}.\n   * @param expression\n   * @param mode\n   */\n  function parse(expression, mode) {\n    switch (mode) {\n      case 'closure':\n        return new Parser(closureGrammar, expression).parse();\n      case 'jsdoc':\n        return new Parser(jsdocGrammar, expression).parse();\n      case 'typescript':\n        return new Parser(typescriptGrammar, expression).parse();\n    }\n  }\n  /**\n   * This function tries to parse the given expression in multiple modes and returns the first successful\n   * {@link RootResult}. By default it tries `'typescript'`, `'closure'` and `'jsdoc'` in this order. If\n   * no mode was successful it throws the error that was produced by the last parsing attempt.\n   * @param expression\n   * @param modes\n   */\n  function tryParse(expression) {\n    let modes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['typescript', 'closure', 'jsdoc'];\n    let error;\n    for (const mode of modes) {\n      try {\n        return parse(expression, mode);\n      } catch (e) {\n        error = e;\n      }\n    }\n    throw error;\n  }\n  function transform(rules, parseResult) {\n    const rule = rules[parseResult.type];\n    if (rule === undefined) {\n      throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);\n    }\n    return rule(parseResult, aParseResult => transform(rules, aParseResult));\n  }\n  function notAvailableTransform(parseResult) {\n    throw new Error('This transform is not available. Are you trying the correct parsing mode?');\n  }\n  function extractSpecialParams(source) {\n    const result = {\n      params: []\n    };\n    for (const param of source.parameters) {\n      if (param.type === 'JsdocTypeKeyValue') {\n        if (param.key === 'this') {\n          result.this = param.right;\n        } else if (param.key === 'new') {\n          result.new = param.right;\n        } else {\n          result.params.push(param);\n        }\n      } else {\n        result.params.push(param);\n      }\n    }\n    return result;\n  }\n  function applyPosition(position, target, value) {\n    return position === 'prefix' ? value + target : target + value;\n  }\n  function quote(value, quote) {\n    switch (quote) {\n      case 'double':\n        return `\"${value}\"`;\n      case 'single':\n        return `'${value}'`;\n      case undefined:\n        return value;\n    }\n  }\n  function stringifyRules() {\n    return {\n      JsdocTypeParenthesis: (result, transform) => `(${result.element !== undefined ? transform(result.element) : ''})`,\n      JsdocTypeKeyof: (result, transform) => `keyof ${transform(result.element)}`,\n      JsdocTypeFunction: (result, transform) => {\n        if (!result.arrow) {\n          let stringified = result.constructor ? 'new' : 'function';\n          if (!result.parenthesis) {\n            return stringified;\n          }\n          stringified += `(${result.parameters.map(transform).join(', ')})`;\n          if (result.returnType !== undefined) {\n            stringified += `: ${transform(result.returnType)}`;\n          }\n          return stringified;\n        } else {\n          if (result.returnType === undefined) {\n            throw new Error('Arrow function needs a return type.');\n          }\n          let stringified = `(${result.parameters.map(transform).join(', ')}) => ${transform(result.returnType)}`;\n          if (result.constructor) {\n            stringified = 'new ' + stringified;\n          }\n          return stringified;\n        }\n      },\n      JsdocTypeName: result => result.value,\n      JsdocTypeTuple: (result, transform) => `[${result.elements.map(transform).join(', ')}]`,\n      JsdocTypeVariadic: (result, transform) => result.meta.position === undefined ? '...' : applyPosition(result.meta.position, transform(result.element), '...'),\n      JsdocTypeNamePath: (result, transform) => {\n        const left = transform(result.left);\n        const right = transform(result.right);\n        switch (result.pathType) {\n          case 'inner':\n            return `${left}~${right}`;\n          case 'instance':\n            return `${left}#${right}`;\n          case 'property':\n            return `${left}.${right}`;\n          case 'property-brackets':\n            return `${left}[${right}]`;\n        }\n      },\n      JsdocTypeStringValue: result => quote(result.value, result.meta.quote),\n      JsdocTypeAny: () => '*',\n      JsdocTypeGeneric: (result, transform) => {\n        if (result.meta.brackets === 'square') {\n          const element = result.elements[0];\n          const transformed = transform(element);\n          if (element.type === 'JsdocTypeUnion' || element.type === 'JsdocTypeIntersection') {\n            return `(${transformed})[]`;\n          } else {\n            return `${transformed}[]`;\n          }\n        } else {\n          return `${transform(result.left)}${result.meta.dot ? '.' : ''}<${result.elements.map(transform).join(', ')}>`;\n        }\n      },\n      JsdocTypeImport: (result, transform) => `import(${transform(result.element)})`,\n      JsdocTypeObjectField: (result, transform) => {\n        let text = '';\n        if (result.readonly) {\n          text += 'readonly ';\n        }\n        if (typeof result.key === 'string') {\n          text += quote(result.key, result.meta.quote);\n        } else {\n          text += transform(result.key);\n        }\n        if (result.optional) {\n          text += '?';\n        }\n        if (result.right === undefined) {\n          return text;\n        } else {\n          return text + `: ${transform(result.right)}`;\n        }\n      },\n      JsdocTypeJsdocObjectField: (result, transform) => {\n        return `${transform(result.left)}: ${transform(result.right)}`;\n      },\n      JsdocTypeKeyValue: (result, transform) => {\n        let text = result.key;\n        if (result.optional) {\n          text += '?';\n        }\n        if (result.variadic) {\n          text = '...' + text;\n        }\n        if (result.right === undefined) {\n          return text;\n        } else {\n          return text + `: ${transform(result.right)}`;\n        }\n      },\n      JsdocTypeSpecialNamePath: result => `${result.specialType}:${quote(result.value, result.meta.quote)}`,\n      JsdocTypeNotNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '!'),\n      JsdocTypeNull: () => 'null',\n      JsdocTypeNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '?'),\n      JsdocTypeNumber: result => result.value.toString(),\n      JsdocTypeObject: (result, transform) => `{${result.elements.map(transform).join((result.meta.separator === 'comma' ? ',' : ';') + ' ')}}`,\n      JsdocTypeOptional: (result, transform) => applyPosition(result.meta.position, transform(result.element), '='),\n      JsdocTypeSymbol: (result, transform) => `${result.value}(${result.element !== undefined ? transform(result.element) : ''})`,\n      JsdocTypeTypeof: (result, transform) => `typeof ${transform(result.element)}`,\n      JsdocTypeUndefined: () => 'undefined',\n      JsdocTypeUnion: (result, transform) => result.elements.map(transform).join(' | '),\n      JsdocTypeUnknown: () => '?',\n      JsdocTypeIntersection: (result, transform) => result.elements.map(transform).join(' & '),\n      JsdocTypeProperty: result => quote(result.value, result.meta.quote),\n      JsdocTypePredicate: (result, transform) => `${transform(result.left)} is ${transform(result.right)}`,\n      JsdocTypeIndexSignature: (result, transform) => `[${result.key}: ${transform(result.right)}]`,\n      JsdocTypeMappedType: (result, transform) => `[${result.key} in ${transform(result.right)}]`,\n      JsdocTypeAsserts: (result, transform) => `asserts ${transform(result.left)} is ${transform(result.right)}`\n    };\n  }\n  const storedStringifyRules = stringifyRules();\n  function stringify(result) {\n    return transform(storedStringifyRules, result);\n  }\n  const reservedWords = ['null', 'true', 'false', 'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'export', 'extends', 'finally', 'for', 'function', 'if', 'import', 'in', 'instanceof', 'new', 'return', 'super', 'switch', 'this', 'throw', 'try', 'typeof', 'var', 'void', 'while', 'with', 'yield'];\n  function makeName(value) {\n    const result = {\n      type: 'NameExpression',\n      name: value\n    };\n    if (reservedWords.includes(value)) {\n      result.reservedWord = true;\n    }\n    return result;\n  }\n  const catharsisTransformRules = {\n    JsdocTypeOptional: (result, transform) => {\n      const transformed = transform(result.element);\n      transformed.optional = true;\n      return transformed;\n    },\n    JsdocTypeNullable: (result, transform) => {\n      const transformed = transform(result.element);\n      transformed.nullable = true;\n      return transformed;\n    },\n    JsdocTypeNotNullable: (result, transform) => {\n      const transformed = transform(result.element);\n      transformed.nullable = false;\n      return transformed;\n    },\n    JsdocTypeVariadic: (result, transform) => {\n      if (result.element === undefined) {\n        throw new Error('dots without value are not allowed in catharsis mode');\n      }\n      const transformed = transform(result.element);\n      transformed.repeatable = true;\n      return transformed;\n    },\n    JsdocTypeAny: () => ({\n      type: 'AllLiteral'\n    }),\n    JsdocTypeNull: () => ({\n      type: 'NullLiteral'\n    }),\n    JsdocTypeStringValue: result => makeName(quote(result.value, result.meta.quote)),\n    JsdocTypeUndefined: () => ({\n      type: 'UndefinedLiteral'\n    }),\n    JsdocTypeUnknown: () => ({\n      type: 'UnknownLiteral'\n    }),\n    JsdocTypeFunction: (result, transform) => {\n      const params = extractSpecialParams(result);\n      const transformed = {\n        type: 'FunctionType',\n        params: params.params.map(transform)\n      };\n      if (params.this !== undefined) {\n        transformed.this = transform(params.this);\n      }\n      if (params.new !== undefined) {\n        transformed.new = transform(params.new);\n      }\n      if (result.returnType !== undefined) {\n        transformed.result = transform(result.returnType);\n      }\n      return transformed;\n    },\n    JsdocTypeGeneric: (result, transform) => ({\n      type: 'TypeApplication',\n      applications: result.elements.map(o => transform(o)),\n      expression: transform(result.left)\n    }),\n    JsdocTypeSpecialNamePath: result => makeName(result.specialType + ':' + quote(result.value, result.meta.quote)),\n    JsdocTypeName: result => {\n      if (result.value !== 'function') {\n        return makeName(result.value);\n      } else {\n        return {\n          type: 'FunctionType',\n          params: []\n        };\n      }\n    },\n    JsdocTypeNumber: result => makeName(result.value.toString()),\n    JsdocTypeObject: (result, transform) => {\n      const transformed = {\n        type: 'RecordType',\n        fields: []\n      };\n      for (const field of result.elements) {\n        if (field.type !== 'JsdocTypeObjectField' && field.type !== 'JsdocTypeJsdocObjectField') {\n          transformed.fields.push({\n            type: 'FieldType',\n            key: transform(field),\n            value: undefined\n          });\n        } else {\n          transformed.fields.push(transform(field));\n        }\n      }\n      return transformed;\n    },\n    JsdocTypeObjectField: (result, transform) => {\n      if (typeof result.key !== 'string') {\n        throw new Error('Index signatures and mapped types are not supported');\n      }\n      return {\n        type: 'FieldType',\n        key: makeName(quote(result.key, result.meta.quote)),\n        value: result.right === undefined ? undefined : transform(result.right)\n      };\n    },\n    JsdocTypeJsdocObjectField: (result, transform) => ({\n      type: 'FieldType',\n      key: transform(result.left),\n      value: transform(result.right)\n    }),\n    JsdocTypeUnion: (result, transform) => ({\n      type: 'TypeUnion',\n      elements: result.elements.map(e => transform(e))\n    }),\n    JsdocTypeKeyValue: (result, transform) => {\n      return {\n        type: 'FieldType',\n        key: makeName(result.key),\n        value: result.right === undefined ? undefined : transform(result.right)\n      };\n    },\n    JsdocTypeNamePath: (result, transform) => {\n      const leftResult = transform(result.left);\n      let rightValue;\n      if (result.right.type === 'JsdocTypeSpecialNamePath') {\n        rightValue = transform(result.right).name;\n      } else {\n        rightValue = quote(result.right.value, result.right.meta.quote);\n      }\n      const joiner = result.pathType === 'inner' ? '~' : result.pathType === 'instance' ? '#' : '.';\n      return makeName(`${leftResult.name}${joiner}${rightValue}`);\n    },\n    JsdocTypeSymbol: result => {\n      let value = '';\n      let element = result.element;\n      let trailingDots = false;\n      if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeVariadic') {\n        if (element.meta.position === 'prefix') {\n          value = '...';\n        } else {\n          trailingDots = true;\n        }\n        element = element.element;\n      }\n      if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeName') {\n        value += element.value;\n      } else if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeNumber') {\n        value += element.value.toString();\n      }\n      if (trailingDots) {\n        value += '...';\n      }\n      return makeName(`${result.value}(${value})`);\n    },\n    JsdocTypeParenthesis: (result, transform) => transform(assertRootResult(result.element)),\n    JsdocTypeMappedType: notAvailableTransform,\n    JsdocTypeIndexSignature: notAvailableTransform,\n    JsdocTypeImport: notAvailableTransform,\n    JsdocTypeKeyof: notAvailableTransform,\n    JsdocTypeTuple: notAvailableTransform,\n    JsdocTypeTypeof: notAvailableTransform,\n    JsdocTypeIntersection: notAvailableTransform,\n    JsdocTypeProperty: notAvailableTransform,\n    JsdocTypePredicate: notAvailableTransform,\n    JsdocTypeAsserts: notAvailableTransform\n  };\n  function catharsisTransform(result) {\n    return transform(catharsisTransformRules, result);\n  }\n  function getQuoteStyle(quote) {\n    switch (quote) {\n      case undefined:\n        return 'none';\n      case 'single':\n        return 'single';\n      case 'double':\n        return 'double';\n    }\n  }\n  function getMemberType(type) {\n    switch (type) {\n      case 'inner':\n        return 'INNER_MEMBER';\n      case 'instance':\n        return 'INSTANCE_MEMBER';\n      case 'property':\n        return 'MEMBER';\n      case 'property-brackets':\n        return 'MEMBER';\n    }\n  }\n  function nestResults(type, results) {\n    if (results.length === 2) {\n      return {\n        type,\n        left: results[0],\n        right: results[1]\n      };\n    } else {\n      return {\n        type,\n        left: results[0],\n        right: nestResults(type, results.slice(1))\n      };\n    }\n  }\n  const jtpRules = {\n    JsdocTypeOptional: (result, transform) => ({\n      type: 'OPTIONAL',\n      value: transform(result.element),\n      meta: {\n        syntax: result.meta.position === 'prefix' ? 'PREFIX_EQUAL_SIGN' : 'SUFFIX_EQUALS_SIGN'\n      }\n    }),\n    JsdocTypeNullable: (result, transform) => ({\n      type: 'NULLABLE',\n      value: transform(result.element),\n      meta: {\n        syntax: result.meta.position === 'prefix' ? 'PREFIX_QUESTION_MARK' : 'SUFFIX_QUESTION_MARK'\n      }\n    }),\n    JsdocTypeNotNullable: (result, transform) => ({\n      type: 'NOT_NULLABLE',\n      value: transform(result.element),\n      meta: {\n        syntax: result.meta.position === 'prefix' ? 'PREFIX_BANG' : 'SUFFIX_BANG'\n      }\n    }),\n    JsdocTypeVariadic: (result, transform) => {\n      const transformed = {\n        type: 'VARIADIC',\n        meta: {\n          syntax: result.meta.position === 'prefix' ? 'PREFIX_DOTS' : result.meta.position === 'suffix' ? 'SUFFIX_DOTS' : 'ONLY_DOTS'\n        }\n      };\n      if (result.element !== undefined) {\n        transformed.value = transform(result.element);\n      }\n      return transformed;\n    },\n    JsdocTypeName: result => ({\n      type: 'NAME',\n      name: result.value\n    }),\n    JsdocTypeTypeof: (result, transform) => ({\n      type: 'TYPE_QUERY',\n      name: transform(result.element)\n    }),\n    JsdocTypeTuple: (result, transform) => ({\n      type: 'TUPLE',\n      entries: result.elements.map(transform)\n    }),\n    JsdocTypeKeyof: (result, transform) => ({\n      type: 'KEY_QUERY',\n      value: transform(result.element)\n    }),\n    JsdocTypeImport: result => ({\n      type: 'IMPORT',\n      path: {\n        type: 'STRING_VALUE',\n        quoteStyle: getQuoteStyle(result.element.meta.quote),\n        string: result.element.value\n      }\n    }),\n    JsdocTypeUndefined: () => ({\n      type: 'NAME',\n      name: 'undefined'\n    }),\n    JsdocTypeAny: () => ({\n      type: 'ANY'\n    }),\n    JsdocTypeFunction: (result, transform) => {\n      const specialParams = extractSpecialParams(result);\n      const transformed = {\n        type: result.arrow ? 'ARROW' : 'FUNCTION',\n        params: specialParams.params.map(param => {\n          if (param.type === 'JsdocTypeKeyValue') {\n            if (param.right === undefined) {\n              throw new Error('Function parameter without \\':\\' is not expected to be \\'KEY_VALUE\\'');\n            }\n            return {\n              type: 'NAMED_PARAMETER',\n              name: param.key,\n              typeName: transform(param.right)\n            };\n          } else {\n            return transform(param);\n          }\n        }),\n        new: null,\n        returns: null\n      };\n      if (specialParams.this !== undefined) {\n        transformed.this = transform(specialParams.this);\n      } else if (!result.arrow) {\n        transformed.this = null;\n      }\n      if (specialParams.new !== undefined) {\n        transformed.new = transform(specialParams.new);\n      }\n      if (result.returnType !== undefined) {\n        transformed.returns = transform(result.returnType);\n      }\n      return transformed;\n    },\n    JsdocTypeGeneric: (result, transform) => {\n      const transformed = {\n        type: 'GENERIC',\n        subject: transform(result.left),\n        objects: result.elements.map(transform),\n        meta: {\n          syntax: result.meta.brackets === 'square' ? 'SQUARE_BRACKET' : result.meta.dot ? 'ANGLE_BRACKET_WITH_DOT' : 'ANGLE_BRACKET'\n        }\n      };\n      if (result.meta.brackets === 'square' && result.elements[0].type === 'JsdocTypeFunction' && !result.elements[0].parenthesis) {\n        transformed.objects[0] = {\n          type: 'NAME',\n          name: 'function'\n        };\n      }\n      return transformed;\n    },\n    JsdocTypeObjectField: (result, transform) => {\n      if (typeof result.key !== 'string') {\n        throw new Error('Index signatures and mapped types are not supported');\n      }\n      if (result.right === undefined) {\n        return {\n          type: 'RECORD_ENTRY',\n          key: result.key,\n          quoteStyle: getQuoteStyle(result.meta.quote),\n          value: null,\n          readonly: false\n        };\n      }\n      let right = transform(result.right);\n      if (result.optional) {\n        right = {\n          type: 'OPTIONAL',\n          value: right,\n          meta: {\n            syntax: 'SUFFIX_KEY_QUESTION_MARK'\n          }\n        };\n      }\n      return {\n        type: 'RECORD_ENTRY',\n        key: result.key.toString(),\n        quoteStyle: getQuoteStyle(result.meta.quote),\n        value: right,\n        readonly: false\n      };\n    },\n    JsdocTypeJsdocObjectField: () => {\n      throw new Error('Keys may not be typed in jsdoctypeparser.');\n    },\n    JsdocTypeKeyValue: (result, transform) => {\n      if (result.right === undefined) {\n        return {\n          type: 'RECORD_ENTRY',\n          key: result.key,\n          quoteStyle: 'none',\n          value: null,\n          readonly: false\n        };\n      }\n      let right = transform(result.right);\n      if (result.optional) {\n        right = {\n          type: 'OPTIONAL',\n          value: right,\n          meta: {\n            syntax: 'SUFFIX_KEY_QUESTION_MARK'\n          }\n        };\n      }\n      return {\n        type: 'RECORD_ENTRY',\n        key: result.key,\n        quoteStyle: 'none',\n        value: right,\n        readonly: false\n      };\n    },\n    JsdocTypeObject: (result, transform) => {\n      const entries = [];\n      for (const field of result.elements) {\n        if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {\n          entries.push(transform(field));\n        }\n      }\n      return {\n        type: 'RECORD',\n        entries\n      };\n    },\n    JsdocTypeSpecialNamePath: result => {\n      if (result.specialType !== 'module') {\n        throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);\n      }\n      return {\n        type: 'MODULE',\n        value: {\n          type: 'FILE_PATH',\n          quoteStyle: getQuoteStyle(result.meta.quote),\n          path: result.value\n        }\n      };\n    },\n    JsdocTypeNamePath: (result, transform) => {\n      let hasEventPrefix = false;\n      let name;\n      let quoteStyle;\n      if (result.right.type === 'JsdocTypeSpecialNamePath' && result.right.specialType === 'event') {\n        hasEventPrefix = true;\n        name = result.right.value;\n        quoteStyle = getQuoteStyle(result.right.meta.quote);\n      } else {\n        name = result.right.value;\n        quoteStyle = getQuoteStyle(result.right.meta.quote);\n      }\n      const transformed = {\n        type: getMemberType(result.pathType),\n        owner: transform(result.left),\n        name,\n        quoteStyle,\n        hasEventPrefix\n      };\n      if (transformed.owner.type === 'MODULE') {\n        const tModule = transformed.owner;\n        transformed.owner = transformed.owner.value;\n        tModule.value = transformed;\n        return tModule;\n      } else {\n        return transformed;\n      }\n    },\n    JsdocTypeUnion: (result, transform) => nestResults('UNION', result.elements.map(transform)),\n    JsdocTypeParenthesis: (result, transform) => ({\n      type: 'PARENTHESIS',\n      value: transform(assertRootResult(result.element))\n    }),\n    JsdocTypeNull: () => ({\n      type: 'NAME',\n      name: 'null'\n    }),\n    JsdocTypeUnknown: () => ({\n      type: 'UNKNOWN'\n    }),\n    JsdocTypeStringValue: result => ({\n      type: 'STRING_VALUE',\n      quoteStyle: getQuoteStyle(result.meta.quote),\n      string: result.value\n    }),\n    JsdocTypeIntersection: (result, transform) => nestResults('INTERSECTION', result.elements.map(transform)),\n    JsdocTypeNumber: result => ({\n      type: 'NUMBER_VALUE',\n      number: result.value.toString()\n    }),\n    JsdocTypeSymbol: notAvailableTransform,\n    JsdocTypeProperty: notAvailableTransform,\n    JsdocTypePredicate: notAvailableTransform,\n    JsdocTypeMappedType: notAvailableTransform,\n    JsdocTypeIndexSignature: notAvailableTransform,\n    JsdocTypeAsserts: notAvailableTransform\n  };\n  function jtpTransform(result) {\n    return transform(jtpRules, result);\n  }\n  function identityTransformRules() {\n    return {\n      JsdocTypeIntersection: (result, transform) => ({\n        type: 'JsdocTypeIntersection',\n        elements: result.elements.map(transform)\n      }),\n      JsdocTypeGeneric: (result, transform) => ({\n        type: 'JsdocTypeGeneric',\n        left: transform(result.left),\n        elements: result.elements.map(transform),\n        meta: {\n          dot: result.meta.dot,\n          brackets: result.meta.brackets\n        }\n      }),\n      JsdocTypeNullable: result => result,\n      JsdocTypeUnion: (result, transform) => ({\n        type: 'JsdocTypeUnion',\n        elements: result.elements.map(transform)\n      }),\n      JsdocTypeUnknown: result => result,\n      JsdocTypeUndefined: result => result,\n      JsdocTypeTypeof: (result, transform) => ({\n        type: 'JsdocTypeTypeof',\n        element: transform(result.element)\n      }),\n      JsdocTypeSymbol: (result, transform) => {\n        const transformed = {\n          type: 'JsdocTypeSymbol',\n          value: result.value\n        };\n        if (result.element !== undefined) {\n          transformed.element = transform(result.element);\n        }\n        return transformed;\n      },\n      JsdocTypeOptional: (result, transform) => ({\n        type: 'JsdocTypeOptional',\n        element: transform(result.element),\n        meta: {\n          position: result.meta.position\n        }\n      }),\n      JsdocTypeObject: (result, transform) => ({\n        type: 'JsdocTypeObject',\n        meta: {\n          separator: 'comma'\n        },\n        elements: result.elements.map(transform)\n      }),\n      JsdocTypeNumber: result => result,\n      JsdocTypeNull: result => result,\n      JsdocTypeNotNullable: (result, transform) => ({\n        type: 'JsdocTypeNotNullable',\n        element: transform(result.element),\n        meta: {\n          position: result.meta.position\n        }\n      }),\n      JsdocTypeSpecialNamePath: result => result,\n      JsdocTypeObjectField: (result, transform) => ({\n        type: 'JsdocTypeObjectField',\n        key: result.key,\n        right: result.right === undefined ? undefined : transform(result.right),\n        optional: result.optional,\n        readonly: result.readonly,\n        meta: result.meta\n      }),\n      JsdocTypeJsdocObjectField: (result, transform) => ({\n        type: 'JsdocTypeJsdocObjectField',\n        left: transform(result.left),\n        right: transform(result.right)\n      }),\n      JsdocTypeKeyValue: (result, transform) => {\n        return {\n          type: 'JsdocTypeKeyValue',\n          key: result.key,\n          right: result.right === undefined ? undefined : transform(result.right),\n          optional: result.optional,\n          variadic: result.variadic\n        };\n      },\n      JsdocTypeImport: (result, transform) => ({\n        type: 'JsdocTypeImport',\n        element: transform(result.element)\n      }),\n      JsdocTypeAny: result => result,\n      JsdocTypeStringValue: result => result,\n      JsdocTypeNamePath: result => result,\n      JsdocTypeVariadic: (result, transform) => {\n        const transformed = {\n          type: 'JsdocTypeVariadic',\n          meta: {\n            position: result.meta.position,\n            squareBrackets: result.meta.squareBrackets\n          }\n        };\n        if (result.element !== undefined) {\n          transformed.element = transform(result.element);\n        }\n        return transformed;\n      },\n      JsdocTypeTuple: (result, transform) => ({\n        type: 'JsdocTypeTuple',\n        elements: result.elements.map(transform)\n      }),\n      JsdocTypeName: result => result,\n      JsdocTypeFunction: (result, transform) => {\n        const transformed = {\n          type: 'JsdocTypeFunction',\n          arrow: result.arrow,\n          parameters: result.parameters.map(transform),\n          constructor: result.constructor,\n          parenthesis: result.parenthesis\n        };\n        if (result.returnType !== undefined) {\n          transformed.returnType = transform(result.returnType);\n        }\n        return transformed;\n      },\n      JsdocTypeKeyof: (result, transform) => ({\n        type: 'JsdocTypeKeyof',\n        element: transform(result.element)\n      }),\n      JsdocTypeParenthesis: (result, transform) => ({\n        type: 'JsdocTypeParenthesis',\n        element: transform(result.element)\n      }),\n      JsdocTypeProperty: result => result,\n      JsdocTypePredicate: (result, transform) => ({\n        type: 'JsdocTypePredicate',\n        left: transform(result.left),\n        right: transform(result.right)\n      }),\n      JsdocTypeIndexSignature: (result, transform) => ({\n        type: 'JsdocTypeIndexSignature',\n        key: result.key,\n        right: transform(result.right)\n      }),\n      JsdocTypeMappedType: (result, transform) => ({\n        type: 'JsdocTypeMappedType',\n        key: result.key,\n        right: transform(result.right)\n      }),\n      JsdocTypeAsserts: (result, transform) => ({\n        type: 'JsdocTypeAsserts',\n        left: transform(result.left),\n        right: transform(result.right)\n      })\n    };\n  }\n  const visitorKeys = {\n    JsdocTypeAny: [],\n    JsdocTypeFunction: ['parameters', 'returnType'],\n    JsdocTypeGeneric: ['left', 'elements'],\n    JsdocTypeImport: [],\n    JsdocTypeIndexSignature: ['right'],\n    JsdocTypeIntersection: ['elements'],\n    JsdocTypeKeyof: ['element'],\n    JsdocTypeKeyValue: ['right'],\n    JsdocTypeMappedType: ['right'],\n    JsdocTypeName: [],\n    JsdocTypeNamePath: ['left', 'right'],\n    JsdocTypeNotNullable: ['element'],\n    JsdocTypeNull: [],\n    JsdocTypeNullable: ['element'],\n    JsdocTypeNumber: [],\n    JsdocTypeObject: ['elements'],\n    JsdocTypeObjectField: ['right'],\n    JsdocTypeJsdocObjectField: ['left', 'right'],\n    JsdocTypeOptional: ['element'],\n    JsdocTypeParenthesis: ['element'],\n    JsdocTypeSpecialNamePath: [],\n    JsdocTypeStringValue: [],\n    JsdocTypeSymbol: ['element'],\n    JsdocTypeTuple: ['elements'],\n    JsdocTypeTypeof: ['element'],\n    JsdocTypeUndefined: [],\n    JsdocTypeUnion: ['elements'],\n    JsdocTypeUnknown: [],\n    JsdocTypeVariadic: ['element'],\n    JsdocTypeProperty: [],\n    JsdocTypePredicate: ['left', 'right'],\n    JsdocTypeAsserts: ['left', 'right']\n  };\n  function _traverse(node, parentNode, property, onEnter, onLeave) {\n    onEnter === null || onEnter === void 0 ? void 0 : onEnter(node, parentNode, property);\n    const keysToVisit = visitorKeys[node.type];\n    for (const key of keysToVisit) {\n      const value = node[key];\n      if (value !== undefined) {\n        if (Array.isArray(value)) {\n          for (const element of value) {\n            _traverse(element, node, key, onEnter, onLeave);\n          }\n        } else {\n          _traverse(value, node, key, onEnter, onLeave);\n        }\n      }\n    }\n    onLeave === null || onLeave === void 0 ? void 0 : onLeave(node, parentNode, property);\n  }\n  /**\n   * A function to traverse an AST. It traverses it depth first.\n   * @param node the node to start traversing at.\n   * @param onEnter node visitor function that will be called on entering the node. This corresponds to preorder traversing.\n   * @param onLeave node visitor function that will be called on leaving the node. This corresponds to postorder traversing.\n   */\n  function traverse(node, onEnter, onLeave) {\n    _traverse(node, undefined, undefined, onEnter, onLeave);\n  }\n  exports.catharsisTransform = catharsisTransform;\n  exports.identityTransformRules = identityTransformRules;\n  exports.jtpTransform = jtpTransform;\n  exports.parse = parse;\n  exports.stringify = stringify;\n  exports.stringifyRules = stringifyRules;\n  exports.transform = transform;\n  exports.traverse = traverse;\n  exports.tryParse = tryParse;\n  exports.visitorKeys = visitorKeys;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ek8sT0FBTyxDQUFDbVUsUUFBUSxHQUFHQSxRQUFRO0VBQzNCblUsT0FBTyxDQUFDdU8sUUFBUSxHQUFHQSxRQUFRO0VBQzNCdk8sT0FBTyxDQUFDMlQsV0FBVyxHQUFHQSxXQUFXO0FBRXJDLENBQUUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2pzZG9jLXR5cGUtcHJhdHQtcGFyc2VyL2Rpc3QvaW5kZXguanM/ODBiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmp0cHAgPSB7fSkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIGZ1bmN0aW9uIHRva2VuVG9TdHJpbmcodG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuLnRleHQgIT09IHVuZGVmaW5lZCAmJiB0b2tlbi50ZXh0ICE9PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGAnJHt0b2tlbi50eXBlfScgd2l0aCB2YWx1ZSAnJHt0b2tlbi50ZXh0fSdgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGAnJHt0b2tlbi50eXBlfSdgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsYXNzIE5vUGFyc2xldEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHRva2VuKSB7XG4gICAgICAgICAgICBzdXBlcihgTm8gcGFyc2xldCBmb3VuZCBmb3IgdG9rZW46ICR7dG9rZW5Ub1N0cmluZyh0b2tlbil9YCk7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgTm9QYXJzbGV0Rm91bmRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGdldFRva2VuKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xhc3MgRWFybHlFbmRPZlBhcnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHRva2VuKSB7XG4gICAgICAgICAgICBzdXBlcihgVGhlIHBhcnNpbmcgZW5kZWQgZWFybHkuIFRoZSBuZXh0IHRva2VuIHdhczogJHt0b2tlblRvU3RyaW5nKHRva2VuKX1gKTtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBFYXJseUVuZE9mUGFyc2VFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGdldFRva2VuKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xhc3MgVW5leHBlY3RlZFR5cGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAgICAgY29uc3RydWN0b3IocmVzdWx0LCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBgVW5leHBlY3RlZCB0eXBlOiAnJHtyZXN1bHQudHlwZX0nLmA7XG4gICAgICAgICAgICBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgKz0gYCBNZXNzYWdlOiAke21lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1cGVyKGVycm9yKTtcbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBVbmV4cGVjdGVkVHlwZUVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXhwb3J0IGNsYXNzIFVuZXhwZWN0ZWRUb2tlbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8vICAgcHJpdmF0ZSBleHBlY3RlZDogVG9rZW5cbiAgICAvLyAgIHByaXZhdGUgZm91bmQ6IFRva2VuXG4gICAgLy9cbiAgICAvLyAgIGNvbnN0cnVjdG9yIChleHBlY3RlZDogVG9rZW4sIGZvdW5kOiBUb2tlbikge1xuICAgIC8vICAgICBzdXBlcihgVGhlIHBhcnNpbmcgZW5kZWQgZWFybHkuIFRoZSBuZXh0IHRva2VuIHdhczogJHt0b2tlblRvU3RyaW5nKHRva2VuKX1gKVxuICAgIC8vXG4gICAgLy8gICAgIHRoaXMudG9rZW4gPSB0b2tlblxuICAgIC8vXG4gICAgLy8gICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBFYXJseUVuZE9mUGFyc2VFcnJvci5wcm90b3R5cGUpXG4gICAgLy8gICB9XG4gICAgLy9cbiAgICAvLyAgIGdldFRva2VuKCkge1xuICAgIC8vICAgICByZXR1cm4gdGhpcy50b2tlblxuICAgIC8vICAgfVxuICAgIC8vIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VQdW5jdHVhdGlvblJ1bGUodHlwZSkge1xuICAgICAgICByZXR1cm4gdGV4dCA9PiB7XG4gICAgICAgICAgICBpZiAodGV4dC5zdGFydHNXaXRoKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZSwgdGV4dDogdHlwZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFF1b3RlZCh0ZXh0KSB7XG4gICAgICAgIGxldCBwb3NpdGlvbiA9IDA7XG4gICAgICAgIGxldCBjaGFyO1xuICAgICAgICBjb25zdCBtYXJrID0gdGV4dFswXTtcbiAgICAgICAgbGV0IGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1hcmsgIT09ICdcXCcnICYmIG1hcmsgIT09ICdcIicpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChwb3NpdGlvbiA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBwb3NpdGlvbisrO1xuICAgICAgICAgICAgY2hhciA9IHRleHRbcG9zaXRpb25dO1xuICAgICAgICAgICAgaWYgKCFlc2NhcGVkICYmIGNoYXIgPT09IG1hcmspIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIGNoYXIgPT09ICdcXFxcJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciAhPT0gbWFyaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnRlcm1pbmF0ZWQgU3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoMCwgcG9zaXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBpZGVudGlmaWVyU3RhcnRSZWdleCA9IC9bJF9cXHB7SURfU3RhcnR9XXxcXFxcdVxccHtIZXhfRGlnaXR9ezR9fFxcXFx1XFx7MCooPzpcXHB7SGV4X0RpZ2l0fXsxLDV9fDEwXFxwe0hleF9EaWdpdH17NH0pXFx9L3U7XG4gICAgLy8gQSBoeXBoZW4gaXMgbm90IHRlY2huaWNhbGx5IGFsbG93ZWQsIGJ1dCB0byBrZWVwIGl0IGxpYmVyYWwgZm9yIG5vdyxcbiAgICAvLyAgYWRkaW5nIGl0IGhlcmVcbiAgICBjb25zdCBpZGVudGlmaWVyQ29udGludWVSZWdleCA9IC9bJFxcLVxccHtJRF9Db250aW51ZX1cXHUyMDBDXFx1MjAwRF18XFxcXHVcXHB7SGV4X0RpZ2l0fXs0fXxcXFxcdVxcezAqKD86XFxwe0hleF9EaWdpdH17MSw1fXwxMFxccHtIZXhfRGlnaXR9ezR9KVxcfS91O1xuICAgIGZ1bmN0aW9uIGdldElkZW50aWZpZXIodGV4dCkge1xuICAgICAgICBsZXQgY2hhciA9IHRleHRbMF07XG4gICAgICAgIGlmICghaWRlbnRpZmllclN0YXJ0UmVnZXgudGVzdChjaGFyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBvc2l0aW9uID0gMTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY2hhciA9IHRleHRbcG9zaXRpb25dO1xuICAgICAgICAgICAgaWYgKCFpZGVudGlmaWVyQ29udGludWVSZWdleC50ZXN0KGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NpdGlvbisrO1xuICAgICAgICB9IHdoaWxlIChwb3NpdGlvbiA8IHRleHQubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoMCwgcG9zaXRpb24pO1xuICAgIH1cbiAgICAvLyB3ZSBhcmUgYSBiaXQgbW9yZSBsaWJlcmFsIHRoYW4gVHlwZVNjcmlwdCBoZXJlIGFuZCBhbGxvdyBgTmFOYCwgYEluZmluaXR5YCBhbmQgYC1JbmZpbml0eWBcbiAgICBjb25zdCBudW1iZXJSZWdleCA9IC9eKE5hTnwtPygoXFxkKlxcLlxcZCt8XFxkKykoW0VlXVsrLV0/XFxkKyk/fEluZmluaXR5KSkvO1xuICAgIGZ1bmN0aW9uIGdldE51bWJlcih0ZXh0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBudW1iZXJSZWdleC5leGVjKHRleHQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGlkZW50aWZpZXJSdWxlID0gdGV4dCA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0SWRlbnRpZmllcih0ZXh0KTtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXG4gICAgICAgICAgICB0ZXh0OiB2YWx1ZVxuICAgICAgICB9O1xuICAgIH07XG4gICAgZnVuY3Rpb24gbWFrZUtleVdvcmRSdWxlKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRleHQgPT4ge1xuICAgICAgICAgICAgaWYgKCF0ZXh0LnN0YXJ0c1dpdGgodHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByZXBlbmRzID0gdGV4dFt0eXBlLmxlbmd0aF07XG4gICAgICAgICAgICBpZiAocHJlcGVuZHMgIT09IHVuZGVmaW5lZCAmJiBpZGVudGlmaWVyQ29udGludWVSZWdleC50ZXN0KHByZXBlbmRzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIHRleHQ6IHR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHN0cmluZ1ZhbHVlUnVsZSA9IHRleHQgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldFF1b3RlZCh0ZXh0KTtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nVmFsdWUnLFxuICAgICAgICAgICAgdGV4dDogdmFsdWVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGVvZlJ1bGUgPSB0ZXh0ID0+IHtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdFT0YnLFxuICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IG51bWJlclJ1bGUgPSB0ZXh0ID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXROdW1iZXIodGV4dCk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdOdW1iZXInLFxuICAgICAgICAgICAgdGV4dDogdmFsdWVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHJ1bGVzID0gW1xuICAgICAgICBlb2ZSdWxlLFxuICAgICAgICBtYWtlUHVuY3R1YXRpb25SdWxlKCc9PicpLFxuICAgICAgICBtYWtlUHVuY3R1YXRpb25SdWxlKCcoJyksXG4gICAgICAgIG1ha2VQdW5jdHVhdGlvblJ1bGUoJyknKSxcbiAgICAgICAgbWFrZVB1bmN0dWF0aW9uUnVsZSgneycpLFxuICAgICAgICBtYWtlUHVuY3R1YXRpb25SdWxlKCd9JyksXG4gICAgICAgIG1ha2VQdW5jdHVhdGlvblJ1bGUoJ1snKSxcbiAgICAgICAgbWFrZVB1bmN0dWF0aW9uUnVsZSgnXScpLFxuICAgICAgICBtYWtlUHVuY3R1YXRpb25SdWxlKCd8JyksXG4gICAgICAgIG1ha2VQdW5jdHVhdGlvblJ1bGUoJyYnKSxcbiAgICAgICAgbWFrZVB1bmN0dWF0aW9uUnVsZSgnPCcpLFxuICAgICAgICBtYWtlUHVuY3R1YXRpb25SdWxlKCc+JyksXG4gICAgICAgIG1ha2VQdW5jdHVhdGlvblJ1bGUoJywnKSxcbiAgICAgICAgbWFrZVB1bmN0dWF0aW9uUnVsZSgnOycpLFxuICAgICAgICBtYWtlUHVuY3R1YXRpb25SdWxlKCcqJyksXG4gICAgICAgIG1ha2VQdW5jdHVhdGlvblJ1bGUoJz8nKSxcbiAgICAgICAgbWFrZVB1bmN0dWF0aW9uUnVsZSgnIScpLFxuICAgICAgICBtYWtlUHVuY3R1YXRpb25SdWxlKCc9JyksXG4gICAgICAgIG1ha2VQdW5jdHVhdGlvblJ1bGUoJzonKSxcbiAgICAgICAgbWFrZVB1bmN0dWF0aW9uUnVsZSgnLi4uJyksXG4gICAgICAgIG1ha2VQdW5jdHVhdGlvblJ1bGUoJy4nKSxcbiAgICAgICAgbWFrZVB1bmN0dWF0aW9uUnVsZSgnIycpLFxuICAgICAgICBtYWtlUHVuY3R1YXRpb25SdWxlKCd+JyksXG4gICAgICAgIG1ha2VQdW5jdHVhdGlvblJ1bGUoJy8nKSxcbiAgICAgICAgbWFrZVB1bmN0dWF0aW9uUnVsZSgnQCcpLFxuICAgICAgICBtYWtlS2V5V29yZFJ1bGUoJ3VuZGVmaW5lZCcpLFxuICAgICAgICBtYWtlS2V5V29yZFJ1bGUoJ251bGwnKSxcbiAgICAgICAgbWFrZUtleVdvcmRSdWxlKCdmdW5jdGlvbicpLFxuICAgICAgICBtYWtlS2V5V29yZFJ1bGUoJ3RoaXMnKSxcbiAgICAgICAgbWFrZUtleVdvcmRSdWxlKCduZXcnKSxcbiAgICAgICAgbWFrZUtleVdvcmRSdWxlKCdtb2R1bGUnKSxcbiAgICAgICAgbWFrZUtleVdvcmRSdWxlKCdldmVudCcpLFxuICAgICAgICBtYWtlS2V5V29yZFJ1bGUoJ2V4dGVybmFsJyksXG4gICAgICAgIG1ha2VLZXlXb3JkUnVsZSgndHlwZW9mJyksXG4gICAgICAgIG1ha2VLZXlXb3JkUnVsZSgna2V5b2YnKSxcbiAgICAgICAgbWFrZUtleVdvcmRSdWxlKCdyZWFkb25seScpLFxuICAgICAgICBtYWtlS2V5V29yZFJ1bGUoJ2ltcG9ydCcpLFxuICAgICAgICBtYWtlS2V5V29yZFJ1bGUoJ2lzJyksXG4gICAgICAgIG1ha2VLZXlXb3JkUnVsZSgnaW4nKSxcbiAgICAgICAgbWFrZUtleVdvcmRSdWxlKCdhc3NlcnRzJyksXG4gICAgICAgIG51bWJlclJ1bGUsXG4gICAgICAgIGlkZW50aWZpZXJSdWxlLFxuICAgICAgICBzdHJpbmdWYWx1ZVJ1bGVcbiAgICBdO1xuICAgIGNvbnN0IGJyZWFraW5nV2hpdGVzcGFjZVJlZ2V4ID0gL15cXHMqXFxuXFxzKi87XG4gICAgY2xhc3MgTGV4ZXIge1xuICAgICAgICBzdGF0aWMgY3JlYXRlKHRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLnJlYWQodGV4dCk7XG4gICAgICAgICAgICB0ZXh0ID0gY3VycmVudC50ZXh0O1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMucmVhZCh0ZXh0KTtcbiAgICAgICAgICAgIHRleHQgPSBuZXh0LnRleHQ7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExleGVyKHRleHQsIHVuZGVmaW5lZCwgY3VycmVudC50b2tlbiwgbmV4dC50b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RydWN0b3IodGV4dCwgcHJldmlvdXMsIGN1cnJlbnQsIG5leHQpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9ICcnO1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyByZWFkKHRleHQsIHN0YXJ0T2ZMaW5lID0gZmFsc2UpIHtcbiAgICAgICAgICAgIHN0YXJ0T2ZMaW5lID0gc3RhcnRPZkxpbmUgfHwgYnJlYWtpbmdXaGl0ZXNwYWNlUmVnZXgudGVzdCh0ZXh0KTtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnRyaW0oKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVsZSBvZiBydWxlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRpYWwgPSBydWxlKHRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0aWFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJ0aWFsKSwgeyBzdGFydE9mTGluZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UodG9rZW4udGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0LCB0b2tlbiB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBUb2tlbiAnICsgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgYWR2YW5jZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBMZXhlci5yZWFkKHRoaXMudGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExleGVyKG5leHQudGV4dCwgdGhpcy5jdXJyZW50LCB0aGlzLm5leHQsIG5leHQudG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBwcm92aWRlZCByZXN1bHQgaXMgbm90IGEge0BsaW5rIFJvb3RSZXN1bHR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzZXJ0Um9vdFJlc3VsdChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdW5kZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSAnSnNkb2NUeXBlS2V5VmFsdWUnIHx8IHJlc3VsdC50eXBlID09PSAnSnNkb2NUeXBlUGFyYW1ldGVyTGlzdCcgfHxcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID09PSAnSnNkb2NUeXBlUHJvcGVydHknIHx8IHJlc3VsdC50eXBlID09PSAnSnNkb2NUeXBlUmVhZG9ubHlQcm9wZXJ0eScgfHxcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID09PSAnSnNkb2NUeXBlT2JqZWN0RmllbGQnIHx8IHJlc3VsdC50eXBlID09PSAnSnNkb2NUeXBlSnNkb2NPYmplY3RGaWVsZCcgfHxcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID09PSAnSnNkb2NUeXBlSW5kZXhTaWduYXR1cmUnIHx8IHJlc3VsdC50eXBlID09PSAnSnNkb2NUeXBlTWFwcGVkVHlwZScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkVHlwZUVycm9yKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0UGxhaW5LZXlWYWx1ZU9yUm9vdFJlc3VsdChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSAnSnNkb2NUeXBlS2V5VmFsdWUnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXNzZXJ0UGxhaW5LZXlWYWx1ZVJlc3VsdChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3NlcnRSb290UmVzdWx0KHJlc3VsdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydFBsYWluS2V5VmFsdWVPck5hbWVSZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ0pzZG9jVHlwZU5hbWUnKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3NlcnRQbGFpbktleVZhbHVlUmVzdWx0KHJlc3VsdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydFBsYWluS2V5VmFsdWVSZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZSAhPT0gJ0pzZG9jVHlwZUtleVZhbHVlJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRUeXBlRXJyb3IocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnROdW1iZXJPclZhcmlhZGljTmFtZVJlc3VsdChyZXN1bHQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09ICdKc2RvY1R5cGVWYXJpYWRpYycpIHtcbiAgICAgICAgICAgIGlmICgoKF9hID0gcmVzdWx0LmVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA9PT0gJ0pzZG9jVHlwZU5hbWUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkVHlwZUVycm9yKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC50eXBlICE9PSAnSnNkb2NUeXBlTnVtYmVyJyAmJiByZXN1bHQudHlwZSAhPT0gJ0pzZG9jVHlwZU5hbWUnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZFR5cGVFcnJvcihyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzU3F1YXJlZFByb3BlcnR5KHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0LnR5cGUgPT09ICdKc2RvY1R5cGVJbmRleFNpZ25hdHVyZScgfHwgcmVzdWx0LnR5cGUgPT09ICdKc2RvY1R5cGVNYXBwZWRUeXBlJztcbiAgICB9XG5cbiAgICAvLyBoaWdoZXIgcHJlY2VkZW5jZSA9IGhpZ2hlciBpbXBvcnRhbmNlXG4gICAgdmFyIFByZWNlZGVuY2U7XG4gICAgKGZ1bmN0aW9uIChQcmVjZWRlbmNlKSB7XG4gICAgICAgIFByZWNlZGVuY2VbUHJlY2VkZW5jZVtcIkFMTFwiXSA9IDBdID0gXCJBTExcIjtcbiAgICAgICAgUHJlY2VkZW5jZVtQcmVjZWRlbmNlW1wiUEFSQU1FVEVSX0xJU1RcIl0gPSAxXSA9IFwiUEFSQU1FVEVSX0xJU1RcIjtcbiAgICAgICAgUHJlY2VkZW5jZVtQcmVjZWRlbmNlW1wiT0JKRUNUXCJdID0gMl0gPSBcIk9CSkVDVFwiO1xuICAgICAgICBQcmVjZWRlbmNlW1ByZWNlZGVuY2VbXCJLRVlfVkFMVUVcIl0gPSAzXSA9IFwiS0VZX1ZBTFVFXCI7XG4gICAgICAgIFByZWNlZGVuY2VbUHJlY2VkZW5jZVtcIklOREVYX0JSQUNLRVRTXCJdID0gNF0gPSBcIklOREVYX0JSQUNLRVRTXCI7XG4gICAgICAgIFByZWNlZGVuY2VbUHJlY2VkZW5jZVtcIlVOSU9OXCJdID0gNV0gPSBcIlVOSU9OXCI7XG4gICAgICAgIFByZWNlZGVuY2VbUHJlY2VkZW5jZVtcIklOVEVSU0VDVElPTlwiXSA9IDZdID0gXCJJTlRFUlNFQ1RJT05cIjtcbiAgICAgICAgUHJlY2VkZW5jZVtQcmVjZWRlbmNlW1wiUFJFRklYXCJdID0gN10gPSBcIlBSRUZJWFwiO1xuICAgICAgICBQcmVjZWRlbmNlW1ByZWNlZGVuY2VbXCJJTkZJWFwiXSA9IDhdID0gXCJJTkZJWFwiO1xuICAgICAgICBQcmVjZWRlbmNlW1ByZWNlZGVuY2VbXCJUVVBMRVwiXSA9IDldID0gXCJUVVBMRVwiO1xuICAgICAgICBQcmVjZWRlbmNlW1ByZWNlZGVuY2VbXCJTWU1CT0xcIl0gPSAxMF0gPSBcIlNZTUJPTFwiO1xuICAgICAgICBQcmVjZWRlbmNlW1ByZWNlZGVuY2VbXCJPUFRJT05BTFwiXSA9IDExXSA9IFwiT1BUSU9OQUxcIjtcbiAgICAgICAgUHJlY2VkZW5jZVtQcmVjZWRlbmNlW1wiTlVMTEFCTEVcIl0gPSAxMl0gPSBcIk5VTExBQkxFXCI7XG4gICAgICAgIFByZWNlZGVuY2VbUHJlY2VkZW5jZVtcIktFWV9PRl9UWVBFX09GXCJdID0gMTNdID0gXCJLRVlfT0ZfVFlQRV9PRlwiO1xuICAgICAgICBQcmVjZWRlbmNlW1ByZWNlZGVuY2VbXCJGVU5DVElPTlwiXSA9IDE0XSA9IFwiRlVOQ1RJT05cIjtcbiAgICAgICAgUHJlY2VkZW5jZVtQcmVjZWRlbmNlW1wiQVJST1dcIl0gPSAxNV0gPSBcIkFSUk9XXCI7XG4gICAgICAgIFByZWNlZGVuY2VbUHJlY2VkZW5jZVtcIkFSUkFZX0JSQUNLRVRTXCJdID0gMTZdID0gXCJBUlJBWV9CUkFDS0VUU1wiO1xuICAgICAgICBQcmVjZWRlbmNlW1ByZWNlZGVuY2VbXCJHRU5FUklDXCJdID0gMTddID0gXCJHRU5FUklDXCI7XG4gICAgICAgIFByZWNlZGVuY2VbUHJlY2VkZW5jZVtcIk5BTUVfUEFUSFwiXSA9IDE4XSA9IFwiTkFNRV9QQVRIXCI7XG4gICAgICAgIFByZWNlZGVuY2VbUHJlY2VkZW5jZVtcIlBBUkVOVEhFU0lTXCJdID0gMTldID0gXCJQQVJFTlRIRVNJU1wiO1xuICAgICAgICBQcmVjZWRlbmNlW1ByZWNlZGVuY2VbXCJTUEVDSUFMX1RZUEVTXCJdID0gMjBdID0gXCJTUEVDSUFMX1RZUEVTXCI7XG4gICAgfSkoUHJlY2VkZW5jZSB8fCAoUHJlY2VkZW5jZSA9IHt9KSk7XG5cbiAgICBjbGFzcyBQYXJzZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihncmFtbWFyLCB0ZXh0T3JMZXhlciwgYmFzZVBhcnNlcikge1xuICAgICAgICAgICAgdGhpcy5ncmFtbWFyID0gZ3JhbW1hcjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGV4dE9yTGV4ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGV4ZXIgPSBMZXhlci5jcmVhdGUodGV4dE9yTGV4ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGV4ZXIgPSB0ZXh0T3JMZXhlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlciA9IGJhc2VQYXJzZXI7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGxleGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xleGVyO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZXMgYSBnaXZlbiBzdHJpbmcgYW5kIHRocm93cyBhbiBlcnJvciBpZiB0aGUgcGFyc2UgZW5kZWQgYmVmb3JlIHRoZSBlbmQgb2YgdGhlIHN0cmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHBhcnNlKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wYXJzZVR5cGUoUHJlY2VkZW5jZS5BTEwpO1xuICAgICAgICAgICAgaWYgKHRoaXMubGV4ZXIuY3VycmVudC50eXBlICE9PSAnRU9GJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFYXJseUVuZE9mUGFyc2VFcnJvcih0aGlzLmxleGVyLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIHdpdGggdGhlIGN1cnJlbnQgbGV4ZXIgYW5kIGFzc2VydHMgdGhhdCB0aGUgcmVzdWx0IGlzIGEge0BsaW5rIFJvb3RSZXN1bHR9LlxuICAgICAgICAgKi9cbiAgICAgICAgcGFyc2VUeXBlKHByZWNlZGVuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3NlcnRSb290UmVzdWx0KHRoaXMucGFyc2VJbnRlcm1lZGlhdGVUeXBlKHByZWNlZGVuY2UpKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1haW4gcGFyc2luZyBmdW5jdGlvbi4gRmlyc3QgaXQgdHJpZXMgdG8gcGFyc2UgdGhlIGN1cnJlbnQgc3RhdGUgaW4gdGhlIHByZWZpeCBzdGVwLCBhbmQgdGhlbiBpdCBjb250aW51ZXNcbiAgICAgICAgICogdG8gcGFyc2UgdGhlIHN0YXRlIGluIHRoZSBpbmZpeCBzdGVwLlxuICAgICAgICAgKi9cbiAgICAgICAgcGFyc2VJbnRlcm1lZGlhdGVUeXBlKHByZWNlZGVuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHJ5UGFyc2xldHMobnVsbCwgcHJlY2VkZW5jZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vUGFyc2xldEZvdW5kRXJyb3IodGhpcy5sZXhlci5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlSW5maXhJbnRlcm1lZGlhdGVUeXBlKHJlc3VsdCwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluIHRoZSBpbmZpeCBwYXJzaW5nIHN0ZXAgdGhlIHBhcnNlciBjb250aW51ZXMgdG8gcGFyc2UgdGhlIGN1cnJlbnQgc3RhdGUgd2l0aCBhbGwgcGFyc2xldHMgdW50aWwgbm9uZSByZXR1cm5zXG4gICAgICAgICAqIGEgcmVzdWx0LlxuICAgICAgICAgKi9cbiAgICAgICAgcGFyc2VJbmZpeEludGVybWVkaWF0ZVR5cGUobGVmdCwgcHJlY2VkZW5jZSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMudHJ5UGFyc2xldHMobGVmdCwgcHJlY2VkZW5jZSk7XG4gICAgICAgICAgICB3aGlsZSAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnRyeVBhcnNsZXRzKGxlZnQsIHByZWNlZGVuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyaWVzIHRvIHBhcnNlIHRoZSBjdXJyZW50IHN0YXRlIHdpdGggYWxsIHBhcnNsZXRzIGluIHRoZSBncmFtbWFyIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBub24gbnVsbCByZXN1bHQuXG4gICAgICAgICAqL1xuICAgICAgICB0cnlQYXJzbGV0cyhsZWZ0LCBwcmVjZWRlbmNlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnNsZXQgb2YgdGhpcy5ncmFtbWFyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2xldCh0aGlzLCBwcmVjZWRlbmNlLCBsZWZ0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBnaXZlbiB0eXBlIGVxdWFscyB0aGUgY3VycmVudCB0eXBlIG9mIHRoZSB7QGxpbmsgTGV4ZXJ9IGFkdmFuY2UgdGhlIGxleGVyLiBSZXR1cm4gdHJ1ZSBpZiB0aGUgbGV4ZXIgd2FzXG4gICAgICAgICAqIGFkdmFuY2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3VtZSh0eXBlcykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGVzKSkge1xuICAgICAgICAgICAgICAgIHR5cGVzID0gW3R5cGVzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlcy5pbmNsdWRlcyh0aGlzLmxleGVyLmN1cnJlbnQudHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sZXhlciA9IHRoaXMubGV4ZXIuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFjY2VwdExleGVyU3RhdGUocGFyc2VyKSB7XG4gICAgICAgICAgICB0aGlzLl9sZXhlciA9IHBhcnNlci5sZXhlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUXVlc3Rpb25NYXJrVW5rbm93blR5cGUobmV4dCkge1xuICAgICAgICByZXR1cm4gbmV4dCA9PT0gJ0VPRicgfHwgbmV4dCA9PT0gJ3wnIHx8IG5leHQgPT09ICcsJyB8fCBuZXh0ID09PSAnKScgfHwgbmV4dCA9PT0gJz4nO1xuICAgIH1cblxuICAgIGNvbnN0IG51bGxhYmxlUGFyc2xldCA9IChwYXJzZXIsIHByZWNlZGVuY2UsIGxlZnQpID0+IHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHBhcnNlci5sZXhlci5jdXJyZW50LnR5cGU7XG4gICAgICAgIGNvbnN0IG5leHQgPSBwYXJzZXIubGV4ZXIubmV4dC50eXBlO1xuICAgICAgICBjb25zdCBhY2NlcHQgPSAoKGxlZnQgPT0gbnVsbCkgJiYgdHlwZSA9PT0gJz8nICYmICFpc1F1ZXN0aW9uTWFya1Vua25vd25UeXBlKG5leHQpKSB8fFxuICAgICAgICAgICAgKChsZWZ0ICE9IG51bGwpICYmIHR5cGUgPT09ICc/Jyk7XG4gICAgICAgIGlmICghYWNjZXB0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIuY29uc3VtZSgnPycpO1xuICAgICAgICBpZiAobGVmdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVOdWxsYWJsZScsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogcGFyc2VyLnBhcnNlVHlwZShQcmVjZWRlbmNlLk5VTExBQkxFKSxcbiAgICAgICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncHJlZml4J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVOdWxsYWJsZScsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogYXNzZXJ0Um9vdFJlc3VsdChsZWZ0KSxcbiAgICAgICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnc3VmZml4J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY29tcG9zZVBhcnNsZXQob3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXJzbGV0ID0gKHBhcnNlciwgY3VyUHJlY2VkZW5jZSwgbGVmdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHBhcnNlci5sZXhlci5jdXJyZW50LnR5cGU7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gcGFyc2VyLmxleGVyLm5leHQudHlwZTtcbiAgICAgICAgICAgIGlmIChsZWZ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCdwYXJzZVByZWZpeCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hY2NlcHQodHlwZSwgbmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnBhcnNlUHJlZml4KHBhcnNlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoJ3BhcnNlSW5maXgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucHJlY2VkZW5jZSA+IGN1clByZWNlZGVuY2UgJiYgb3B0aW9ucy5hY2NlcHQodHlwZSwgbmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnBhcnNlSW5maXgocGFyc2VyLCBsZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvLyBmb3IgZGVidWdnaW5nXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJzbGV0LCAnbmFtZScsIHtcbiAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLm5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJzbGV0O1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbmFsUGFyc2xldCA9IGNvbXBvc2VQYXJzbGV0KHtcbiAgICAgICAgbmFtZTogJ29wdGlvbmFsUGFyc2xldCcsXG4gICAgICAgIGFjY2VwdDogdHlwZSA9PiB0eXBlID09PSAnPScsXG4gICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuT1BUSU9OQUwsXG4gICAgICAgIHBhcnNlUHJlZml4OiBwYXJzZXIgPT4ge1xuICAgICAgICAgICAgcGFyc2VyLmNvbnN1bWUoJz0nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZU9wdGlvbmFsJyxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBwYXJzZXIucGFyc2VUeXBlKFByZWNlZGVuY2UuT1BUSU9OQUwpLFxuICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdwcmVmaXgnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2VJbmZpeDogKHBhcnNlciwgbGVmdCkgPT4ge1xuICAgICAgICAgICAgcGFyc2VyLmNvbnN1bWUoJz0nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZU9wdGlvbmFsJyxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBhc3NlcnRSb290UmVzdWx0KGxlZnQpLFxuICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdzdWZmaXgnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgbnVtYmVyUGFyc2xldCA9IGNvbXBvc2VQYXJzbGV0KHtcbiAgICAgICAgbmFtZTogJ251bWJlclBhcnNsZXQnLFxuICAgICAgICBhY2NlcHQ6IHR5cGUgPT4gdHlwZSA9PT0gJ051bWJlcicsXG4gICAgICAgIHBhcnNlUHJlZml4OiBwYXJzZXIgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUZsb2F0KHBhcnNlci5sZXhlci5jdXJyZW50LnRleHQpO1xuICAgICAgICAgICAgcGFyc2VyLmNvbnN1bWUoJ051bWJlcicpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlTnVtYmVyJyxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgcGFyZW50aGVzaXNQYXJzbGV0ID0gY29tcG9zZVBhcnNsZXQoe1xuICAgICAgICBuYW1lOiAncGFyZW50aGVzaXNQYXJzbGV0JyxcbiAgICAgICAgYWNjZXB0OiB0eXBlID0+IHR5cGUgPT09ICcoJyxcbiAgICAgICAgcGFyc2VQcmVmaXg6IHBhcnNlciA9PiB7XG4gICAgICAgICAgICBwYXJzZXIuY29uc3VtZSgnKCcpO1xuICAgICAgICAgICAgaWYgKHBhcnNlci5jb25zdW1lKCcpJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlUGFyYW1ldGVyTGlzdCcsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIucGFyc2VJbnRlcm1lZGlhdGVUeXBlKFByZWNlZGVuY2UuQUxMKTtcbiAgICAgICAgICAgIGlmICghcGFyc2VyLmNvbnN1bWUoJyknKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW50ZXJtaW5hdGVkIHBhcmVudGhlc2lzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09ICdKc2RvY1R5cGVQYXJhbWV0ZXJMaXN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQudHlwZSA9PT0gJ0pzZG9jVHlwZUtleVZhbHVlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVQYXJhbWV0ZXJMaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IFtyZXN1bHRdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZVBhcmVudGhlc2lzJyxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBhc3NlcnRSb290UmVzdWx0KHJlc3VsdClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHNwZWNpYWxUeXBlc1BhcnNsZXQgPSBjb21wb3NlUGFyc2xldCh7XG4gICAgICAgIG5hbWU6ICdzcGVjaWFsVHlwZXNQYXJzbGV0JyxcbiAgICAgICAgYWNjZXB0OiAodHlwZSwgbmV4dCkgPT4gKHR5cGUgPT09ICc/JyAmJiBpc1F1ZXN0aW9uTWFya1Vua25vd25UeXBlKG5leHQpKSB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gJ251bGwnIHx8IHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICcqJyxcbiAgICAgICAgcGFyc2VQcmVmaXg6IHBhcnNlciA9PiB7XG4gICAgICAgICAgICBpZiAocGFyc2VyLmNvbnN1bWUoJ251bGwnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVOdWxsJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyc2VyLmNvbnN1bWUoJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZVVuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnNlci5jb25zdW1lKCcqJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlQW55J1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyc2VyLmNvbnN1bWUoJz8nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVVbmtub3duJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWNjZXB0YWJsZSB0b2tlbjogJyArIHBhcnNlci5sZXhlci5jdXJyZW50LnRleHQpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBub3ROdWxsYWJsZVBhcnNsZXQgPSBjb21wb3NlUGFyc2xldCh7XG4gICAgICAgIG5hbWU6ICdub3ROdWxsYWJsZVBhcnNsZXQnLFxuICAgICAgICBhY2NlcHQ6IHR5cGUgPT4gdHlwZSA9PT0gJyEnLFxuICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLk5VTExBQkxFLFxuICAgICAgICBwYXJzZVByZWZpeDogcGFyc2VyID0+IHtcbiAgICAgICAgICAgIHBhcnNlci5jb25zdW1lKCchJyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVOb3ROdWxsYWJsZScsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogcGFyc2VyLnBhcnNlVHlwZShQcmVjZWRlbmNlLk5VTExBQkxFKSxcbiAgICAgICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncHJlZml4J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlSW5maXg6IChwYXJzZXIsIGxlZnQpID0+IHtcbiAgICAgICAgICAgIHBhcnNlci5jb25zdW1lKCchJyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVOb3ROdWxsYWJsZScsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogYXNzZXJ0Um9vdFJlc3VsdChsZWZ0KSxcbiAgICAgICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnc3VmZml4J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhcmFtZXRlckxpc3RQYXJzbGV0KHsgYWxsb3dUcmFpbGluZ0NvbW1hIH0pIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2VQYXJzbGV0KHtcbiAgICAgICAgICAgIG5hbWU6ICdwYXJhbWV0ZXJMaXN0UGFyc2xldCcsXG4gICAgICAgICAgICBhY2NlcHQ6IHR5cGUgPT4gdHlwZSA9PT0gJywnLFxuICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5QQVJBTUVURVJfTElTVCxcbiAgICAgICAgICAgIHBhcnNlSW5maXg6IChwYXJzZXIsIGxlZnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0UGxhaW5LZXlWYWx1ZU9yUm9vdFJlc3VsdChsZWZ0KVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgcGFyc2VyLmNvbnN1bWUoJywnKTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gcGFyc2VyLnBhcnNlSW50ZXJtZWRpYXRlVHlwZShQcmVjZWRlbmNlLlBBUkFNRVRFUl9MSVNUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goYXNzZXJ0UGxhaW5LZXlWYWx1ZU9yUm9vdFJlc3VsdChuZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgZSBpbnN0YW5jZW9mIE5vUGFyc2xldEZvdW5kRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlIChwYXJzZXIuY29uc3VtZSgnLCcpKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCAmJiBlbGVtZW50cy5zbGljZSgwLCAtMSkuc29tZShlID0+IGUudHlwZSA9PT0gJ0pzZG9jVHlwZVZhcmlhZGljJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IHRoZSBsYXN0IHBhcmFtZXRlciBtYXkgYmUgYSByZXN0IHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlUGFyYW1ldGVyTGlzdCcsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgZ2VuZXJpY1BhcnNsZXQgPSBjb21wb3NlUGFyc2xldCh7XG4gICAgICAgIG5hbWU6ICdnZW5lcmljUGFyc2xldCcsXG4gICAgICAgIGFjY2VwdDogKHR5cGUsIG5leHQpID0+IHR5cGUgPT09ICc8JyB8fCAodHlwZSA9PT0gJy4nICYmIG5leHQgPT09ICc8JyksXG4gICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuR0VORVJJQyxcbiAgICAgICAgcGFyc2VJbmZpeDogKHBhcnNlciwgbGVmdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG90ID0gcGFyc2VyLmNvbnN1bWUoJy4nKTtcbiAgICAgICAgICAgIHBhcnNlci5jb25zdW1lKCc8Jyk7XG4gICAgICAgICAgICBjb25zdCBvYmplY3RzID0gW107XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgb2JqZWN0cy5wdXNoKHBhcnNlci5wYXJzZVR5cGUoUHJlY2VkZW5jZS5QQVJBTUVURVJfTElTVCkpO1xuICAgICAgICAgICAgfSB3aGlsZSAocGFyc2VyLmNvbnN1bWUoJywnKSk7XG4gICAgICAgICAgICBpZiAoIXBhcnNlci5jb25zdW1lKCc+JykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VudGVybWluYXRlZCBnZW5lcmljIHBhcmFtZXRlciBsaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVHZW5lcmljJyxcbiAgICAgICAgICAgICAgICBsZWZ0OiBhc3NlcnRSb290UmVzdWx0KGxlZnQpLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBvYmplY3RzLFxuICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgYnJhY2tldHM6ICdhbmdsZScsXG4gICAgICAgICAgICAgICAgICAgIGRvdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHVuaW9uUGFyc2xldCA9IGNvbXBvc2VQYXJzbGV0KHtcbiAgICAgICAgbmFtZTogJ3VuaW9uUGFyc2xldCcsXG4gICAgICAgIGFjY2VwdDogdHlwZSA9PiB0eXBlID09PSAnfCcsXG4gICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuVU5JT04sXG4gICAgICAgIHBhcnNlSW5maXg6IChwYXJzZXIsIGxlZnQpID0+IHtcbiAgICAgICAgICAgIHBhcnNlci5jb25zdW1lKCd8Jyk7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gocGFyc2VyLnBhcnNlVHlwZShQcmVjZWRlbmNlLlVOSU9OKSk7XG4gICAgICAgICAgICB9IHdoaWxlIChwYXJzZXIuY29uc3VtZSgnfCcpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZVVuaW9uJyxcbiAgICAgICAgICAgICAgICBlbGVtZW50czogW2Fzc2VydFJvb3RSZXN1bHQobGVmdCksIC4uLmVsZW1lbnRzXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgYmFzZUdyYW1tYXIgPSBbXG4gICAgICAgIG51bGxhYmxlUGFyc2xldCxcbiAgICAgICAgb3B0aW9uYWxQYXJzbGV0LFxuICAgICAgICBudW1iZXJQYXJzbGV0LFxuICAgICAgICBwYXJlbnRoZXNpc1BhcnNsZXQsXG4gICAgICAgIHNwZWNpYWxUeXBlc1BhcnNsZXQsXG4gICAgICAgIG5vdE51bGxhYmxlUGFyc2xldCxcbiAgICAgICAgY3JlYXRlUGFyYW1ldGVyTGlzdFBhcnNsZXQoe1xuICAgICAgICAgICAgYWxsb3dUcmFpbGluZ0NvbW1hOiB0cnVlXG4gICAgICAgIH0pLFxuICAgICAgICBnZW5lcmljUGFyc2xldCxcbiAgICAgICAgdW5pb25QYXJzbGV0LFxuICAgICAgICBvcHRpb25hbFBhcnNsZXRcbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlTmFtZVBhdGhQYXJzbGV0KHsgYWxsb3dTcXVhcmVCcmFja2V0c09uQW55VHlwZSwgYWxsb3dKc2RvY05hbWVQYXRocywgcGF0aEdyYW1tYXIgfSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmFtZVBhdGhQYXJzbGV0KHBhcnNlciwgcHJlY2VkZW5jZSwgbGVmdCkge1xuICAgICAgICAgICAgaWYgKChsZWZ0ID09IG51bGwpIHx8IHByZWNlZGVuY2UgPj0gUHJlY2VkZW5jZS5OQU1FX1BBVEgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBwYXJzZXIubGV4ZXIuY3VycmVudC50eXBlO1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHBhcnNlci5sZXhlci5uZXh0LnR5cGU7XG4gICAgICAgICAgICBjb25zdCBhY2NlcHQgPSAodHlwZSA9PT0gJy4nICYmIG5leHQgIT09ICc8JykgfHxcbiAgICAgICAgICAgICAgICAodHlwZSA9PT0gJ1snICYmIChhbGxvd1NxdWFyZUJyYWNrZXRzT25BbnlUeXBlIHx8IGxlZnQudHlwZSA9PT0gJ0pzZG9jVHlwZU5hbWUnKSkgfHxcbiAgICAgICAgICAgICAgICAoYWxsb3dKc2RvY05hbWVQYXRocyAmJiAodHlwZSA9PT0gJ34nIHx8IHR5cGUgPT09ICcjJykpO1xuICAgICAgICAgICAgaWYgKCFhY2NlcHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXRoVHlwZTtcbiAgICAgICAgICAgIGxldCBicmFja2V0cyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHBhcnNlci5jb25zdW1lKCcuJykpIHtcbiAgICAgICAgICAgICAgICBwYXRoVHlwZSA9ICdwcm9wZXJ0eSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJzZXIuY29uc3VtZSgnWycpKSB7XG4gICAgICAgICAgICAgICAgcGF0aFR5cGUgPSAncHJvcGVydHktYnJhY2tldHMnO1xuICAgICAgICAgICAgICAgIGJyYWNrZXRzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnNlci5jb25zdW1lKCd+JykpIHtcbiAgICAgICAgICAgICAgICBwYXRoVHlwZSA9ICdpbm5lcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuY29uc3VtZSgnIycpO1xuICAgICAgICAgICAgICAgIHBhdGhUeXBlID0gJ2luc3RhbmNlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhdGhQYXJzZXIgPSBwYXRoR3JhbW1hciAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gbmV3IFBhcnNlcihwYXRoR3JhbW1hciwgcGFyc2VyLmxleGVyLCBwYXJzZXIpXG4gICAgICAgICAgICAgICAgOiBwYXJzZXI7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXRoUGFyc2VyLnBhcnNlSW50ZXJtZWRpYXRlVHlwZShQcmVjZWRlbmNlLk5BTUVfUEFUSCk7XG4gICAgICAgICAgICBwYXJzZXIuYWNjZXB0TGV4ZXJTdGF0ZShwYXRoUGFyc2VyKTtcbiAgICAgICAgICAgIGxldCByaWdodDtcbiAgICAgICAgICAgIHN3aXRjaCAocGFyc2VkLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdKc2RvY1R5cGVOYW1lJzpcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlUHJvcGVydHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlZC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdW90ZTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0pzZG9jVHlwZU51bWJlcic6XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZVByb3BlcnR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZWQudmFsdWUudG9TdHJpbmcoMTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RlOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnSnNkb2NUeXBlU3RyaW5nVmFsdWUnOlxuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVQcm9wZXJ0eScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VkLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RlOiBwYXJzZWQubWV0YS5xdW90ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdKc2RvY1R5cGVTcGVjaWFsTmFtZVBhdGgnOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkLnNwZWNpYWxUeXBlID09PSAnZXZlbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHBhcnNlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkVHlwZUVycm9yKHBhcnNlZCwgJ1R5cGUgXFwnSnNkb2NUeXBlU3BlY2lhbE5hbWVQYXRoXFwnIGlzIG9ubHkgYWxsb3dlZCB3aXRoIHNwZWNpYWxUeXBlIFxcJ2V2ZW50XFwnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRUeXBlRXJyb3IocGFyc2VkLCAnRXhwZWN0aW5nIFxcJ0pzZG9jVHlwZU5hbWVcXCcsIFxcJ0pzZG9jVHlwZU51bWJlclxcJywgXFwnSnNkb2NTdHJpbmdWYWx1ZVxcJyBvciBcXCdKc2RvY1R5cGVTcGVjaWFsTmFtZVBhdGhcXCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChicmFja2V0cyAmJiAhcGFyc2VyLmNvbnN1bWUoJ10nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuID0gcGFyc2VyLmxleGVyLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnRlcm1pbmF0ZWQgc3F1YXJlIGJyYWNrZXRzLiBOZXh0IHRva2VuIGlzICcke3Rva2VuLnR5cGV9JyBgICtcbiAgICAgICAgICAgICAgICAgICAgYHdpdGggdGV4dCAnJHt0b2tlbi50ZXh0fSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZU5hbWVQYXRoJyxcbiAgICAgICAgICAgICAgICBsZWZ0OiBhc3NlcnRSb290UmVzdWx0KGxlZnQpLFxuICAgICAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgICAgIHBhdGhUeXBlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZU5hbWVQYXJzbGV0KHsgYWxsb3dlZEFkZGl0aW9uYWxUb2tlbnMgfSkge1xuICAgICAgICByZXR1cm4gY29tcG9zZVBhcnNsZXQoe1xuICAgICAgICAgICAgbmFtZTogJ25hbWVQYXJzbGV0JyxcbiAgICAgICAgICAgIGFjY2VwdDogdHlwZSA9PiB0eXBlID09PSAnSWRlbnRpZmllcicgfHwgdHlwZSA9PT0gJ3RoaXMnIHx8IHR5cGUgPT09ICduZXcnIHx8IGFsbG93ZWRBZGRpdGlvbmFsVG9rZW5zLmluY2x1ZGVzKHR5cGUpLFxuICAgICAgICAgICAgcGFyc2VQcmVmaXg6IHBhcnNlciA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0eXBlLCB0ZXh0IH0gPSBwYXJzZXIubGV4ZXIuY3VycmVudDtcbiAgICAgICAgICAgICAgICBwYXJzZXIuY29uc3VtZSh0eXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlTmFtZScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0ZXh0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyaW5nVmFsdWVQYXJzbGV0ID0gY29tcG9zZVBhcnNsZXQoe1xuICAgICAgICBuYW1lOiAnc3RyaW5nVmFsdWVQYXJzbGV0JyxcbiAgICAgICAgYWNjZXB0OiB0eXBlID0+IHR5cGUgPT09ICdTdHJpbmdWYWx1ZScsXG4gICAgICAgIHBhcnNlUHJlZml4OiBwYXJzZXIgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHBhcnNlci5sZXhlci5jdXJyZW50LnRleHQ7XG4gICAgICAgICAgICBwYXJzZXIuY29uc3VtZSgnU3RyaW5nVmFsdWUnKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZVN0cmluZ1ZhbHVlJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGV4dC5zbGljZSgxLCAtMSksXG4gICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICBxdW90ZTogdGV4dFswXSA9PT0gJ1xcJycgPyAnc2luZ2xlJyA6ICdkb3VibGUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlU3BlY2lhbE5hbWVQYXRoUGFyc2xldCh7IHBhdGhHcmFtbWFyLCBhbGxvd2VkVHlwZXMgfSkge1xuICAgICAgICByZXR1cm4gY29tcG9zZVBhcnNsZXQoe1xuICAgICAgICAgICAgbmFtZTogJ3NwZWNpYWxOYW1lUGF0aFBhcnNsZXQnLFxuICAgICAgICAgICAgYWNjZXB0OiB0eXBlID0+IGFsbG93ZWRUeXBlcy5pbmNsdWRlcyh0eXBlKSxcbiAgICAgICAgICAgIHBhcnNlUHJlZml4OiBwYXJzZXIgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBwYXJzZXIubGV4ZXIuY3VycmVudC50eXBlO1xuICAgICAgICAgICAgICAgIHBhcnNlci5jb25zdW1lKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VyLmNvbnN1bWUoJzonKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZU5hbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBsZXQgdG9rZW4gPSBwYXJzZXIubGV4ZXIuY3VycmVudDtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VyLmNvbnN1bWUoJ1N0cmluZ1ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZVNwZWNpYWxOYW1lUGF0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdG9rZW4udGV4dC5zbGljZSgxLCAtMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWFsVHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdW90ZTogdG9rZW4udGV4dFswXSA9PT0gJ1xcJycgPyAnc2luZ2xlJyA6ICdkb3VibGUnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsb3dlZCA9IFsnSWRlbnRpZmllcicsICdAJywgJy8nXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFsbG93ZWQuc29tZSh0eXBlID0+IHBhcnNlci5jb25zdW1lKHR5cGUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gcGFyc2VyLmxleGVyLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZVNwZWNpYWxOYW1lUGF0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWxUeXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RlOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlUGFyc2VyID0gbmV3IFBhcnNlcihwYXRoR3JhbW1hciwgcGFyc2VyLmxleGVyLCBwYXJzZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZVJlc3VsdCA9IG1vZHVsZVBhcnNlci5wYXJzZUluZml4SW50ZXJtZWRpYXRlVHlwZShyZXN1bHQsIFByZWNlZGVuY2UuQUxMKTtcbiAgICAgICAgICAgICAgICBwYXJzZXIuYWNjZXB0TGV4ZXJTdGF0ZShtb2R1bGVQYXJzZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhc3NlcnRSb290UmVzdWx0KG1vZHVsZVJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGJhc2VQYXRoR3JhbW1hciA9IFtcbiAgICAgICAgY3JlYXRlTmFtZVBhcnNsZXQoe1xuICAgICAgICAgICAgYWxsb3dlZEFkZGl0aW9uYWxUb2tlbnM6IFsnZXh0ZXJuYWwnLCAnbW9kdWxlJ11cbiAgICAgICAgfSksXG4gICAgICAgIHN0cmluZ1ZhbHVlUGFyc2xldCxcbiAgICAgICAgbnVtYmVyUGFyc2xldCxcbiAgICAgICAgY3JlYXRlTmFtZVBhdGhQYXJzbGV0KHtcbiAgICAgICAgICAgIGFsbG93U3F1YXJlQnJhY2tldHNPbkFueVR5cGU6IGZhbHNlLFxuICAgICAgICAgICAgYWxsb3dKc2RvY05hbWVQYXRoczogdHJ1ZSxcbiAgICAgICAgICAgIHBhdGhHcmFtbWFyOiBudWxsXG4gICAgICAgIH0pXG4gICAgXTtcbiAgICBjb25zdCBwYXRoR3JhbW1hciA9IFtcbiAgICAgICAgLi4uYmFzZVBhdGhHcmFtbWFyLFxuICAgICAgICBjcmVhdGVTcGVjaWFsTmFtZVBhdGhQYXJzbGV0KHtcbiAgICAgICAgICAgIGFsbG93ZWRUeXBlczogWydldmVudCddLFxuICAgICAgICAgICAgcGF0aEdyYW1tYXI6IGJhc2VQYXRoR3JhbW1hclxuICAgICAgICB9KVxuICAgIF07XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJhbWV0ZXJzKHZhbHVlKSB7XG4gICAgICAgIGxldCBwYXJhbWV0ZXJzO1xuICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gJ0pzZG9jVHlwZVBhcmFtZXRlckxpc3QnKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzID0gdmFsdWUuZWxlbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUudHlwZSA9PT0gJ0pzZG9jVHlwZVBhcmVudGhlc2lzJykge1xuICAgICAgICAgICAgcGFyYW1ldGVycyA9IFt2YWx1ZS5lbGVtZW50XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkVHlwZUVycm9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5tYXAocCA9PiBhc3NlcnRQbGFpbktleVZhbHVlT3JSb290UmVzdWx0KHApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VW5uYW1lZFBhcmFtZXRlcnModmFsdWUpIHtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IGdldFBhcmFtZXRlcnModmFsdWUpO1xuICAgICAgICBpZiAocGFyYW1ldGVycy5zb21lKHAgPT4gcC50eXBlID09PSAnSnNkb2NUeXBlS2V5VmFsdWUnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwYXJhbWV0ZXIgc2hvdWxkIGJlIG5hbWVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uUGFyc2xldCh7IGFsbG93TmFtZWRQYXJhbWV0ZXJzLCBhbGxvd05vUmV0dXJuVHlwZSwgYWxsb3dXaXRob3V0UGFyZW50aGVzaXMsIGFsbG93TmV3QXNGdW5jdGlvbktleXdvcmQgfSkge1xuICAgICAgICByZXR1cm4gY29tcG9zZVBhcnNsZXQoe1xuICAgICAgICAgICAgbmFtZTogJ2Z1bmN0aW9uUGFyc2xldCcsXG4gICAgICAgICAgICBhY2NlcHQ6ICh0eXBlLCBuZXh0KSA9PiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IChhbGxvd05ld0FzRnVuY3Rpb25LZXl3b3JkICYmIHR5cGUgPT09ICduZXcnICYmIG5leHQgPT09ICcoJyksXG4gICAgICAgICAgICBwYXJzZVByZWZpeDogcGFyc2VyID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdLZXl3b3JkID0gcGFyc2VyLmNvbnN1bWUoJ25ldycpO1xuICAgICAgICAgICAgICAgIHBhcnNlci5jb25zdW1lKCdmdW5jdGlvbicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc1BhcmVudGhlc2lzID0gcGFyc2VyLmxleGVyLmN1cnJlbnQudHlwZSA9PT0gJygnO1xuICAgICAgICAgICAgICAgIGlmICghaGFzUGFyZW50aGVzaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd1dpdGhvdXRQYXJlbnRoZXNpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdW5jdGlvbiBpcyBtaXNzaW5nIHBhcmFtZXRlciBsaXN0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVOYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVGdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBhcnJvdzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBuZXdLZXl3b3JkLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRoZXNpczogaGFzUGFyZW50aGVzaXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VyLnBhcnNlSW50ZXJtZWRpYXRlVHlwZShQcmVjZWRlbmNlLkZVTkNUSU9OKTtcbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dOYW1lZFBhcmFtZXRlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucGFyYW1ldGVycyA9IGdldFVubmFtZWRQYXJhbWV0ZXJzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV3S2V5d29yZCAmJiB2YWx1ZS50eXBlID09PSAnSnNkb2NUeXBlRnVuY3Rpb24nICYmIHZhbHVlLmFycm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY29uc3RydWN0b3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBhcmFtZXRlcnMgPSBnZXRQYXJhbWV0ZXJzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHJlc3VsdC5wYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC50eXBlID09PSAnSnNkb2NUeXBlS2V5VmFsdWUnICYmICghYWxsb3dOYW1lZFBhcmFtZXRlcnMuaW5jbHVkZXMocC5rZXkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb25seSBhbGxvd2VkIG5hbWVkIHBhcmFtZXRlcnMgYXJlICR7YWxsb3dOYW1lZFBhcmFtZXRlcnMuam9pbignLCAnKX0gYnV0IGdvdCAke3AudHlwZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VyLmNvbnN1bWUoJzonKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucmV0dXJuVHlwZSA9IHBhcnNlci5wYXJzZVR5cGUoUHJlY2VkZW5jZS5QUkVGSVgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd05vUmV0dXJuVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdW5jdGlvbiBpcyBtaXNzaW5nIHJldHVybiB0eXBlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVmFyaWFkaWNQYXJzbGV0KHsgYWxsb3dQb3N0Zml4LCBhbGxvd0VuY2xvc2luZ0JyYWNrZXRzIH0pIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2VQYXJzbGV0KHtcbiAgICAgICAgICAgIG5hbWU6ICd2YXJpYWRpY1BhcnNsZXQnLFxuICAgICAgICAgICAgYWNjZXB0OiB0eXBlID0+IHR5cGUgPT09ICcuLi4nLFxuICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5QUkVGSVgsXG4gICAgICAgICAgICBwYXJzZVByZWZpeDogcGFyc2VyID0+IHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuY29uc3VtZSgnLi4uJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnJhY2tldHMgPSBhbGxvd0VuY2xvc2luZ0JyYWNrZXRzICYmIHBhcnNlci5jb25zdW1lKCdbJyk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHBhcnNlci5wYXJzZVR5cGUoUHJlY2VkZW5jZS5QUkVGSVgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnJhY2tldHMgJiYgIXBhcnNlci5jb25zdW1lKCddJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW50ZXJtaW5hdGVkIHZhcmlhZGljIHR5cGUuIE1pc3NpbmcgXFwnXVxcJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlVmFyaWFkaWMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogYXNzZXJ0Um9vdFJlc3VsdChlbGVtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3ByZWZpeCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3F1YXJlQnJhY2tldHM6IGJyYWNrZXRzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgTm9QYXJzbGV0Rm91bmRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJyYWNrZXRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBzcXVhcmUgYnJhY2tldHMgZm9yIHZhcmlhZGljIGFyZSBub3QgYWxsb3dlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZVZhcmlhZGljJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNxdWFyZUJyYWNrZXRzOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcnNlSW5maXg6IGFsbG93UG9zdGZpeFxuICAgICAgICAgICAgICAgID8gKHBhcnNlciwgbGVmdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY29uc3VtZSgnLi4uJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlVmFyaWFkaWMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogYXNzZXJ0Um9vdFJlc3VsdChsZWZ0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3N1ZmZpeCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3F1YXJlQnJhY2tldHM6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHN5bWJvbFBhcnNsZXQgPSBjb21wb3NlUGFyc2xldCh7XG4gICAgICAgIG5hbWU6ICdzeW1ib2xQYXJzbGV0JyxcbiAgICAgICAgYWNjZXB0OiB0eXBlID0+IHR5cGUgPT09ICcoJyxcbiAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5TWU1CT0wsXG4gICAgICAgIHBhcnNlSW5maXg6IChwYXJzZXIsIGxlZnQpID0+IHtcbiAgICAgICAgICAgIGlmIChsZWZ0LnR5cGUgIT09ICdKc2RvY1R5cGVOYW1lJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3ltYm9sIGV4cGVjdHMgYSBuYW1lIG9uIHRoZSBsZWZ0IHNpZGUuIChSZWFjdGluZyBvbiBcXCcoXFwnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLmNvbnN1bWUoJygnKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlU3ltYm9sJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGVmdC52YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghcGFyc2VyLmNvbnN1bWUoJyknKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBwYXJzZXIucGFyc2VJbnRlcm1lZGlhdGVUeXBlKFByZWNlZGVuY2UuU1lNQk9MKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuZWxlbWVudCA9IGFzc2VydE51bWJlck9yVmFyaWFkaWNOYW1lUmVzdWx0KG5leHQpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VyLmNvbnN1bWUoJyknKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N5bWJvbCBkb2VzIG5vdCBlbmQgYWZ0ZXIgdmFsdWUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBhcnJheUJyYWNrZXRzUGFyc2xldCA9IGNvbXBvc2VQYXJzbGV0KHtcbiAgICAgICAgbmFtZTogJ2FycmF5QnJhY2tldHNQYXJzbGV0JyxcbiAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5BUlJBWV9CUkFDS0VUUyxcbiAgICAgICAgYWNjZXB0OiAodHlwZSwgbmV4dCkgPT4gdHlwZSA9PT0gJ1snICYmIG5leHQgPT09ICddJyxcbiAgICAgICAgcGFyc2VJbmZpeDogKHBhcnNlciwgbGVmdCkgPT4ge1xuICAgICAgICAgICAgcGFyc2VyLmNvbnN1bWUoJ1snKTtcbiAgICAgICAgICAgIHBhcnNlci5jb25zdW1lKCddJyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVHZW5lcmljJyxcbiAgICAgICAgICAgICAgICBsZWZ0OiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVOYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICdBcnJheSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydFJvb3RSZXN1bHQobGVmdClcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgYnJhY2tldHM6ICdzcXVhcmUnLFxuICAgICAgICAgICAgICAgICAgICBkb3Q6IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0UGFyc2xldCh7IG9iamVjdEZpZWxkR3JhbW1hciwgYWxsb3dLZXlUeXBlcyB9KSB7XG4gICAgICAgIHJldHVybiBjb21wb3NlUGFyc2xldCh7XG4gICAgICAgICAgICBuYW1lOiAnb2JqZWN0UGFyc2xldCcsXG4gICAgICAgICAgICBhY2NlcHQ6IHR5cGUgPT4gdHlwZSA9PT0gJ3snLFxuICAgICAgICAgICAgcGFyc2VQcmVmaXg6IHBhcnNlciA9PiB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmNvbnN1bWUoJ3snKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVPYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3I6ICdjb21tYSdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlci5jb25zdW1lKCd9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlcGFyYXRvcjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRQYXJzZXIgPSBuZXcgUGFyc2VyKG9iamVjdEZpZWxkR3JhbW1hciwgcGFyc2VyLmxleGVyLCBwYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRQYXJzZXIuYWNjZXB0TGV4ZXJTdGF0ZShwYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpZWxkID0gZmllbGRQYXJzZXIucGFyc2VJbnRlcm1lZGlhdGVUeXBlKFByZWNlZGVuY2UuT0JKRUNUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hY2NlcHRMZXhlclN0YXRlKGZpZWxkUGFyc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZCA9PT0gdW5kZWZpbmVkICYmIGFsbG93S2V5VHlwZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IHBhcnNlci5wYXJzZUludGVybWVkaWF0ZVR5cGUoUHJlY2VkZW5jZS5PQkpFQ1QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9wdGlvbmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQudHlwZSA9PT0gJ0pzZG9jVHlwZU51bGxhYmxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IGZpZWxkLmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQudHlwZSA9PT0gJ0pzZG9jVHlwZU51bWJlcicgfHwgZmllbGQudHlwZSA9PT0gJ0pzZG9jVHlwZU5hbWUnIHx8IGZpZWxkLnR5cGUgPT09ICdKc2RvY1R5cGVTdHJpbmdWYWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcXVvdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLnR5cGUgPT09ICdKc2RvY1R5cGVTdHJpbmdWYWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVvdGUgPSBmaWVsZC5tZXRhLnF1b3RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZWxlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVPYmplY3RGaWVsZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogZmllbGQudmFsdWUudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVvdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQudHlwZSA9PT0gJ0pzZG9jVHlwZU9iamVjdEZpZWxkJyB8fCBmaWVsZC50eXBlID09PSAnSnNkb2NUeXBlSnNkb2NPYmplY3RGaWVsZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZWxlbWVudHMucHVzaChmaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZFR5cGVFcnJvcihmaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLmxleGVyLmN1cnJlbnQuc3RhcnRPZkxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IgPSAnbGluZWJyZWFrJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnNlci5jb25zdW1lKCcsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IgPSAnY29tbWEnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VyLmNvbnN1bWUoJzsnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvciA9ICdzZW1pY29sb24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gcGFyc2VyLmxleGVyLmN1cnJlbnQudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQubWV0YS5zZXBhcmF0b3IgPSBzZXBhcmF0b3IgIT09IG51bGwgJiYgc2VwYXJhdG9yICE9PSB2b2lkIDAgPyBzZXBhcmF0b3IgOiAnY29tbWEnOyAvLyBUT0RPOiB1c2UgdW5kZWZpbmVkIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXIuY29uc3VtZSgnfScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VudGVybWluYXRlZCByZWNvcmQgdHlwZS4gTWlzc2luZyBcXCd9XFwnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0RmllbGRQYXJzbGV0KHsgYWxsb3dTcXVhcmVkUHJvcGVydGllcywgYWxsb3dLZXlUeXBlcywgYWxsb3dSZWFkb25seSwgYWxsb3dPcHRpb25hbCB9KSB7XG4gICAgICAgIHJldHVybiBjb21wb3NlUGFyc2xldCh7XG4gICAgICAgICAgICBuYW1lOiAnb2JqZWN0RmllbGRQYXJzbGV0JyxcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuS0VZX1ZBTFVFLFxuICAgICAgICAgICAgYWNjZXB0OiB0eXBlID0+IHR5cGUgPT09ICc6JyxcbiAgICAgICAgICAgIHBhcnNlSW5maXg6IChwYXJzZXIsIGxlZnQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgbGV0IG9wdGlvbmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IHJlYWRvbmx5UHJvcGVydHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dPcHRpb25hbCAmJiBsZWZ0LnR5cGUgPT09ICdKc2RvY1R5cGVOdWxsYWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5lbGVtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dSZWFkb25seSAmJiBsZWZ0LnR5cGUgPT09ICdKc2RvY1R5cGVSZWFkb25seVByb3BlcnR5Jykge1xuICAgICAgICAgICAgICAgICAgICByZWFkb25seVByb3BlcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0IHBhcnNsZXQgdXNlcyBhIHNwZWNpYWwgZ3JhbW1hciBhbmQgZm9yIHRoZSB2YWx1ZSB3ZSB3YW50IHRvIHN3aXRjaCBiYWNrIHRvIHRoZSBwYXJlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRQYXJzZXIgPSAoX2EgPSBwYXJzZXIuYmFzZVBhcnNlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcGFyc2VyO1xuICAgICAgICAgICAgICAgIHBhcmVudFBhcnNlci5hY2NlcHRMZXhlclN0YXRlKHBhcnNlcik7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ0pzZG9jVHlwZU51bWJlcicgfHwgbGVmdC50eXBlID09PSAnSnNkb2NUeXBlTmFtZScgfHwgbGVmdC50eXBlID09PSAnSnNkb2NUeXBlU3RyaW5nVmFsdWUnIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzU3F1YXJlZFByb3BlcnR5KGxlZnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1NxdWFyZWRQcm9wZXJ0eShsZWZ0KSAmJiAhYWxsb3dTcXVhcmVkUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRUeXBlRXJyb3IobGVmdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50UGFyc2VyLmNvbnN1bWUoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHF1b3RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdC50eXBlID09PSAnSnNkb2NUeXBlU3RyaW5nVmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdW90ZSA9IGxlZnQubWV0YS5xdW90ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IHBhcmVudFBhcnNlci5wYXJzZVR5cGUoUHJlY2VkZW5jZS5LRVlfVkFMVUUpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYWNjZXB0TGV4ZXJTdGF0ZShwYXJlbnRQYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZU9iamVjdEZpZWxkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogaXNTcXVhcmVkUHJvcGVydHkobGVmdCkgPyBsZWZ0IDogbGVmdC52YWx1ZS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiByZWFkb25seVByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG93S2V5VHlwZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkVHlwZUVycm9yKGxlZnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFBhcnNlci5jb25zdW1lKCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gcGFyZW50UGFyc2VyLnBhcnNlVHlwZShQcmVjZWRlbmNlLktFWV9WQUxVRSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5hY2NlcHRMZXhlclN0YXRlKHBhcmVudFBhcnNlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlSnNkb2NPYmplY3RGaWVsZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBhc3NlcnRSb290UmVzdWx0KGxlZnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUtleVZhbHVlUGFyc2xldCh7IGFsbG93T3B0aW9uYWwsIGFsbG93VmFyaWFkaWMgfSkge1xuICAgICAgICByZXR1cm4gY29tcG9zZVBhcnNsZXQoe1xuICAgICAgICAgICAgbmFtZTogJ2tleVZhbHVlUGFyc2xldCcsXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLktFWV9WQUxVRSxcbiAgICAgICAgICAgIGFjY2VwdDogdHlwZSA9PiB0eXBlID09PSAnOicsXG4gICAgICAgICAgICBwYXJzZUluZml4OiAocGFyc2VyLCBsZWZ0KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG9wdGlvbmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IHZhcmlhZGljID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93T3B0aW9uYWwgJiYgbGVmdC50eXBlID09PSAnSnNkb2NUeXBlTnVsbGFibGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93VmFyaWFkaWMgJiYgbGVmdC50eXBlID09PSAnSnNkb2NUeXBlVmFyaWFkaWMnICYmIGxlZnQuZWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhcmlhZGljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxlZnQudHlwZSAhPT0gJ0pzZG9jVHlwZU5hbWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkVHlwZUVycm9yKGxlZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZXIuY29uc3VtZSgnOicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gcGFyc2VyLnBhcnNlVHlwZShQcmVjZWRlbmNlLktFWV9WQUxVRSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZUtleVZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBsZWZ0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWwsXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhZGljXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QganNkb2NCYXNlR3JhbW1hciA9IFtcbiAgICAgICAgLi4uYmFzZUdyYW1tYXIsXG4gICAgICAgIGNyZWF0ZUZ1bmN0aW9uUGFyc2xldCh7XG4gICAgICAgICAgICBhbGxvd1dpdGhvdXRQYXJlbnRoZXNpczogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93TmFtZWRQYXJhbWV0ZXJzOiBbJ3RoaXMnLCAnbmV3J10sXG4gICAgICAgICAgICBhbGxvd05vUmV0dXJuVHlwZTogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93TmV3QXNGdW5jdGlvbktleXdvcmQ6IGZhbHNlXG4gICAgICAgIH0pLFxuICAgICAgICBzdHJpbmdWYWx1ZVBhcnNsZXQsXG4gICAgICAgIGNyZWF0ZVNwZWNpYWxOYW1lUGF0aFBhcnNsZXQoe1xuICAgICAgICAgICAgYWxsb3dlZFR5cGVzOiBbJ21vZHVsZScsICdleHRlcm5hbCcsICdldmVudCddLFxuICAgICAgICAgICAgcGF0aEdyYW1tYXJcbiAgICAgICAgfSksXG4gICAgICAgIGNyZWF0ZVZhcmlhZGljUGFyc2xldCh7XG4gICAgICAgICAgICBhbGxvd0VuY2xvc2luZ0JyYWNrZXRzOiB0cnVlLFxuICAgICAgICAgICAgYWxsb3dQb3N0Zml4OiB0cnVlXG4gICAgICAgIH0pLFxuICAgICAgICBjcmVhdGVOYW1lUGFyc2xldCh7XG4gICAgICAgICAgICBhbGxvd2VkQWRkaXRpb25hbFRva2VuczogWydrZXlvZiddXG4gICAgICAgIH0pLFxuICAgICAgICBzeW1ib2xQYXJzbGV0LFxuICAgICAgICBhcnJheUJyYWNrZXRzUGFyc2xldCxcbiAgICAgICAgY3JlYXRlTmFtZVBhdGhQYXJzbGV0KHtcbiAgICAgICAgICAgIGFsbG93U3F1YXJlQnJhY2tldHNPbkFueVR5cGU6IGZhbHNlLFxuICAgICAgICAgICAgYWxsb3dKc2RvY05hbWVQYXRoczogdHJ1ZSxcbiAgICAgICAgICAgIHBhdGhHcmFtbWFyXG4gICAgICAgIH0pXG4gICAgXTtcbiAgICBjb25zdCBqc2RvY0dyYW1tYXIgPSBbXG4gICAgICAgIC4uLmpzZG9jQmFzZUdyYW1tYXIsXG4gICAgICAgIGNyZWF0ZU9iamVjdFBhcnNsZXQoe1xuICAgICAgICAgICAgLy8ganNkb2Mgc3ludGF4IGFsbG93cyBmdWxsIHR5cGVzIGFzIGtleXMsIHNvIHdlIG5lZWQgdG8gcHVsbCBpbiB0aGUgZnVsbCBncmFtbWFyIGhlcmVcbiAgICAgICAgICAgIC8vIHdlIGxlYXZlIG91dCB0aGUgb2JqZWN0IHR5cGUgZGVsaWJlcmF0ZWx5XG4gICAgICAgICAgICBvYmplY3RGaWVsZEdyYW1tYXI6IFtcbiAgICAgICAgICAgICAgICBjcmVhdGVOYW1lUGFyc2xldCh7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93ZWRBZGRpdGlvbmFsVG9rZW5zOiBbJ21vZHVsZScsICdpbiddXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgY3JlYXRlT2JqZWN0RmllbGRQYXJzbGV0KHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dTcXVhcmVkUHJvcGVydGllczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93S2V5VHlwZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd1JlYWRvbmx5OiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmpzZG9jQmFzZUdyYW1tYXJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBhbGxvd0tleVR5cGVzOiB0cnVlXG4gICAgICAgIH0pLFxuICAgICAgICBjcmVhdGVLZXlWYWx1ZVBhcnNsZXQoe1xuICAgICAgICAgICAgYWxsb3dPcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93VmFyaWFkaWM6IHRydWVcbiAgICAgICAgfSlcbiAgICBdO1xuXG4gICAgY29uc3QgdHlwZU9mUGFyc2xldCA9IGNvbXBvc2VQYXJzbGV0KHtcbiAgICAgICAgbmFtZTogJ3R5cGVPZlBhcnNsZXQnLFxuICAgICAgICBhY2NlcHQ6IHR5cGUgPT4gdHlwZSA9PT0gJ3R5cGVvZicsXG4gICAgICAgIHBhcnNlUHJlZml4OiBwYXJzZXIgPT4ge1xuICAgICAgICAgICAgcGFyc2VyLmNvbnN1bWUoJ3R5cGVvZicpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlVHlwZW9mJyxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBhc3NlcnRSb290UmVzdWx0KHBhcnNlci5wYXJzZVR5cGUoUHJlY2VkZW5jZS5LRVlfT0ZfVFlQRV9PRikpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBvYmplY3RGaWVsZEdyYW1tYXIkMSA9IFtcbiAgICAgICAgY3JlYXRlTmFtZVBhcnNsZXQoe1xuICAgICAgICAgICAgYWxsb3dlZEFkZGl0aW9uYWxUb2tlbnM6IFsnbW9kdWxlJywgJ2tleW9mJywgJ2V2ZW50JywgJ2V4dGVybmFsJywgJ2luJ11cbiAgICAgICAgfSksXG4gICAgICAgIG51bGxhYmxlUGFyc2xldCxcbiAgICAgICAgb3B0aW9uYWxQYXJzbGV0LFxuICAgICAgICBzdHJpbmdWYWx1ZVBhcnNsZXQsXG4gICAgICAgIG51bWJlclBhcnNsZXQsXG4gICAgICAgIGNyZWF0ZU9iamVjdEZpZWxkUGFyc2xldCh7XG4gICAgICAgICAgICBhbGxvd1NxdWFyZWRQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICAgICAgICAgIGFsbG93S2V5VHlwZXM6IGZhbHNlLFxuICAgICAgICAgICAgYWxsb3dPcHRpb25hbDogZmFsc2UsXG4gICAgICAgICAgICBhbGxvd1JlYWRvbmx5OiBmYWxzZVxuICAgICAgICB9KVxuICAgIF07XG4gICAgY29uc3QgY2xvc3VyZUdyYW1tYXIgPSBbXG4gICAgICAgIC4uLmJhc2VHcmFtbWFyLFxuICAgICAgICBjcmVhdGVPYmplY3RQYXJzbGV0KHtcbiAgICAgICAgICAgIGFsbG93S2V5VHlwZXM6IGZhbHNlLFxuICAgICAgICAgICAgb2JqZWN0RmllbGRHcmFtbWFyOiBvYmplY3RGaWVsZEdyYW1tYXIkMVxuICAgICAgICB9KSxcbiAgICAgICAgY3JlYXRlTmFtZVBhcnNsZXQoe1xuICAgICAgICAgICAgYWxsb3dlZEFkZGl0aW9uYWxUb2tlbnM6IFsnZXZlbnQnLCAnZXh0ZXJuYWwnLCAnaW4nXVxuICAgICAgICB9KSxcbiAgICAgICAgdHlwZU9mUGFyc2xldCxcbiAgICAgICAgY3JlYXRlRnVuY3Rpb25QYXJzbGV0KHtcbiAgICAgICAgICAgIGFsbG93V2l0aG91dFBhcmVudGhlc2lzOiBmYWxzZSxcbiAgICAgICAgICAgIGFsbG93TmFtZWRQYXJhbWV0ZXJzOiBbJ3RoaXMnLCAnbmV3J10sXG4gICAgICAgICAgICBhbGxvd05vUmV0dXJuVHlwZTogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93TmV3QXNGdW5jdGlvbktleXdvcmQ6IGZhbHNlXG4gICAgICAgIH0pLFxuICAgICAgICBjcmVhdGVWYXJpYWRpY1BhcnNsZXQoe1xuICAgICAgICAgICAgYWxsb3dFbmNsb3NpbmdCcmFja2V0czogZmFsc2UsXG4gICAgICAgICAgICBhbGxvd1Bvc3RmaXg6IGZhbHNlXG4gICAgICAgIH0pLFxuICAgICAgICAvLyBhZGRpdGlvbmFsIG5hbWUgcGFyc2xldCBpcyBuZWVkZWQgZm9yIHNvbWUgc3BlY2lhbCBjYXNlc1xuICAgICAgICBjcmVhdGVOYW1lUGFyc2xldCh7XG4gICAgICAgICAgICBhbGxvd2VkQWRkaXRpb25hbFRva2VuczogWydrZXlvZiddXG4gICAgICAgIH0pLFxuICAgICAgICBjcmVhdGVTcGVjaWFsTmFtZVBhdGhQYXJzbGV0KHtcbiAgICAgICAgICAgIGFsbG93ZWRUeXBlczogWydtb2R1bGUnXSxcbiAgICAgICAgICAgIHBhdGhHcmFtbWFyXG4gICAgICAgIH0pLFxuICAgICAgICBjcmVhdGVOYW1lUGF0aFBhcnNsZXQoe1xuICAgICAgICAgICAgYWxsb3dTcXVhcmVCcmFja2V0c09uQW55VHlwZTogZmFsc2UsXG4gICAgICAgICAgICBhbGxvd0pzZG9jTmFtZVBhdGhzOiB0cnVlLFxuICAgICAgICAgICAgcGF0aEdyYW1tYXJcbiAgICAgICAgfSksXG4gICAgICAgIGNyZWF0ZUtleVZhbHVlUGFyc2xldCh7XG4gICAgICAgICAgICBhbGxvd09wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgICAgIGFsbG93VmFyaWFkaWM6IGZhbHNlXG4gICAgICAgIH0pLFxuICAgICAgICBzeW1ib2xQYXJzbGV0XG4gICAgXTtcblxuICAgIGNvbnN0IGFzc2VydHNQYXJzbGV0ID0gY29tcG9zZVBhcnNsZXQoe1xuICAgICAgICBuYW1lOiAnYXNzZXJ0c1BhcnNsZXQnLFxuICAgICAgICBhY2NlcHQ6IHR5cGUgPT4gdHlwZSA9PT0gJ2Fzc2VydHMnLFxuICAgICAgICBwYXJzZVByZWZpeDogKHBhcnNlcikgPT4ge1xuICAgICAgICAgICAgcGFyc2VyLmNvbnN1bWUoJ2Fzc2VydHMnKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBwYXJzZXIucGFyc2VJbnRlcm1lZGlhdGVUeXBlKFByZWNlZGVuY2UuU1lNQk9MKTtcbiAgICAgICAgICAgIGlmIChsZWZ0LnR5cGUgIT09ICdKc2RvY1R5cGVOYW1lJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkVHlwZUVycm9yKGxlZnQsICdBIHR5cGVzY3JpcHQgYXNzZXJ0cyBhbHdheXMgaGFzIHRvIGhhdmUgYSBuYW1lIG9uIHRoZSBsZWZ0IHNpZGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuY29uc3VtZSgnaXMnKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZUFzc2VydHMnLFxuICAgICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGFzc2VydFJvb3RSZXN1bHQocGFyc2VyLnBhcnNlSW50ZXJtZWRpYXRlVHlwZShQcmVjZWRlbmNlLklORklYKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVR1cGxlUGFyc2xldCh7IGFsbG93UXVlc3Rpb25NYXJrIH0pIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2VQYXJzbGV0KHtcbiAgICAgICAgICAgIG5hbWU6ICd0dXBsZVBhcnNsZXQnLFxuICAgICAgICAgICAgYWNjZXB0OiB0eXBlID0+IHR5cGUgPT09ICdbJyxcbiAgICAgICAgICAgIHBhcnNlUHJlZml4OiBwYXJzZXIgPT4ge1xuICAgICAgICAgICAgICAgIHBhcnNlci5jb25zdW1lKCdbJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlVHVwbGUnLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuY29uc3VtZSgnXScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVMaXN0ID0gcGFyc2VyLnBhcnNlSW50ZXJtZWRpYXRlVHlwZShQcmVjZWRlbmNlLkFMTCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVMaXN0LnR5cGUgPT09ICdKc2RvY1R5cGVQYXJhbWV0ZXJMaXN0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZUxpc3QuZWxlbWVudHNbMF0udHlwZSA9PT0gJ0pzZG9jVHlwZUtleVZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVsZW1lbnRzID0gdHlwZUxpc3QuZWxlbWVudHMubWFwKGFzc2VydFBsYWluS2V5VmFsdWVSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVsZW1lbnRzID0gdHlwZUxpc3QuZWxlbWVudHMubWFwKGFzc2VydFJvb3RSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZUxpc3QudHlwZSA9PT0gJ0pzZG9jVHlwZUtleVZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVsZW1lbnRzID0gW2Fzc2VydFBsYWluS2V5VmFsdWVSZXN1bHQodHlwZUxpc3QpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lbGVtZW50cyA9IFthc3NlcnRSb290UmVzdWx0KHR5cGVMaXN0KV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZXIuY29uc3VtZSgnXScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW50ZXJtaW5hdGVkIFxcJ1tcXCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFhbGxvd1F1ZXN0aW9uTWFyayAmJiByZXN1bHQuZWxlbWVudHMuc29tZSgoZSkgPT4gZS50eXBlID09PSAnSnNkb2NUeXBlVW5rbm93bicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVlc3Rpb24gbWFyayBpbiB0dXBsZSBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlPZlBhcnNsZXQgPSBjb21wb3NlUGFyc2xldCh7XG4gICAgICAgIG5hbWU6ICdrZXlPZlBhcnNsZXQnLFxuICAgICAgICBhY2NlcHQ6IHR5cGUgPT4gdHlwZSA9PT0gJ2tleW9mJyxcbiAgICAgICAgcGFyc2VQcmVmaXg6IHBhcnNlciA9PiB7XG4gICAgICAgICAgICBwYXJzZXIuY29uc3VtZSgna2V5b2YnKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZUtleW9mJyxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBhc3NlcnRSb290UmVzdWx0KHBhcnNlci5wYXJzZVR5cGUoUHJlY2VkZW5jZS5LRVlfT0ZfVFlQRV9PRikpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBpbXBvcnRQYXJzbGV0ID0gY29tcG9zZVBhcnNsZXQoe1xuICAgICAgICBuYW1lOiAnaW1wb3J0UGFyc2xldCcsXG4gICAgICAgIGFjY2VwdDogdHlwZSA9PiB0eXBlID09PSAnaW1wb3J0JyxcbiAgICAgICAgcGFyc2VQcmVmaXg6IHBhcnNlciA9PiB7XG4gICAgICAgICAgICBwYXJzZXIuY29uc3VtZSgnaW1wb3J0Jyk7XG4gICAgICAgICAgICBpZiAoIXBhcnNlci5jb25zdW1lKCcoJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcGFyZW50aGVzaXMgYWZ0ZXIgaW1wb3J0IGtleXdvcmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBwYXJzZXIucGFyc2VUeXBlKFByZWNlZGVuY2UuUFJFRklYKTtcbiAgICAgICAgICAgIGlmIChwYXRoLnR5cGUgIT09ICdKc2RvY1R5cGVTdHJpbmdWYWx1ZScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgc3RyaW5nIHZhbHVlcyBhcmUgYWxsb3dlZCBhcyBwYXRocyBmb3IgaW1wb3J0cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwYXJzZXIuY29uc3VtZSgnKScpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGNsb3NpbmcgcGFyZW50aGVzaXMgYWZ0ZXIgaW1wb3J0IGtleXdvcmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZUltcG9ydCcsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogcGF0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVhZG9ubHlQcm9wZXJ0eVBhcnNsZXQgPSBjb21wb3NlUGFyc2xldCh7XG4gICAgICAgIG5hbWU6ICdyZWFkb25seVByb3BlcnR5UGFyc2xldCcsXG4gICAgICAgIGFjY2VwdDogdHlwZSA9PiB0eXBlID09PSAncmVhZG9ubHknLFxuICAgICAgICBwYXJzZVByZWZpeDogcGFyc2VyID0+IHtcbiAgICAgICAgICAgIHBhcnNlci5jb25zdW1lKCdyZWFkb25seScpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlUmVhZG9ubHlQcm9wZXJ0eScsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogcGFyc2VyLnBhcnNlVHlwZShQcmVjZWRlbmNlLktFWV9WQUxVRSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IGFycm93RnVuY3Rpb25QYXJzbGV0ID0gY29tcG9zZVBhcnNsZXQoe1xuICAgICAgICBuYW1lOiAnYXJyb3dGdW5jdGlvblBhcnNsZXQnLFxuICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLkFSUk9XLFxuICAgICAgICBhY2NlcHQ6IHR5cGUgPT4gdHlwZSA9PT0gJz0+JyxcbiAgICAgICAgcGFyc2VJbmZpeDogKHBhcnNlciwgbGVmdCkgPT4ge1xuICAgICAgICAgICAgcGFyc2VyLmNvbnN1bWUoJz0+Jyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVGdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyczogZ2V0UGFyYW1ldGVycyhsZWZ0KS5tYXAoYXNzZXJ0UGxhaW5LZXlWYWx1ZU9yTmFtZVJlc3VsdCksXG4gICAgICAgICAgICAgICAgYXJyb3c6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBhcmVudGhlc2lzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJldHVyblR5cGU6IHBhcnNlci5wYXJzZVR5cGUoUHJlY2VkZW5jZS5PQkpFQ1QpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBpbnRlcnNlY3Rpb25QYXJzbGV0ID0gY29tcG9zZVBhcnNsZXQoe1xuICAgICAgICBuYW1lOiAnaW50ZXJzZWN0aW9uUGFyc2xldCcsXG4gICAgICAgIGFjY2VwdDogdHlwZSA9PiB0eXBlID09PSAnJicsXG4gICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuSU5URVJTRUNUSU9OLFxuICAgICAgICBwYXJzZUluZml4OiAocGFyc2VyLCBsZWZ0KSA9PiB7XG4gICAgICAgICAgICBwYXJzZXIuY29uc3VtZSgnJicpO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHBhcnNlci5wYXJzZVR5cGUoUHJlY2VkZW5jZS5JTlRFUlNFQ1RJT04pKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHBhcnNlci5jb25zdW1lKCcmJykpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlSW50ZXJzZWN0aW9uJyxcbiAgICAgICAgICAgICAgICBlbGVtZW50czogW2Fzc2VydFJvb3RSZXN1bHQobGVmdCksIC4uLmVsZW1lbnRzXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgcHJlZGljYXRlUGFyc2xldCA9IGNvbXBvc2VQYXJzbGV0KHtcbiAgICAgICAgbmFtZTogJ3ByZWRpY2F0ZVBhcnNsZXQnLFxuICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLklORklYLFxuICAgICAgICBhY2NlcHQ6IHR5cGUgPT4gdHlwZSA9PT0gJ2lzJyxcbiAgICAgICAgcGFyc2VJbmZpeDogKHBhcnNlciwgbGVmdCkgPT4ge1xuICAgICAgICAgICAgaWYgKGxlZnQudHlwZSAhPT0gJ0pzZG9jVHlwZU5hbWUnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRUeXBlRXJyb3IobGVmdCwgJ0EgdHlwZXNjcmlwdCBwcmVkaWNhdGUgYWx3YXlzIGhhcyB0byBoYXZlIGEgbmFtZSBvbiB0aGUgbGVmdCBzaWRlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLmNvbnN1bWUoJ2lzJyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVQcmVkaWNhdGUnLFxuICAgICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGFzc2VydFJvb3RSZXN1bHQocGFyc2VyLnBhcnNlSW50ZXJtZWRpYXRlVHlwZShQcmVjZWRlbmNlLklORklYKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IG9iamVjdFNxdWFyZWRQcm9wZXJ0eVBhcnNsZXQgPSBjb21wb3NlUGFyc2xldCh7XG4gICAgICAgIG5hbWU6ICdvYmplY3RTcXVhcmVCcmFja2V0UHJvcGVydHlQYXJzbGV0JyxcbiAgICAgICAgYWNjZXB0OiB0eXBlID0+IHR5cGUgPT09ICdbJyxcbiAgICAgICAgcGFyc2VQcmVmaXg6IHBhcnNlciA9PiB7XG4gICAgICAgICAgICBpZiAocGFyc2VyLmJhc2VQYXJzZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBhbGxvd2VkIGluc2lkZSBvYmplY3QgZ3JhbW1hcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLmNvbnN1bWUoJ1snKTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHBhcnNlci5sZXhlci5jdXJyZW50LnRleHQ7XG4gICAgICAgICAgICBwYXJzZXIuY29uc3VtZSgnSWRlbnRpZmllcicpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChwYXJzZXIuY29uc3VtZSgnOicpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50UGFyc2VyID0gcGFyc2VyLmJhc2VQYXJzZXI7XG4gICAgICAgICAgICAgICAgcGFyZW50UGFyc2VyLmFjY2VwdExleGVyU3RhdGUocGFyc2VyKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVJbmRleFNpZ25hdHVyZScsXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHBhcmVudFBhcnNlci5wYXJzZVR5cGUoUHJlY2VkZW5jZS5JTkRFWF9CUkFDS0VUUylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBhcnNlci5hY2NlcHRMZXhlclN0YXRlKHBhcmVudFBhcnNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJzZXIuY29uc3VtZSgnaW4nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFBhcnNlciA9IHBhcnNlci5iYXNlUGFyc2VyO1xuICAgICAgICAgICAgICAgIHBhcmVudFBhcnNlci5hY2NlcHRMZXhlclN0YXRlKHBhcnNlcik7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlTWFwcGVkVHlwZScsXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHBhcmVudFBhcnNlci5wYXJzZVR5cGUoUHJlY2VkZW5jZS5BUlJBWV9CUkFDS0VUUylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBhcnNlci5hY2NlcHRMZXhlclN0YXRlKHBhcmVudFBhcnNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgXFwnOlxcJyBvciBcXCdpblxcJyBpbnNpZGUgc3F1YXJlIGJyYWNrZXRlZCBwcm9wZXJ0eS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGFyc2VyLmNvbnN1bWUoJ10nKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW50ZXJtaW5hdGVkIHNxdWFyZSBicmFja2V0cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgb2JqZWN0RmllbGRHcmFtbWFyID0gW1xuICAgICAgICByZWFkb25seVByb3BlcnR5UGFyc2xldCxcbiAgICAgICAgY3JlYXRlTmFtZVBhcnNsZXQoe1xuICAgICAgICAgICAgYWxsb3dlZEFkZGl0aW9uYWxUb2tlbnM6IFsnbW9kdWxlJywgJ2V2ZW50JywgJ2tleW9mJywgJ2V2ZW50JywgJ2V4dGVybmFsJywgJ2luJ11cbiAgICAgICAgfSksXG4gICAgICAgIG51bGxhYmxlUGFyc2xldCxcbiAgICAgICAgb3B0aW9uYWxQYXJzbGV0LFxuICAgICAgICBzdHJpbmdWYWx1ZVBhcnNsZXQsXG4gICAgICAgIG51bWJlclBhcnNsZXQsXG4gICAgICAgIGNyZWF0ZU9iamVjdEZpZWxkUGFyc2xldCh7XG4gICAgICAgICAgICBhbGxvd1NxdWFyZWRQcm9wZXJ0aWVzOiB0cnVlLFxuICAgICAgICAgICAgYWxsb3dLZXlUeXBlczogZmFsc2UsXG4gICAgICAgICAgICBhbGxvd09wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgYWxsb3dSZWFkb25seTogdHJ1ZVxuICAgICAgICB9KSxcbiAgICAgICAgb2JqZWN0U3F1YXJlZFByb3BlcnR5UGFyc2xldFxuICAgIF07XG4gICAgY29uc3QgdHlwZXNjcmlwdEdyYW1tYXIgPSBbXG4gICAgICAgIC4uLmJhc2VHcmFtbWFyLFxuICAgICAgICBjcmVhdGVPYmplY3RQYXJzbGV0KHtcbiAgICAgICAgICAgIGFsbG93S2V5VHlwZXM6IGZhbHNlLFxuICAgICAgICAgICAgb2JqZWN0RmllbGRHcmFtbWFyXG4gICAgICAgIH0pLFxuICAgICAgICB0eXBlT2ZQYXJzbGV0LFxuICAgICAgICBrZXlPZlBhcnNsZXQsXG4gICAgICAgIGltcG9ydFBhcnNsZXQsXG4gICAgICAgIHN0cmluZ1ZhbHVlUGFyc2xldCxcbiAgICAgICAgY3JlYXRlRnVuY3Rpb25QYXJzbGV0KHtcbiAgICAgICAgICAgIGFsbG93V2l0aG91dFBhcmVudGhlc2lzOiB0cnVlLFxuICAgICAgICAgICAgYWxsb3dOb1JldHVyblR5cGU6IGZhbHNlLFxuICAgICAgICAgICAgYWxsb3dOYW1lZFBhcmFtZXRlcnM6IFsndGhpcycsICduZXcnLCAnYXJncyddLFxuICAgICAgICAgICAgYWxsb3dOZXdBc0Z1bmN0aW9uS2V5d29yZDogdHJ1ZVxuICAgICAgICB9KSxcbiAgICAgICAgY3JlYXRlVHVwbGVQYXJzbGV0KHtcbiAgICAgICAgICAgIGFsbG93UXVlc3Rpb25NYXJrOiBmYWxzZVxuICAgICAgICB9KSxcbiAgICAgICAgY3JlYXRlVmFyaWFkaWNQYXJzbGV0KHtcbiAgICAgICAgICAgIGFsbG93RW5jbG9zaW5nQnJhY2tldHM6IGZhbHNlLFxuICAgICAgICAgICAgYWxsb3dQb3N0Zml4OiBmYWxzZVxuICAgICAgICB9KSxcbiAgICAgICAgYXNzZXJ0c1BhcnNsZXQsXG4gICAgICAgIGNyZWF0ZU5hbWVQYXJzbGV0KHtcbiAgICAgICAgICAgIGFsbG93ZWRBZGRpdGlvbmFsVG9rZW5zOiBbJ2V2ZW50JywgJ2V4dGVybmFsJywgJ2luJ11cbiAgICAgICAgfSksXG4gICAgICAgIGNyZWF0ZVNwZWNpYWxOYW1lUGF0aFBhcnNsZXQoe1xuICAgICAgICAgICAgYWxsb3dlZFR5cGVzOiBbJ21vZHVsZSddLFxuICAgICAgICAgICAgcGF0aEdyYW1tYXJcbiAgICAgICAgfSksXG4gICAgICAgIGFycmF5QnJhY2tldHNQYXJzbGV0LFxuICAgICAgICBhcnJvd0Z1bmN0aW9uUGFyc2xldCxcbiAgICAgICAgY3JlYXRlTmFtZVBhdGhQYXJzbGV0KHtcbiAgICAgICAgICAgIGFsbG93U3F1YXJlQnJhY2tldHNPbkFueVR5cGU6IHRydWUsXG4gICAgICAgICAgICBhbGxvd0pzZG9jTmFtZVBhdGhzOiBmYWxzZSxcbiAgICAgICAgICAgIHBhdGhHcmFtbWFyXG4gICAgICAgIH0pLFxuICAgICAgICBpbnRlcnNlY3Rpb25QYXJzbGV0LFxuICAgICAgICBwcmVkaWNhdGVQYXJzbGV0LFxuICAgICAgICBjcmVhdGVLZXlWYWx1ZVBhcnNsZXQoe1xuICAgICAgICAgICAgYWxsb3dWYXJpYWRpYzogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93T3B0aW9uYWw6IHRydWVcbiAgICAgICAgfSlcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBwYXJzZXMgdGhlIGdpdmVuIGV4cHJlc3Npb24gaW4gdGhlIGdpdmVuIG1vZGUgYW5kIHByb2R1Y2VzIGEge0BsaW5rIFJvb3RSZXN1bHR9LlxuICAgICAqIEBwYXJhbSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIG1vZGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZShleHByZXNzaW9uLCBtb2RlKSB7XG4gICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgY2FzZSAnY2xvc3VyZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChuZXcgUGFyc2VyKGNsb3N1cmVHcmFtbWFyLCBleHByZXNzaW9uKSkucGFyc2UoKTtcbiAgICAgICAgICAgIGNhc2UgJ2pzZG9jJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5ldyBQYXJzZXIoanNkb2NHcmFtbWFyLCBleHByZXNzaW9uKSkucGFyc2UoKTtcbiAgICAgICAgICAgIGNhc2UgJ3R5cGVzY3JpcHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiAobmV3IFBhcnNlcih0eXBlc2NyaXB0R3JhbW1hciwgZXhwcmVzc2lvbikpLnBhcnNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB0cmllcyB0byBwYXJzZSB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBpbiBtdWx0aXBsZSBtb2RlcyBhbmQgcmV0dXJucyB0aGUgZmlyc3Qgc3VjY2Vzc2Z1bFxuICAgICAqIHtAbGluayBSb290UmVzdWx0fS4gQnkgZGVmYXVsdCBpdCB0cmllcyBgJ3R5cGVzY3JpcHQnYCwgYCdjbG9zdXJlJ2AgYW5kIGAnanNkb2MnYCBpbiB0aGlzIG9yZGVyLiBJZlxuICAgICAqIG5vIG1vZGUgd2FzIHN1Y2Nlc3NmdWwgaXQgdGhyb3dzIHRoZSBlcnJvciB0aGF0IHdhcyBwcm9kdWNlZCBieSB0aGUgbGFzdCBwYXJzaW5nIGF0dGVtcHQuXG4gICAgICogQHBhcmFtIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gbW9kZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnlQYXJzZShleHByZXNzaW9uLCBtb2RlcyA9IFsndHlwZXNjcmlwdCcsICdjbG9zdXJlJywgJ2pzZG9jJ10pIHtcbiAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICBmb3IgKGNvbnN0IG1vZGUgb2YgbW9kZXMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlKGV4cHJlc3Npb24sIG1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKHJ1bGVzLCBwYXJzZVJlc3VsdCkge1xuICAgICAgICBjb25zdCBydWxlID0gcnVsZXNbcGFyc2VSZXN1bHQudHlwZV07XG4gICAgICAgIGlmIChydWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW4gdGhpcyBzZXQgb2YgdHJhbnNmb3JtIHJ1bGVzIGV4aXN0cyBubyBydWxlIGZvciB0eXBlICR7cGFyc2VSZXN1bHQudHlwZX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bGUocGFyc2VSZXN1bHQsIGFQYXJzZVJlc3VsdCA9PiB0cmFuc2Zvcm0ocnVsZXMsIGFQYXJzZVJlc3VsdCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3RBdmFpbGFibGVUcmFuc2Zvcm0ocGFyc2VSZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHRyYW5zZm9ybSBpcyBub3QgYXZhaWxhYmxlLiBBcmUgeW91IHRyeWluZyB0aGUgY29ycmVjdCBwYXJzaW5nIG1vZGU/Jyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4dHJhY3RTcGVjaWFsUGFyYW1zKHNvdXJjZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBwYXJhbXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgcGFyYW0gb2Ygc291cmNlLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSAnSnNkb2NUeXBlS2V5VmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLmtleSA9PT0gJ3RoaXMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC50aGlzID0gcGFyYW0ucmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmtleSA9PT0gJ25ldycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm5ldyA9IHBhcmFtLnJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlQb3NpdGlvbihwb3NpdGlvbiwgdGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcG9zaXRpb24gPT09ICdwcmVmaXgnID8gdmFsdWUgKyB0YXJnZXQgOiB0YXJnZXQgKyB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcXVvdGUodmFsdWUsIHF1b3RlKSB7XG4gICAgICAgIHN3aXRjaCAocXVvdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgO1xuICAgICAgICAgICAgY2FzZSAnc2luZ2xlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCcke3ZhbHVlfSdgO1xuICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeVJ1bGVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgSnNkb2NUeXBlUGFyZW50aGVzaXM6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4gYCgke3Jlc3VsdC5lbGVtZW50ICE9PSB1bmRlZmluZWQgPyB0cmFuc2Zvcm0ocmVzdWx0LmVsZW1lbnQpIDogJyd9KWAsXG4gICAgICAgICAgICBKc2RvY1R5cGVLZXlvZjogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiBga2V5b2YgJHt0cmFuc2Zvcm0ocmVzdWx0LmVsZW1lbnQpfWAsXG4gICAgICAgICAgICBKc2RvY1R5cGVGdW5jdGlvbjogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuYXJyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0cmluZ2lmaWVkID0gcmVzdWx0LmNvbnN0cnVjdG9yID8gJ25ldycgOiAnZnVuY3Rpb24nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5wYXJlbnRoZXNpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmaWVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVkICs9IGAoJHtyZXN1bHQucGFyYW1ldGVycy5tYXAodHJhbnNmb3JtKS5qb2luKCcsICcpfSlgO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJldHVyblR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5naWZpZWQgKz0gYDogJHt0cmFuc2Zvcm0ocmVzdWx0LnJldHVyblR5cGUpfWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmaWVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXR1cm5UeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJyb3cgZnVuY3Rpb24gbmVlZHMgYSByZXR1cm4gdHlwZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgc3RyaW5naWZpZWQgPSBgKCR7cmVzdWx0LnBhcmFtZXRlcnMubWFwKHRyYW5zZm9ybSkuam9pbignLCAnKX0pID0+ICR7dHJhbnNmb3JtKHJlc3VsdC5yZXR1cm5UeXBlKX1gO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZmllZCA9ICduZXcgJyArIHN0cmluZ2lmaWVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZmllZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgSnNkb2NUeXBlTmFtZTogcmVzdWx0ID0+IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgIEpzZG9jVHlwZVR1cGxlOiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+IGBbJHtyZXN1bHQuZWxlbWVudHMubWFwKHRyYW5zZm9ybSkuam9pbignLCAnKX1dYCxcbiAgICAgICAgICAgIEpzZG9jVHlwZVZhcmlhZGljOiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+IHJlc3VsdC5tZXRhLnBvc2l0aW9uID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/ICcuLi4nXG4gICAgICAgICAgICAgICAgOiBhcHBseVBvc2l0aW9uKHJlc3VsdC5tZXRhLnBvc2l0aW9uLCB0cmFuc2Zvcm0ocmVzdWx0LmVsZW1lbnQpLCAnLi4uJyksXG4gICAgICAgICAgICBKc2RvY1R5cGVOYW1lUGF0aDogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdCA9IHRyYW5zZm9ybShyZXN1bHQubGVmdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB0cmFuc2Zvcm0ocmVzdWx0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlc3VsdC5wYXRoVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbm5lcic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7bGVmdH1+JHtyaWdodH1gO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbnN0YW5jZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7bGVmdH0jJHtyaWdodH1gO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdwcm9wZXJ0eSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7bGVmdH0uJHtyaWdodH1gO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdwcm9wZXJ0eS1icmFja2V0cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7bGVmdH1bJHtyaWdodH1dYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgSnNkb2NUeXBlU3RyaW5nVmFsdWU6IHJlc3VsdCA9PiBxdW90ZShyZXN1bHQudmFsdWUsIHJlc3VsdC5tZXRhLnF1b3RlKSxcbiAgICAgICAgICAgIEpzZG9jVHlwZUFueTogKCkgPT4gJyonLFxuICAgICAgICAgICAgSnNkb2NUeXBlR2VuZXJpYzogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tZXRhLmJyYWNrZXRzID09PSAnc3F1YXJlJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gcmVzdWx0LmVsZW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IHRyYW5zZm9ybShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gJ0pzZG9jVHlwZVVuaW9uJyB8fCBlbGVtZW50LnR5cGUgPT09ICdKc2RvY1R5cGVJbnRlcnNlY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCgke3RyYW5zZm9ybWVkfSlbXWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7dHJhbnNmb3JtZWR9W11gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7dHJhbnNmb3JtKHJlc3VsdC5sZWZ0KX0ke3Jlc3VsdC5tZXRhLmRvdCA/ICcuJyA6ICcnfTwke3Jlc3VsdC5lbGVtZW50cy5tYXAodHJhbnNmb3JtKS5qb2luKCcsICcpfT5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBKc2RvY1R5cGVJbXBvcnQ6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4gYGltcG9ydCgke3RyYW5zZm9ybShyZXN1bHQuZWxlbWVudCl9KWAsXG4gICAgICAgICAgICBKc2RvY1R5cGVPYmplY3RGaWVsZDogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHQgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlYWRvbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gJ3JlYWRvbmx5ICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0LmtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBxdW90ZShyZXN1bHQua2V5LCByZXN1bHQubWV0YS5xdW90ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IHRyYW5zZm9ybShyZXN1bHQua2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5vcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9ICc/JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQgKyBgOiAke3RyYW5zZm9ybShyZXN1bHQucmlnaHQpfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEpzZG9jVHlwZUpzZG9jT2JqZWN0RmllbGQ6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0cmFuc2Zvcm0ocmVzdWx0LmxlZnQpfTogJHt0cmFuc2Zvcm0ocmVzdWx0LnJpZ2h0KX1gO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEpzZG9jVHlwZUtleVZhbHVlOiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IHJlc3VsdC5rZXk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5vcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9ICc/JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC52YXJpYWRpYykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gJy4uLicgKyB0ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dCArIGA6ICR7dHJhbnNmb3JtKHJlc3VsdC5yaWdodCl9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgSnNkb2NUeXBlU3BlY2lhbE5hbWVQYXRoOiByZXN1bHQgPT4gYCR7cmVzdWx0LnNwZWNpYWxUeXBlfToke3F1b3RlKHJlc3VsdC52YWx1ZSwgcmVzdWx0Lm1ldGEucXVvdGUpfWAsXG4gICAgICAgICAgICBKc2RvY1R5cGVOb3ROdWxsYWJsZTogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiBhcHBseVBvc2l0aW9uKHJlc3VsdC5tZXRhLnBvc2l0aW9uLCB0cmFuc2Zvcm0ocmVzdWx0LmVsZW1lbnQpLCAnIScpLFxuICAgICAgICAgICAgSnNkb2NUeXBlTnVsbDogKCkgPT4gJ251bGwnLFxuICAgICAgICAgICAgSnNkb2NUeXBlTnVsbGFibGU6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4gYXBwbHlQb3NpdGlvbihyZXN1bHQubWV0YS5wb3NpdGlvbiwgdHJhbnNmb3JtKHJlc3VsdC5lbGVtZW50KSwgJz8nKSxcbiAgICAgICAgICAgIEpzZG9jVHlwZU51bWJlcjogcmVzdWx0ID0+IHJlc3VsdC52YWx1ZS50b1N0cmluZygpLFxuICAgICAgICAgICAgSnNkb2NUeXBlT2JqZWN0OiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+IGB7JHtyZXN1bHQuZWxlbWVudHMubWFwKHRyYW5zZm9ybSkuam9pbigocmVzdWx0Lm1ldGEuc2VwYXJhdG9yID09PSAnY29tbWEnID8gJywnIDogJzsnKSArICcgJyl9fWAsXG4gICAgICAgICAgICBKc2RvY1R5cGVPcHRpb25hbDogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiBhcHBseVBvc2l0aW9uKHJlc3VsdC5tZXRhLnBvc2l0aW9uLCB0cmFuc2Zvcm0ocmVzdWx0LmVsZW1lbnQpLCAnPScpLFxuICAgICAgICAgICAgSnNkb2NUeXBlU3ltYm9sOiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+IGAke3Jlc3VsdC52YWx1ZX0oJHtyZXN1bHQuZWxlbWVudCAhPT0gdW5kZWZpbmVkID8gdHJhbnNmb3JtKHJlc3VsdC5lbGVtZW50KSA6ICcnfSlgLFxuICAgICAgICAgICAgSnNkb2NUeXBlVHlwZW9mOiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+IGB0eXBlb2YgJHt0cmFuc2Zvcm0ocmVzdWx0LmVsZW1lbnQpfWAsXG4gICAgICAgICAgICBKc2RvY1R5cGVVbmRlZmluZWQ6ICgpID0+ICd1bmRlZmluZWQnLFxuICAgICAgICAgICAgSnNkb2NUeXBlVW5pb246IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4gcmVzdWx0LmVsZW1lbnRzLm1hcCh0cmFuc2Zvcm0pLmpvaW4oJyB8ICcpLFxuICAgICAgICAgICAgSnNkb2NUeXBlVW5rbm93bjogKCkgPT4gJz8nLFxuICAgICAgICAgICAgSnNkb2NUeXBlSW50ZXJzZWN0aW9uOiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+IHJlc3VsdC5lbGVtZW50cy5tYXAodHJhbnNmb3JtKS5qb2luKCcgJiAnKSxcbiAgICAgICAgICAgIEpzZG9jVHlwZVByb3BlcnR5OiByZXN1bHQgPT4gcXVvdGUocmVzdWx0LnZhbHVlLCByZXN1bHQubWV0YS5xdW90ZSksXG4gICAgICAgICAgICBKc2RvY1R5cGVQcmVkaWNhdGU6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4gYCR7dHJhbnNmb3JtKHJlc3VsdC5sZWZ0KX0gaXMgJHt0cmFuc2Zvcm0ocmVzdWx0LnJpZ2h0KX1gLFxuICAgICAgICAgICAgSnNkb2NUeXBlSW5kZXhTaWduYXR1cmU6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4gYFske3Jlc3VsdC5rZXl9OiAke3RyYW5zZm9ybShyZXN1bHQucmlnaHQpfV1gLFxuICAgICAgICAgICAgSnNkb2NUeXBlTWFwcGVkVHlwZTogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiBgWyR7cmVzdWx0LmtleX0gaW4gJHt0cmFuc2Zvcm0ocmVzdWx0LnJpZ2h0KX1dYCxcbiAgICAgICAgICAgIEpzZG9jVHlwZUFzc2VydHM6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4gYGFzc2VydHMgJHt0cmFuc2Zvcm0ocmVzdWx0LmxlZnQpfSBpcyAke3RyYW5zZm9ybShyZXN1bHQucmlnaHQpfWBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmVkU3RyaW5naWZ5UnVsZXMgPSBzdHJpbmdpZnlSdWxlcygpO1xuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeShyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybShzdG9yZWRTdHJpbmdpZnlSdWxlcywgcmVzdWx0KTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNlcnZlZFdvcmRzID0gW1xuICAgICAgICAnbnVsbCcsXG4gICAgICAgICd0cnVlJyxcbiAgICAgICAgJ2ZhbHNlJyxcbiAgICAgICAgJ2JyZWFrJyxcbiAgICAgICAgJ2Nhc2UnLFxuICAgICAgICAnY2F0Y2gnLFxuICAgICAgICAnY2xhc3MnLFxuICAgICAgICAnY29uc3QnLFxuICAgICAgICAnY29udGludWUnLFxuICAgICAgICAnZGVidWdnZXInLFxuICAgICAgICAnZGVmYXVsdCcsXG4gICAgICAgICdkZWxldGUnLFxuICAgICAgICAnZG8nLFxuICAgICAgICAnZWxzZScsXG4gICAgICAgICdleHBvcnQnLFxuICAgICAgICAnZXh0ZW5kcycsXG4gICAgICAgICdmaW5hbGx5JyxcbiAgICAgICAgJ2ZvcicsXG4gICAgICAgICdmdW5jdGlvbicsXG4gICAgICAgICdpZicsXG4gICAgICAgICdpbXBvcnQnLFxuICAgICAgICAnaW4nLFxuICAgICAgICAnaW5zdGFuY2VvZicsXG4gICAgICAgICduZXcnLFxuICAgICAgICAncmV0dXJuJyxcbiAgICAgICAgJ3N1cGVyJyxcbiAgICAgICAgJ3N3aXRjaCcsXG4gICAgICAgICd0aGlzJyxcbiAgICAgICAgJ3Rocm93JyxcbiAgICAgICAgJ3RyeScsXG4gICAgICAgICd0eXBlb2YnLFxuICAgICAgICAndmFyJyxcbiAgICAgICAgJ3ZvaWQnLFxuICAgICAgICAnd2hpbGUnLFxuICAgICAgICAnd2l0aCcsXG4gICAgICAgICd5aWVsZCdcbiAgICBdO1xuICAgIGZ1bmN0aW9uIG1ha2VOYW1lKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdOYW1lRXhwcmVzc2lvbicsXG4gICAgICAgICAgICBuYW1lOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVzZXJ2ZWRXb3Jkcy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5yZXNlcnZlZFdvcmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGNhdGhhcnNpc1RyYW5zZm9ybVJ1bGVzID0ge1xuICAgICAgICBKc2RvY1R5cGVPcHRpb25hbDogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IHRyYW5zZm9ybShyZXN1bHQuZWxlbWVudCk7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZC5vcHRpb25hbCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIEpzZG9jVHlwZU51bGxhYmxlOiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkID0gdHJhbnNmb3JtKHJlc3VsdC5lbGVtZW50KTtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkLm51bGxhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgICAgICAgfSxcbiAgICAgICAgSnNkb2NUeXBlTm90TnVsbGFibGU6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm0ocmVzdWx0LmVsZW1lbnQpO1xuICAgICAgICAgICAgdHJhbnNmb3JtZWQubnVsbGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgICAgICAgfSxcbiAgICAgICAgSnNkb2NUeXBlVmFyaWFkaWM6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5lbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvdHMgd2l0aG91dCB2YWx1ZSBhcmUgbm90IGFsbG93ZWQgaW4gY2F0aGFyc2lzIG1vZGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkID0gdHJhbnNmb3JtKHJlc3VsdC5lbGVtZW50KTtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkLnJlcGVhdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xuICAgICAgICB9LFxuICAgICAgICBKc2RvY1R5cGVBbnk6ICgpID0+ICh7XG4gICAgICAgICAgICB0eXBlOiAnQWxsTGl0ZXJhbCdcbiAgICAgICAgfSksXG4gICAgICAgIEpzZG9jVHlwZU51bGw6ICgpID0+ICh7XG4gICAgICAgICAgICB0eXBlOiAnTnVsbExpdGVyYWwnXG4gICAgICAgIH0pLFxuICAgICAgICBKc2RvY1R5cGVTdHJpbmdWYWx1ZTogcmVzdWx0ID0+IG1ha2VOYW1lKHF1b3RlKHJlc3VsdC52YWx1ZSwgcmVzdWx0Lm1ldGEucXVvdGUpKSxcbiAgICAgICAgSnNkb2NUeXBlVW5kZWZpbmVkOiAoKSA9PiAoe1xuICAgICAgICAgICAgdHlwZTogJ1VuZGVmaW5lZExpdGVyYWwnXG4gICAgICAgIH0pLFxuICAgICAgICBKc2RvY1R5cGVVbmtub3duOiAoKSA9PiAoe1xuICAgICAgICAgICAgdHlwZTogJ1Vua25vd25MaXRlcmFsJ1xuICAgICAgICB9KSxcbiAgICAgICAgSnNkb2NUeXBlRnVuY3Rpb246IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gZXh0cmFjdFNwZWNpYWxQYXJhbXMocmVzdWx0KTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdGdW5jdGlvblR5cGUnLFxuICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLnBhcmFtcy5tYXAodHJhbnNmb3JtKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMudGhpcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWQudGhpcyA9IHRyYW5zZm9ybShwYXJhbXMudGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW1zLm5ldyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWQubmV3ID0gdHJhbnNmb3JtKHBhcmFtcy5uZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXR1cm5UeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZC5yZXN1bHQgPSB0cmFuc2Zvcm0ocmVzdWx0LnJldHVyblR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xuICAgICAgICB9LFxuICAgICAgICBKc2RvY1R5cGVHZW5lcmljOiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+ICh7XG4gICAgICAgICAgICB0eXBlOiAnVHlwZUFwcGxpY2F0aW9uJyxcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uczogcmVzdWx0LmVsZW1lbnRzLm1hcChvID0+IHRyYW5zZm9ybShvKSksXG4gICAgICAgICAgICBleHByZXNzaW9uOiB0cmFuc2Zvcm0ocmVzdWx0LmxlZnQpXG4gICAgICAgIH0pLFxuICAgICAgICBKc2RvY1R5cGVTcGVjaWFsTmFtZVBhdGg6IHJlc3VsdCA9PiBtYWtlTmFtZShyZXN1bHQuc3BlY2lhbFR5cGUgKyAnOicgKyBxdW90ZShyZXN1bHQudmFsdWUsIHJlc3VsdC5tZXRhLnF1b3RlKSksXG4gICAgICAgIEpzZG9jVHlwZU5hbWU6IHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VOYW1lKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRnVuY3Rpb25UeXBlJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIEpzZG9jVHlwZU51bWJlcjogcmVzdWx0ID0+IG1ha2VOYW1lKHJlc3VsdC52YWx1ZS50b1N0cmluZygpKSxcbiAgICAgICAgSnNkb2NUeXBlT2JqZWN0OiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdSZWNvcmRUeXBlJyxcbiAgICAgICAgICAgICAgICBmaWVsZHM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiByZXN1bHQuZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQudHlwZSAhPT0gJ0pzZG9jVHlwZU9iamVjdEZpZWxkJyAmJiBmaWVsZC50eXBlICE9PSAnSnNkb2NUeXBlSnNkb2NPYmplY3RGaWVsZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWQuZmllbGRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0ZpZWxkVHlwZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHRyYW5zZm9ybShmaWVsZCksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWQuZmllbGRzLnB1c2godHJhbnNmb3JtKGZpZWxkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xuICAgICAgICB9LFxuICAgICAgICBKc2RvY1R5cGVPYmplY3RGaWVsZDogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdC5rZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmRleCBzaWduYXR1cmVzIGFuZCBtYXBwZWQgdHlwZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0ZpZWxkVHlwZScsXG4gICAgICAgICAgICAgICAga2V5OiBtYWtlTmFtZShxdW90ZShyZXN1bHQua2V5LCByZXN1bHQubWV0YS5xdW90ZSkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQucmlnaHQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHRyYW5zZm9ybShyZXN1bHQucmlnaHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBKc2RvY1R5cGVKc2RvY09iamVjdEZpZWxkOiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+ICh7XG4gICAgICAgICAgICB0eXBlOiAnRmllbGRUeXBlJyxcbiAgICAgICAgICAgIGtleTogdHJhbnNmb3JtKHJlc3VsdC5sZWZ0KSxcbiAgICAgICAgICAgIHZhbHVlOiB0cmFuc2Zvcm0ocmVzdWx0LnJpZ2h0KVxuICAgICAgICB9KSxcbiAgICAgICAgSnNkb2NUeXBlVW5pb246IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4gKHtcbiAgICAgICAgICAgIHR5cGU6ICdUeXBlVW5pb24nLFxuICAgICAgICAgICAgZWxlbWVudHM6IHJlc3VsdC5lbGVtZW50cy5tYXAoZSA9PiB0cmFuc2Zvcm0oZSkpXG4gICAgICAgIH0pLFxuICAgICAgICBKc2RvY1R5cGVLZXlWYWx1ZTogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdGaWVsZFR5cGUnLFxuICAgICAgICAgICAgICAgIGtleTogbWFrZU5hbWUocmVzdWx0LmtleSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC5yaWdodCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdHJhbnNmb3JtKHJlc3VsdC5yaWdodClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIEpzZG9jVHlwZU5hbWVQYXRoOiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRSZXN1bHQgPSB0cmFuc2Zvcm0ocmVzdWx0LmxlZnQpO1xuICAgICAgICAgICAgbGV0IHJpZ2h0VmFsdWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJpZ2h0LnR5cGUgPT09ICdKc2RvY1R5cGVTcGVjaWFsTmFtZVBhdGgnKSB7XG4gICAgICAgICAgICAgICAgcmlnaHRWYWx1ZSA9IHRyYW5zZm9ybShyZXN1bHQucmlnaHQpLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByaWdodFZhbHVlID0gcXVvdGUocmVzdWx0LnJpZ2h0LnZhbHVlLCByZXN1bHQucmlnaHQubWV0YS5xdW90ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBqb2luZXIgPSByZXN1bHQucGF0aFR5cGUgPT09ICdpbm5lcicgPyAnficgOiByZXN1bHQucGF0aFR5cGUgPT09ICdpbnN0YW5jZScgPyAnIycgOiAnLic7XG4gICAgICAgICAgICByZXR1cm4gbWFrZU5hbWUoYCR7bGVmdFJlc3VsdC5uYW1lfSR7am9pbmVyfSR7cmlnaHRWYWx1ZX1gKTtcbiAgICAgICAgfSxcbiAgICAgICAgSnNkb2NUeXBlU3ltYm9sOiByZXN1bHQgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gJyc7XG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IHJlc3VsdC5lbGVtZW50O1xuICAgICAgICAgICAgbGV0IHRyYWlsaW5nRG90cyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQudHlwZSkgPT09ICdKc2RvY1R5cGVWYXJpYWRpYycpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5tZXRhLnBvc2l0aW9uID09PSAncHJlZml4Jykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICcuLi4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdEb3RzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQuZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50LnR5cGUpID09PSAnSnNkb2NUeXBlTmFtZScpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBlbGVtZW50LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudC50eXBlKSA9PT0gJ0pzZG9jVHlwZU51bWJlcicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBlbGVtZW50LnZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhaWxpbmdEb3RzKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gJy4uLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFrZU5hbWUoYCR7cmVzdWx0LnZhbHVlfSgke3ZhbHVlfSlgKTtcbiAgICAgICAgfSxcbiAgICAgICAgSnNkb2NUeXBlUGFyZW50aGVzaXM6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4gdHJhbnNmb3JtKGFzc2VydFJvb3RSZXN1bHQocmVzdWx0LmVsZW1lbnQpKSxcbiAgICAgICAgSnNkb2NUeXBlTWFwcGVkVHlwZTogbm90QXZhaWxhYmxlVHJhbnNmb3JtLFxuICAgICAgICBKc2RvY1R5cGVJbmRleFNpZ25hdHVyZTogbm90QXZhaWxhYmxlVHJhbnNmb3JtLFxuICAgICAgICBKc2RvY1R5cGVJbXBvcnQ6IG5vdEF2YWlsYWJsZVRyYW5zZm9ybSxcbiAgICAgICAgSnNkb2NUeXBlS2V5b2Y6IG5vdEF2YWlsYWJsZVRyYW5zZm9ybSxcbiAgICAgICAgSnNkb2NUeXBlVHVwbGU6IG5vdEF2YWlsYWJsZVRyYW5zZm9ybSxcbiAgICAgICAgSnNkb2NUeXBlVHlwZW9mOiBub3RBdmFpbGFibGVUcmFuc2Zvcm0sXG4gICAgICAgIEpzZG9jVHlwZUludGVyc2VjdGlvbjogbm90QXZhaWxhYmxlVHJhbnNmb3JtLFxuICAgICAgICBKc2RvY1R5cGVQcm9wZXJ0eTogbm90QXZhaWxhYmxlVHJhbnNmb3JtLFxuICAgICAgICBKc2RvY1R5cGVQcmVkaWNhdGU6IG5vdEF2YWlsYWJsZVRyYW5zZm9ybSxcbiAgICAgICAgSnNkb2NUeXBlQXNzZXJ0czogbm90QXZhaWxhYmxlVHJhbnNmb3JtXG4gICAgfTtcbiAgICBmdW5jdGlvbiBjYXRoYXJzaXNUcmFuc2Zvcm0ocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm0oY2F0aGFyc2lzVHJhbnNmb3JtUnVsZXMsIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UXVvdGVTdHlsZShxdW90ZSkge1xuICAgICAgICBzd2l0Y2ggKHF1b3RlKSB7XG4gICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25vbmUnO1xuICAgICAgICAgICAgY2FzZSAnc2luZ2xlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3NpbmdsZSc7XG4gICAgICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnZG91YmxlJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRNZW1iZXJUeXBlKHR5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdpbm5lcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdJTk5FUl9NRU1CRVInO1xuICAgICAgICAgICAgY2FzZSAnaW5zdGFuY2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnSU5TVEFOQ0VfTUVNQkVSJztcbiAgICAgICAgICAgIGNhc2UgJ3Byb3BlcnR5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ01FTUJFUic7XG4gICAgICAgICAgICBjYXNlICdwcm9wZXJ0eS1icmFja2V0cyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdNRU1CRVInO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5lc3RSZXN1bHRzKHR5cGUsIHJlc3VsdHMpIHtcbiAgICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgbGVmdDogcmVzdWx0c1swXSxcbiAgICAgICAgICAgICAgICByaWdodDogcmVzdWx0c1sxXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBsZWZ0OiByZXN1bHRzWzBdLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBuZXN0UmVzdWx0cyh0eXBlLCByZXN1bHRzLnNsaWNlKDEpKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBqdHBSdWxlcyA9IHtcbiAgICAgICAgSnNkb2NUeXBlT3B0aW9uYWw6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4gKHtcbiAgICAgICAgICAgIHR5cGU6ICdPUFRJT05BTCcsXG4gICAgICAgICAgICB2YWx1ZTogdHJhbnNmb3JtKHJlc3VsdC5lbGVtZW50KSxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICBzeW50YXg6IHJlc3VsdC5tZXRhLnBvc2l0aW9uID09PSAncHJlZml4JyA/ICdQUkVGSVhfRVFVQUxfU0lHTicgOiAnU1VGRklYX0VRVUFMU19TSUdOJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgSnNkb2NUeXBlTnVsbGFibGU6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4gKHtcbiAgICAgICAgICAgIHR5cGU6ICdOVUxMQUJMRScsXG4gICAgICAgICAgICB2YWx1ZTogdHJhbnNmb3JtKHJlc3VsdC5lbGVtZW50KSxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICBzeW50YXg6IHJlc3VsdC5tZXRhLnBvc2l0aW9uID09PSAncHJlZml4JyA/ICdQUkVGSVhfUVVFU1RJT05fTUFSSycgOiAnU1VGRklYX1FVRVNUSU9OX01BUksnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBKc2RvY1R5cGVOb3ROdWxsYWJsZTogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiAoe1xuICAgICAgICAgICAgdHlwZTogJ05PVF9OVUxMQUJMRScsXG4gICAgICAgICAgICB2YWx1ZTogdHJhbnNmb3JtKHJlc3VsdC5lbGVtZW50KSxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICBzeW50YXg6IHJlc3VsdC5tZXRhLnBvc2l0aW9uID09PSAncHJlZml4JyA/ICdQUkVGSVhfQkFORycgOiAnU1VGRklYX0JBTkcnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBKc2RvY1R5cGVWYXJpYWRpYzogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnVkFSSUFESUMnLFxuICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgc3ludGF4OiByZXN1bHQubWV0YS5wb3NpdGlvbiA9PT0gJ3ByZWZpeCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ1BSRUZJWF9ET1RTJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiByZXN1bHQubWV0YS5wb3NpdGlvbiA9PT0gJ3N1ZmZpeCcgPyAnU1VGRklYX0RPVFMnIDogJ09OTFlfRE9UUydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5lbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZC52YWx1ZSA9IHRyYW5zZm9ybShyZXN1bHQuZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIEpzZG9jVHlwZU5hbWU6IHJlc3VsdCA9PiAoe1xuICAgICAgICAgICAgdHlwZTogJ05BTUUnLFxuICAgICAgICAgICAgbmFtZTogcmVzdWx0LnZhbHVlXG4gICAgICAgIH0pLFxuICAgICAgICBKc2RvY1R5cGVUeXBlb2Y6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4gKHtcbiAgICAgICAgICAgIHR5cGU6ICdUWVBFX1FVRVJZJyxcbiAgICAgICAgICAgIG5hbWU6IHRyYW5zZm9ybShyZXN1bHQuZWxlbWVudClcbiAgICAgICAgfSksXG4gICAgICAgIEpzZG9jVHlwZVR1cGxlOiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+ICh7XG4gICAgICAgICAgICB0eXBlOiAnVFVQTEUnLFxuICAgICAgICAgICAgZW50cmllczogcmVzdWx0LmVsZW1lbnRzLm1hcCh0cmFuc2Zvcm0pXG4gICAgICAgIH0pLFxuICAgICAgICBKc2RvY1R5cGVLZXlvZjogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiAoe1xuICAgICAgICAgICAgdHlwZTogJ0tFWV9RVUVSWScsXG4gICAgICAgICAgICB2YWx1ZTogdHJhbnNmb3JtKHJlc3VsdC5lbGVtZW50KVxuICAgICAgICB9KSxcbiAgICAgICAgSnNkb2NUeXBlSW1wb3J0OiByZXN1bHQgPT4gKHtcbiAgICAgICAgICAgIHR5cGU6ICdJTVBPUlQnLFxuICAgICAgICAgICAgcGF0aDoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdTVFJJTkdfVkFMVUUnLFxuICAgICAgICAgICAgICAgIHF1b3RlU3R5bGU6IGdldFF1b3RlU3R5bGUocmVzdWx0LmVsZW1lbnQubWV0YS5xdW90ZSksXG4gICAgICAgICAgICAgICAgc3RyaW5nOiByZXN1bHQuZWxlbWVudC52YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgSnNkb2NUeXBlVW5kZWZpbmVkOiAoKSA9PiAoe1xuICAgICAgICAgICAgdHlwZTogJ05BTUUnLFxuICAgICAgICAgICAgbmFtZTogJ3VuZGVmaW5lZCdcbiAgICAgICAgfSksXG4gICAgICAgIEpzZG9jVHlwZUFueTogKCkgPT4gKHtcbiAgICAgICAgICAgIHR5cGU6ICdBTlknXG4gICAgICAgIH0pLFxuICAgICAgICBKc2RvY1R5cGVGdW5jdGlvbjogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzcGVjaWFsUGFyYW1zID0gZXh0cmFjdFNwZWNpYWxQYXJhbXMocmVzdWx0KTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHJlc3VsdC5hcnJvdyA/ICdBUlJPVycgOiAnRlVOQ1RJT04nLFxuICAgICAgICAgICAgICAgIHBhcmFtczogc3BlY2lhbFBhcmFtcy5wYXJhbXMubWFwKHBhcmFtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09ICdKc2RvY1R5cGVLZXlWYWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbS5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBwYXJhbWV0ZXIgd2l0aG91dCBcXCc6XFwnIGlzIG5vdCBleHBlY3RlZCB0byBiZSBcXCdLRVlfVkFMVUVcXCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ05BTUVEX1BBUkFNRVRFUicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcGFyYW0ua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVOYW1lOiB0cmFuc2Zvcm0ocGFyYW0ucmlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybShwYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBuZXc6IG51bGwsXG4gICAgICAgICAgICAgICAgcmV0dXJuczogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChzcGVjaWFsUGFyYW1zLnRoaXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkLnRoaXMgPSB0cmFuc2Zvcm0oc3BlY2lhbFBhcmFtcy50aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFyZXN1bHQuYXJyb3cpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZC50aGlzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcGVjaWFsUGFyYW1zLm5ldyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWQubmV3ID0gdHJhbnNmb3JtKHNwZWNpYWxQYXJhbXMubmV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQucmV0dXJuVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWQucmV0dXJucyA9IHRyYW5zZm9ybShyZXN1bHQucmV0dXJuVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIEpzZG9jVHlwZUdlbmVyaWM6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0dFTkVSSUMnLFxuICAgICAgICAgICAgICAgIHN1YmplY3Q6IHRyYW5zZm9ybShyZXN1bHQubGVmdCksXG4gICAgICAgICAgICAgICAgb2JqZWN0czogcmVzdWx0LmVsZW1lbnRzLm1hcCh0cmFuc2Zvcm0pLFxuICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgc3ludGF4OiByZXN1bHQubWV0YS5icmFja2V0cyA9PT0gJ3NxdWFyZScgPyAnU1FVQVJFX0JSQUNLRVQnIDogcmVzdWx0Lm1ldGEuZG90ID8gJ0FOR0xFX0JSQUNLRVRfV0lUSF9ET1QnIDogJ0FOR0xFX0JSQUNLRVQnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubWV0YS5icmFja2V0cyA9PT0gJ3NxdWFyZScgJiYgcmVzdWx0LmVsZW1lbnRzWzBdLnR5cGUgPT09ICdKc2RvY1R5cGVGdW5jdGlvbicgJiYgIXJlc3VsdC5lbGVtZW50c1swXS5wYXJlbnRoZXNpcykge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkLm9iamVjdHNbMF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdOQU1FJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIEpzZG9jVHlwZU9iamVjdEZpZWxkOiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0LmtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luZGV4IHNpZ25hdHVyZXMgYW5kIG1hcHBlZCB0eXBlcyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFQ09SRF9FTlRSWScsXG4gICAgICAgICAgICAgICAgICAgIGtleTogcmVzdWx0LmtleSxcbiAgICAgICAgICAgICAgICAgICAgcXVvdGVTdHlsZTogZ2V0UXVvdGVTdHlsZShyZXN1bHQubWV0YS5xdW90ZSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJpZ2h0ID0gdHJhbnNmb3JtKHJlc3VsdC5yaWdodCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lm9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdPUFRJT05BTCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiByaWdodCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ludGF4OiAnU1VGRklYX0tFWV9RVUVTVElPTl9NQVJLJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1JFQ09SRF9FTlRSWScsXG4gICAgICAgICAgICAgICAga2V5OiByZXN1bHQua2V5LnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgcXVvdGVTdHlsZTogZ2V0UXVvdGVTdHlsZShyZXN1bHQubWV0YS5xdW90ZSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJpZ2h0LFxuICAgICAgICAgICAgICAgIHJlYWRvbmx5OiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgSnNkb2NUeXBlSnNkb2NPYmplY3RGaWVsZDogKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXlzIG1heSBub3QgYmUgdHlwZWQgaW4ganNkb2N0eXBlcGFyc2VyLicpO1xuICAgICAgICB9LFxuICAgICAgICBKc2RvY1R5cGVLZXlWYWx1ZTogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUkVDT1JEX0VOVFJZJyxcbiAgICAgICAgICAgICAgICAgICAga2V5OiByZXN1bHQua2V5LFxuICAgICAgICAgICAgICAgICAgICBxdW90ZVN0eWxlOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJpZ2h0ID0gdHJhbnNmb3JtKHJlc3VsdC5yaWdodCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lm9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdPUFRJT05BTCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiByaWdodCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ludGF4OiAnU1VGRklYX0tFWV9RVUVTVElPTl9NQVJLJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1JFQ09SRF9FTlRSWScsXG4gICAgICAgICAgICAgICAga2V5OiByZXN1bHQua2V5LFxuICAgICAgICAgICAgICAgIHF1b3RlU3R5bGU6ICdub25lJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmlnaHQsXG4gICAgICAgICAgICAgICAgcmVhZG9ubHk6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBKc2RvY1R5cGVPYmplY3Q6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiByZXN1bHQuZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQudHlwZSA9PT0gJ0pzZG9jVHlwZU9iamVjdEZpZWxkJyB8fCBmaWVsZC50eXBlID09PSAnSnNkb2NUeXBlSnNkb2NPYmplY3RGaWVsZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKHRyYW5zZm9ybShmaWVsZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1JFQ09SRCcsXG4gICAgICAgICAgICAgICAgZW50cmllc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgSnNkb2NUeXBlU3BlY2lhbE5hbWVQYXRoOiByZXN1bHQgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zcGVjaWFsVHlwZSAhPT0gJ21vZHVsZScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGpzZG9jdHlwZXBhcnNlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGUgJHtyZXN1bHQuc3BlY2lhbFR5cGV9IGF0IHRoaXMgcG9pbnQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdNT0RVTEUnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdGSUxFX1BBVEgnLFxuICAgICAgICAgICAgICAgICAgICBxdW90ZVN0eWxlOiBnZXRRdW90ZVN0eWxlKHJlc3VsdC5tZXRhLnF1b3RlKSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogcmVzdWx0LnZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgSnNkb2NUeXBlTmFtZVBhdGg6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4ge1xuICAgICAgICAgICAgbGV0IGhhc0V2ZW50UHJlZml4ID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbmFtZTtcbiAgICAgICAgICAgIGxldCBxdW90ZVN0eWxlO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5yaWdodC50eXBlID09PSAnSnNkb2NUeXBlU3BlY2lhbE5hbWVQYXRoJyAmJiByZXN1bHQucmlnaHQuc3BlY2lhbFR5cGUgPT09ICdldmVudCcpIHtcbiAgICAgICAgICAgICAgICBoYXNFdmVudFByZWZpeCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbmFtZSA9IHJlc3VsdC5yaWdodC52YWx1ZTtcbiAgICAgICAgICAgICAgICBxdW90ZVN0eWxlID0gZ2V0UXVvdGVTdHlsZShyZXN1bHQucmlnaHQubWV0YS5xdW90ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gcmVzdWx0LnJpZ2h0LnZhbHVlO1xuICAgICAgICAgICAgICAgIHF1b3RlU3R5bGUgPSBnZXRRdW90ZVN0eWxlKHJlc3VsdC5yaWdodC5tZXRhLnF1b3RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGdldE1lbWJlclR5cGUocmVzdWx0LnBhdGhUeXBlKSxcbiAgICAgICAgICAgICAgICBvd25lcjogdHJhbnNmb3JtKHJlc3VsdC5sZWZ0KSxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHF1b3RlU3R5bGUsXG4gICAgICAgICAgICAgICAgaGFzRXZlbnRQcmVmaXhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtZWQub3duZXIudHlwZSA9PT0gJ01PRFVMRScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0TW9kdWxlID0gdHJhbnNmb3JtZWQub3duZXI7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWQub3duZXIgPSB0cmFuc2Zvcm1lZC5vd25lci52YWx1ZTtcbiAgICAgICAgICAgICAgICB0TW9kdWxlLnZhbHVlID0gdHJhbnNmb3JtZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRNb2R1bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIEpzZG9jVHlwZVVuaW9uOiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+IG5lc3RSZXN1bHRzKCdVTklPTicsIHJlc3VsdC5lbGVtZW50cy5tYXAodHJhbnNmb3JtKSksXG4gICAgICAgIEpzZG9jVHlwZVBhcmVudGhlc2lzOiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+ICh7XG4gICAgICAgICAgICB0eXBlOiAnUEFSRU5USEVTSVMnLFxuICAgICAgICAgICAgdmFsdWU6IHRyYW5zZm9ybShhc3NlcnRSb290UmVzdWx0KHJlc3VsdC5lbGVtZW50KSlcbiAgICAgICAgfSksXG4gICAgICAgIEpzZG9jVHlwZU51bGw6ICgpID0+ICh7XG4gICAgICAgICAgICB0eXBlOiAnTkFNRScsXG4gICAgICAgICAgICBuYW1lOiAnbnVsbCdcbiAgICAgICAgfSksXG4gICAgICAgIEpzZG9jVHlwZVVua25vd246ICgpID0+ICh7XG4gICAgICAgICAgICB0eXBlOiAnVU5LTk9XTidcbiAgICAgICAgfSksXG4gICAgICAgIEpzZG9jVHlwZVN0cmluZ1ZhbHVlOiByZXN1bHQgPT4gKHtcbiAgICAgICAgICAgIHR5cGU6ICdTVFJJTkdfVkFMVUUnLFxuICAgICAgICAgICAgcXVvdGVTdHlsZTogZ2V0UXVvdGVTdHlsZShyZXN1bHQubWV0YS5xdW90ZSksXG4gICAgICAgICAgICBzdHJpbmc6IHJlc3VsdC52YWx1ZVxuICAgICAgICB9KSxcbiAgICAgICAgSnNkb2NUeXBlSW50ZXJzZWN0aW9uOiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+IG5lc3RSZXN1bHRzKCdJTlRFUlNFQ1RJT04nLCByZXN1bHQuZWxlbWVudHMubWFwKHRyYW5zZm9ybSkpLFxuICAgICAgICBKc2RvY1R5cGVOdW1iZXI6IHJlc3VsdCA9PiAoe1xuICAgICAgICAgICAgdHlwZTogJ05VTUJFUl9WQUxVRScsXG4gICAgICAgICAgICBudW1iZXI6IHJlc3VsdC52YWx1ZS50b1N0cmluZygpXG4gICAgICAgIH0pLFxuICAgICAgICBKc2RvY1R5cGVTeW1ib2w6IG5vdEF2YWlsYWJsZVRyYW5zZm9ybSxcbiAgICAgICAgSnNkb2NUeXBlUHJvcGVydHk6IG5vdEF2YWlsYWJsZVRyYW5zZm9ybSxcbiAgICAgICAgSnNkb2NUeXBlUHJlZGljYXRlOiBub3RBdmFpbGFibGVUcmFuc2Zvcm0sXG4gICAgICAgIEpzZG9jVHlwZU1hcHBlZFR5cGU6IG5vdEF2YWlsYWJsZVRyYW5zZm9ybSxcbiAgICAgICAgSnNkb2NUeXBlSW5kZXhTaWduYXR1cmU6IG5vdEF2YWlsYWJsZVRyYW5zZm9ybSxcbiAgICAgICAgSnNkb2NUeXBlQXNzZXJ0czogbm90QXZhaWxhYmxlVHJhbnNmb3JtXG4gICAgfTtcbiAgICBmdW5jdGlvbiBqdHBUcmFuc2Zvcm0ocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm0oanRwUnVsZXMsIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaWRlbnRpdHlUcmFuc2Zvcm1SdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEpzZG9jVHlwZUludGVyc2VjdGlvbjogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiAoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVJbnRlcnNlY3Rpb24nLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzOiByZXN1bHQuZWxlbWVudHMubWFwKHRyYW5zZm9ybSlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgSnNkb2NUeXBlR2VuZXJpYzogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiAoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVHZW5lcmljJyxcbiAgICAgICAgICAgICAgICBsZWZ0OiB0cmFuc2Zvcm0ocmVzdWx0LmxlZnQpLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzOiByZXN1bHQuZWxlbWVudHMubWFwKHRyYW5zZm9ybSksXG4gICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICBkb3Q6IHJlc3VsdC5tZXRhLmRvdCxcbiAgICAgICAgICAgICAgICAgICAgYnJhY2tldHM6IHJlc3VsdC5tZXRhLmJyYWNrZXRzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBKc2RvY1R5cGVOdWxsYWJsZTogcmVzdWx0ID0+IHJlc3VsdCxcbiAgICAgICAgICAgIEpzZG9jVHlwZVVuaW9uOiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+ICh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZVVuaW9uJyxcbiAgICAgICAgICAgICAgICBlbGVtZW50czogcmVzdWx0LmVsZW1lbnRzLm1hcCh0cmFuc2Zvcm0pXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIEpzZG9jVHlwZVVua25vd246IHJlc3VsdCA9PiByZXN1bHQsXG4gICAgICAgICAgICBKc2RvY1R5cGVVbmRlZmluZWQ6IHJlc3VsdCA9PiByZXN1bHQsXG4gICAgICAgICAgICBKc2RvY1R5cGVUeXBlb2Y6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4gKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlVHlwZW9mJyxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB0cmFuc2Zvcm0ocmVzdWx0LmVsZW1lbnQpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIEpzZG9jVHlwZVN5bWJvbDogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVTeW1ib2wnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnZhbHVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZC5lbGVtZW50ID0gdHJhbnNmb3JtKHJlc3VsdC5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEpzZG9jVHlwZU9wdGlvbmFsOiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+ICh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZU9wdGlvbmFsJyxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB0cmFuc2Zvcm0ocmVzdWx0LmVsZW1lbnQpLFxuICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHJlc3VsdC5tZXRhLnBvc2l0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBKc2RvY1R5cGVPYmplY3Q6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4gKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlT2JqZWN0JyxcbiAgICAgICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvcjogJ2NvbW1hJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZWxlbWVudHM6IHJlc3VsdC5lbGVtZW50cy5tYXAodHJhbnNmb3JtKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBKc2RvY1R5cGVOdW1iZXI6IHJlc3VsdCA9PiByZXN1bHQsXG4gICAgICAgICAgICBKc2RvY1R5cGVOdWxsOiByZXN1bHQgPT4gcmVzdWx0LFxuICAgICAgICAgICAgSnNkb2NUeXBlTm90TnVsbGFibGU6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4gKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlTm90TnVsbGFibGUnLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRyYW5zZm9ybShyZXN1bHQuZWxlbWVudCksXG4gICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcmVzdWx0Lm1ldGEucG9zaXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIEpzZG9jVHlwZVNwZWNpYWxOYW1lUGF0aDogcmVzdWx0ID0+IHJlc3VsdCxcbiAgICAgICAgICAgIEpzZG9jVHlwZU9iamVjdEZpZWxkOiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+ICh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZU9iamVjdEZpZWxkJyxcbiAgICAgICAgICAgICAgICBrZXk6IHJlc3VsdC5rZXksXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHJlc3VsdC5yaWdodCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdHJhbnNmb3JtKHJlc3VsdC5yaWdodCksXG4gICAgICAgICAgICAgICAgb3B0aW9uYWw6IHJlc3VsdC5vcHRpb25hbCxcbiAgICAgICAgICAgICAgICByZWFkb25seTogcmVzdWx0LnJlYWRvbmx5LFxuICAgICAgICAgICAgICAgIG1ldGE6IHJlc3VsdC5tZXRhXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIEpzZG9jVHlwZUpzZG9jT2JqZWN0RmllbGQ6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4gKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlSnNkb2NPYmplY3RGaWVsZCcsXG4gICAgICAgICAgICAgICAgbGVmdDogdHJhbnNmb3JtKHJlc3VsdC5sZWZ0KSxcbiAgICAgICAgICAgICAgICByaWdodDogdHJhbnNmb3JtKHJlc3VsdC5yaWdodClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgSnNkb2NUeXBlS2V5VmFsdWU6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVLZXlWYWx1ZScsXG4gICAgICAgICAgICAgICAgICAgIGtleTogcmVzdWx0LmtleSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJlc3VsdC5yaWdodCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdHJhbnNmb3JtKHJlc3VsdC5yaWdodCksXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiByZXN1bHQub3B0aW9uYWwsXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhZGljOiByZXN1bHQudmFyaWFkaWNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEpzZG9jVHlwZUltcG9ydDogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiAoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVJbXBvcnQnLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRyYW5zZm9ybShyZXN1bHQuZWxlbWVudClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgSnNkb2NUeXBlQW55OiByZXN1bHQgPT4gcmVzdWx0LFxuICAgICAgICAgICAgSnNkb2NUeXBlU3RyaW5nVmFsdWU6IHJlc3VsdCA9PiByZXN1bHQsXG4gICAgICAgICAgICBKc2RvY1R5cGVOYW1lUGF0aDogcmVzdWx0ID0+IHJlc3VsdCxcbiAgICAgICAgICAgIEpzZG9jVHlwZVZhcmlhZGljOiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZVZhcmlhZGljJyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHJlc3VsdC5tZXRhLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3F1YXJlQnJhY2tldHM6IHJlc3VsdC5tZXRhLnNxdWFyZUJyYWNrZXRzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkLmVsZW1lbnQgPSB0cmFuc2Zvcm0ocmVzdWx0LmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgSnNkb2NUeXBlVHVwbGU6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4gKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlVHVwbGUnLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzOiByZXN1bHQuZWxlbWVudHMubWFwKHRyYW5zZm9ybSlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgSnNkb2NUeXBlTmFtZTogcmVzdWx0ID0+IHJlc3VsdCxcbiAgICAgICAgICAgIEpzZG9jVHlwZUZ1bmN0aW9uOiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZUZ1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgYXJyb3c6IHJlc3VsdC5hcnJvdyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczogcmVzdWx0LnBhcmFtZXRlcnMubWFwKHRyYW5zZm9ybSksXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yOiByZXN1bHQuY29uc3RydWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudGhlc2lzOiByZXN1bHQucGFyZW50aGVzaXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmV0dXJuVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkLnJldHVyblR5cGUgPSB0cmFuc2Zvcm0ocmVzdWx0LnJldHVyblR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgSnNkb2NUeXBlS2V5b2Y6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4gKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlS2V5b2YnLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRyYW5zZm9ybShyZXN1bHQuZWxlbWVudClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgSnNkb2NUeXBlUGFyZW50aGVzaXM6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4gKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlUGFyZW50aGVzaXMnLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRyYW5zZm9ybShyZXN1bHQuZWxlbWVudClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgSnNkb2NUeXBlUHJvcGVydHk6IHJlc3VsdCA9PiByZXN1bHQsXG4gICAgICAgICAgICBKc2RvY1R5cGVQcmVkaWNhdGU6IChyZXN1bHQsIHRyYW5zZm9ybSkgPT4gKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnSnNkb2NUeXBlUHJlZGljYXRlJyxcbiAgICAgICAgICAgICAgICBsZWZ0OiB0cmFuc2Zvcm0ocmVzdWx0LmxlZnQpLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0cmFuc2Zvcm0ocmVzdWx0LnJpZ2h0KVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBKc2RvY1R5cGVJbmRleFNpZ25hdHVyZTogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiAoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVJbmRleFNpZ25hdHVyZScsXG4gICAgICAgICAgICAgICAga2V5OiByZXN1bHQua2V5LFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0cmFuc2Zvcm0ocmVzdWx0LnJpZ2h0KVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBKc2RvY1R5cGVNYXBwZWRUeXBlOiAocmVzdWx0LCB0cmFuc2Zvcm0pID0+ICh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0pzZG9jVHlwZU1hcHBlZFR5cGUnLFxuICAgICAgICAgICAgICAgIGtleTogcmVzdWx0LmtleSxcbiAgICAgICAgICAgICAgICByaWdodDogdHJhbnNmb3JtKHJlc3VsdC5yaWdodClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgSnNkb2NUeXBlQXNzZXJ0czogKHJlc3VsdCwgdHJhbnNmb3JtKSA9PiAoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdKc2RvY1R5cGVBc3NlcnRzJyxcbiAgICAgICAgICAgICAgICBsZWZ0OiB0cmFuc2Zvcm0ocmVzdWx0LmxlZnQpLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0cmFuc2Zvcm0ocmVzdWx0LnJpZ2h0KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCB2aXNpdG9yS2V5cyA9IHtcbiAgICAgICAgSnNkb2NUeXBlQW55OiBbXSxcbiAgICAgICAgSnNkb2NUeXBlRnVuY3Rpb246IFsncGFyYW1ldGVycycsICdyZXR1cm5UeXBlJ10sXG4gICAgICAgIEpzZG9jVHlwZUdlbmVyaWM6IFsnbGVmdCcsICdlbGVtZW50cyddLFxuICAgICAgICBKc2RvY1R5cGVJbXBvcnQ6IFtdLFxuICAgICAgICBKc2RvY1R5cGVJbmRleFNpZ25hdHVyZTogWydyaWdodCddLFxuICAgICAgICBKc2RvY1R5cGVJbnRlcnNlY3Rpb246IFsnZWxlbWVudHMnXSxcbiAgICAgICAgSnNkb2NUeXBlS2V5b2Y6IFsnZWxlbWVudCddLFxuICAgICAgICBKc2RvY1R5cGVLZXlWYWx1ZTogWydyaWdodCddLFxuICAgICAgICBKc2RvY1R5cGVNYXBwZWRUeXBlOiBbJ3JpZ2h0J10sXG4gICAgICAgIEpzZG9jVHlwZU5hbWU6IFtdLFxuICAgICAgICBKc2RvY1R5cGVOYW1lUGF0aDogWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICAgIEpzZG9jVHlwZU5vdE51bGxhYmxlOiBbJ2VsZW1lbnQnXSxcbiAgICAgICAgSnNkb2NUeXBlTnVsbDogW10sXG4gICAgICAgIEpzZG9jVHlwZU51bGxhYmxlOiBbJ2VsZW1lbnQnXSxcbiAgICAgICAgSnNkb2NUeXBlTnVtYmVyOiBbXSxcbiAgICAgICAgSnNkb2NUeXBlT2JqZWN0OiBbJ2VsZW1lbnRzJ10sXG4gICAgICAgIEpzZG9jVHlwZU9iamVjdEZpZWxkOiBbJ3JpZ2h0J10sXG4gICAgICAgIEpzZG9jVHlwZUpzZG9jT2JqZWN0RmllbGQ6IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBKc2RvY1R5cGVPcHRpb25hbDogWydlbGVtZW50J10sXG4gICAgICAgIEpzZG9jVHlwZVBhcmVudGhlc2lzOiBbJ2VsZW1lbnQnXSxcbiAgICAgICAgSnNkb2NUeXBlU3BlY2lhbE5hbWVQYXRoOiBbXSxcbiAgICAgICAgSnNkb2NUeXBlU3RyaW5nVmFsdWU6IFtdLFxuICAgICAgICBKc2RvY1R5cGVTeW1ib2w6IFsnZWxlbWVudCddLFxuICAgICAgICBKc2RvY1R5cGVUdXBsZTogWydlbGVtZW50cyddLFxuICAgICAgICBKc2RvY1R5cGVUeXBlb2Y6IFsnZWxlbWVudCddLFxuICAgICAgICBKc2RvY1R5cGVVbmRlZmluZWQ6IFtdLFxuICAgICAgICBKc2RvY1R5cGVVbmlvbjogWydlbGVtZW50cyddLFxuICAgICAgICBKc2RvY1R5cGVVbmtub3duOiBbXSxcbiAgICAgICAgSnNkb2NUeXBlVmFyaWFkaWM6IFsnZWxlbWVudCddLFxuICAgICAgICBKc2RvY1R5cGVQcm9wZXJ0eTogW10sXG4gICAgICAgIEpzZG9jVHlwZVByZWRpY2F0ZTogWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICAgIEpzZG9jVHlwZUFzc2VydHM6IFsnbGVmdCcsICdyaWdodCddXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF90cmF2ZXJzZShub2RlLCBwYXJlbnROb2RlLCBwcm9wZXJ0eSwgb25FbnRlciwgb25MZWF2ZSkge1xuICAgICAgICBvbkVudGVyID09PSBudWxsIHx8IG9uRW50ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uRW50ZXIobm9kZSwgcGFyZW50Tm9kZSwgcHJvcGVydHkpO1xuICAgICAgICBjb25zdCBrZXlzVG9WaXNpdCA9IHZpc2l0b3JLZXlzW25vZGUudHlwZV07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXNUb1Zpc2l0KSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5vZGVba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RyYXZlcnNlKGVsZW1lbnQsIG5vZGUsIGtleSwgb25FbnRlciwgb25MZWF2ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90cmF2ZXJzZSh2YWx1ZSwgbm9kZSwga2V5LCBvbkVudGVyLCBvbkxlYXZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb25MZWF2ZSA9PT0gbnVsbCB8fCBvbkxlYXZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkxlYXZlKG5vZGUsIHBhcmVudE5vZGUsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0byB0cmF2ZXJzZSBhbiBBU1QuIEl0IHRyYXZlcnNlcyBpdCBkZXB0aCBmaXJzdC5cbiAgICAgKiBAcGFyYW0gbm9kZSB0aGUgbm9kZSB0byBzdGFydCB0cmF2ZXJzaW5nIGF0LlxuICAgICAqIEBwYXJhbSBvbkVudGVyIG5vZGUgdmlzaXRvciBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uIGVudGVyaW5nIHRoZSBub2RlLiBUaGlzIGNvcnJlc3BvbmRzIHRvIHByZW9yZGVyIHRyYXZlcnNpbmcuXG4gICAgICogQHBhcmFtIG9uTGVhdmUgbm9kZSB2aXNpdG9yIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb24gbGVhdmluZyB0aGUgbm9kZS4gVGhpcyBjb3JyZXNwb25kcyB0byBwb3N0b3JkZXIgdHJhdmVyc2luZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmF2ZXJzZShub2RlLCBvbkVudGVyLCBvbkxlYXZlKSB7XG4gICAgICAgIF90cmF2ZXJzZShub2RlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb25FbnRlciwgb25MZWF2ZSk7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5jYXRoYXJzaXNUcmFuc2Zvcm0gPSBjYXRoYXJzaXNUcmFuc2Zvcm07XG4gICAgZXhwb3J0cy5pZGVudGl0eVRyYW5zZm9ybVJ1bGVzID0gaWRlbnRpdHlUcmFuc2Zvcm1SdWxlcztcbiAgICBleHBvcnRzLmp0cFRyYW5zZm9ybSA9IGp0cFRyYW5zZm9ybTtcbiAgICBleHBvcnRzLnBhcnNlID0gcGFyc2U7XG4gICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG4gICAgZXhwb3J0cy5zdHJpbmdpZnlSdWxlcyA9IHN0cmluZ2lmeVJ1bGVzO1xuICAgIGV4cG9ydHMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGV4cG9ydHMudHJhdmVyc2UgPSB0cmF2ZXJzZTtcbiAgICBleHBvcnRzLnRyeVBhcnNlID0gdHJ5UGFyc2U7XG4gICAgZXhwb3J0cy52aXNpdG9yS2V5cyA9IHZpc2l0b3JLZXlzO1xuXG59KSk7XG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJnbG9iYWxUaGlzIiwic2VsZiIsImp0cHAiLCJ0b2tlblRvU3RyaW5nIiwidG9rZW4iLCJ0ZXh0IiwidW5kZWZpbmVkIiwidHlwZSIsIk5vUGFyc2xldEZvdW5kRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJnZXRUb2tlbiIsIkVhcmx5RW5kT2ZQYXJzZUVycm9yIiwiVW5leHBlY3RlZFR5cGVFcnJvciIsInJlc3VsdCIsIm1lc3NhZ2UiLCJlcnJvciIsIm1ha2VQdW5jdHVhdGlvblJ1bGUiLCJzdGFydHNXaXRoIiwiZ2V0UXVvdGVkIiwicG9zaXRpb24iLCJjaGFyIiwibWFyayIsImVzY2FwZWQiLCJsZW5ndGgiLCJzbGljZSIsImlkZW50aWZpZXJTdGFydFJlZ2V4IiwiaWRlbnRpZmllckNvbnRpbnVlUmVnZXgiLCJnZXRJZGVudGlmaWVyIiwidGVzdCIsIm51bWJlclJlZ2V4IiwiZ2V0TnVtYmVyIiwiX2EiLCJfYiIsImV4ZWMiLCJpZGVudGlmaWVyUnVsZSIsInZhbHVlIiwibWFrZUtleVdvcmRSdWxlIiwicHJlcGVuZHMiLCJzdHJpbmdWYWx1ZVJ1bGUiLCJlb2ZSdWxlIiwibnVtYmVyUnVsZSIsInJ1bGVzIiwiYnJlYWtpbmdXaGl0ZXNwYWNlUmVnZXgiLCJMZXhlciIsImNyZWF0ZSIsImN1cnJlbnQiLCJyZWFkIiwibmV4dCIsInByZXZpb3VzIiwic3RhcnRPZkxpbmUiLCJhcmd1bWVudHMiLCJ0cmltIiwicnVsZSIsInBhcnRpYWwiLCJhc3NpZ24iLCJhZHZhbmNlIiwiYXNzZXJ0Um9vdFJlc3VsdCIsImFzc2VydFBsYWluS2V5VmFsdWVPclJvb3RSZXN1bHQiLCJhc3NlcnRQbGFpbktleVZhbHVlUmVzdWx0IiwiYXNzZXJ0UGxhaW5LZXlWYWx1ZU9yTmFtZVJlc3VsdCIsImFzc2VydE51bWJlck9yVmFyaWFkaWNOYW1lUmVzdWx0IiwiZWxlbWVudCIsImlzU3F1YXJlZFByb3BlcnR5IiwiUHJlY2VkZW5jZSIsIlBhcnNlciIsImdyYW1tYXIiLCJ0ZXh0T3JMZXhlciIsImJhc2VQYXJzZXIiLCJfbGV4ZXIiLCJsZXhlciIsInBhcnNlIiwicGFyc2VUeXBlIiwiQUxMIiwicHJlY2VkZW5jZSIsInBhcnNlSW50ZXJtZWRpYXRlVHlwZSIsInRyeVBhcnNsZXRzIiwicGFyc2VJbmZpeEludGVybWVkaWF0ZVR5cGUiLCJsZWZ0IiwicGFyc2xldCIsImNvbnN1bWUiLCJ0eXBlcyIsIkFycmF5IiwiaXNBcnJheSIsImluY2x1ZGVzIiwiYWNjZXB0TGV4ZXJTdGF0ZSIsInBhcnNlciIsImlzUXVlc3Rpb25NYXJrVW5rbm93blR5cGUiLCJudWxsYWJsZVBhcnNsZXQiLCJhY2NlcHQiLCJOVUxMQUJMRSIsIm1ldGEiLCJjb21wb3NlUGFyc2xldCIsIm9wdGlvbnMiLCJjdXJQcmVjZWRlbmNlIiwicGFyc2VQcmVmaXgiLCJwYXJzZUluZml4IiwiZGVmaW5lUHJvcGVydHkiLCJuYW1lIiwib3B0aW9uYWxQYXJzbGV0IiwiT1BUSU9OQUwiLCJudW1iZXJQYXJzbGV0IiwicGFyc2VGbG9hdCIsInBhcmVudGhlc2lzUGFyc2xldCIsImVsZW1lbnRzIiwic3BlY2lhbFR5cGVzUGFyc2xldCIsIm5vdE51bGxhYmxlUGFyc2xldCIsImNyZWF0ZVBhcmFtZXRlckxpc3RQYXJzbGV0IiwiX3JlZiIsImFsbG93VHJhaWxpbmdDb21tYSIsIlBBUkFNRVRFUl9MSVNUIiwicHVzaCIsImUiLCJzb21lIiwiZ2VuZXJpY1BhcnNsZXQiLCJHRU5FUklDIiwiZG90Iiwib2JqZWN0cyIsImJyYWNrZXRzIiwidW5pb25QYXJzbGV0IiwiVU5JT04iLCJiYXNlR3JhbW1hciIsImNyZWF0ZU5hbWVQYXRoUGFyc2xldCIsIl9yZWYyIiwiYWxsb3dTcXVhcmVCcmFja2V0c09uQW55VHlwZSIsImFsbG93SnNkb2NOYW1lUGF0aHMiLCJwYXRoR3JhbW1hciIsIm5hbWVQYXRoUGFyc2xldCIsIk5BTUVfUEFUSCIsInBhdGhUeXBlIiwicGF0aFBhcnNlciIsInBhcnNlZCIsInJpZ2h0IiwicXVvdGUiLCJ0b1N0cmluZyIsInNwZWNpYWxUeXBlIiwiY3JlYXRlTmFtZVBhcnNsZXQiLCJfcmVmMyIsImFsbG93ZWRBZGRpdGlvbmFsVG9rZW5zIiwic3RyaW5nVmFsdWVQYXJzbGV0IiwiY3JlYXRlU3BlY2lhbE5hbWVQYXRoUGFyc2xldCIsIl9yZWY0IiwiYWxsb3dlZFR5cGVzIiwiYWxsb3dlZCIsIm1vZHVsZVBhcnNlciIsIm1vZHVsZVJlc3VsdCIsImJhc2VQYXRoR3JhbW1hciIsImdldFBhcmFtZXRlcnMiLCJwYXJhbWV0ZXJzIiwibWFwIiwicCIsImdldFVubmFtZWRQYXJhbWV0ZXJzIiwiY3JlYXRlRnVuY3Rpb25QYXJzbGV0IiwiX3JlZjUiLCJhbGxvd05hbWVkUGFyYW1ldGVycyIsImFsbG93Tm9SZXR1cm5UeXBlIiwiYWxsb3dXaXRob3V0UGFyZW50aGVzaXMiLCJhbGxvd05ld0FzRnVuY3Rpb25LZXl3b3JkIiwibmV3S2V5d29yZCIsImhhc1BhcmVudGhlc2lzIiwiYXJyb3ciLCJwYXJlbnRoZXNpcyIsIkZVTkNUSU9OIiwia2V5Iiwiam9pbiIsInJldHVyblR5cGUiLCJQUkVGSVgiLCJjcmVhdGVWYXJpYWRpY1BhcnNsZXQiLCJfcmVmNiIsImFsbG93UG9zdGZpeCIsImFsbG93RW5jbG9zaW5nQnJhY2tldHMiLCJzcXVhcmVCcmFja2V0cyIsInN5bWJvbFBhcnNsZXQiLCJTWU1CT0wiLCJhcnJheUJyYWNrZXRzUGFyc2xldCIsIkFSUkFZX0JSQUNLRVRTIiwiY3JlYXRlT2JqZWN0UGFyc2xldCIsIl9yZWY3Iiwib2JqZWN0RmllbGRHcmFtbWFyIiwiYWxsb3dLZXlUeXBlcyIsInNlcGFyYXRvciIsImZpZWxkUGFyc2VyIiwiZmllbGQiLCJPQkpFQ1QiLCJvcHRpb25hbCIsInJlYWRvbmx5IiwiY3JlYXRlT2JqZWN0RmllbGRQYXJzbGV0IiwiX3JlZjgiLCJhbGxvd1NxdWFyZWRQcm9wZXJ0aWVzIiwiYWxsb3dSZWFkb25seSIsImFsbG93T3B0aW9uYWwiLCJLRVlfVkFMVUUiLCJyZWFkb25seVByb3BlcnR5IiwicGFyZW50UGFyc2VyIiwiY3JlYXRlS2V5VmFsdWVQYXJzbGV0IiwiX3JlZjkiLCJhbGxvd1ZhcmlhZGljIiwidmFyaWFkaWMiLCJqc2RvY0Jhc2VHcmFtbWFyIiwianNkb2NHcmFtbWFyIiwidHlwZU9mUGFyc2xldCIsIktFWV9PRl9UWVBFX09GIiwib2JqZWN0RmllbGRHcmFtbWFyJDEiLCJjbG9zdXJlR3JhbW1hciIsImFzc2VydHNQYXJzbGV0IiwiSU5GSVgiLCJjcmVhdGVUdXBsZVBhcnNsZXQiLCJfcmVmMTAiLCJhbGxvd1F1ZXN0aW9uTWFyayIsInR5cGVMaXN0Iiwia2V5T2ZQYXJzbGV0IiwiaW1wb3J0UGFyc2xldCIsInBhdGgiLCJyZWFkb25seVByb3BlcnR5UGFyc2xldCIsImFycm93RnVuY3Rpb25QYXJzbGV0IiwiQVJST1ciLCJpbnRlcnNlY3Rpb25QYXJzbGV0IiwiSU5URVJTRUNUSU9OIiwicHJlZGljYXRlUGFyc2xldCIsIm9iamVjdFNxdWFyZWRQcm9wZXJ0eVBhcnNsZXQiLCJJTkRFWF9CUkFDS0VUUyIsInR5cGVzY3JpcHRHcmFtbWFyIiwiZXhwcmVzc2lvbiIsIm1vZGUiLCJ0cnlQYXJzZSIsIm1vZGVzIiwidHJhbnNmb3JtIiwicGFyc2VSZXN1bHQiLCJhUGFyc2VSZXN1bHQiLCJub3RBdmFpbGFibGVUcmFuc2Zvcm0iLCJleHRyYWN0U3BlY2lhbFBhcmFtcyIsInNvdXJjZSIsInBhcmFtcyIsInBhcmFtIiwidGhpcyIsIm5ldyIsImFwcGx5UG9zaXRpb24iLCJ0YXJnZXQiLCJzdHJpbmdpZnlSdWxlcyIsIkpzZG9jVHlwZVBhcmVudGhlc2lzIiwiSnNkb2NUeXBlS2V5b2YiLCJKc2RvY1R5cGVGdW5jdGlvbiIsInN0cmluZ2lmaWVkIiwiSnNkb2NUeXBlTmFtZSIsIkpzZG9jVHlwZVR1cGxlIiwiSnNkb2NUeXBlVmFyaWFkaWMiLCJKc2RvY1R5cGVOYW1lUGF0aCIsIkpzZG9jVHlwZVN0cmluZ1ZhbHVlIiwiSnNkb2NUeXBlQW55IiwiSnNkb2NUeXBlR2VuZXJpYyIsInRyYW5zZm9ybWVkIiwiSnNkb2NUeXBlSW1wb3J0IiwiSnNkb2NUeXBlT2JqZWN0RmllbGQiLCJKc2RvY1R5cGVKc2RvY09iamVjdEZpZWxkIiwiSnNkb2NUeXBlS2V5VmFsdWUiLCJKc2RvY1R5cGVTcGVjaWFsTmFtZVBhdGgiLCJKc2RvY1R5cGVOb3ROdWxsYWJsZSIsIkpzZG9jVHlwZU51bGwiLCJKc2RvY1R5cGVOdWxsYWJsZSIsIkpzZG9jVHlwZU51bWJlciIsIkpzZG9jVHlwZU9iamVjdCIsIkpzZG9jVHlwZU9wdGlvbmFsIiwiSnNkb2NUeXBlU3ltYm9sIiwiSnNkb2NUeXBlVHlwZW9mIiwiSnNkb2NUeXBlVW5kZWZpbmVkIiwiSnNkb2NUeXBlVW5pb24iLCJKc2RvY1R5cGVVbmtub3duIiwiSnNkb2NUeXBlSW50ZXJzZWN0aW9uIiwiSnNkb2NUeXBlUHJvcGVydHkiLCJKc2RvY1R5cGVQcmVkaWNhdGUiLCJKc2RvY1R5cGVJbmRleFNpZ25hdHVyZSIsIkpzZG9jVHlwZU1hcHBlZFR5cGUiLCJKc2RvY1R5cGVBc3NlcnRzIiwic3RvcmVkU3RyaW5naWZ5UnVsZXMiLCJzdHJpbmdpZnkiLCJyZXNlcnZlZFdvcmRzIiwibWFrZU5hbWUiLCJyZXNlcnZlZFdvcmQiLCJjYXRoYXJzaXNUcmFuc2Zvcm1SdWxlcyIsIm51bGxhYmxlIiwicmVwZWF0YWJsZSIsImFwcGxpY2F0aW9ucyIsIm8iLCJmaWVsZHMiLCJsZWZ0UmVzdWx0IiwicmlnaHRWYWx1ZSIsImpvaW5lciIsInRyYWlsaW5nRG90cyIsImNhdGhhcnNpc1RyYW5zZm9ybSIsImdldFF1b3RlU3R5bGUiLCJnZXRNZW1iZXJUeXBlIiwibmVzdFJlc3VsdHMiLCJyZXN1bHRzIiwianRwUnVsZXMiLCJzeW50YXgiLCJlbnRyaWVzIiwicXVvdGVTdHlsZSIsInN0cmluZyIsInNwZWNpYWxQYXJhbXMiLCJ0eXBlTmFtZSIsInJldHVybnMiLCJzdWJqZWN0IiwiaGFzRXZlbnRQcmVmaXgiLCJvd25lciIsInRNb2R1bGUiLCJudW1iZXIiLCJqdHBUcmFuc2Zvcm0iLCJpZGVudGl0eVRyYW5zZm9ybVJ1bGVzIiwidmlzaXRvcktleXMiLCJfdHJhdmVyc2UiLCJub2RlIiwicGFyZW50Tm9kZSIsInByb3BlcnR5Iiwib25FbnRlciIsIm9uTGVhdmUiLCJrZXlzVG9WaXNpdCIsInRyYXZlcnNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1804\n")}}]);