"use strict";(self.webpackChunk_ibm_aiops_ui_extension_template=self.webpackChunk_ibm_aiops_ui_extension_template||[]).push([[732],{6732:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  nD3: function() { return /* reexport */ Accordion; },\n  AsP: function() { return /* reexport */ AccordionItem; },\n  sg: function() { return /* reexport */ AccordionSkeleton; },\n  kZS: function() { return /* reexport */ ActionableNotification; },\n  $nd: function() { return /* reexport */ Button; },\n  Sc0: function() { return /* reexport */ Checkbox; },\n  msM: function() { return /* reexport */ Dropdown; },\n  Rhj: function() { return /* reexport */ Loading; },\n  KFt: function() { return /* reexport */ MultiSelect; }\n});\n\n// UNUSED EXPORTS: AILabel, AILabelActions, AILabelContent, AISkeletonIcon, AISkeletonPlaceholder, AISkeletonText, AspectRatio, Breadcrumb, BreadcrumbItem, BreadcrumbSkeleton, ButtonKinds, ButtonSet, ButtonSizes, ButtonSkeleton, ButtonTooltipAlignments, ButtonTooltipPositions, Callout, CheckboxGroup, CheckboxSkeleton, ClassPrefix, ClickableTile, CodeSnippet, CodeSnippetSkeleton, Column, ColumnHang, ComboBox, ComboButton, ComposedModal, ContainedList, ContainedListItem, Content, ContentSwitcher, ControlledPasswordInput, Copy, CopyButton, DangerButton, DataTable, DataTableSkeleton, DatePicker, DatePickerInput, DatePickerSkeleton, DefinitionTooltip, DismissibleTag, DropdownSkeleton, ErrorBoundary, ErrorBoundaryContext, ExpandableSearch, ExpandableTile, FeatureFlags, FileUploader, FileUploaderButton, FileUploaderDropContainer, FileUploaderItem, FileUploaderSkeleton, Filename, FilterableMultiSelect, FlexGrid, FluidForm, Form, FormContext, FormGroup, FormItem, FormLabel, GlobalTheme, Grid, GridSettings, HStack, Header, HeaderContainer, HeaderGlobalAction, HeaderGlobalBar, HeaderMenu, HeaderMenuButton, HeaderMenuItem, HeaderName, HeaderNavigation, HeaderPanel, HeaderSideNavItems, Heading, IconButton, IconButtonKinds, IconSkeleton, IconSwitch, IconTab, IdPrefix, InlineLoading, InlineNotification, Layer, Link, ListItem, Menu, MenuButton, MenuItem, MenuItemDivider, MenuItemGroup, MenuItemRadioGroup, MenuItemSelectable, Modal, ModalBody, ModalFooter, ModalHeader, ModalWrapper, NotificationActionButton, NotificationButton, NumberInput, NumberInputSkeleton, OperationalTag, OrderedList, OverflowMenu, OverflowMenuItem, Pagination, PaginationNav, PaginationSkeleton, PasswordInput, Popover, PopoverContent, PrefixContext, PrimaryButton, ProgressBar, ProgressIndicator, ProgressIndicatorSkeleton, ProgressStep, RadioButton, RadioButtonGroup, RadioButtonSkeleton, RadioTile, Row, Search, SearchSkeleton, SecondaryButton, Section, Select, SelectItem, SelectItemGroup, SelectSkeleton, SelectableTag, SelectableTile, SideNav, SideNavDetails, SideNavDivider, SideNavFooter, SideNavHeader, SideNavIcon, SideNavItem, SideNavItems, SideNavLink, SideNavLinkText, SideNavMenu, SideNavMenuItem, SideNavSwitcher, SkeletonIcon, SkeletonPlaceholder, SkeletonText, SkipToContent, Slider, SliderSkeleton, Stack, StaticNotification, StructuredListBody, StructuredListCell, StructuredListHead, StructuredListInput, StructuredListRow, StructuredListSkeleton, StructuredListWrapper, Switch, Switcher, SwitcherDivider, SwitcherItem, Tab, TabContent, TabList, TabListVertical, TabPanel, TabPanels, Table, TableActionList, TableBatchAction, TableBatchActions, TableBody, TableCell, TableContainer, TableDecoratorRow, TableExpandHeader, TableExpandRow, TableExpandedRow, TableHead, TableHeader, TableRow, TableSelectAll, TableSelectRow, TableSlugRow, TableToolbar, TableToolbarAction, TableToolbarContent, TableToolbarMenu, TableToolbarSearch, Tabs, TabsSkeleton, TabsVertical, Tag, TagSkeleton, TextArea, TextAreaSkeleton, TextInput, TextInputSkeleton, Theme, ThemeContext, Tile, TileAboveTheFoldContent, TileBelowTheFoldContent, TileGroup, TimePicker, TimePickerSelect, ToastNotification, Toggle, ToggleSkeleton, ToggleSmallSkeleton, Toggletip, ToggletipActions, ToggletipButton, ToggletipContent, ToggletipLabel, Tooltip, TreeNode, TreeView, UnorderedList, VStack, unstable_FeatureFlags, unstable_Layout, unstable_LayoutDirection, unstable_OverflowMenuV2, unstable_PageSelector, unstable_Pagination, unstable_Text, unstable_TextDirection, unstable__AiSkeletonIcon, unstable__AiSkeletonPlaceholder, unstable__AiSkeletonText, unstable__ChatButton, unstable__ChatButtonSkeleton, unstable__FluidComboBox, unstable__FluidComboBoxSkeleton, unstable__FluidDatePicker, unstable__FluidDatePickerInput, unstable__FluidDatePickerSkeleton, unstable__FluidDropdown, unstable__FluidDropdownSkeleton, unstable__FluidMultiSelect, unstable__FluidMultiSelectSkeleton, unstable__FluidNumberInput, unstable__FluidNumberInputSkeleton, unstable__FluidSearch, unstable__FluidSearchSkeleton, unstable__FluidSelect, unstable__FluidSelectSkeleton, unstable__FluidTextArea, unstable__FluidTextAreaSkeleton, unstable__FluidTextInput, unstable__FluidTextInputSkeleton, unstable__FluidTimePicker, unstable__FluidTimePickerSelect, unstable__FluidTimePickerSkeleton, unstable__IconIndicator, unstable__PageHeader, unstable__ShapeIndicator, unstable__Slug, unstable__SlugActions, unstable__SlugContent, unstable_useFeatureFlag, unstable_useFeatureFlags, unstable_useLayoutDirection, useContextMenu, useFeatureFlag, useFeatureFlags, useIdPrefix, useLayer, usePrefersDarkScheme, usePrefix, useTheme\n\n// EXTERNAL MODULE: ./node_modules/@carbon/feature-flags/es/index.js\nvar es = __webpack_require__(9952);\n;// ./node_modules/@carbon/react/es/feature-flags.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nes/* merge */.h1({\n  'enable-css-custom-properties': true,\n  'enable-css-grid': true,\n  'enable-v11-release': true,\n  'enable-experimental-tile-contrast': false,\n  'enable-v12-tile-radio-icons': false,\n  'enable-v12-structured-list-visible-icons': false,\n  'enable-v12-dynamic-floating-styles': false\n});\n;// ./node_modules/@carbon/react/es/_virtual/_rollupPluginBabelHelpers.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\n// EXTERNAL MODULE: ./node_modules/classnames/index.js\nvar classnames = __webpack_require__(4176);\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(4674);\n;// ./node_modules/@carbon/react/es/internal/usePrefix.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst PrefixContext = /*#__PURE__*/react.createContext('cds');\nfunction usePrefix() {\n  return react.useContext(PrefixContext);\n}\n\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(4370);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n;// ./node_modules/@carbon/react/es/components/Accordion/AccordionProvider.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst AccordionContext = /*#__PURE__*/(0,react.createContext)({\n  disabled: false\n});\nconst AccordionProvider = _ref => {\n  let {\n    disabled,\n    children\n  } = _ref;\n  return /*#__PURE__*/react.createElement(AccordionContext.Provider, {\n    value: {\n      disabled\n    }\n  }, children);\n};\n\n;// ./node_modules/@carbon/react/es/components/Accordion/Accordion.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\nfunction Accordion(_ref) {\n  let {\n    align = 'end',\n    children,\n    className: customClassName,\n    disabled = false,\n    isFlush = false,\n    ordered = false,\n    size,\n    ...rest\n  } = _ref;\n  const prefix = usePrefix();\n  const className = classnames_default()(`${prefix}--accordion`, customClassName, {\n    [`${prefix}--accordion--${align}`]: align,\n    [`${prefix}--accordion--${size}`]: size,\n    // TODO: V12 - Remove this class\n    [`${prefix}--layout--size-${size}`]: size,\n    [`${prefix}--accordion--flush`]: isFlush && align !== 'start'\n  });\n  const ListTag = ordered ? 'ol' : 'ul';\n  return /*#__PURE__*/react.createElement(AccordionProvider, {\n    disabled: disabled\n  }, /*#__PURE__*/react.createElement(ListTag, _extends({\n    className: className\n  }, rest), children));\n}\nAccordion.propTypes = {\n  /**\n   * Specify the alignment of the accordion heading title and chevron.\n   */\n  align: prop_types_default().oneOf(['start', 'end']),\n  /**\n   * Pass in the children that will be rendered within the Accordion\n   */\n  children: (prop_types_default()).node,\n  /**\n   * Specify an optional className to be applied to the container node\n   */\n  className: (prop_types_default()).string,\n  /**\n   * Specify whether an individual AccordionItem should be disabled\n   */\n  disabled: (prop_types_default()).bool,\n  /**\n   * Specify whether Accordion text should be flush, default is false, does not work with align=\"start\"\n   */\n  isFlush: (prop_types_default()).bool,\n  /**\n   * Specify if the Accordion should be an ordered list,\n   * default is `false`\n   */\n  ordered: (prop_types_default()).bool,\n  /**\n   * Specify the size of the Accordion. Currently supports the following:\n   */\n  size: prop_types_default().oneOf(['sm', 'md', 'lg'])\n};\n\n// EXTERNAL MODULE: ./node_modules/@carbon/icons-react/es/generated/bucket-3.js\nvar bucket_3 = __webpack_require__(1626);\n;// ./node_modules/@carbon/react/es/internal/keyboard/keys.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst Tab = {\n  key: 'Tab',\n  which: 9,\n  keyCode: 9,\n  code: 'Tab'\n};\nconst Enter = {\n  key: 'Enter',\n  which: 13,\n  keyCode: 13,\n  code: 'Enter'\n};\nconst Escape = {\n  key: ['Escape',\n  // IE11 Escape\n  'Esc'],\n  which: 27,\n  keyCode: 27,\n  code: 'Esc'\n};\nconst Space = {\n  key: ' ',\n  which: 32,\n  keyCode: 32,\n  code: 'Space'\n};\nconst End = {\n  key: 'End',\n  which: 35,\n  keyCode: 35,\n  code: 'Numpad1'\n};\nconst Home = {\n  key: 'Home',\n  which: 36,\n  keyCode: 36,\n  code: 'Numpad7'\n};\nconst keys_ArrowLeft = {\n  key: 'ArrowLeft',\n  which: 37,\n  keyCode: 37,\n  code: 'ArrowLeft'\n};\nconst ArrowUp = {\n  key: 'ArrowUp',\n  which: 38,\n  keyCode: 38,\n  code: 'ArrowUp'\n};\nconst keys_ArrowRight = {\n  key: 'ArrowRight',\n  which: 39,\n  keyCode: 39,\n  code: 'ArrowRight'\n};\nconst ArrowDown = {\n  key: 'ArrowDown',\n  which: 40,\n  keyCode: 40,\n  code: 'ArrowDown'\n};\nconst Delete = {\n  key: 'Delete',\n  which: 8,\n  keyCode: 8,\n  code: 'ArrowDecimal'\n};\n\n;// ./node_modules/@carbon/react/es/internal/keyboard/match.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * Check to see if at least one key code matches the key code of the\n * given event.\n *\n * @param event - The event to test.\n * @param keysToMatch - An array of key definitions to match against.\n * @returns `true` if one of the keys matches.\n */\nconst matches = (event, keysToMatch) => {\n  for (let i = 0; i < keysToMatch.length; i++) {\n    if (match_match(event, keysToMatch[i])) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Check to see if the given key matches the corresponding keyboard event. Also\n * supports passing in the value directly if you can't use the given event.\n *\n * @param eventOrCode - A `KeyboardEvent`, a number, or a string value.\n * @param keyObj - An object with key properties to match against.\n * @returns `true` if the event or code matches the key definition.\n */\nconst match_match = (eventOrCode, _ref) => {\n  let {\n    key,\n    which,\n    keyCode,\n    code\n  } = _ref;\n  if (typeof eventOrCode === 'string') {\n    return eventOrCode === key;\n  }\n  if (typeof eventOrCode === 'number') {\n    return eventOrCode === which || eventOrCode === keyCode;\n  }\n  if (eventOrCode.key && Array.isArray(key)) {\n    return key.includes(eventOrCode.key);\n  }\n  return eventOrCode.key === key ||\n  // TODO: When can these checks for deprecated properties be deleted?\n  // Presumably, the `Key` type should also be pruned of these properties.\n  eventOrCode.which === which || eventOrCode.keyCode === keyCode || eventOrCode.code === code;\n};\n\n;// ./node_modules/@carbon/react/es/tools/setupGetInstanceId.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * Creates an instance ID generator.\n *\n * @returns A function that returns a unique sequential ID on each call.\n */\nconst setupGetInstanceId = () => {\n  let instanceId = 0;\n  return () => ++instanceId;\n};\n\n;// ./node_modules/@carbon/react/es/internal/environment.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * Indicate whether current execution environment can access the DOM.\n *\n * @see https://github.com/facebook/fbjs/blob/4d1751311d3f67af2dcce2e40df8512a23c7b9c6/packages/fbjs/src/core/ExecutionEnvironment.js#L12\n */\nconst canUseDOM = !!(typeof window !== 'undefined' &&\n// TODO: `ssr-friendly` doesn't support ESLint v9.\n// https://github.com/kopiro/eslint-plugin-ssr-friendly/issues/30\n// https://github.com/carbon-design-system/carbon/issues/18991\n/*\n// eslint-disable-next-line ssr-friendly/no-dom-globals-in-module-scope\n*/\nwindow.document &&\n/*\n// eslint-disable-next-line ssr-friendly/no-dom-globals-in-module-scope\n*/\nwindow.document.createElement);\n\n;// ./node_modules/@carbon/react/es/internal/useIdPrefix.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst IdPrefixContext = /*#__PURE__*/react.createContext(null);\nfunction useIdPrefix() {\n  return react.useContext(IdPrefixContext);\n}\n\n;// ./node_modules/@carbon/react/es/internal/useId.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n// This file was heavily inspired by:\n\n// This tricks bundlers so they can't statically analyze this and produce\n// compilation warnings/errors.\n// https://github.com/webpack/webpack/issues/14814\n// https://github.com/mui/material-ui/issues/41190\nconst _React = {\n  ...react\n};\nconst instanceId = setupGetInstanceId();\nconst useIsomorphicLayoutEffect = canUseDOM ? react.useLayoutEffect : react.useEffect;\nlet serverHandoffCompleted = false;\nconst defaultId = 'id';\n\n/**\n * Generate a unique ID for React <=17 with an optional prefix prepended to it.\n * This is an internal utility, not intended for public usage.\n * @param {string} [prefix]\n * @returns {string}\n */\nfunction useCompatibleId() {\n  let prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultId;\n  const contextPrefix = useIdPrefix();\n  const [id, setId] = (0,react.useState)(() => {\n    if (serverHandoffCompleted) {\n      return `${contextPrefix ? `${contextPrefix}-` : ``}${prefix}-${instanceId()}`;\n    }\n    return null;\n  });\n  useIsomorphicLayoutEffect(() => {\n    if (id === null) {\n      setId(`${contextPrefix ? `${contextPrefix}-` : ``}${prefix}-${instanceId()}`);\n    }\n  }, [instanceId]);\n  (0,react.useEffect)(() => {\n    if (serverHandoffCompleted === false) {\n      serverHandoffCompleted = true;\n    }\n  }, []);\n  return id;\n}\n\n/**\n * Generate a unique ID for React >=18 with an optional prefix prepended to it.\n * This is an internal utility, not intended for public usage.\n * @param {string} [prefix]\n * @returns {string}\n */\nfunction useReactId() {\n  let prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultId;\n  const contextPrefix = useIdPrefix();\n  return `${contextPrefix ? `${contextPrefix}-` : ``}${prefix}-${_React.useId()}`;\n}\n\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n */\nconst useId = _React.useId ? useReactId : useCompatibleId;\n\n/**\n * Generate a unique id if a given `id` is not provided\n * This is an internal utility, not intended for public usage.\n * @param {string|undefined} id\n * @returns {string}\n */\nfunction useFallbackId(id) {\n  const fallback = useId();\n  return id ?? fallback;\n}\n\n;// ./node_modules/@carbon/react/es/prop-types/deprecate.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst didWarnAboutDeprecation = {};\nfunction deprecate(propType, message) {\n  function checker(props, propName, componentName) {\n    if (props[propName] === undefined) {\n      return;\n    }\n    if (!didWarnAboutDeprecation[componentName] || !didWarnAboutDeprecation[componentName][propName]) {\n      didWarnAboutDeprecation[componentName] = {\n        ...didWarnAboutDeprecation[componentName],\n        [propName]: true\n      };\n       false ? 0 : void 0;\n    }\n    for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      rest[_key - 3] = arguments[_key];\n    }\n    return propType(props, propName, componentName, ...rest);\n  }\n  return checker;\n}\n\n;// ./node_modules/@carbon/react/es/components/Text/TextDirectionContext.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst TextDirectionContext = /*#__PURE__*/(0,react.createContext)({\n  direction: 'auto',\n  getTextDirection: {\n    current: undefined\n  }\n});\n\n;// ./node_modules/@carbon/react/es/components/Text/Text.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\nconst TextBase = /*#__PURE__*/react.forwardRef((_ref, ref) => {\n  let {\n    as,\n    children,\n    dir = 'auto',\n    ...rest\n  } = _ref;\n  const context = (0,react.useContext)(TextDirectionContext);\n  const textProps = {};\n  const BaseComponent = as ?? 'span';\n  const value = {\n    ...context\n  };\n  if (!context) {\n    textProps.dir = dir;\n    value.direction = dir;\n  } else {\n    const {\n      direction: parentDirection,\n      getTextDirection\n    } = context;\n    if (getTextDirection && getTextDirection.current) {\n      const text = getTextFromChildren(children);\n      const override = getTextDirection.current(text);\n      if (parentDirection !== override) {\n        textProps.dir = override;\n        value.direction = override;\n      } else if (parentDirection === 'auto') {\n        textProps.dir = override;\n      }\n    } else if (parentDirection !== dir) {\n      textProps.dir = dir;\n      value.direction = dir;\n    } else if (parentDirection === 'auto') {\n      textProps.dir = dir;\n    }\n  }\n  return /*#__PURE__*/react.createElement(TextDirectionContext.Provider, {\n    value: value\n  }, /*#__PURE__*/react.createElement(BaseComponent, _extends({\n    ref: ref\n  }, rest, textProps), children));\n});\nconst Text = TextBase;\nText.propTypes = {\n  /**\n   * Provide a custom element type used to render the outermost node\n   */\n  as: prop_types_default().oneOfType([(prop_types_default()).func, (prop_types_default()).string, (prop_types_default()).elementType]),\n  /**\n   * Provide child elements or text to be rendered inside of this component\n   */\n  children: (prop_types_default()).node.isRequired,\n  /**\n   * Specify the text direction to be used for this component and any of its\n   * children\n   */\n  dir: prop_types_default().oneOf(['ltr', 'rtl', 'auto'])\n};\nconst getTextFromChildren = children => {\n  if (typeof children === 'string') {\n    return children;\n  }\n  const text = react.Children.map(children, child => {\n    if (typeof child === 'string') {\n      return child;\n    }\n    return null;\n  })?.filter(text => {\n    return text !== null;\n  });\n  if (text?.length === 1) {\n    return text[0];\n  }\n  return text;\n};\n\n;// ./node_modules/@carbon/react/es/components/Accordion/AccordionItem.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst defaultRenderToggle = props => /*#__PURE__*/react.createElement(\"button\", _extends({\n  type: \"button\"\n}, props));\nfunction AccordionItem(_ref) {\n  let {\n    children,\n    className: customClassName = '',\n    open = false,\n    onHeadingClick,\n    renderExpando = defaultRenderToggle,\n    // remove renderExpando in next major release\n    renderToggle,\n    title = 'title',\n    disabled: controlledDisabled,\n    handleAnimationEnd,\n    ...rest\n  } = _ref;\n  const [isOpen, setIsOpen] = (0,react.useState)(open);\n  const [prevIsOpen, setPrevIsOpen] = (0,react.useState)(open);\n  const accordionState = (0,react.useContext)(AccordionContext);\n  const disabledIsControlled = typeof controlledDisabled === 'boolean';\n  const disabled = disabledIsControlled ? controlledDisabled : accordionState.disabled;\n  const id = useId('accordion-item');\n  const prefix = usePrefix();\n  const className = classnames_default()({\n    [`${prefix}--accordion__item`]: true,\n    [`${prefix}--accordion__item--active`]: isOpen && !disabled,\n    [`${prefix}--accordion__item--disabled`]: disabled,\n    [customClassName]: !!customClassName\n  });\n  const Toggle = renderToggle || renderExpando; // remove renderExpando in next major release\n\n  const content = react.useCallback(node => {\n    if (!node) {\n      return;\n    }\n    if (isOpen) {\n      // accordion closes\n      node.style.maxBlockSize = '';\n    }\n  }, [isOpen]);\n  if (open !== prevIsOpen) {\n    setIsOpen(open);\n    setPrevIsOpen(open);\n  }\n\n  // When the AccordionItem heading is clicked, toggle the open state of the\n  // panel\n  function onClick(event) {\n    const nextValue = !isOpen;\n    setIsOpen(nextValue);\n    if (onHeadingClick) {\n      // TODO: normalize signature, potentially:\n      // onHeadingClick :: (event: Event, state: { isOpen: Boolean }) => any\n      onHeadingClick({\n        isOpen: nextValue,\n        event\n      });\n    }\n  }\n\n  // If the AccordionItem is open, and the user hits the ESC key, then close it\n  function onKeyDown(event) {\n    if (isOpen && match_match(event, Escape)) {\n      setIsOpen(false);\n    }\n  }\n  function onAnimationEnd(event) {\n    if (handleAnimationEnd) {\n      handleAnimationEnd(event);\n    }\n  }\n  return /*#__PURE__*/react.createElement(\"li\", _extends({\n    className: className\n  }, rest), /*#__PURE__*/react.createElement(Toggle, {\n    disabled: disabled,\n    \"aria-controls\": id,\n    \"aria-expanded\": isOpen,\n    className: `${prefix}--accordion__heading`,\n    onClick: onClick,\n    onKeyDown: onKeyDown,\n    type: \"button\"\n  }, /*#__PURE__*/react.createElement(bucket_3/* ChevronRight */.c_, {\n    className: `${prefix}--accordion__arrow`\n  }), /*#__PURE__*/react.createElement(Text, {\n    as: \"div\",\n    className: `${prefix}--accordion__title`\n  }, title)), /*#__PURE__*/react.createElement(\"div\", {\n    ref: content,\n    className: `${prefix}--accordion__wrapper`,\n    onTransitionEnd: onAnimationEnd\n  }, /*#__PURE__*/react.createElement(\"div\", {\n    id: id,\n    className: `${prefix}--accordion__content`\n  }, children)));\n}\nAccordionItem.propTypes = {\n  /**\n   * Provide the contents of your AccordionItem\n   */\n  children: (prop_types_default()).node,\n  /**\n   * Specify an optional className to be applied to the container node\n   */\n  className: (prop_types_default()).string,\n  /**\n   * Specify whether an individual AccordionItem should be disabled\n   */\n  disabled: (prop_types_default()).bool,\n  /**\n   * The handler of the massaged `click` event.\n   */\n  onClick: (prop_types_default()).func,\n  /**\n   * The handler of the massaged `click` event on the heading.\n   */\n  onHeadingClick: (prop_types_default()).func,\n  /**\n   * `true` to open the expand.\n   */\n  open: (prop_types_default()).bool,\n  /**\n   * The callback function to render the expand button.\n   * Can be a React component class.\n   */\n  renderExpando: deprecate((prop_types_default()).func, 'The `renderExpando` prop has been deprecated and will be removed in the next major release of Carbon. Use the `renderToggle` prop instead.'),\n  /**\n   * The callback function to render the expand button.\n   * Can be a React component class.\n   */\n  renderToggle: (prop_types_default()).func,\n  /**\n   * The accordion title.\n   */\n  title: (prop_types_default()).node\n};\n\n;// ./node_modules/@carbon/react/es/internal/useIsomorphicEffect.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n/** `useLayoutEffect` on the client, `useEffect` on the server */\nconst useIsomorphicEffect = typeof window !== 'undefined' ? react.useLayoutEffect : react.useEffect;\n\n;// ./node_modules/@carbon/react/es/components/SkeletonText/SkeletonText.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\nconst randoms = [0.973051493507435, 0.15334737213558558, 0.5671034553053769];\nfunction getRandomInt(min, max, n) {\n  return Math.floor(randoms[n % 3] * (max - min + 1)) + min;\n}\nconst SkeletonText = _ref => {\n  let {\n    paragraph = false,\n    lineCount = 3,\n    width = '100%',\n    heading = false,\n    className = '',\n    ...rest\n  } = _ref;\n  const prefix = usePrefix();\n  const skeletonTextClasses = classnames_default()({\n    [`${prefix}--skeleton__text`]: true,\n    [`${prefix}--skeleton__heading`]: heading,\n    [className]: className\n  });\n  const widthNum = parseInt(width, 10);\n  const widthPx = width.includes('px');\n  const widthPercent = width.includes('%');\n  let lineCountNumber = 1;\n  if (paragraph) {\n    lineCountNumber = lineCount;\n  }\n  const refs = (0,react.useRef)([]);\n  useIsomorphicEffect(() => {\n    refs.current.map((item, j) => {\n      const randomPercentWidth = getRandomInt(0, 75, j) + 'px';\n      const randomPxWidth = getRandomInt(Math.max(widthNum - 75, 0), widthNum, j) + 'px';\n      if (item) {\n        if (widthPercent && paragraph) {\n          item.style.width = `calc(${width} - ${randomPercentWidth})`;\n        } else if (widthPx && paragraph) {\n          item.style.width = randomPxWidth;\n        } else {\n          item.style.width = width;\n        }\n      }\n    });\n  }, [lineCountNumber, paragraph, refs, width, widthNum, widthPercent, widthPx]);\n  const lines = [];\n  for (let i = 0; i < lineCountNumber; i++) {\n    lines.push(/*#__PURE__*/react.createElement(\"p\", _extends({\n      className: skeletonTextClasses,\n      key: i,\n      ref: el => {\n        refs.current = [...refs.current, el];\n      }\n    }, rest)));\n  }\n  if (lineCountNumber !== 1) {\n    return /*#__PURE__*/react.createElement(\"div\", null, lines);\n  }\n\n  // eslint-disable-next-line react/jsx-no-useless-fragment\n  return /*#__PURE__*/react.createElement(react.Fragment, null, lines);\n};\nSkeletonText.propTypes = {\n  /**\n   * Specify an optional className to be applied to the container node\n   */\n  className: (prop_types_default()).string,\n  /**\n   * generates skeleton text at a larger size\n   */\n  heading: (prop_types_default()).bool,\n  /**\n   * the number of lines shown if paragraph is true\n   */\n  lineCount: (prop_types_default()).number,\n  /**\n   * will generate multiple lines of text\n   */\n  paragraph: (prop_types_default()).bool,\n  /**\n   * width (in px or %) of single line of text or max-width of paragraph lines\n   */\n  width: (prop_types_default()).string\n};\n\n;// ./node_modules/@carbon/react/es/components/Accordion/Accordion.Skeleton.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\n\nvar _SkeletonText, _SkeletonText2, _SkeletonText3;\nfunction AccordionSkeleton(_ref) {\n  let {\n    align = 'end',\n    className,\n    count = 4,\n    isFlush,\n    open = true,\n    ordered = false,\n    ...rest\n  } = _ref;\n  const prefix = usePrefix();\n  const classes = classnames_default()(`${prefix}--accordion`, `${prefix}--skeleton`, className, {\n    [`${prefix}--accordion--${align}`]: align,\n    [`${prefix}--accordion--flush`]: isFlush && align !== 'start'\n  });\n  const numSkeletonItems = open ? count - 1 : count;\n  const ListTag = ordered ? 'ol' : 'ul';\n  return /*#__PURE__*/react.createElement(ListTag, _extends({\n    className: classes\n  }, rest), open && /*#__PURE__*/react.createElement(\"li\", {\n    className: `${prefix}--accordion__item ${prefix}--accordion__item--active`\n  }, /*#__PURE__*/react.createElement(\"span\", {\n    className: `${prefix}--accordion__heading`\n  }, /*#__PURE__*/react.createElement(bucket_3/* ChevronRight */.c_, {\n    className: `${prefix}--accordion__arrow`\n  }), /*#__PURE__*/react.createElement(SkeletonText, {\n    className: `${prefix}--accordion__title`\n  })), /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefix}--accordion__content`\n  }, _SkeletonText || (_SkeletonText = /*#__PURE__*/react.createElement(SkeletonText, {\n    width: \"90%\"\n  })), _SkeletonText2 || (_SkeletonText2 = /*#__PURE__*/react.createElement(SkeletonText, {\n    width: \"80%\"\n  })), _SkeletonText3 || (_SkeletonText3 = /*#__PURE__*/react.createElement(SkeletonText, {\n    width: \"95%\"\n  })))), Array.from({\n    length: numSkeletonItems\n  }).map((_, i) => /*#__PURE__*/react.createElement(AccordionSkeletonItem, {\n    key: i\n  })));\n}\nAccordionSkeleton.propTypes = {\n  /**\n   * Specify the alignment of the accordion heading title and chevron.\n   */\n  align: prop_types_default().oneOf(['start', 'end']),\n  /**\n   * Specify an optional className to add.\n   */\n  className: (prop_types_default()).string,\n  /**\n   * Set number of items to render\n   */\n  count: (prop_types_default()).number,\n  /**\n   * Specify whether an individual AccordionItem should be flush, default is false\n   */\n  isFlush: (prop_types_default()).bool,\n  /**\n   * `false` to not display the first item opened\n   */\n  open: (prop_types_default()).bool\n};\nfunction AccordionSkeletonItem() {\n  const prefix = usePrefix();\n  return /*#__PURE__*/react.createElement(\"li\", {\n    className: `${prefix}--accordion__item`\n  }, /*#__PURE__*/react.createElement(\"span\", {\n    className: `${prefix}--accordion__heading`\n  }, /*#__PURE__*/react.createElement(bucket_3/* ChevronRight */.c_, {\n    className: `${prefix}--accordion__arrow`\n  }), /*#__PURE__*/react.createElement(SkeletonText, {\n    className: `${prefix}--accordion__title`\n  })));\n}\n\n;// ./node_modules/@carbon/react/es/prop-types/deprecateValuesWithin.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst deprecateValuesWithin_didWarnAboutDeprecation = {};\nfunction deprecateValuesWithin(propType, allowedValues, propMappingFunction) {\n  return function checker(props, propName, componentName) {\n    if (props[propName] === undefined) {\n      return;\n    }\n    if (!deprecateValuesWithin_didWarnAboutDeprecation[componentName] || !deprecateValuesWithin_didWarnAboutDeprecation[componentName][propName]) {\n      deprecateValuesWithin_didWarnAboutDeprecation[componentName] = {\n        ...deprecateValuesWithin_didWarnAboutDeprecation[componentName],\n        [propName]: true\n      };\n      const deprecatedValue = props[propName];\n      const newValue = propMappingFunction ? propMappingFunction(deprecatedValue) : null;\n      if (allowedValues && !allowedValues.includes(deprecatedValue)) {\n        const message = propMappingFunction ? `\"${deprecatedValue}\" is a deprecated value for the \"${propName}\" prop on the \"${componentName}\" component. Use \"${newValue}\" instead. \"${deprecatedValue}\" will be removed in the next major release.` : `\"${deprecatedValue}\" is a deprecated value for the \"${propName}\" prop on the \"${componentName}\" component. Allowed values is/are: ${allowedValues.join(', ')}.  \"${deprecatedValue}\" will be removed in the next major release. `;\n         false ? 0 : void 0;\n      }\n    }\n    for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      rest[_key - 3] = arguments[_key];\n    }\n    return propType(props, propName, componentName, ...rest);\n  };\n}\n\n;// ./node_modules/@carbon/react/es/internal/useMergedRefs.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n/**\n * Merges multiple refs into a single callback ref.\n *\n * This hook is useful when you need to attach multiple refs (for example, a ref\n * passed from `forwardRef` and a local ref from `useRef`) to the same node. It\n * accepts an array of refs and returns a callback ref that, when attached to a\n * node, assigns that node to every ref in the array.\n */\nconst useMergedRefs = refs => {\n  return (0,react.useCallback)(node => {\n    refs.forEach(ref => {\n      if (typeof ref === 'function') {\n        ref(node);\n      } else if (ref) {\n        ref.current = node;\n      }\n    });\n  }, [refs]);\n};\n\n;// ./node_modules/@carbon/react/es/internal/useEvent.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst useEvent = (elementOrRef, eventName, callback) => {\n  const savedCallback = useRef(null);\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n  useEffect(() => {\n    const handler = event => {\n      if (savedCallback.current) {\n        savedCallback.current(event);\n      }\n    };\n    const element = 'current' in elementOrRef ? elementOrRef.current : elementOrRef;\n    element?.addEventListener(eventName, handler);\n    return () => {\n      element?.removeEventListener(eventName, handler);\n    };\n  }, [elementOrRef, eventName]);\n};\nconst useWindowEvent = (eventName, callback) => {\n  const savedCallback = (0,react.useRef)(null);\n  (0,react.useEffect)(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n  (0,react.useEffect)(() => {\n    const handler = event => {\n      if (savedCallback.current) {\n        savedCallback.current(event);\n      }\n    };\n    window.addEventListener(eventName, handler);\n    return () => {\n      window.removeEventListener(eventName, handler);\n    };\n  }, [eventName]);\n};\n\n;// ./node_modules/@carbon/react/es/tools/mapPopoverAlign.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst popoverAlignMapping = {\n  'top-left': 'top-start',\n  'top-right': 'top-end',\n  'bottom-left': 'bottom-start',\n  'bottom-right': 'bottom-end',\n  'left-bottom': 'left-end',\n  'left-top': 'left-start',\n  'right-bottom': 'right-end',\n  'right-top': 'right-start'\n};\n\n/**\n * Maps popover alignment values to their corresponding replacement values.\n *\n * @param align - The original align value.\n * @returns The new align value based on mapping or the original align if no\n *          mapping exists.\n */\nconst mapPopoverAlign = align => popoverAlignMapping[align] ?? align;\n\n// EXTERNAL MODULE: ./node_modules/@floating-ui/react/dist/floating-ui.react.mjs\nvar floating_ui_react = __webpack_require__(8689);\n// EXTERNAL MODULE: ./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\nvar floating_ui_react_dom = __webpack_require__(4743);\n// EXTERNAL MODULE: ./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs + 1 modules\nvar floating_ui_dom = __webpack_require__(6885);\n;// ./node_modules/@carbon/react/es/components/FeatureFlags/index.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n/**\n * Our FeatureFlagContext is used alongside the FeatureFlags component to enable\n * or disable feature flags in a given React tree\n */\nconst FeatureFlagContext = /*#__PURE__*/(0,react.createContext)(es/* FeatureFlags */.gH);\n\n/**\n * Supports an object of feature flag values with the `flags` prop, merging them\n * along with the current `FeatureFlagContext` to provide consumers to check if\n * a feature flag is enabled or disabled in a given React tree\n */\nfunction FeatureFlags(_ref) {\n  let {\n    children,\n    flags = {},\n    enableV12TileDefaultIcons = false,\n    enableV12TileRadioIcons = false,\n    enableV12Overflowmenu = false,\n    enableTreeviewControllable = false,\n    enableExperimentalFocusWrapWithoutSentinels = false,\n    enableDialogElement = false,\n    enableV12DynamicFloatingStyles = false\n  } = _ref;\n  const parentScope = (0,react.useContext)(FeatureFlagContext);\n  const [prevParentScope, setPrevParentScope] = (0,react.useState)(parentScope);\n  const combinedFlags = {\n    'enable-v12-tile-default-icons': enableV12TileDefaultIcons,\n    'enable-v12-tile-radio-icons': enableV12TileRadioIcons,\n    'enable-v12-overflowmenu': enableV12Overflowmenu,\n    'enable-treeview-controllable': enableTreeviewControllable,\n    'enable-experimental-focus-wrap-without-sentinels': enableExperimentalFocusWrapWithoutSentinels,\n    'enable-dialog-element': enableDialogElement,\n    'enable-v12-dynamic-floating-styles': enableV12DynamicFloatingStyles,\n    ...flags\n  };\n  const [scope, updateScope] = (0,react.useState)(() => {\n    const scope = (0,es/* createScope */.Ds)(combinedFlags);\n    scope.mergeWithScope(parentScope);\n    return scope;\n  });\n  if (parentScope !== prevParentScope) {\n    const scope = (0,es/* createScope */.Ds)(combinedFlags);\n    scope.mergeWithScope(parentScope);\n    updateScope(scope);\n    setPrevParentScope(parentScope);\n  }\n\n  // We use a custom hook to detect if any of the keys or their values change\n  // for flags that are passed in. If they have changed, then we re-create the\n  // FeatureFlagScope using the new flags\n  useChangedValue(combinedFlags, isEqual, changedFlags => {\n    const scope = (0,es/* createScope */.Ds)(changedFlags);\n    scope.mergeWithScope(parentScope);\n    updateScope(scope);\n  });\n  return /*#__PURE__*/react.createElement(FeatureFlagContext.Provider, {\n    value: scope\n  }, children);\n}\nFeatureFlags.propTypes = {\n  children: (prop_types_default()).node,\n  /**\n   * Provide the feature flags to enabled or disabled in the current Rea,ct tree\n   */\n  flags: deprecate(prop_types_default().objectOf((prop_types_default()).bool), 'The `flags` prop for `FeatureFlag` has ' + 'been deprecated. Please run the `featureflag-deprecate-flags-prop` codemod to migrate to individual boolean props.' + `npx @carbon/upgrade migrate featureflag-deprecate-flags-prop --write`),\n  enableV12TileDefaultIcons: (prop_types_default()).bool,\n  enableV12TileRadioIcons: (prop_types_default()).bool,\n  enableV12Overflowmenu: (prop_types_default()).bool,\n  enableTreeviewControllable: (prop_types_default()).bool,\n  enableExperimentalFocusWrapWithoutSentinels: (prop_types_default()).bool,\n  enableDialogElement: (prop_types_default()).bool,\n  enableV12DynamicFloatingStyles: (prop_types_default()).bool\n};\n\n/**\n * This hook will store previous versions of the given `value` and compare the\n * current value to the previous one using the `compare` function. If the\n * compare function returns true, then the given `callback` is invoked in an\n * effect.\n *\n * @param {any} value\n * @param {Function} compare\n * @param {Function} callback\n */\nfunction useChangedValue(value, compare, callback) {\n  const initialRender = (0,react.useRef)(false);\n  const savedCallback = (0,react.useRef)(callback);\n  const [prevValue, setPrevValue] = (0,react.useState)(value);\n  if (!compare(prevValue, value)) {\n    setPrevValue(value);\n  }\n  (0,react.useEffect)(() => {\n    savedCallback.current = callback;\n  });\n  (0,react.useEffect)(() => {\n    // We only want the callback triggered after the first render\n    if (initialRender.current) {\n      savedCallback.current(prevValue);\n    }\n  }, [prevValue]);\n  (0,react.useEffect)(() => {\n    initialRender.current = true;\n  }, []);\n}\n\n/**\n * Access whether a given flag is enabled or disabled in a given\n * FeatureFlagContext\n *\n * @returns {boolean}\n */\nfunction useFeatureFlag(flag) {\n  const scope = (0,react.useContext)(FeatureFlagContext);\n  return scope.enabled(flag);\n}\n\n/**\n * Access all feature flag information for the given FeatureFlagContext\n *\n * @returns {FeatureFlagScope}\n */\nfunction useFeatureFlags() {\n  return useContext(FeatureFlagContext);\n}\n\n/**\n * Compare two objects and determine if they are equal. This is a shallow\n * comparison since the objects we are comparing are objects with boolean flags\n * from the flags prop in the `FeatureFlags` component\n *\n * @param {object} a\n * @param {object} b\n * @returns {boolean}\n */\nfunction isEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  for (const key of Object.keys(a)) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n  for (const key of Object.keys(b)) {\n    if (b[key] !== a[key]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n;// ./node_modules/@carbon/react/es/components/Popover/index.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst PopoverContext = /*#__PURE__*/react.createContext({\n  setFloating: {\n    current: null\n  },\n  caretRef: {\n    current: null\n  },\n  autoAlign: null\n});\n\n/**\n * Deprecated popover alignment values.\n * @deprecated Use NewPopoverAlignment instead.\n */\n\nconst Popover = /*#__PURE__*/react.forwardRef(function PopoverRenderFunction(_ref,\n//this is a workaround, have to come back and fix this.\nforwardRef) {\n  let {\n    isTabTip,\n    align: initialAlign = isTabTip ? 'bottom-start' : 'bottom',\n    as: BaseComponent = 'span',\n    autoAlign = false,\n    autoAlignBoundary,\n    caret = isTabTip ? false : true,\n    className: customClassName,\n    children,\n    dropShadow = true,\n    highContrast = false,\n    onRequestClose,\n    open,\n    alignmentAxisOffset,\n    ...rest\n  } = _ref;\n  const prefix = usePrefix();\n  const floating = (0,react.useRef)(null);\n  const caretRef = (0,react.useRef)(null);\n  const popover = (0,react.useRef)(null);\n  const enableFloatingStyles = useFeatureFlag('enable-v12-dynamic-floating-styles') || autoAlign;\n  let align = mapPopoverAlign(initialAlign);\n\n  // If the `Popover` is the last focusable item in the tab order, it should also close when the browser window loses focus  (#12922)\n  useWindowEvent('blur', () => {\n    if (open) {\n      onRequestClose?.();\n    }\n  });\n  useWindowEvent('click', _ref2 => {\n    let {\n      target\n    } = _ref2;\n    if (open && target instanceof Node && !popover.current?.contains(target)) {\n      onRequestClose?.();\n    }\n  });\n\n  // Slug styling places a border around the popover content so the caret\n  // needs to be placed 1px further outside the popover content. To do so,\n  // we look to see if any of the children has a className containing \"slug\"\n  const initialCaretHeight = react.Children.toArray(children).some(x => {\n    return x?.props?.className?.includes('slug') || x?.props?.className?.includes('ai-label');\n  }) ? 7 : 6;\n  // These defaults match the defaults defined in packages/styles/scss/components/popover/_popover.scss\n  const popoverDimensions = (0,react.useRef)({\n    offset: 10,\n    caretHeight: initialCaretHeight\n  });\n  useIsomorphicEffect(() => {\n    // The popover is only offset when a caret is present. Technically, the custom properties\n    // accessed below can be set by a user even if caret=false, but doing so does not follow\n    // the design specification for Popover.\n    if (caret && popover.current) {\n      // Gather the dimensions of the caret and prefer the values set via custom properties.\n      // If a value is not set via a custom property, provide a default value that matches the\n      // default values defined in the sass style file\n      const getStyle = window.getComputedStyle(popover.current, null);\n      const offsetProperty = getStyle.getPropertyValue('--cds-popover-offset');\n      const caretProperty = getStyle.getPropertyValue('--cds-popover-caret-height');\n\n      // Handle if the property values are in px or rem.\n      // We want to store just the base number value without a unit suffix\n      if (offsetProperty) {\n        popoverDimensions.current.offset = offsetProperty.includes('px') ? Number(offsetProperty.split('px', 1)[0]) * 1 : Number(offsetProperty.split('rem', 1)[0]) * 16;\n      }\n      if (caretProperty) {\n        popoverDimensions.current.caretHeight = caretProperty.includes('px') ? Number(caretProperty.split('px', 1)[0]) * 1 : Number(caretProperty.split('rem', 1)[0]) * 16;\n      }\n    }\n  });\n  const {\n    refs,\n    floatingStyles,\n    placement,\n    middlewareData\n  } = (0,floating_ui_react/* useFloating */.we)(enableFloatingStyles ? {\n    placement: align,\n    // The floating element is positioned relative to its nearest\n    // containing block (usually the viewport). It will in many cases also\n    // “break” the floating element out of a clipping ancestor.\n    // https://floating-ui.com/docs/misc#clipping\n    strategy: 'fixed',\n    // Middleware order matters, arrow should be last\n    middleware: [(0,floating_ui_react_dom/* offset */.cY)(!isTabTip ? {\n      alignmentAxis: alignmentAxisOffset,\n      mainAxis: popoverDimensions?.current?.offset\n    } : 0), autoAlign && (0,floating_ui_react_dom/* flip */.UU)({\n      fallbackPlacements: isTabTip ? align.includes('bottom') ? ['bottom-start', 'bottom-end', 'top-start', 'top-end'] : ['top-start', 'top-end', 'bottom-start', 'bottom-end'] : align.includes('bottom') ? ['bottom', 'bottom-start', 'bottom-end', 'right', 'right-start', 'right-end', 'left', 'left-start', 'left-end', 'top', 'top-start', 'top-end'] : ['top', 'top-start', 'top-end', 'left', 'left-start', 'left-end', 'right', 'right-start', 'right-end', 'bottom', 'bottom-start', 'bottom-end'],\n      fallbackStrategy: 'initialPlacement',\n      fallbackAxisSideDirection: 'start',\n      boundary: autoAlignBoundary\n    }), (0,floating_ui_react_dom/* arrow */.UE)({\n      element: caretRef\n    }), autoAlign && (0,floating_ui_react_dom/* hide */.jD)()],\n    whileElementsMounted: floating_ui_dom/* autoUpdate */.ll\n  } : {}\n  // When autoAlign is turned off & the `enable-v12-dynamic-floating-styles` feature flag is not\n  // enabled, floating-ui will not be used\n  );\n  const value = (0,react.useMemo)(() => {\n    return {\n      floating,\n      setFloating: refs.setFloating,\n      caretRef,\n      autoAlign: autoAlign\n    };\n  }, [refs.setFloating, autoAlign]);\n  if (isTabTip) {\n    const tabTipAlignments = ['bottom-start', 'bottom-end'];\n    if (!tabTipAlignments.includes(align)) {\n      align = 'bottom-start';\n    }\n  }\n  (0,react.useEffect)(() => {\n    if (enableFloatingStyles) {\n      const updatedFloatingStyles = {\n        ...floatingStyles,\n        visibility: middlewareData.hide?.referenceHidden ? 'hidden' : 'visible'\n      };\n      Object.keys(updatedFloatingStyles).forEach(style => {\n        if (refs.floating.current) {\n          refs.floating.current.style[style] = updatedFloatingStyles[style];\n        }\n      });\n      if (caret && middlewareData && middlewareData.arrow && caretRef?.current) {\n        const {\n          x,\n          y\n        } = middlewareData.arrow;\n        const staticSide = {\n          top: 'bottom',\n          right: 'left',\n          bottom: 'top',\n          left: 'right'\n        }[placement.split('-')[0]];\n        caretRef.current.style.left = x != null ? `${x}px` : '';\n        caretRef.current.style.top = y != null ? `${y}px` : '';\n\n        // Ensure the static side gets unset when flipping to other placements' axes.\n        caretRef.current.style.right = '';\n        caretRef.current.style.bottom = '';\n        if (staticSide) {\n          caretRef.current.style[staticSide] = `${-popoverDimensions?.current?.caretHeight}px`;\n        }\n      }\n    }\n  }, [floatingStyles, refs.floating, enableFloatingStyles, middlewareData, placement, caret]);\n  const ref = useMergedRefs([forwardRef, popover]);\n  const currentAlignment = autoAlign && placement !== align ? placement : align;\n  const className = classnames_default()({\n    [`${prefix}--popover-container`]: true,\n    [`${prefix}--popover--caret`]: caret,\n    [`${prefix}--popover--drop-shadow`]: dropShadow,\n    [`${prefix}--popover--high-contrast`]: highContrast,\n    [`${prefix}--popover--open`]: open,\n    [`${prefix}--popover--auto-align ${prefix}--autoalign`]: enableFloatingStyles,\n    [`${prefix}--popover--${currentAlignment}`]: true,\n    [`${prefix}--popover--tab-tip`]: isTabTip\n  }, customClassName);\n  const mappedChildren = react.Children.map(children, child => {\n    const item = child;\n    const displayName = item?.type?.displayName;\n\n    /**\n     * Only trigger elements (button) or trigger components (ToggletipButton) should be\n     * cloned because these will be decorated with a trigger-specific className and ref.\n     *\n     * There are also some specific components that should not be cloned when autoAlign\n     * is on, even if they are a trigger element.\n     */\n    const isTriggerElement = item?.type === 'button';\n    const isTriggerComponent = enableFloatingStyles && displayName && ['ToggletipButton'].includes(displayName);\n    const isAllowedTriggerComponent = enableFloatingStyles && !['ToggletipContent', 'PopoverContent'].includes(displayName);\n    if (/*#__PURE__*/ /*#__PURE__*/react.isValidElement(item) && (isTriggerElement || isTriggerComponent || isAllowedTriggerComponent)) {\n      const className = item?.props?.className;\n      const ref = (item?.props).ref;\n      const tabTipClasses = classnames_default()(`${prefix}--popover--tab-tip__button`, className);\n      return /*#__PURE__*/react.cloneElement(item, {\n        className: isTabTip && item?.type === 'button' ? tabTipClasses : className || '',\n        // With cloneElement, if you pass a `ref`, it overrides the original ref.\n        // https://react.dev/reference/react/cloneElement#parameters\n        // The block below works around this and ensures that the original ref is still\n        // called while allowing the floating-ui reference element to be set as well.\n        // `useMergedRefs` can't be used here because hooks can't be called from within a callback.\n        // More here: https://github.com/facebook/react/issues/8873#issuecomment-489579878\n        ref: node => {\n          // For a popover, there isn't an explicit trigger component, it's just the first child that's\n          // passed in which should *not* be PopoverContent.\n          // For a toggletip there is a specific trigger component, ToggletipButton.\n          // In either of these cases we want to set this as the reference node for floating-ui autoAlign\n          // positioning.\n          if (enableFloatingStyles && item?.type?.displayName !== 'PopoverContent' || enableFloatingStyles && item?.type?.displayName === 'ToggletipButton') {\n            // Set the reference element for floating-ui\n            refs.setReference(node);\n          }\n\n          // Call the original ref, if any\n          if (typeof ref === 'function') {\n            ref(node);\n          } else if (ref !== null && ref !== undefined) {\n            ref.current = node;\n          }\n        }\n      });\n    } else {\n      return item;\n    }\n  });\n  const BaseComponentAsAny = BaseComponent;\n  return /*#__PURE__*/react.createElement(PopoverContext.Provider, {\n    value: value\n  }, /*#__PURE__*/react.createElement(BaseComponentAsAny, _extends({}, rest, {\n    className: className,\n    ref: ref\n  }), enableFloatingStyles || isTabTip ? mappedChildren : children));\n});\n\n// Note: this displayName is temporarily set so that Storybook ArgTable\n// correctly displays the name of this component\nif (false) {}\nPopover.propTypes = {\n  /**\n   * Specify how the popover should align with the trigger element\n   */\n  align: deprecateValuesWithin(prop_types_default().oneOf(['top', 'top-left',\n  // deprecated use top-start instead\n  'top-right',\n  // deprecated use top-end instead\n\n  'bottom', 'bottom-left',\n  // deprecated use bottom-start instead\n  'bottom-right',\n  // deprecated use bottom-end instead\n\n  'left', 'left-bottom',\n  // deprecated use left-end instead\n  'left-top',\n  // deprecated use left-start instead\n\n  'right', 'right-bottom',\n  // deprecated use right-end instead\n  'right-top',\n  // deprecated use right-start instead\n\n  // new values to match floating-ui\n  'top-start', 'top-end', 'bottom-start', 'bottom-end', 'left-end', 'left-start', 'right-end', 'right-start']), ['top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left', 'left-start', 'left-end', 'right', 'right-start', 'right-end'], mapPopoverAlign),\n  /**\n   * Provide a custom element or component to render the top-level node for the\n   * component.\n   */\n  as: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).elementType]),\n  /**\n   * Will auto-align the popover on first render if it is not visible. This prop is currently experimental and is subject to future changes.\n   */\n  autoAlign: (prop_types_default()).bool,\n  /**\n   * Specify a bounding element to be used for autoAlign calculations. The viewport is used by default. This prop is currently experimental and is subject to future changes.\n   */\n  autoAlignBoundary: prop_types_default().oneOfType([prop_types_default().oneOf(['clippingAncestors']), (prop_types_default()).elementType, prop_types_default().arrayOf((prop_types_default()).elementType), prop_types_default().exact({\n    x: (prop_types_default()).number.isRequired,\n    y: (prop_types_default()).number.isRequired,\n    width: (prop_types_default()).number.isRequired,\n    height: (prop_types_default()).number.isRequired\n  })]),\n  /**\n   * Specify whether a caret should be rendered\n   */\n  caret: (prop_types_default()).bool,\n  /**\n   * Provide elements to be rendered inside of the component\n   */\n  children: (prop_types_default()).node,\n  /**\n   * Provide a custom class name to be added to the outermost node in the\n   * component\n   */\n  className: (prop_types_default()).string,\n  /**\n   * Specify whether a drop shadow should be rendered on the popover\n   */\n  dropShadow: (prop_types_default()).bool,\n  /**\n   * Render the component using the high-contrast variant\n   */\n  highContrast: (prop_types_default()).bool,\n  /**\n   * Render the component using the tab tip variant\n   */\n  isTabTip: (prop_types_default()).bool,\n  /**\n   * Specify a handler for closing popover.\n   * The handler should take care of closing the popover, e.g. changing the `open` prop.\n   */\n  onRequestClose: (prop_types_default()).func,\n  /**\n   * Specify whether the component is currently open or closed\n   */\n  open: (prop_types_default()).bool.isRequired\n};\nfunction PopoverContentRenderFunction(\n// eslint-disable-next-line react/prop-types\n_ref3, forwardRef) {\n  let {\n    className,\n    children,\n    ...rest\n  } = _ref3;\n  const prefix = usePrefix();\n  const {\n    setFloating,\n    caretRef,\n    autoAlign\n  } = react.useContext(PopoverContext);\n  const ref = useMergedRefs([setFloating, forwardRef]);\n  const enableFloatingStyles = useFeatureFlag('enable-v12-dynamic-floating-styles') || autoAlign;\n  return /*#__PURE__*/react.createElement(\"span\", _extends({}, rest, {\n    className: `${prefix}--popover`\n  }), /*#__PURE__*/react.createElement(\"span\", {\n    className: classnames_default()(`${prefix}--popover-content`, className),\n    ref: ref\n  }, children, enableFloatingStyles && /*#__PURE__*/react.createElement(\"span\", {\n    className: classnames_default()({\n      [`${prefix}--popover-caret`]: true,\n      [`${prefix}--popover--auto-align`]: true\n    }),\n    ref: caretRef\n  })), !enableFloatingStyles && /*#__PURE__*/react.createElement(\"span\", {\n    className: classnames_default()({\n      [`${prefix}--popover-caret`]: true\n    }),\n    ref: caretRef\n  }));\n}\nconst PopoverContent = /*#__PURE__*/react.forwardRef(PopoverContentRenderFunction);\nPopoverContent.displayName = 'PopoverContent';\nPopoverContent.propTypes = {\n  /**\n   * Provide elements to be rendered inside of the component\n   */\n  children: (prop_types_default()).node,\n  /**\n   * Provide a custom class name to be added to the outermost node in the\n   * component\n   */\n  className: (prop_types_default()).string\n};\n\n;// ./node_modules/@carbon/react/es/internal/useDelayedState.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n/**\n * `useDelayedState` mirrors `useState` but also allows you to add a delay to\n * when your state updates. You can provide a second argument to `setState`,\n * `delayMs`, which will be the time in milliseconds after which the state is\n * updated.\n *\n * This hook will clean up pending timers in `useEffect` and will cancel any\n * pending timers when a `setState` is called before the state is updated from\n * a previous call\n */\n\nfunction useDelayedState(initialState) {\n  const [state, setState] = (0,react.useState)(initialState);\n  const timeoutId = (0,react.useRef)(null);\n  // We use `useCallback` to match the signature of React's `useState` which will\n  // always return the same reference for the `setState` updater\n  const setStateWithDelay = (0,react.useCallback)(function (stateToSet) {\n    let delayMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    window.clearTimeout(timeoutId.current ?? undefined);\n    timeoutId.current = null;\n    if (delayMs === 0) {\n      setState(stateToSet);\n      return;\n    }\n    timeoutId.current = window.setTimeout(() => {\n      setState(stateToSet);\n      timeoutId.current = null;\n    }, delayMs);\n  }, []);\n  (0,react.useEffect)(() => {\n    return () => {\n      window.clearTimeout(timeoutId.current ?? undefined);\n    };\n  }, []);\n  return [state, setStateWithDelay];\n}\n\n;// ./node_modules/@carbon/react/es/internal/useNoInteractiveChildren.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nfunction useNoInteractiveChildren(ref) {\n  let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'component should have no interactive child nodes';\n  if (false) {}\n}\nfunction useInteractiveChildrenNeedDescription(ref) {\n  let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : `interactive child node(s) should have an \\`aria-describedby\\` property`;\n  if (false) {}\n}\n\n/**\n * Determines if a given DOM node has interactive content, or is itself\n * interactive. It returns the interactive node if one is found\n *\n * @param {HTMLElement} node\n * @returns {HTMLElement}\n */\nfunction getInteractiveContent(node) {\n  if (!node || !node.childNodes) {\n    return null;\n  }\n  if (isFocusable(node)) {\n    return node;\n  }\n  for (const childNode of node.childNodes) {\n    const interactiveNode = getInteractiveContent(childNode);\n    if (interactiveNode) {\n      return interactiveNode;\n    }\n  }\n  return null;\n}\n\n/**\n * Determines if a given DOM node has a role, or has itself a role.\n * It returns the node with a role if one is found\n *\n * @param {HTMLElement} node\n * @returns {HTMLElement}\n */\nfunction getRoleContent(node) {\n  if (!node || !node.childNodes) {\n    return null;\n  }\n  if (node?.getAttribute?.('role') && node.getAttribute('role') !== '') {\n    return node;\n  }\n  for (const childNode of node.childNodes) {\n    const roleNode = getRoleContent(childNode);\n    if (roleNode) {\n      return roleNode;\n    }\n  }\n  return null;\n}\n\n/**\n * Determines if the given element is focusable, or not\n *\n * @param {HTMLElement} element\n * @returns {boolean}\n * @see https://github.com/w3c/aria-practices/blob/0553bb51588ffa517506e2a1b2ca1422ed438c5f/examples/js/utils.js#L68\n */\nfunction isFocusable(element) {\n  if (element.tabIndex === undefined || element.tabIndex < 0) {\n    return false;\n  }\n  if (element.disabled) {\n    return false;\n  }\n  switch (element.nodeName) {\n    case 'A':\n      return !!element.href && element.rel !== 'ignore';\n    case 'INPUT':\n      return element.type !== 'hidden';\n    default:\n      return true;\n  }\n}\n\n;// ./node_modules/@carbon/react/es/components/Tooltip/Tooltip.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Event types that trigger a \"drag\" to stop.\n */\nconst DRAG_STOP_EVENT_TYPES = new Set(['mouseup', 'touchend', 'touchcancel']);\nconst Tooltip = /*#__PURE__*/react.forwardRef((_ref, ref) => {\n  let {\n    as,\n    align = 'top',\n    className: customClassName,\n    children,\n    label,\n    description,\n    enterDelayMs = 100,\n    leaveDelayMs = 300,\n    defaultOpen = false,\n    closeOnActivation = false,\n    dropShadow = false,\n    highContrast = true,\n    ...rest\n  } = _ref;\n  const tooltipRef = (0,react.useRef)(null);\n  const [open, setOpen] = useDelayedState(defaultOpen);\n  const [isDragging, setIsDragging] = (0,react.useState)(false);\n  const [focusByMouse, setFocusByMouse] = (0,react.useState)(false);\n  const [isPointerIntersecting, setIsPointerIntersecting] = (0,react.useState)(false);\n  const id = useId('tooltip');\n  const prefix = usePrefix();\n  const child = react.Children.only(children);\n  const {\n    'aria-label': ariaLabel,\n    'aria-labelledby': ariaLabelledBy,\n    'aria-describedby': ariaDescribedBy\n  } = child?.props ?? {};\n  const hasLabel = !!label;\n  const hasAriaLabel = typeof ariaLabel === 'string' ? ariaLabel.trim() !== '' : false;\n\n  // An `aria-label` takes precedence over `aria-describedby`, but when it's\n  // needed and the user doesn't specify one, the fallback `id` is used.\n  const labelledBy = hasAriaLabel ? null : hasLabel ? ariaLabelledBy ?? id : undefined;\n\n  // If `aria-label` is present, use any provided `aria-describedby`.\n  // If not, fallback to child's `aria-describedby` or the tooltip `id` if needed.\n  const describedBy = hasAriaLabel ? ariaDescribedBy : ariaDescribedBy ?? (!hasLabel && !ariaLabelledBy ? id : undefined);\n  const triggerProps = {\n    onFocus: () => !focusByMouse && setOpen(true),\n    onBlur: () => {\n      setOpen(false);\n      setFocusByMouse(false);\n    },\n    onClick: () => closeOnActivation && setOpen(false),\n    // This should be placed on the trigger in case the element is disabled\n    onMouseEnter,\n    onMouseLeave,\n    onMouseDown,\n    onMouseMove: onMouseMove,\n    onTouchStart: onDragStart,\n    'aria-labelledby': labelledBy,\n    'aria-describedby': describedBy\n  };\n  function getChildEventHandlers(childProps) {\n    const eventHandlerFunctions = Object.keys(triggerProps).filter(prop => prop.startsWith('on'));\n    const eventHandlers = {};\n    eventHandlerFunctions.forEach(functionName => {\n      eventHandlers[functionName] = evt => {\n        triggerProps[functionName](evt);\n        if (childProps?.[functionName]) {\n          childProps?.[functionName](evt);\n        }\n      };\n    });\n    return eventHandlers;\n  }\n  const onKeyDown = (0,react.useCallback)(event => {\n    if (open && match_match(event, Escape)) {\n      event.stopPropagation();\n      setOpen(false);\n    }\n    if (open && closeOnActivation && (match_match(event, Enter) || match_match(event, Space))) {\n      setOpen(false);\n    }\n  }, [closeOnActivation, open, setOpen]);\n  useIsomorphicEffect(() => {\n    if (!open) {\n      return undefined;\n    }\n    function handleKeyDown(event) {\n      if (match_match(event, Escape)) {\n        onKeyDown(event);\n      }\n    }\n    document.addEventListener('keydown', handleKeyDown);\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [open, onKeyDown]);\n  function onMouseEnter() {\n    // Interactive Tags should not support onMouseEnter\n    if (!rest?.onMouseEnter) {\n      setIsPointerIntersecting(true);\n      setOpen(true, enterDelayMs);\n    }\n  }\n  function onMouseDown() {\n    setFocusByMouse(true);\n    onDragStart();\n  }\n  function onMouseLeave() {\n    setIsPointerIntersecting(false);\n    if (isDragging) {\n      return;\n    }\n    setOpen(false, leaveDelayMs);\n  }\n  function onMouseMove(evt) {\n    if (evt.buttons === 1) {\n      setIsDragging(true);\n    } else {\n      setIsDragging(false);\n    }\n  }\n  function onDragStart() {\n    setIsDragging(true);\n  }\n  const onDragStop = (0,react.useCallback)(() => {\n    setIsDragging(false);\n    // Close the tooltip, unless the mouse pointer is within the bounds of the\n    // trigger.\n    if (!isPointerIntersecting) {\n      setOpen(false, leaveDelayMs);\n    }\n  }, [isPointerIntersecting, leaveDelayMs, setOpen]);\n  useNoInteractiveChildren(tooltipRef, 'The Tooltip component must have no interactive content rendered by the' + '`label` or `description` prop');\n  (0,react.useEffect)(() => {\n    if (isDragging) {\n      // Register drag stop handlers.\n      DRAG_STOP_EVENT_TYPES.forEach(eventType => {\n        document.addEventListener(eventType, onDragStop);\n      });\n    }\n    return () => {\n      DRAG_STOP_EVENT_TYPES.forEach(eventType => {\n        document.removeEventListener(eventType, onDragStop);\n      });\n    };\n  }, [isDragging, onDragStop]);\n  return /*#__PURE__*/react.createElement(Popover, _extends({\n    as: as,\n    ref: ref\n  }, rest, {\n    align: align,\n    className: classnames_default()(`${prefix}--tooltip`, customClassName),\n    dropShadow: dropShadow,\n    highContrast: highContrast,\n    onKeyDown: onKeyDown,\n    onMouseLeave: onMouseLeave,\n    open: open\n  }), /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefix}--tooltip-trigger__wrapper`\n  }, child !== undefined ? /*#__PURE__*/react.cloneElement(child, {\n    ...triggerProps,\n    ...getChildEventHandlers(child.props)\n  }) : null), /*#__PURE__*/react.createElement(PopoverContent, {\n    \"aria-hidden\": open ? 'false' : 'true',\n    className: `${prefix}--tooltip-content`,\n    id: id,\n    onMouseEnter: onMouseEnter,\n    role: \"tooltip\"\n  }, label || description));\n});\nTooltip.propTypes = {\n  /**\n   * Specify how the trigger should align with the tooltip\n   */\n  align: prop_types_default().oneOf(['top', 'top-left',\n  // deprecated use top-start instead\n  'top-right',\n  // deprecated use top-end instead\n\n  'bottom', 'bottom-left',\n  // deprecated use bottom-start instead\n  'bottom-right',\n  // deprecated use bottom-end instead\n\n  'left', 'left-bottom',\n  // deprecated use left-end instead\n  'left-top',\n  // deprecated use left-start instead\n\n  'right', 'right-bottom',\n  // deprecated use right-end instead\n  'right-top',\n  // deprecated use right-start instead\n\n  // new values to match floating-ui\n  'top-start', 'top-end', 'bottom-start', 'bottom-end', 'left-end', 'left-start', 'right-end', 'right-start']),\n  /**\n   * Pass in the child to which the tooltip will be applied\n   */\n  children: (prop_types_default()).node,\n  /**\n   * Specify an optional className to be applied to the container node\n   */\n  className: (prop_types_default()).string,\n  /**\n   * Determines wether the tooltip should close when inner content is activated (click, Enter or Space)\n   */\n  closeOnActivation: (prop_types_default()).bool,\n  /**\n   * Specify whether the tooltip should be open when it first renders\n   */\n  defaultOpen: (prop_types_default()).bool,\n  /**\n   * Provide the description to be rendered inside of the Tooltip. The\n   * description will use `aria-describedby` and will describe the child node\n   * in addition to the text rendered inside of the child. This means that if you\n   * have text in the child node, that it will be announced alongside the\n   * description to the screen reader.\n   *\n   * Note: if label and description are both provided, label will be used and\n   * description will not be used\n   */\n  description: (prop_types_default()).node,\n  /**\n   * Specify whether a drop shadow should be rendered\n   */\n  dropShadow: (prop_types_default()).bool,\n  /**\n   * Specify the duration in milliseconds to delay before displaying the tooltip\n   */\n  enterDelayMs: (prop_types_default()).number,\n  /**\n   * Render the component using the high-contrast theme\n   */\n  highContrast: (prop_types_default()).bool,\n  /**\n   * Provide the label to be rendered inside of the Tooltip. The label will use\n   * `aria-labelledby` and will fully describe the child node that is provided.\n   * This means that if you have text in the child node, that it will not be\n   * announced to the screen reader.\n   *\n   * Note: if label and description are both provided, description will not be\n   * used\n   */\n  label: (prop_types_default()).node,\n  /**\n   * Specify the duration in milliseconds to delay before hiding the tooltip\n   */\n  leaveDelayMs: (prop_types_default()).number\n};\n\n;// ./node_modules/@carbon/react/es/components/Button/ButtonBase.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nconst ButtonBase = /*#__PURE__*/react.forwardRef(function ButtonBase(_ref, ref) {\n  let {\n    as,\n    children,\n    className,\n    dangerDescription = 'danger',\n    disabled = false,\n    hasIconOnly = false,\n    href,\n    iconDescription,\n    isExpressive = false,\n    isSelected,\n    kind = 'primary',\n    onBlur,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    renderIcon: ButtonImageElement,\n    size,\n    tabIndex,\n    type = 'button',\n    ...rest\n  } = _ref;\n  const prefix = usePrefix();\n  const buttonClasses = classnames_default()(className, {\n    [`${prefix}--btn`]: true,\n    [`${prefix}--btn--sm`]: size === 'sm' && !isExpressive,\n    // TODO: V12 - Remove this class\n    [`${prefix}--btn--md`]: size === 'md' && !isExpressive,\n    // TODO: V12 - Remove this class\n    [`${prefix}--btn--lg`]: size === 'lg' && !isExpressive,\n    // TODO: V12 - Remove this class\n    [`${prefix}--btn--xl`]: size === 'xl',\n    // TODO: V12 - Remove this class\n    [`${prefix}--btn--2xl`]: size === '2xl',\n    // TODO: V12 - Remove this class\n    [`${prefix}--layout--size-${size}`]: size,\n    [`${prefix}--btn--${kind}`]: kind,\n    [`${prefix}--btn--disabled`]: disabled,\n    [`${prefix}--btn--expressive`]: isExpressive,\n    [`${prefix}--btn--icon-only`]: hasIconOnly,\n    [`${prefix}--btn--selected`]: hasIconOnly && isSelected && kind === 'ghost'\n  });\n  const commonProps = {\n    tabIndex,\n    className: buttonClasses,\n    ref\n  };\n  const buttonImage = !ButtonImageElement ? null : /*#__PURE__*/react.createElement(ButtonImageElement, {\n    \"aria-label\": iconDescription,\n    className: `${prefix}--btn__icon`,\n    \"aria-hidden\": \"true\"\n  });\n  const dangerButtonVariants = ['danger', 'danger--tertiary', 'danger--ghost'];\n  let component = 'button';\n  const assistiveId = useId('danger-description');\n  const {\n    'aria-pressed': ariaPressed,\n    'aria-describedby': ariaDescribedBy\n  } = rest;\n  let otherProps = {\n    disabled,\n    type,\n    'aria-describedby': dangerButtonVariants.includes(kind) ? assistiveId : ariaDescribedBy || undefined,\n    'aria-pressed': ariaPressed ?? (hasIconOnly && kind === 'ghost' ? isSelected : undefined)\n  };\n  const anchorProps = {\n    href\n  };\n  let assistiveText = null;\n  if (dangerButtonVariants.includes(kind)) {\n    assistiveText = /*#__PURE__*/react.createElement(\"span\", {\n      id: assistiveId,\n      className: `${prefix}--visually-hidden`\n    }, dangerDescription);\n  }\n  if (as) {\n    component = as;\n    otherProps = {\n      ...otherProps,\n      ...anchorProps\n    };\n  } else if (href && !disabled) {\n    component = 'a';\n    otherProps = anchorProps;\n  }\n  return /*#__PURE__*/react.createElement(component, {\n    onMouseEnter,\n    onMouseLeave,\n    onFocus,\n    onBlur,\n    onClick,\n    ...rest,\n    ...commonProps,\n    ...otherProps\n  }, assistiveText, children, buttonImage);\n});\n\n;// ./node_modules/@carbon/react/es/components/BadgeIndicator/index.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\nconst BadgeIndicator = /*#__PURE__*/react.forwardRef(function BadgeIndicatorContent(_ref, ref) {\n  let {\n    className: customClassName,\n    count,\n    ...rest\n  } = _ref;\n  const prefix = usePrefix();\n  const classNames = classnames_default()(`${prefix}--badge-indicator`, customClassName, {\n    [`${prefix}--badge-indicator--count`]: count\n  });\n  const displayCount = count && count > 999 ? '999+' : count;\n  return /*#__PURE__*/react.createElement(\"div\", _extends({\n    className: classNames,\n    ref: ref\n  }, rest), displayCount);\n});\nBadgeIndicator.propTypes = {\n  /**\n   * Specify an optional className to add.\n   */\n  className: (prop_types_default()).string,\n  /**\n   * Count of badge indicator\n   */\n  count: (prop_types_default()).number,\n  /**\n   * Provide an `id` to uniquely identify the BadgeIndidcator\n   */\n  id: (prop_types_default()).string\n};\n\n;// ./node_modules/@carbon/react/es/components/IconButton/index.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst IconButtonKinds = ['primary', 'secondary', 'ghost', 'tertiary'];\nconst IconButton = /*#__PURE__*/react.forwardRef(function IconButton(_ref, ref) {\n  let {\n    align,\n    autoAlign = false,\n    badgeCount,\n    children,\n    className,\n    closeOnActivation = true,\n    defaultOpen = false,\n    disabled,\n    dropShadow = false,\n    enterDelayMs = 100,\n    highContrast = true,\n    kind,\n    label,\n    leaveDelayMs = 100,\n    wrapperClasses,\n    size,\n    isSelected,\n    ...rest\n  } = _ref;\n  const prefix = usePrefix();\n  const tooltipClasses = classnames_default()(wrapperClasses, `${prefix}--icon-tooltip`, {\n    [`${prefix}--icon-tooltip--disabled`]: disabled\n  });\n  if (badgeCount && (kind !== 'ghost' || size !== 'lg')) {\n    console.warn(\"The prop BadgeCount must be used with hasIconOnly=true, kind='ghost' and size='lg'\");\n  }\n  const badgeId = useId('badge-indicator');\n  return /*#__PURE__*/react.createElement(Tooltip, {\n    align: align,\n    autoAlign: autoAlign,\n    closeOnActivation: closeOnActivation,\n    className: tooltipClasses,\n    defaultOpen: defaultOpen,\n    dropShadow: dropShadow,\n    enterDelayMs: enterDelayMs,\n    highContrast: highContrast,\n    label: label,\n    leaveDelayMs: leaveDelayMs\n  }, /*#__PURE__*/react.createElement(ButtonBase, _extends({}, rest, {\n    disabled: disabled,\n    kind: kind,\n    ref: ref,\n    size: size,\n    isSelected: isSelected,\n    hasIconOnly: true,\n    className: className,\n    \"aria-describedby\": rest['aria-describedby'] || badgeCount && badgeId\n  }), children, !disabled && badgeCount !== undefined && /*#__PURE__*/react.createElement(BadgeIndicator, {\n    id: badgeId,\n    count: badgeCount > 0 ? badgeCount : undefined\n  })));\n});\nIconButton.propTypes = {\n  /**\n   * Specify how the trigger should align with the tooltip\n   */\n  align: deprecateValuesWithin(prop_types_default().oneOf(['top', 'top-left',\n  // deprecated use top-start instead\n  'top-right',\n  // deprecated use top-end instead\n\n  'bottom', 'bottom-left',\n  // deprecated use bottom-start instead\n  'bottom-right',\n  // deprecated use bottom-end instead\n\n  'left', 'left-bottom',\n  // deprecated use left-end instead\n  'left-top',\n  // deprecated use left-start instead\n\n  'right', 'right-bottom',\n  // deprecated use right-end instead\n  'right-top',\n  // deprecated use right-start instead\n\n  // new values to match floating-ui\n  'top-start', 'top-end', 'bottom-start', 'bottom-end', 'left-end', 'left-start', 'right-end', 'right-start']), ['top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left', 'left-start', 'left-end', 'right', 'right-start', 'right-end'], mapPopoverAlign),\n  /**\n   * **Experimental**: Will attempt to automatically align the tooltip\n   */\n  autoAlign: (prop_types_default()).bool,\n  /**\n   * **Experimental**: Display a badge on the button. An empty/dot badge if 0, a numbered badge if > 0.\n   * Must be used with size=\"lg\", kind=\"ghost\" and hasIconOnly=true\n   */\n  badgeCount: (prop_types_default()).number,\n  /**\n   * Optionally specify an href for your IconButton to become an `<a>` element\n   */\n  href: (prop_types_default()).string,\n  /**\n   * Provide an icon or asset to be rendered inside of the IconButton\n   */\n  children: (prop_types_default()).node,\n  /**\n   * Specify an optional className to be added to your Button\n   */\n  className: (prop_types_default()).string,\n  /**\n   * Determines whether the tooltip should close when inner content is activated (click, Enter or Space)\n   */\n  closeOnActivation: (prop_types_default()).bool,\n  /**\n   * Specify whether the tooltip should be open when it first renders\n   */\n  defaultOpen: (prop_types_default()).bool,\n  /**\n   * Specify whether a drop shadow should be rendered on the tooltip\n   */\n  dropShadow: (prop_types_default()).bool,\n  /**\n   * Specify whether the Button should be disabled, or not\n   */\n  disabled: (prop_types_default()).bool,\n  /**\n   * Specify the duration in milliseconds to delay before displaying the tooltip\n   */\n  enterDelayMs: (prop_types_default()).number,\n  /**\n   * Specify whether the IconButton is currently selected\n   */\n  isSelected: (prop_types_default()).bool,\n  /**\n   * Render the tooltip using the high-contrast theme\n   */\n  highContrast: (prop_types_default()).bool,\n  /**\n   * Specify the type of button to be used as the base for the IconButton\n   */\n  kind: prop_types_default().oneOf(IconButtonKinds),\n  /**\n   * Provide the label to be rendered inside of the Tooltip. The label will use\n   * `aria-labelledby` and will fully describe the child node that is provided.\n   * If the child node already has an `aria-label`, the tooltip will not apply\n   * `aria-labelledby`. If the child node has `aria-labelledby`, that value will\n   * be used instead. Otherwise, the tooltip will use its own ID as the label.\n   * This means that if you have text in the child node it will not be\n   * announced to the screen reader.\n   * If using `badgeCount={0}`, make sure the label explains that there is a\n   * new notification.\n   */\n  label: (prop_types_default()).node.isRequired,\n  /**\n   * Specify the duration in milliseconds to delay before hiding the tooltip\n   */\n  leaveDelayMs: (prop_types_default()).number,\n  /**\n   * Optionally specify a `rel` when using an `<a>` element.\n   */\n  rel: (prop_types_default()).string,\n  /**\n   * Specify the size of the Button.\n   */\n  size: prop_types_default().oneOf(['sm', 'md', 'lg']),\n  /**\n   * Optionally specify a `target` when using an `<a>` element.\n   */\n  target: (prop_types_default()).string,\n  /**\n   * Specify an optional className to be added to your Tooltip wrapper\n   */\n  wrapperClasses: (prop_types_default()).string\n};\n\n;// ./node_modules/@carbon/react/es/components/Button/Button.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\nconst ButtonKinds = ['primary', 'secondary', 'danger', 'ghost', 'danger--primary', 'danger--ghost', 'danger--tertiary', 'tertiary'];\nconst ButtonSizes = (/* unused pure expression or super */ null && (['sm', 'md', 'lg', 'xl', '2xl']));\nconst ButtonTooltipAlignments = (/* unused pure expression or super */ null && (['start', 'center', 'end']));\nconst ButtonTooltipPositions = (/* unused pure expression or super */ null && (['top', 'right', 'bottom', 'left']));\nfunction isIconOnlyButton(hasIconOnly, _kind) {\n  if (hasIconOnly === true) {\n    return true;\n  }\n  return false;\n}\nconst Button = /*#__PURE__*/react.forwardRef((props, ref) => {\n  const {\n    as,\n    autoAlign = false,\n    children,\n    hasIconOnly = false,\n    tooltipHighContrast = true,\n    tooltipDropShadow = false,\n    iconDescription,\n    kind = 'primary',\n    onBlur,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    renderIcon: ButtonImageElement,\n    size,\n    tooltipAlignment = 'center',\n    tooltipPosition = 'top',\n    ...rest\n  } = props;\n  if (ButtonImageElement && !children && !iconDescription) {\n    console.error('Button: renderIcon property specified without also providing an iconDescription property. ' + 'This may impact accessibility for screen reader users.');\n  }\n  const iconOnlyImage = !ButtonImageElement ? null : /*#__PURE__*/react.createElement(ButtonImageElement, null);\n  if (!isIconOnlyButton(hasIconOnly)) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const {\n      tooltipAlignment,\n      ...propsWithoutTooltipAlignment\n    } = props;\n    return /*#__PURE__*/react.createElement(ButtonBase, _extends({\n      ref: ref\n    }, propsWithoutTooltipAlignment));\n  } else {\n    let align = undefined;\n    if (tooltipPosition === 'top' || tooltipPosition === 'bottom') {\n      if (tooltipAlignment === 'center') {\n        align = tooltipPosition;\n      }\n      if (tooltipAlignment === 'end') {\n        align = `${tooltipPosition}-end`;\n      }\n      if (tooltipAlignment === 'start') {\n        align = `${tooltipPosition}-start`;\n      }\n    }\n    if (tooltipPosition === 'right' || tooltipPosition === 'left') {\n      align = tooltipPosition;\n    }\n    return (/*#__PURE__*/\n      // @ts-expect-error - `IconButton` does not support all `size`s that\n      // `Button` supports.\n      //\n      // TODO: What should be done here?\n      // 1. Should the `IconButton` not be rendered if the `size` is not\n      //    supported?\n      // 2. Should an error be thrown?\n      // 3. Something else?\n      react.createElement(IconButton, _extends({}, rest, {\n        ref: ref,\n        as: as,\n        align: align,\n        label: iconDescription,\n        kind: kind,\n        size: size,\n        highContrast: tooltipHighContrast,\n        dropShadow: tooltipDropShadow,\n        onMouseEnter: onMouseEnter,\n        onMouseLeave: onMouseLeave,\n        onFocus: onFocus,\n        onBlur: onBlur,\n        autoAlign: autoAlign,\n        onClick: onClick,\n        renderIcon: iconOnlyImage ? null : ButtonImageElement // avoid doubling the icon.\n      }), iconOnlyImage ?? children)\n    );\n  }\n});\nButton.displayName = 'Button';\nButton.propTypes = {\n  /**\n   * Specify how the button itself should be rendered.\n   * Make sure to apply all props to the root node and render children appropriately\n   */\n  as: prop_types_default().oneOfType([(prop_types_default()).func, (prop_types_default()).string, (prop_types_default()).elementType]),\n  /**\n   * **Experimental**: Will attempt to automatically align the tooltip\n   */\n  autoAlign: (prop_types_default()).bool,\n  /**\n   * Specify the content of your Button\n   */\n  children: (prop_types_default()).node,\n  /**\n   * Specify an optional className to be added to your Button\n   */\n  className: (prop_types_default()).string,\n  /**\n   * Specify the message read by screen readers for the danger button variant\n   */\n  dangerDescription: (prop_types_default()).string,\n  /**\n   * Specify whether the Button should be disabled, or not\n   */\n  disabled: (prop_types_default()).bool,\n  /**\n   * Specify if the button is an icon-only button\n   */\n  hasIconOnly: (prop_types_default()).bool,\n  /**\n   * Optionally specify an href for your Button to become an `<a>` element\n   */\n  href: (prop_types_default()).string,\n  /**\n   * If specifying the `renderIcon` prop, provide a description for that icon that can\n   * be read by screen readers\n   */\n  iconDescription: props => {\n    if (props.renderIcon && !props.children && !props.iconDescription) {\n      return new Error('renderIcon property specified without also providing an iconDescription property.');\n    }\n    return null;\n  },\n  /**\n   * Specify whether the Button is expressive, or not\n   */\n  isExpressive: (prop_types_default()).bool,\n  /**\n   * Specify whether the Button is currently selected. Only applies to the Ghost variant.\n   */\n  isSelected: (prop_types_default()).bool,\n  /**\n   * Specify the kind of Button you want to create\n   */\n  kind: (props, propName, componentName) => {\n    const {\n      hasIconOnly\n    } = props;\n    const validKinds = hasIconOnly ? IconButtonKinds : ButtonKinds;\n    if (props[propName] === undefined) {\n      return null;\n    }\n    if (!validKinds.includes(props[propName])) {\n      return new Error(`Invalid prop \\`${propName}\\` supplied to \\`${componentName}\\`. Expected one of ${validKinds.join(', ')}.`);\n    }\n    return null;\n  },\n  /**\n   * Provide an optional function to be called when the button element\n   * loses focus\n   */\n  onBlur: (prop_types_default()).func,\n  /**\n   * Provide an optional function to be called when the button element\n   * is clicked\n   */\n  onClick: (prop_types_default()).func,\n  /**\n   * Provide an optional function to be called when the button element\n   * receives focus\n   */\n  onFocus: (prop_types_default()).func,\n  /**\n   * Provide an optional function to be called when the mouse\n   * enters the button element\n   */\n  onMouseEnter: (prop_types_default()).func,\n  /**\n   * Provide an optional function to be called when the mouse\n   * leaves the button element\n   */\n  onMouseLeave: (prop_types_default()).func,\n  /**\n   * Optionally specify a `rel` when using an `<a>` element.\n   */\n  rel: (prop_types_default()).string,\n  /**\n   * A component used to render an icon.\n   */\n  renderIcon: prop_types_default().oneOfType([(prop_types_default()).func, (prop_types_default()).object]),\n  /**\n   * Optional prop to specify the role of the Button\n   */\n  role: (prop_types_default()).string,\n  /**\n   * Specify the size of the button, from the following list of sizes:\n   */\n  size: prop_types_default().oneOf(['sm', 'md', 'lg', 'xl', '2xl']),\n  /**\n   * Optional prop to specify the tabIndex of the Button\n   */\n  tabIndex: (prop_types_default()).number,\n  /**\n   * Optionally specify a `target` when using an `<a>` element.\n   */\n  target: (prop_types_default()).string,\n  /**\n   * Specify the alignment of the tooltip to the icon-only button.\n   * Can be one of: start, center, or end.\n   */\n  tooltipAlignment: prop_types_default().oneOf(['start', 'center', 'end']),\n  /**\n   * Enable drop shadow for tooltips for icon-only buttons.\n   */\n  tooltipDropShadow: (prop_types_default()).bool,\n  /**\n   * Enable high-contrast theme for tooltips for icon-only buttons.\n   * Defaults to true.\n   */\n  tooltipHighContrast: (prop_types_default()).bool,\n  /**\n   * Specify the direction of the tooltip for icon-only buttons.\n   * Can be either top, right, bottom, or left.\n   */\n  tooltipPosition: prop_types_default().oneOf(['top', 'right', 'bottom', 'left']),\n  /**\n   * Optional prop to specify the type of the Button\n   */\n  type: prop_types_default().oneOf(['button', 'reset', 'submit'])\n};\n\n// EXTERNAL MODULE: ./node_modules/@carbon/icons-react/es/generated/bucket-18.js\nvar bucket_18 = __webpack_require__(42);\n;// ./node_modules/@carbon/react/es/internal/noopFn.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst noopFn = () => {};\n\n;// ./node_modules/@carbon/react/es/components/Checkbox/Checkbox.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\n\n\n\n\n\nconst Checkbox = /*#__PURE__*/react.forwardRef((_ref, ref) => {\n  let {\n    className,\n    decorator,\n    helperText,\n    id,\n    labelText,\n    onChange = noopFn,\n    onClick,\n    indeterminate = false,\n    invalid,\n    invalidText,\n    hideLabel,\n    readOnly,\n    title = '',\n    warn,\n    warnText,\n    slug,\n    ...other\n  } = _ref;\n  const prefix = usePrefix();\n  const showWarning = !readOnly && !invalid && warn;\n  const showHelper = !invalid && !warn;\n  const checkboxGroupInstanceId = useId();\n  const helperId = !helperText ? undefined : `checkbox-helper-text-${checkboxGroupInstanceId}`;\n  const helper = helperText ? /*#__PURE__*/react.createElement(\"div\", {\n    id: helperId,\n    className: `${prefix}--form__helper-text`\n  }, helperText) : null;\n  const wrapperClasses = classnames_default()(`${prefix}--form-item`, `${prefix}--checkbox-wrapper`, className, {\n    [`${prefix}--checkbox-wrapper--readonly`]: readOnly,\n    [`${prefix}--checkbox-wrapper--invalid`]: !readOnly && invalid,\n    [`${prefix}--checkbox-wrapper--warning`]: showWarning,\n    [`${prefix}--checkbox-wrapper--slug`]: slug,\n    [`${prefix}--checkbox-wrapper--decorator`]: decorator\n  });\n  const innerLabelClasses = classnames_default()(`${prefix}--checkbox-label-text`, {\n    [`${prefix}--visually-hidden`]: hideLabel\n  });\n  let normalizedDecorator = /*#__PURE__*/ /*#__PURE__*/react.isValidElement(slug ?? decorator) ? slug ?? decorator : null;\n  if (normalizedDecorator && normalizedDecorator['type']?.displayName === 'AILabel') {\n    const size = normalizedDecorator.props?.['kind'] === 'inline' ? 'md' : 'mini';\n    normalizedDecorator = /*#__PURE__*/react.cloneElement(normalizedDecorator, {\n      size\n    });\n  }\n  return /*#__PURE__*/react.createElement(\"div\", {\n    className: wrapperClasses\n  }, /*#__PURE__*/react.createElement(\"input\", _extends({}, other, {\n    type: \"checkbox\",\n    \"data-invalid\": invalid ? true : undefined,\n    onChange: evt => {\n      if (!readOnly && onChange) {\n        onChange(evt, {\n          checked: evt.target.checked,\n          id\n        });\n      }\n    },\n    className: `${prefix}--checkbox`,\n    id: id,\n    ref: el => {\n      if (el) {\n        el.indeterminate = indeterminate ?? false;\n      }\n      if (typeof ref === 'function') {\n        ref(el);\n      } else if (ref && 'current' in ref) {\n        ref.current = el;\n      }\n    }\n    // readonly attribute not applicable to type=\"checkbox\"\n    // see - https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox\n    ,\n\n    \"aria-readonly\": readOnly,\n    onClick: evt => {\n      if (readOnly) {\n        // prevent default stops the checkbox being updated\n        evt.preventDefault();\n      }\n      // pass onClick event on to the user even if readonly\n      if (onClick) {\n        onClick(evt);\n      }\n    }\n  })), /*#__PURE__*/react.createElement(\"label\", {\n    htmlFor: id,\n    className: `${prefix}--checkbox-label`,\n    title: title\n  }, /*#__PURE__*/react.createElement(Text, {\n    className: innerLabelClasses\n  }, labelText, slug ? normalizedDecorator : decorator ? /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefix}--checkbox-wrapper-inner--decorator`\n  }, normalizedDecorator) : '')), /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefix}--checkbox__validation-msg`\n  }, !readOnly && invalid && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(bucket_18/* WarningFilled */.BF, {\n    className: `${prefix}--checkbox__invalid-icon`\n  }), /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefix}--form-requirement`\n  }, invalidText)), showWarning && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(bucket_18/* WarningAltFilled */.OR, {\n    className: `${prefix}--checkbox__invalid-icon ${prefix}--checkbox__invalid-icon--warning`\n  }), /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefix}--form-requirement`\n  }, warnText))), showHelper && helper);\n});\nCheckbox.propTypes = {\n  /**\n   * Specify whether the underlying input should be checked\n   */\n  checked: (prop_types_default()).bool,\n  /**\n   * Specify an optional className to be applied to the <label> node\n   */\n  className: (prop_types_default()).string,\n  /**\n   * **Experimental**: Provide a decorator component to be rendered inside the `Checkbox` component\n   */\n  decorator: (prop_types_default()).node,\n  /**\n   * Specify whether the underlying input should be checked by default\n   */\n  defaultChecked: (prop_types_default()).bool,\n  /**\n   * Specify whether the Checkbox should be disabled\n   */\n  disabled: (prop_types_default()).bool,\n  /**\n   * Provide text for the form group for additional help\n   */\n  helperText: (prop_types_default()).node,\n  /**\n   * Specify whether the label should be hidden, or not\n   */\n  hideLabel: (prop_types_default()).bool,\n  /**\n   * Provide an `id` to uniquely identify the Checkbox input\n   */\n  id: (prop_types_default()).string.isRequired,\n  /**\n   * Specify whether the Checkbox is in an indeterminate state\n   */\n  indeterminate: (prop_types_default()).bool,\n  /**\n   * Specify whether the Checkbox is currently invalid\n   */\n  invalid: (prop_types_default()).bool,\n  /**\n   * Provide the text that is displayed when the Checkbox is in an invalid state\n   */\n  invalidText: (prop_types_default()).node,\n  /**\n   * Provide a label to provide a description of the Checkbox input that you are\n   * exposing to the user\n   */\n  labelText: (prop_types_default()).node.isRequired,\n  /**\n   * Provide an optional handler that is called when the internal state of\n   * Checkbox changes. This handler is called with event and state info.\n   * `(event, { checked, id }) => void`\n   */\n  onChange: (prop_types_default()).func,\n  /**\n   * Specify whether the Checkbox is read-only\n   */\n  readOnly: (prop_types_default()).bool,\n  /**\n   * **Experimental**: Provide a `Slug` component to be rendered inside the `Checkbox` component\n   */\n  slug: deprecate((prop_types_default()).node, 'The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead.'),\n  /**\n   * Specify a title for the <label> node for the Checkbox\n   */\n  title: (prop_types_default()).string,\n  /**\n   * Specify whether the Checkbox is currently in warning state\n   */\n  warn: (prop_types_default()).bool,\n  /**\n   * Provide the text that is displayed when the Checkbox is in warning state\n   */\n  warnText: (prop_types_default()).node\n};\nCheckbox.displayName = 'Checkbox';\n\n// EXTERNAL MODULE: ./node_modules/downshift/dist/downshift.esm.js + 1 modules\nvar downshift_esm = __webpack_require__(4656);\n;// ./node_modules/@carbon/react/es/components/FluidForm/FormContext.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst FormContext = /*#__PURE__*/(0,react.createContext)({\n  isFluid: false\n});\n\n;// ./node_modules/@carbon/react/es/components/ListBox/ListBoxPropTypes.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst listBoxTypes = ['default', 'inline'];\nconst listBoxSizes = ['sm', 'md', 'lg'];\nconst ListBoxTypePropType = prop_types_default().oneOf(listBoxTypes);\nconst ListBoxSizePropType = prop_types_default().oneOf(listBoxSizes);\n\n;// ./node_modules/@carbon/react/es/components/ListBox/ListBox.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\n\n\n\n\nconst handleOnKeyDown = event => {\n  if (event.keyCode === 27) {\n    event.stopPropagation();\n  }\n};\nconst handleClick = event => {\n  event.preventDefault();\n  event.stopPropagation();\n};\n/**\n * `ListBox` is a generic container component that handles creating the\n * container class name in response to certain props.\n */\nconst ListBox = /*#__PURE__*/(0,react.forwardRef)((props, ref) => {\n  const {\n    children,\n    className: containerClassName,\n    disabled = false,\n    type = 'default',\n    size,\n    invalid,\n    invalidText,\n    invalidTextId,\n    warn,\n    warnText,\n    warnTextId,\n    light,\n    isOpen,\n    ...rest\n  } = props;\n  const prefix = usePrefix();\n  const {\n    isFluid\n  } = (0,react.useContext)(FormContext);\n  const showWarning = !invalid && warn;\n  const className = classnames_default()({\n    ...(containerClassName && {\n      [containerClassName]: true\n    }),\n    [`${prefix}--list-box`]: true,\n    [`${prefix}--list-box--${size}`]: size,\n    [`${prefix}--list-box--inline`]: type === 'inline',\n    [`${prefix}--list-box--disabled`]: disabled,\n    [`${prefix}--list-box--light`]: light,\n    [`${prefix}--list-box--expanded`]: isOpen,\n    [`${prefix}--list-box--invalid`]: invalid,\n    [`${prefix}--list-box--warning`]: showWarning\n  });\n  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(\"div\", _extends({}, rest, {\n    className: className,\n    ref: ref,\n    onKeyDown: handleOnKeyDown,\n    onClick: handleClick,\n    \"data-invalid\": invalid || undefined\n  }), children), isFluid && /*#__PURE__*/react.createElement(\"hr\", {\n    className: `${prefix}--list-box__divider`\n  }), invalid ? /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefix}--form-requirement`,\n    id: invalidTextId\n  }, invalidText) : null, showWarning ? /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefix}--form-requirement`,\n    id: warnTextId\n  }, warnText) : null);\n});\nListBox.displayName = 'ListBox';\nListBox.propTypes = {\n  /**\n   * Provide the contents of your ListBox\n   */\n  children: (prop_types_default()).node,\n  /**\n   * Specify a class name to be applied on the containing list box node\n   */\n  className: (prop_types_default()).string,\n  /**\n   * Specify whether the ListBox is currently disabled\n   */\n  disabled: (prop_types_default()).bool,\n  /**\n   * Specify whether the control is currently invalid\n   */\n  invalid: (prop_types_default()).bool,\n  /**\n   * Specify the text to be displayed when the control is invalid\n   */\n  invalidText: (prop_types_default()).node,\n  /**\n   * Specify the id to be applied to the element containing the invalid text\n   */\n  invalidTextId: (prop_types_default()).string,\n  /**\n   * Specify if the control should render open\n   */\n  isOpen: (prop_types_default()).bool,\n  /**\n   * `true` to use the light version. For use on $ui-01 backgrounds only.\n   * Don't use this to make tile background color same as container background color.\n   */\n  light: deprecate((prop_types_default()).bool, 'The `light` prop for `ListBox` has ' + 'been deprecated in favor of the new `Layer` component. It will be removed in the next major release.'),\n  /**\n   * Specify the size of the ListBox. Currently supports either `sm`, `md` or `lg` as an option.\n   */\n  size: ListBoxSizePropType,\n  /**\n   * Specify the \"type\" of the ListBox. Currently supports either `default` or\n   * `inline` as an option.\n   */\n  type: ListBoxTypePropType,\n  /**\n   * Specify whether the control is currently in warning state\n   */\n  warn: (prop_types_default()).bool,\n  /**\n   * Provide the text that is displayed when the control is in warning state\n   */\n  warnText: (prop_types_default()).string,\n  /**\n   * Specify the id to be applied to the element containing the warn text\n   */\n  warnTextId: (prop_types_default()).string\n};\n\n;// ./node_modules/@carbon/react/es/components/ListBox/ListBoxField.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n/**\n * `ListBoxField` is responsible for creating the containing node for valid\n * elements inside of a field. It also provides a11y-related attributes like\n * `role` to make sure a user can focus the given field.\n */\nfunction ListBoxField(_ref) {\n  let {\n    children,\n    disabled,\n    tabIndex,\n    ...rest\n  } = _ref;\n  const prefix = usePrefix();\n  return /*#__PURE__*/react.createElement(\"div\", _extends({\n    className: `${prefix}--list-box__field`,\n    tabIndex: !disabled && tabIndex || -1\n  }, rest), children);\n}\nListBoxField.propTypes = {\n  /**\n   * Typically set by `getToggleButtonProps`, this should specify whether the\n   * field has a popup.\n   */\n  'aria-haspopup': prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).bool]),\n  /**\n   * Provide the contents of your ListBoxField\n   */\n  children: (prop_types_default()).node,\n  /**\n   * Specify if the parent <ListBox> is disabled\n   */\n  disabled: (prop_types_default()).bool,\n  /**\n   * The role for the component, should be set by `getToggleButtonProps` coming\n   * from Downshift\n   */\n  role: (prop_types_default()).string,\n  /**\n   * Optional prop to specify the tabIndex of the <ListBox> trigger button\n   */\n  tabIndex: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string])\n};\n\n;// ./node_modules/@carbon/react/es/components/ListBox/ListBoxMenuItem.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\n\n/**\n * Determines if the content of an element is truncated.\n *\n * Merges a forwarded ref with a local ref to check the element's dimensions.\n *\n * @template T\n * @param forwardedRef - A ref passed from the parent component.\n * @param deps - Dependencies to re-run the truncation check.\n * @returns An object containing the truncation state and the merged ref.\n */\nconst useIsTruncated = function (forwardedRef) {\n  let deps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const localRef = (0,react.useRef)(null);\n  const mergedRef = useMergedRefs([...(forwardedRef ? [forwardedRef] : []), localRef]);\n  const [isTruncated, setIsTruncated] = (0,react.useState)(false);\n  (0,react.useEffect)(() => {\n    const element = localRef.current;\n    if (element) {\n      const {\n        offsetWidth,\n        scrollWidth\n      } = element;\n      setIsTruncated(offsetWidth < scrollWidth);\n    }\n  }, [localRef, ...deps]);\n  return {\n    isTruncated,\n    ref: mergedRef\n  };\n};\n/**\n * `ListBoxMenuItem` is a helper component for managing the container class\n * name, alongside any classes for any corresponding states, for a generic list\n * box menu item.\n */\nconst ListBoxMenuItem = /*#__PURE__*/(0,react.forwardRef)((_ref, forwardedRef) => {\n  let {\n    children,\n    isActive = false,\n    isHighlighted = false,\n    title,\n    ...rest\n  } = _ref;\n  const prefix = usePrefix();\n  const menuItemOptionRefProp = forwardedRef && typeof forwardedRef !== 'function' ? forwardedRef.menuItemOptionRef : undefined;\n  const {\n    isTruncated,\n    ref: menuItemOptionRef\n  } = useIsTruncated(menuItemOptionRefProp, [children]);\n  const className = classnames_default()(`${prefix}--list-box__menu-item`, {\n    [`${prefix}--list-box__menu-item--active`]: isActive,\n    [`${prefix}--list-box__menu-item--highlighted`]: isHighlighted\n  });\n  return /*#__PURE__*/react.createElement(\"li\", _extends({}, rest, {\n    className: className,\n    title: isTruncated ? title : undefined\n  }), /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefix}--list-box__menu-item__option`,\n    ref: menuItemOptionRef\n  }, children));\n});\nListBoxMenuItem.displayName = 'ListBoxMenuItem';\nListBoxMenuItem.propTypes = {\n  /**\n   * Specify any children nodes that should be rendered inside of the ListBox\n   * Menu Item\n   */\n  children: (prop_types_default()).node,\n  /**\n   * Specify if the item should be disabled\n   */\n  disabled: (prop_types_default()).bool,\n  /**\n   * Specify whether the current menu item is \"active\".\n   */\n  isActive: (prop_types_default()).bool,\n  /**\n   * Specify whether the current menu item is \"highlighted\".\n   */\n  isHighlighted: (prop_types_default()).bool,\n  /**\n   * Provide an optional tooltip for the ListBoxMenuItem\n   */\n  title: (prop_types_default()).string\n};\n\n;// ./node_modules/@carbon/react/es/components/ListBox/ListBoxMenu.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\nconst frFn = react.forwardRef;\n\n/**\n * `ListBoxMenu` is a simple container node that isolates the `list-box__menu`\n * class into a single component. It is also being used to validate given\n * `children` components.\n */\nconst ListBoxMenu = frFn((_ref, ref) => {\n  let {\n    children,\n    id,\n    ...rest\n  } = _ref;\n  const prefix = usePrefix();\n  return /*#__PURE__*/react.createElement(\"ul\", _extends({\n    ref: ref,\n    id: id,\n    className: `${prefix}--list-box__menu`,\n    role: \"listbox\"\n  }, rest), children);\n});\nListBoxMenu.displayName = 'ListBoxMenu';\nListBoxMenu.propTypes = {\n  /**\n   * Provide the contents of your ListBoxMenu\n   */\n  children: prop_types_default().oneOfType([(prop_types_default()).node, prop_types_default().arrayOf(prop_types_default().oneOf([ListBoxMenuItem])),\n  /**\n   * allow single item using the workaround for functional components\n   * https://github.com/facebook/react/issues/2979#issuecomment-222379916\n   */\n  prop_types_default().shape({\n    type: prop_types_default().oneOf([ListBoxMenuItem])\n  }), (prop_types_default()).bool // used in Dropdown for closed state\n  ]),\n  /**\n   * Specify a custom `id`\n   */\n  id: (prop_types_default()).string.isRequired\n};\n\n;// ./node_modules/@carbon/react/es/components/ListBox/ListBoxMenuIcon.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\nconst defaultTranslations = {\n  'close.menu': 'Close menu',\n  'open.menu': 'Open menu'\n};\nconst defaultTranslateWithId = id => defaultTranslations[id];\n/**\n * `ListBoxMenuIcon` is used to orient the icon up or down depending on the\n * state of the menu for a given `ListBox`\n */\nconst ListBoxMenuIcon = _ref => {\n  let {\n    isOpen,\n    translateWithId: t = defaultTranslateWithId\n  } = _ref;\n  const prefix = usePrefix();\n  const className = classnames_default()(`${prefix}--list-box__menu-icon`, {\n    [`${prefix}--list-box__menu-icon--open`]: isOpen\n  });\n  const description = isOpen ? t('close.menu') : t('open.menu');\n  return /*#__PURE__*/react.createElement(\"div\", {\n    className: className\n  }, /*#__PURE__*/react.createElement(bucket_3/* ChevronDown */.yQ, {\n    name: \"chevron--down\",\n    \"aria-label\": description\n  }, /*#__PURE__*/react.createElement(\"title\", null, description)));\n};\nListBoxMenuIcon.propTypes = {\n  /**\n   * Specify whether the menu is currently open, which will influence the\n   * direction of the menu icon\n   */\n  isOpen: (prop_types_default()).bool.isRequired,\n  /**\n   * i18n hook used to provide the appropriate description for the given menu\n   * icon. This function takes a ListBoxMenuIconTranslationKey and should\n   * return a string message for that given message id.\n   */\n  translateWithId: (prop_types_default()).func\n};\n\n;// ./node_modules/@carbon/react/es/components/ListBox/ListBoxSelection.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\nvar _Close, _Close2;\nconst translationIds = {\n  'clear.all': 'clear.all',\n  'clear.selection': 'clear.selection'\n};\n\n/**\n * Message ids that will be passed to translateWithId().\n */\n\nconst ListBoxSelection_defaultTranslations = {\n  [translationIds['clear.all']]: 'Clear all selected items',\n  [translationIds['clear.selection']]: 'Clear selected item'\n};\nconst ListBoxSelection_defaultTranslateWithId = id => ListBoxSelection_defaultTranslations[id];\n\n/**\n * `ListBoxSelection` is used to provide controls for clearing a selection, in\n * addition to conditionally rendering a badge if the control has more than one\n * selection.\n */\nconst ListBoxSelection = _ref => {\n  let {\n    clearSelection,\n    selectionCount,\n    translateWithId: t = ListBoxSelection_defaultTranslateWithId,\n    disabled,\n    onClearSelection,\n    readOnly\n  } = _ref;\n  const prefix = usePrefix();\n  const className = classnames_default()(`${prefix}--list-box__selection`, {\n    [`${prefix}--tag--filter`]: selectionCount,\n    [`${prefix}--list-box__selection--multi`]: selectionCount\n  });\n  const handleOnClick = event => {\n    event.stopPropagation();\n    if (disabled || readOnly) {\n      return;\n    }\n    clearSelection(event);\n    if (onClearSelection) {\n      onClearSelection(event);\n    }\n  };\n  const description = selectionCount ? t('clear.all') : t('clear.selection');\n  const tagClasses = classnames_default()(`${prefix}--tag`, `${prefix}--tag--filter`, `${prefix}--tag--high-contrast`, {\n    [`${prefix}--tag--disabled`]: disabled\n  });\n\n  /* eslint-disable jsx-a11y/click-events-have-key-events */\n  return selectionCount ? /*#__PURE__*/react.createElement(\"div\", {\n    className: tagClasses\n  }, /*#__PURE__*/react.createElement(\"span\", {\n    className: `${prefix}--tag__label`,\n    title: `${selectionCount}`\n  }, selectionCount), /*#__PURE__*/react.createElement(\"div\", {\n    role: \"button\",\n    tabIndex: -1,\n    className: `${prefix}--tag__close-icon`,\n    onClick: handleOnClick,\n    \"aria-label\": t('clear.all'),\n    title: description,\n    \"aria-disabled\": readOnly ? true : undefined\n  }, _Close || (_Close = /*#__PURE__*/react.createElement(bucket_3/* Close */.bm, null)))) : /*#__PURE__*/react.createElement(\"div\", {\n    role: \"button\",\n    className: className,\n    tabIndex: -1,\n    onClick: handleOnClick,\n    \"aria-label\": description,\n    title: description\n  }, selectionCount, _Close2 || (_Close2 = /*#__PURE__*/react.createElement(bucket_3/* Close */.bm, null)));\n};\nListBoxSelection.propTypes = {\n  /**\n   * Specify a function to be invoked when a user interacts with the clear\n   * selection element.\n   */\n  clearSelection: (prop_types_default()).func.isRequired,\n  /**\n   * Specify whether or not the clear selection element should be disabled\n   */\n  disabled: (prop_types_default()).bool,\n  /**\n   * Specify an optional `onClearSelection` handler that is called when the underlying\n   * element is cleared\n   */\n  onClearSelection: (prop_types_default()).func,\n  /**\n   * Whether or not the Dropdown is readonly\n   */\n  readOnly: (prop_types_default()).bool,\n  /**\n   * Specify an optional `selectionCount` value that will be used to determine\n   * whether the selection should display a badge or a single clear icon.\n   */\n  selectionCount: (prop_types_default()).number,\n  /**\n   * i18n hook used to provide the appropriate description for the given menu\n   * icon. This function takes in an id defined in `translationIds` and should\n   * return a string message for that given message id.\n   */\n  translateWithId: (prop_types_default()).func\n};\n\n;// ./node_modules/@carbon/react/es/components/ListBox/index.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\n\nconst ListBox_ListBox = Object.assign(ListBox, {\n  Field: ListBoxField,\n  Menu: ListBoxMenu,\n  MenuIcon: ListBoxMenuIcon,\n  MenuItem: ListBoxMenuItem,\n  Selection: ListBoxSelection\n});\n\n;// ./node_modules/@carbon/react/es/tools/mergeRefs.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * @param {...Ref<Element>} refs List of React refs to merge.\n * @returns {Ref<Element>} Merged React ref.\n */\nconst mergeRefs = function () {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n  return el => {\n    refs.forEach(ref => {\n      // https://github.com/facebook/react/issues/13029#issuecomment-410002316\n      if (typeof ref === 'function') {\n        ref(el);\n      } else if (Object(ref) === ref) {\n        ref.current = el;\n      }\n    });\n  };\n};\nvar mergeRefs$1 = mergeRefs;\n\n;// ./node_modules/@carbon/react/es/components/Dropdown/Dropdown.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst {\n  ItemMouseMove,\n  MenuMouseLeave\n} = downshift_esm/* useSelect */.WM.stateChangeTypes;\nconst defaultItemToString = item => {\n  if (typeof item === 'string') {\n    return item;\n  }\n  if (typeof item === 'number') {\n    return `${item}`;\n  }\n  if (item !== null && typeof item === 'object' && 'label' in item && typeof item['label'] === 'string') {\n    return item['label'];\n  }\n  return '';\n};\n/**\n * Custom state reducer for `useSelect` in Downshift, providing control over\n * state changes.\n *\n * This function is called each time `useSelect` updates its internal state or\n * triggers `onStateChange`. It allows for fine-grained control of state\n * updates by modifying or overriding the default changes from Downshift's\n * reducer.\n * https://github.com/downshift-js/downshift/tree/master/src/hooks/useSelect#statereducer\n *\n * @param {Object} state - The current full state of the Downshift component.\n * @param {Object} actionAndChanges - Contains the action type and proposed\n * changes from the default Downshift reducer.\n * @param {Object} actionAndChanges.changes - Suggested state changes.\n * @param {string} actionAndChanges.type - The action type for the state\n * change (e.g., item selection).\n * @returns {Object} - The modified state based on custom logic or default\n * changes if no custom logic applies.\n */\nfunction stateReducer(state, actionAndChanges) {\n  const {\n    changes,\n    type\n  } = actionAndChanges;\n  switch (type) {\n    case ItemMouseMove:\n    case MenuMouseLeave:\n      if (changes.highlightedIndex === state.highlightedIndex) {\n        // Prevent state update if highlightedIndex hasn't changed\n        return state;\n      }\n      return changes;\n    default:\n      return changes;\n  }\n}\nconst Dropdown = /*#__PURE__*/react.forwardRef((_ref, ref) => {\n  let {\n    autoAlign = false,\n    className: containerClassName,\n    decorator,\n    disabled = false,\n    direction = 'bottom',\n    items: itemsProp,\n    label,\n    ['aria-label']: ariaLabel,\n    ariaLabel: deprecatedAriaLabel,\n    itemToString = defaultItemToString,\n    itemToElement = null,\n    renderSelectedItem,\n    type = 'default',\n    size: size$1,\n    onChange,\n    id,\n    titleText = '',\n    hideLabel,\n    helperText = '',\n    translateWithId,\n    light,\n    invalid,\n    invalidText,\n    warn,\n    warnText,\n    initialSelectedItem,\n    selectedItem: controlledSelectedItem,\n    downshiftProps,\n    readOnly,\n    slug,\n    ...other\n  } = _ref;\n  const enableFloatingStyles = useFeatureFlag('enable-v12-dynamic-floating-styles');\n  const {\n    refs,\n    floatingStyles,\n    middlewareData\n  } = (0,floating_ui_react/* useFloating */.we)(enableFloatingStyles || autoAlign ? {\n    placement: direction,\n    // The floating element is positioned relative to its nearest\n    // containing block (usually the viewport). It will in many cases also\n    // “break” the floating element out of a clipping ancestor.\n    // https://floating-ui.com/docs/misc#clipping\n    strategy: 'fixed',\n    // Middleware order matters, arrow should be last\n    middleware: [(0,floating_ui_react_dom/* size */.Ej)({\n      apply(_ref2) {\n        let {\n          rects,\n          elements\n        } = _ref2;\n        Object.assign(elements.floating.style, {\n          width: `${rects.reference.width}px`\n        });\n      }\n    }), autoAlign && (0,floating_ui_react_dom/* flip */.UU)(), autoAlign && (0,floating_ui_react_dom/* hide */.jD)()],\n    whileElementsMounted: floating_ui_dom/* autoUpdate */.ll\n  } : {}\n  // When autoAlign is turned off & the `enable-v12-dynamic-floating-styles` feature flag is not\n  // enabled, floating-ui will not be used\n  );\n  (0,react.useEffect)(() => {\n    if (enableFloatingStyles || autoAlign) {\n      const updatedFloatingStyles = {\n        ...floatingStyles,\n        visibility: middlewareData.hide?.referenceHidden ? 'hidden' : 'visible'\n      };\n      Object.keys(updatedFloatingStyles).forEach(style => {\n        if (refs.floating.current) {\n          refs.floating.current.style[style] = updatedFloatingStyles[style];\n        }\n      });\n    }\n  }, [floatingStyles, autoAlign, refs.floating]);\n  const prefix = usePrefix();\n  const {\n    isFluid\n  } = (0,react.useContext)(FormContext);\n  const onSelectedItemChange = (0,react.useCallback)(_ref3 => {\n    let {\n      selectedItem\n    } = _ref3;\n    if (onChange) {\n      onChange({\n        selectedItem: selectedItem ?? null\n      });\n    }\n  }, [onChange]);\n  const isItemDisabled = (0,react.useCallback)((item, _index) => {\n    const isObject = item !== null && typeof item === 'object';\n    return isObject && 'disabled' in item && item.disabled === true;\n  }, []);\n  const onHighlightedIndexChange = (0,react.useCallback)(changes => {\n    const {\n      highlightedIndex\n    } = changes;\n    if (highlightedIndex !== undefined && highlightedIndex > -1 && typeof window !== undefined) {\n      const itemArray = document.querySelectorAll(`li.${prefix}--list-box__menu-item[role=\"option\"]`);\n      const highlightedItem = itemArray[highlightedIndex];\n      if (highlightedItem) {\n        highlightedItem.scrollIntoView({\n          behavior: 'smooth',\n          block: 'nearest'\n        });\n      }\n    }\n  }, [prefix]);\n  const items = (0,react.useMemo)(() => itemsProp, [itemsProp]);\n  const selectProps = (0,react.useMemo)(() => ({\n    items,\n    itemToString,\n    initialSelectedItem,\n    onSelectedItemChange,\n    stateReducer,\n    isItemDisabled,\n    onHighlightedIndexChange,\n    ...downshiftProps\n  }), [items, itemToString, initialSelectedItem, onSelectedItemChange, stateReducer, isItemDisabled, onHighlightedIndexChange, downshiftProps]);\n  const dropdownInstanceId = useId();\n\n  // only set selectedItem if the prop is defined. Setting if it is undefined\n  // will overwrite default selected items from useSelect\n  if (controlledSelectedItem !== undefined) {\n    selectProps.selectedItem = controlledSelectedItem;\n  }\n  const {\n    isOpen,\n    getToggleButtonProps,\n    getLabelProps,\n    getMenuProps,\n    getItemProps,\n    selectedItem,\n    highlightedIndex\n  } = (0,downshift_esm/* useSelect */.WM)(selectProps);\n  const inline = type === 'inline';\n  const showWarning = !invalid && warn;\n  const [isFocused, setIsFocused] = (0,react.useState)(false);\n  const className = classnames_default()(`${prefix}--dropdown`, {\n    [`${prefix}--dropdown--invalid`]: invalid,\n    [`${prefix}--dropdown--warning`]: showWarning,\n    [`${prefix}--dropdown--open`]: isOpen,\n    [`${prefix}--dropdown--focus`]: isFocused,\n    [`${prefix}--dropdown--inline`]: inline,\n    [`${prefix}--dropdown--disabled`]: disabled,\n    [`${prefix}--dropdown--light`]: light,\n    [`${prefix}--dropdown--readonly`]: readOnly,\n    [`${prefix}--dropdown--${size$1}`]: size$1,\n    [`${prefix}--list-box--up`]: direction === 'top',\n    [`${prefix}--autoalign`]: autoAlign\n  });\n  const titleClasses = classnames_default()(`${prefix}--label`, {\n    [`${prefix}--label--disabled`]: disabled,\n    [`${prefix}--visually-hidden`]: hideLabel\n  });\n  const helperClasses = classnames_default()(`${prefix}--form__helper-text`, {\n    [`${prefix}--form__helper-text--disabled`]: disabled\n  });\n  const wrapperClasses = classnames_default()(`${prefix}--dropdown__wrapper`, `${prefix}--list-box__wrapper`, containerClassName, {\n    [`${prefix}--dropdown__wrapper--inline`]: inline,\n    [`${prefix}--list-box__wrapper--inline`]: inline,\n    [`${prefix}--dropdown__wrapper--inline--invalid`]: inline && invalid,\n    [`${prefix}--list-box__wrapper--inline--invalid`]: inline && invalid,\n    [`${prefix}--list-box__wrapper--fluid--invalid`]: isFluid && invalid,\n    [`${prefix}--list-box__wrapper--slug`]: slug,\n    [`${prefix}--list-box__wrapper--decorator`]: decorator\n  });\n  const helperId = !helperText ? undefined : `dropdown-helper-text-${dropdownInstanceId}`;\n\n  // needs to be Capitalized for react to render it correctly\n  const ItemToElement = itemToElement;\n  const toggleButtonProps = getToggleButtonProps({\n    'aria-label': ariaLabel || deprecatedAriaLabel\n  });\n  const helper = helperText && !isFluid ? /*#__PURE__*/react.createElement(\"div\", {\n    id: helperId,\n    className: helperClasses\n  }, helperText) : null;\n  const handleFocus = evt => {\n    setIsFocused(evt.type === 'focus' && !selectedItem ? true : false);\n  };\n  const mergedRef = mergeRefs$1(toggleButtonProps.ref, ref);\n  const [currTimer, setCurrTimer] = (0,react.useState)();\n  const [isTyping, setIsTyping] = (0,react.useState)(false);\n  const onKeyDownHandler = (0,react.useCallback)(evt => {\n    if (evt.code !== 'Space' || !['ArrowDown', 'ArrowUp', ' ', 'Enter'].includes(evt.key)) {\n      setIsTyping(true);\n    }\n    if (isTyping && evt.code === 'Space' || !['ArrowDown', 'ArrowUp', ' ', 'Enter'].includes(evt.key)) {\n      if (currTimer) {\n        clearTimeout(currTimer);\n      }\n      setCurrTimer(setTimeout(() => {\n        setIsTyping(false);\n      }, 3000));\n    }\n    if (['ArrowDown'].includes(evt.key)) {\n      setIsFocused(false);\n    }\n    if (['Enter'].includes(evt.key) && !selectedItem && !isOpen) {\n      setIsFocused(true);\n    }\n\n    // For Dropdowns the arrow up key is only allowed if the Dropdown is open\n    if (toggleButtonProps.onKeyDown && (evt.key !== 'ArrowUp' || isOpen && evt.key === 'ArrowUp')) {\n      toggleButtonProps.onKeyDown(evt);\n    }\n  }, [isTyping, currTimer, toggleButtonProps]);\n  const readOnlyEventHandlers = (0,react.useMemo)(() => {\n    if (readOnly) {\n      return {\n        onClick: evt => {\n          // NOTE: does not prevent click\n          evt.preventDefault();\n          // focus on the element as per readonly input behavior\n          mergedRef?.current?.focus();\n        },\n        onKeyDown: evt => {\n          const selectAccessKeys = ['ArrowDown', 'ArrowUp', ' ', 'Enter'];\n          // This prevents the select from opening for the above keys\n          if (selectAccessKeys.includes(evt.key)) {\n            evt.preventDefault();\n          }\n        }\n      };\n    } else {\n      return {\n        onKeyDown: onKeyDownHandler\n      };\n    }\n  }, [readOnly, onKeyDownHandler]);\n  const menuProps = (0,react.useMemo)(() => getMenuProps({\n    ref: enableFloatingStyles || autoAlign ? refs.setFloating : null\n  }), [autoAlign, getMenuProps, refs.setFloating, enableFloatingStyles]);\n\n  // AILabel is always size `mini`\n  const normalizedDecorator = (0,react.useMemo)(() => {\n    let element = slug ?? decorator;\n    if (element && element['type']?.displayName === 'AILabel') {\n      return /*#__PURE__*/react.cloneElement(element, {\n        size: 'mini'\n      });\n    }\n    return /*#__PURE__*/ /*#__PURE__*/react.isValidElement(element) ? element : null;\n  }, [slug, decorator]);\n  const allLabelProps = getLabelProps();\n  const labelProps = /*#__PURE__*/ /*#__PURE__*/(0,react.isValidElement)(titleText) ? {\n    id: allLabelProps.id\n  } : allLabelProps;\n  return /*#__PURE__*/react.createElement(\"div\", _extends({\n    className: wrapperClasses\n  }, other), titleText && /*#__PURE__*/react.createElement(\"label\", _extends({\n    className: titleClasses\n  }, labelProps), titleText), /*#__PURE__*/react.createElement(ListBox_ListBox, {\n    onFocus: handleFocus,\n    onBlur: handleFocus,\n    size: size$1,\n    className: className,\n    invalid: invalid,\n    invalidText: invalidText,\n    warn: warn,\n    warnText: warnText,\n    light: light,\n    isOpen: isOpen,\n    ref: enableFloatingStyles || autoAlign ? refs.setReference : null,\n    id: id\n  }, invalid && /*#__PURE__*/react.createElement(bucket_18/* WarningFilled */.BF, {\n    className: `${prefix}--list-box__invalid-icon`\n  }), showWarning && /*#__PURE__*/react.createElement(bucket_18/* WarningAltFilled */.OR, {\n    className: `${prefix}--list-box__invalid-icon ${prefix}--list-box__invalid-icon--warning`\n  }), /*#__PURE__*/react.createElement(\"button\", _extends({\n    type: \"button\"\n    // aria-expanded is already being passed through {...toggleButtonProps}\n    ,\n\n    className: `${prefix}--list-box__field`,\n    disabled: disabled,\n    \"aria-disabled\": readOnly ? true : undefined // aria-disabled to remain focusable\n    ,\n\n    \"aria-describedby\": !inline && !invalid && !warn && helper ? helperId : undefined,\n    title: selectedItem && itemToString !== undefined ? itemToString(selectedItem) : defaultItemToString(label)\n  }, toggleButtonProps, readOnlyEventHandlers, {\n    ref: mergedRef\n  }), /*#__PURE__*/react.createElement(\"span\", {\n    className: `${prefix}--list-box__label`\n  }, selectedItem ? renderSelectedItem ? renderSelectedItem(selectedItem) : itemToString(selectedItem) : label), /*#__PURE__*/react.createElement(ListBox_ListBox.MenuIcon, {\n    isOpen: isOpen,\n    translateWithId: translateWithId\n  })), slug ? normalizedDecorator : decorator ? /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefix}--list-box__inner-wrapper--decorator`\n  }, normalizedDecorator) : '', /*#__PURE__*/react.createElement(ListBox_ListBox.Menu, menuProps, isOpen && items.map((item, index) => {\n    const isObject = item !== null && typeof item === 'object';\n    const itemProps = getItemProps({\n      item,\n      index\n    });\n    const title = isObject && 'text' in item && itemToElement ? item.text : itemToString(item);\n    return /*#__PURE__*/react.createElement(ListBox_ListBox.MenuItem, _extends({\n      key: itemProps.id,\n      isActive: selectedItem === item,\n      isHighlighted: highlightedIndex === index,\n      title: title,\n      disabled: itemProps['aria-disabled']\n    }, itemProps), typeof item === 'object' && ItemToElement !== undefined && ItemToElement !== null ? /*#__PURE__*/react.createElement(ItemToElement, _extends({\n      key: itemProps.id\n    }, item)) : itemToString(item), selectedItem === item && /*#__PURE__*/react.createElement(bucket_3/* Checkmark */.MG, {\n      className: `${prefix}--list-box__menu-item__selected-icon`\n    }));\n  }))), !inline && !invalid && !warn && helper);\n});\n\n// Workaround problems with forwardRef() and generics.  In the long term, should stop using forwardRef().\n// See https://stackoverflow.com/questions/58469229/react-with-typescript-generics-while-using-react-forwardref.\n\nDropdown.displayName = 'Dropdown';\nDropdown.propTypes = {\n  /**\n   * 'aria-label' of the ListBox component.\n   * Specify a label to be read by screen readers on the container node\n   */\n  ['aria-label']: (prop_types_default()).string,\n  /**\n   * Deprecated, please use `aria-label` instead.\n   * Specify a label to be read by screen readers on the container note.\n   */\n  ariaLabel: deprecate((prop_types_default()).string, 'This prop syntax has been deprecated. Please use the new `aria-label`.'),\n  /**\n   * **Experimental**: Will attempt to automatically align the floating element to avoid collisions with the viewport and being clipped by ancestor elements.\n   */\n  autoAlign: (prop_types_default()).bool,\n  /**\n   * Provide a custom className to be applied on the cds--dropdown node\n   */\n  className: (prop_types_default()).string,\n  /**\n   * **Experimental**: Provide a `decorator` component to be rendered inside the `Dropdown` component\n   */\n  decorator: (prop_types_default()).node,\n  /**\n   * Specify the direction of the dropdown. Can be either top or bottom.\n   */\n  direction: prop_types_default().oneOf(['top', 'bottom']),\n  /**\n   * Disable the control\n   */\n  disabled: (prop_types_default()).bool,\n  /**\n   * Additional props passed to Downshift.\n   *\n   * **Use with caution:** anything you define here overrides the components'\n   * internal handling of that prop. Downshift APIs and internals are subject to\n   * change, and in some cases they can not be shimmed by Carbon to shield you\n   * from potentially breaking changes.\n   */\n  downshiftProps: (prop_types_default()).object,\n  /**\n   * Provide helper text that is used alongside the control label for\n   * additional help\n   */\n  helperText: (prop_types_default()).node,\n  /**\n   * Specify whether the title text should be hidden or not\n   */\n  hideLabel: (prop_types_default()).bool,\n  /**\n   * Specify a custom `id`\n   */\n  id: (prop_types_default()).string.isRequired,\n  /**\n   * Allow users to pass in an arbitrary item or a string (in case their items are an array of strings)\n   * from their collection that are pre-selected\n   */\n  initialSelectedItem: prop_types_default().oneOfType([(prop_types_default()).object, (prop_types_default()).string, (prop_types_default()).number]),\n  /**\n   * Specify if the currently selected value is invalid.\n   */\n  invalid: (prop_types_default()).bool,\n  /**\n   * Message which is displayed if the value is invalid.\n   */\n  invalidText: (prop_types_default()).node,\n  /**\n   * Function to render items as custom components instead of strings.\n   * Defaults to null and is overridden by a getter\n   */\n  itemToElement: (prop_types_default()).func,\n  /**\n   * Helper function passed to downshift that allows the library to render a\n   * given item to a string label. By default, it extracts the `label` field\n   * from a given item to serve as the item label in the list.\n   */\n  itemToString: (prop_types_default()).func,\n  /**\n   * We try to stay as generic as possible here to allow individuals to pass\n   * in a collection of whatever kind of data structure they prefer\n   */\n  items: (prop_types_default()).array.isRequired,\n  /**\n   * Generic `label` that will be used as the textual representation of what\n   * this field is for\n   */\n  label: (prop_types_default()).node.isRequired,\n  /**\n   * `true` to use the light version.\n   */\n  light: deprecate((prop_types_default()).bool, 'The `light` prop for `Dropdown` has ' + 'been deprecated in favor of the new `Layer` component. It will be removed in the next major release.'),\n  /**\n   * `onChange` is a utility for this controlled component to communicate to a\n   * consuming component what kind of internal state changes are occurring.\n   */\n  onChange: (prop_types_default()).func,\n  /**\n   * Whether or not the Dropdown is readonly\n   */\n  readOnly: (prop_types_default()).bool,\n  /**\n   * An optional callback to render the currently selected item as a react element instead of only\n   * as a string.\n   */\n  renderSelectedItem: (prop_types_default()).func,\n  /**\n   * In the case you want to control the dropdown selection entirely.\n   */\n  selectedItem: prop_types_default().oneOfType([(prop_types_default()).object, (prop_types_default()).string, (prop_types_default()).number]),\n  /**\n   * Specify the size of the ListBox. Currently supports either `sm`, `md` or `lg` as an option.\n   */\n  size: ListBoxSizePropType,\n  /**\n   * **Experimental**: Provide a `Slug` component to be rendered inside the `Dropdown` component\n   */\n  slug: deprecate((prop_types_default()).node, 'The `slug` prop for `Dropdown` has ' + 'been deprecated in favor of the new `decorator` prop. It will be removed in the next major release.'),\n  /**\n   * Provide the title text that will be read by a screen reader when\n   * visiting this control\n   */\n  titleText: (prop_types_default()).node.isRequired,\n  /**\n   * Callback function for translating ListBoxMenuIcon SVG title\n   */\n  translateWithId: (prop_types_default()).func,\n  /**\n   * The dropdown type, `default` or `inline`\n   */\n  type: ListBoxTypePropType,\n  /**\n   * Specify whether the control is currently in warning state\n   */\n  warn: (prop_types_default()).bool,\n  /**\n   * Provide the text that is displayed when the control is in warning state\n   */\n  warnText: (prop_types_default()).node\n};\n\n;// ./node_modules/@carbon/react/es/components/Loading/Loading.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\nfunction Loading(_ref) {\n  let {\n    active = true,\n    className: customClassName,\n    withOverlay = true,\n    small = false,\n    description = 'loading',\n    ...rest\n  } = _ref;\n  const prefix = usePrefix();\n  const loadingClassName = classnames_default()(customClassName, {\n    [`${prefix}--loading`]: true,\n    [`${prefix}--loading--small`]: small,\n    [`${prefix}--loading--stop`]: !active\n  });\n  const overlayClassName = classnames_default()({\n    [`${prefix}--loading-overlay`]: true,\n    [`${prefix}--loading-overlay--stop`]: !active\n  });\n  const loading = /*#__PURE__*/react.createElement(\"div\", _extends({}, rest, {\n    \"aria-atomic\": \"true\",\n    \"aria-live\": active ? 'assertive' : 'off',\n    className: loadingClassName\n  }), /*#__PURE__*/react.createElement(\"svg\", {\n    className: `${prefix}--loading__svg`,\n    viewBox: \"0 0 100 100\"\n  }, /*#__PURE__*/react.createElement(\"title\", null, description), small ? /*#__PURE__*/react.createElement(\"circle\", {\n    className: `${prefix}--loading__background`,\n    cx: \"50%\",\n    cy: \"50%\",\n    r: \"42\"\n  }) : null, /*#__PURE__*/react.createElement(\"circle\", {\n    className: `${prefix}--loading__stroke`,\n    cx: \"50%\",\n    cy: \"50%\",\n    r: small ? '42' : '44'\n  })));\n  return withOverlay ? /*#__PURE__*/react.createElement(\"div\", {\n    className: overlayClassName\n  }, loading) : loading;\n}\nLoading.propTypes = {\n  /**\n   * Specify whether you want the loading indicator to be spinning or not\n   */\n  active: (prop_types_default()).bool,\n  /**\n   * Provide an optional className to be applied to the containing node\n   */\n  className: (prop_types_default()).string,\n  /**\n   * Specify a description that would be used to best describe the loading state\n   */\n  description: (prop_types_default()).string,\n  /**\n   * Provide an `id` to uniquely identify the label\n   */\n  id: deprecate((prop_types_default()).string, `\\nThe prop \\`id\\` is no longer needed.`),\n  /**\n   * Specify whether you would like the small variant of <Loading>\n   */\n  small: (prop_types_default()).bool,\n  /**\n   * Specify whether you want the loader to be applied with an overlay\n   */\n  withOverlay: (prop_types_default()).bool\n};\n\n// EXTERNAL MODULE: ./node_modules/react-fast-compare/index.js\nvar react_fast_compare = __webpack_require__(7817);\nvar react_fast_compare_default = /*#__PURE__*/__webpack_require__.n(react_fast_compare);\n;// ./node_modules/@carbon/react/es/components/MultiSelect/MultiSelectPropTypes.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst sortingPropTypes = {\n  /**\n   * Provide a compare function that is used to determine the ordering of\n   * options. `compareItems` has the following function signature:\n   *\n   * compareFunction :\n   *  (itemA: string, itemB: string, { locale: string }) => number\n   */\n  compareItems: (prop_types_default()).func,\n  /**\n   * Provide a method that sorts all options in the control. Overriding this\n   * prop means that you also have to handle the sort logic for selected versus\n   * un-selected items. If you just want to control ordering, consider the\n   * `compareItems` prop instead.\n   *\n   * `sortItems` has the following signature:\n   *\n   * sortItems :\n   *   (items: Array<Item>, {\n   *     selectedItems: Array<Item>,\n   *     itemToString: Item => string,\n   *     compareItems: (itemA: string, itemB: string, {\n   *       locale: string\n   *     }) => number,\n   *     locale: string,\n   *   }) => Array<Item>\n   */\n  sortItems: (prop_types_default()).func\n};\n\n;// ./node_modules/@carbon/react/es/components/MultiSelect/tools/sorting.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * Use the locale `localeCompare` with the `numeric` option to sort two\n * alpha-numeric strings.\n *\n * @param {string} itemA - The first string to compare.\n * @param {string} itemB - The second string to compare.\n * @param {object} options - Options for comparing.\n * @param {string} options.locale - The locale to use for comparison.\n * @returns {number} A negative number if itemA comes before itemB, a positive\n *   number if itemA comes after itemB, or 0 if they are equal.\n */\nconst defaultCompareItems = (itemA, itemB, _ref) => {\n  let {\n    locale\n  } = _ref;\n  return itemA.localeCompare(itemB, locale, {\n    numeric: true\n  });\n};\n\n/**\n * Default sorting algorithm for options in a selection control\n */\nconst defaultSortItems = (items, _ref2) => {\n  let {\n    selectedItems = [],\n    itemToString,\n    compareItems,\n    locale = 'en'\n  } = _ref2;\n  return items.sort((itemA, itemB) => {\n    // Always place \"select all\" option at the beginning\n    if (itemA.isSelectAll) return -1;\n    if (itemB.isSelectAll) return 1;\n    const hasItemA = selectedItems.includes(itemA);\n    const hasItemB = selectedItems.includes(itemB);\n    if (hasItemA && !hasItemB) return -1;\n    if (hasItemB && !hasItemA) return 1;\n    return compareItems(itemToString(itemA), itemToString(itemB), {\n      locale\n    });\n  });\n};\n\n;// ./node_modules/@carbon/react/es/internal/Selection.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nconst callOnChangeHandler = _ref => {\n  let {\n    isControlled,\n    isMounted,\n    onChangeHandlerControlled,\n    onChangeHandlerUncontrolled,\n    selectedItems\n  } = _ref;\n  if (isControlled) {\n    if (isMounted && onChangeHandlerControlled) {\n      onChangeHandlerControlled({\n        selectedItems\n      });\n    }\n  } else {\n    onChangeHandlerUncontrolled(selectedItems);\n  }\n};\nconst useSelection = _ref2 => {\n  let {\n    disabled,\n    onChange,\n    initialSelectedItems = [],\n    selectedItems: controlledItems,\n    selectAll = false,\n    filteredItems = []\n  } = _ref2;\n  const isMounted = (0,react.useRef)(false);\n  const savedOnChange = (0,react.useRef)(onChange);\n  const [uncontrolledItems, setUncontrolledItems] = (0,react.useState)(initialSelectedItems);\n  const isControlled = !!controlledItems;\n  const selectedItems = isControlled ? controlledItems : uncontrolledItems;\n  const onItemChange = (0,react.useCallback)(item => {\n    if (disabled) return;\n\n    // Assert special properties (e.g., `disabled`, `isSelectAll`, etc.) are\n    // `any` since those properties aren’t part of the generic type.\n    const allSelectableItems = filteredItems.filter(item => !item?.disabled);\n    const disabledItemCount = filteredItems.filter(item => item?.disabled).length;\n    let newSelectedItems;\n\n    // deselect all on click to All/indeterminate option\n    if (item?.isSelectAll && selectedItems.length > 0) {\n      newSelectedItems = [];\n    }\n    // select all options\n    else if (item?.isSelectAll && selectedItems.length === 0) {\n      newSelectedItems = allSelectableItems;\n    } else {\n      const selectedIndex = selectedItems.findLastIndex(selectedItem => react_fast_compare_default()(selectedItem, item));\n      if (selectedIndex === -1) {\n        newSelectedItems = selectedItems.concat(item);\n        // checking if all items are selected then We should select mark the 'select All' option as well\n        if (selectAll && filteredItems.length - 1 === newSelectedItems.length + disabledItemCount) {\n          newSelectedItems = allSelectableItems;\n        }\n      } else {\n        newSelectedItems = removeAtIndex(selectedItems, selectedIndex);\n        newSelectedItems = newSelectedItems.filter(item => !item?.isSelectAll);\n      }\n    }\n    callOnChangeHandler({\n      isControlled,\n      isMounted: isMounted.current,\n      onChangeHandlerControlled: savedOnChange.current,\n      onChangeHandlerUncontrolled: setUncontrolledItems,\n      selectedItems: newSelectedItems\n    });\n  }, [disabled, selectedItems, filteredItems, selectAll, isControlled]);\n  const clearSelection = (0,react.useCallback)(() => {\n    if (disabled) return;\n    callOnChangeHandler({\n      isControlled,\n      isMounted: isMounted.current,\n      onChangeHandlerControlled: savedOnChange.current,\n      onChangeHandlerUncontrolled: setUncontrolledItems,\n      selectedItems: []\n    });\n  }, [disabled, isControlled]);\n  (0,react.useEffect)(() => {\n    savedOnChange.current = onChange;\n  }, [onChange]);\n  (0,react.useEffect)(() => {\n    if (isMounted.current && savedOnChange.current && !isControlled) {\n      savedOnChange.current({\n        selectedItems\n      });\n    }\n  }, [isControlled, selectedItems]);\n  (0,react.useEffect)(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n  return {\n    clearSelection,\n    onItemChange,\n    selectedItems\n  };\n};\n\n/**\n * Generic utility for safely removing an element at a given index from an\n * array.\n */\nconst removeAtIndex = (array, index) => {\n  const result = array.slice();\n  result.splice(index, 1);\n  return result;\n};\n\n;// ./node_modules/@carbon/react/es/components/MultiSelect/MultiSelect.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst {\n  ItemClick,\n  ToggleButtonBlur,\n  ToggleButtonKeyDownArrowDown,\n  ToggleButtonKeyDownArrowUp,\n  ToggleButtonKeyDownEnter,\n  ToggleButtonKeyDownEscape,\n  ToggleButtonKeyDownSpaceButton,\n  ItemMouseMove: MultiSelect_ItemMouseMove,\n  MenuMouseLeave: MultiSelect_MenuMouseLeave,\n  ToggleButtonClick,\n  ToggleButtonKeyDownPageDown,\n  ToggleButtonKeyDownPageUp,\n  FunctionSetHighlightedIndex\n} = downshift_esm/* useSelect */.WM.stateChangeTypes;\nconst MultiSelect_defaultItemToString = item => {\n  if (typeof item === 'string') {\n    return item;\n  }\n  if (typeof item === 'number') {\n    return `${item}`;\n  }\n  if (item !== null && typeof item === 'object' && 'label' in item && typeof item['label'] === 'string') {\n    return item['label'];\n  }\n  return '';\n};\nconst MultiSelect = /*#__PURE__*/react.forwardRef((_ref, ref) => {\n  let {\n    autoAlign = false,\n    className: containerClassName,\n    decorator,\n    id,\n    items,\n    itemToElement,\n    itemToString = MultiSelect_defaultItemToString,\n    titleText = false,\n    hideLabel,\n    helperText,\n    label,\n    type = 'default',\n    size: size$1,\n    disabled = false,\n    initialSelectedItems = [],\n    sortItems = defaultSortItems,\n    compareItems = defaultCompareItems,\n    clearSelectionText = 'To clear selection, press Delete or Backspace',\n    clearAnnouncement = 'all items have been cleared',\n    clearSelectionDescription = 'Total items selected: ',\n    light,\n    invalid,\n    invalidText,\n    warn,\n    warnText,\n    useTitleInItem,\n    translateWithId,\n    downshiftProps,\n    open = false,\n    selectionFeedback = 'top-after-reopen',\n    onChange,\n    onMenuChange,\n    direction = 'bottom',\n    selectedItems: selected,\n    readOnly,\n    locale = 'en',\n    slug\n  } = _ref;\n  const filteredItems = (0,react.useMemo)(() => {\n    return items.filter(item => {\n      if (typeof item === 'object' && item !== null) {\n        for (const key in item) {\n          if (Object.hasOwn(item, key) && item[key] === undefined) {\n            return false; // Return false if any property has an undefined value\n          }\n        }\n      }\n      return true; // Return true if item is not an object with undefined values\n    });\n  }, [items]);\n  let selectAll = filteredItems.some(item => item.isSelectAll);\n  if ((selected ?? []).length > 0 && selectAll) {\n    console.warn('Warning: `selectAll` should not be used when `selectedItems` is provided. Please pass either `selectAll` or `selectedItems`, not both.');\n    selectAll = false;\n  }\n  const prefix = usePrefix();\n  const {\n    isFluid\n  } = (0,react.useContext)(FormContext);\n  const multiSelectInstanceId = useId();\n  const [isFocused, setIsFocused] = (0,react.useState)(false);\n  const [inputFocused, setInputFocused] = (0,react.useState)(false);\n  const [isOpen, setIsOpen] = (0,react.useState)(open || false);\n  const [prevOpenProp, setPrevOpenProp] = (0,react.useState)(open);\n  const [topItems, setTopItems] = (0,react.useState)([]);\n  const [itemsCleared, setItemsCleared] = (0,react.useState)(false);\n  const enableFloatingStyles = useFeatureFlag('enable-v12-dynamic-floating-styles') || autoAlign;\n  const {\n    refs,\n    floatingStyles,\n    middlewareData\n  } = (0,floating_ui_react/* useFloating */.we)(enableFloatingStyles ? {\n    placement: direction,\n    // The floating element is positioned relative to its nearest\n    // containing block (usually the viewport). It will in many cases also\n    // “break” the floating element out of a clipping ancestor.\n    // https://floating-ui.com/docs/misc#clipping\n    strategy: 'fixed',\n    // Middleware order matters, arrow should be last\n    middleware: [autoAlign && (0,floating_ui_react_dom/* flip */.UU)({\n      crossAxis: false\n    }), (0,floating_ui_react_dom/* size */.Ej)({\n      apply(_ref2) {\n        let {\n          rects,\n          elements\n        } = _ref2;\n        Object.assign(elements.floating.style, {\n          width: `${rects.reference.width}px`\n        });\n      }\n    }), autoAlign && (0,floating_ui_react_dom/* hide */.jD)()],\n    whileElementsMounted: floating_ui_dom/* autoUpdate */.ll\n  } : {});\n  (0,react.useLayoutEffect)(() => {\n    if (enableFloatingStyles) {\n      const updatedFloatingStyles = {\n        ...floatingStyles,\n        visibility: middlewareData.hide?.referenceHidden ? 'hidden' : 'visible'\n      };\n      Object.keys(updatedFloatingStyles).forEach(style => {\n        if (refs.floating.current) {\n          refs.floating.current.style[style] = updatedFloatingStyles[style];\n        }\n      });\n    }\n  }, [enableFloatingStyles, floatingStyles, refs.floating, middlewareData, open]);\n  const {\n    selectedItems: controlledSelectedItems,\n    onItemChange,\n    clearSelection\n  } = useSelection({\n    disabled,\n    initialSelectedItems,\n    onChange,\n    selectedItems: selected,\n    selectAll,\n    filteredItems\n  });\n  const sortOptions = {\n    selectedItems: controlledSelectedItems,\n    itemToString,\n    compareItems,\n    locale\n  };\n  const selectProps = {\n    stateReducer,\n    isOpen,\n    itemToString: filteredItems => {\n      return Array.isArray(filteredItems) && filteredItems.map(function (item) {\n        return itemToString(item);\n      }).join(', ') || '';\n    },\n    selectedItem: controlledSelectedItems,\n    items: filteredItems,\n    isItemDisabled(item, _index) {\n      return item?.disabled;\n    },\n    ...downshiftProps\n  };\n  const {\n    getToggleButtonProps,\n    getLabelProps,\n    getMenuProps,\n    getItemProps,\n    selectedItem,\n    highlightedIndex,\n    setHighlightedIndex\n  } = (0,downshift_esm/* useSelect */.WM)(selectProps);\n  const toggleButtonProps = getToggleButtonProps({\n    onFocus: () => {\n      setInputFocused(true);\n    },\n    onBlur: () => {\n      setInputFocused(false);\n    },\n    onKeyDown: e => {\n      if (!disabled) {\n        if ((match_match(e, Delete) || match_match(e, Escape)) && !isOpen) {\n          clearSelection();\n          e.stopPropagation();\n        }\n        if (!isOpen && match_match(e, Delete) && selectedItems.length > 0) {\n          setItemsCleared(true);\n        }\n        if ((match_match(e, Space) || match_match(e, ArrowDown) || match_match(e, Enter)) && !isOpen) {\n          setHighlightedIndex(0);\n          setItemsCleared(false);\n          setIsOpenWrapper(true);\n        }\n        if (match_match(e, ArrowDown) && selectedItems.length === 0) {\n          setInputFocused(false);\n          setIsFocused(false);\n        }\n        if (match_match(e, Escape) && isOpen) {\n          setInputFocused(true);\n        }\n        if (match_match(e, Enter) && isOpen) {\n          setInputFocused(true);\n        }\n      }\n    }\n  });\n  const mergedRef = mergeRefs$1(toggleButtonProps.ref, ref);\n  const selectedItems = selectedItem;\n\n  /**\n   * wrapper function to forward changes to consumer\n   */\n  const setIsOpenWrapper = open => {\n    setIsOpen(open);\n    if (onMenuChange) {\n      onMenuChange(open);\n    }\n  };\n\n  /**\n   * programmatically control this `open` prop\n   */\n  if (prevOpenProp !== open) {\n    setIsOpenWrapper(open);\n    setPrevOpenProp(open);\n  }\n  const inline = type === 'inline';\n  const showWarning = !invalid && warn;\n  const wrapperClasses = classnames_default()(`${prefix}--multi-select__wrapper`, `${prefix}--list-box__wrapper`, containerClassName, {\n    [`${prefix}--multi-select__wrapper--inline`]: inline,\n    [`${prefix}--list-box__wrapper--inline`]: inline,\n    [`${prefix}--multi-select__wrapper--inline--invalid`]: inline && invalid,\n    [`${prefix}--list-box__wrapper--inline--invalid`]: inline && invalid,\n    [`${prefix}--list-box__wrapper--fluid--invalid`]: isFluid && invalid,\n    [`${prefix}--list-box__wrapper--slug`]: slug,\n    [`${prefix}--list-box__wrapper--decorator`]: decorator\n  });\n  const titleClasses = classnames_default()(`${prefix}--label`, {\n    [`${prefix}--label--disabled`]: disabled,\n    [`${prefix}--visually-hidden`]: hideLabel\n  });\n  const helperId = !helperText ? undefined : `multiselect-helper-text-${multiSelectInstanceId}`;\n  const fieldLabelId = `multiselect-field-label-${multiSelectInstanceId}`;\n  const helperClasses = classnames_default()(`${prefix}--form__helper-text`, {\n    [`${prefix}--form__helper-text--disabled`]: disabled\n  });\n  const className = classnames_default()(`${prefix}--multi-select`, {\n    [`${prefix}--multi-select--invalid`]: invalid,\n    [`${prefix}--multi-select--invalid--focused`]: invalid && inputFocused,\n    [`${prefix}--multi-select--warning`]: showWarning,\n    [`${prefix}--multi-select--inline`]: inline,\n    [`${prefix}--multi-select--selected`]: selectedItems && selectedItems.length > 0,\n    [`${prefix}--list-box--up`]: direction === 'top',\n    [`${prefix}--multi-select--readonly`]: readOnly,\n    [`${prefix}--autoalign`]: enableFloatingStyles,\n    [`${prefix}--multi-select--selectall`]: selectAll\n  });\n\n  // needs to be capitalized for react to render it correctly\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const ItemToElement = itemToElement;\n  if (selectionFeedback === 'fixed') {\n    sortOptions.selectedItems = [];\n  } else if (selectionFeedback === 'top-after-reopen') {\n    sortOptions.selectedItems = topItems;\n  }\n  function stateReducer(state, actionAndChanges) {\n    const {\n      changes,\n      props,\n      type\n    } = actionAndChanges;\n    const {\n      highlightedIndex\n    } = changes;\n    if (changes.isOpen && !isOpen) {\n      setTopItems(controlledSelectedItems);\n    }\n    switch (type) {\n      case ToggleButtonKeyDownSpaceButton:\n      case ToggleButtonKeyDownEnter:\n        if (changes.selectedItem === undefined) {\n          break;\n        }\n        if (Array.isArray(changes.selectedItem)) {\n          break;\n        }\n        onItemChange(changes.selectedItem);\n        return {\n          ...changes,\n          highlightedIndex: state.highlightedIndex\n        };\n      case ToggleButtonBlur:\n      case ToggleButtonKeyDownEscape:\n        setIsOpenWrapper(false);\n        break;\n      case ToggleButtonClick:\n        setIsOpenWrapper(changes.isOpen || false);\n        return {\n          ...changes,\n          highlightedIndex: controlledSelectedItems.length > 0 ? 0 : undefined\n        };\n      case ItemClick:\n        setHighlightedIndex(changes.selectedItem);\n        onItemChange(changes.selectedItem);\n        return {\n          ...changes,\n          highlightedIndex: state.highlightedIndex\n        };\n      case MultiSelect_MenuMouseLeave:\n        return {\n          ...changes,\n          highlightedIndex: state.highlightedIndex\n        };\n      case FunctionSetHighlightedIndex:\n        if (!isOpen) {\n          return {\n            ...changes,\n            highlightedIndex: 0\n          };\n        } else {\n          return {\n            ...changes,\n            highlightedIndex: filteredItems.indexOf(highlightedIndex)\n          };\n        }\n      case ToggleButtonKeyDownArrowDown:\n      case ToggleButtonKeyDownArrowUp:\n      case ToggleButtonKeyDownPageDown:\n      case ToggleButtonKeyDownPageUp:\n        if (highlightedIndex > -1) {\n          const itemArray = document.querySelectorAll(`li.${prefix}--list-box__menu-item[role=\"option\"]`);\n          props.scrollIntoView(itemArray[highlightedIndex]);\n        }\n        if (highlightedIndex === -1) {\n          return {\n            ...changes,\n            highlightedIndex: 0\n          };\n        }\n        return changes;\n      case MultiSelect_ItemMouseMove:\n        return {\n          ...changes,\n          highlightedIndex: state.highlightedIndex\n        };\n    }\n    return changes;\n  }\n  const multiSelectFieldWrapperClasses = classnames_default()(`${prefix}--list-box__field--wrapper`, {\n    [`${prefix}--list-box__field--wrapper--input-focused`]: inputFocused\n  });\n  const handleFocus = evt => {\n    evt.target.classList.contains(`${prefix}--tag__close-icon`) ? setIsFocused(false) : setIsFocused(evt.type === 'focus' ? true : false);\n  };\n  const readOnlyEventHandlers = readOnly ? {\n    onClick: evt => {\n      // NOTE: does not prevent click\n      evt.preventDefault();\n      // focus on the element as per readonly input behavior\n      if (mergedRef.current !== undefined) {\n        mergedRef.current.focus();\n      }\n    },\n    onKeyDown: evt => {\n      const selectAccessKeys = ['ArrowDown', 'ArrowUp', ' ', 'Enter'];\n      // This prevents the select from opening for the above keys\n      if (selectAccessKeys.includes(evt.key)) {\n        evt.preventDefault();\n      }\n    }\n  } : {};\n\n  // AILabel always size `mini`\n  let normalizedDecorator = /*#__PURE__*/ /*#__PURE__*/react.isValidElement(slug ?? decorator) ? slug ?? decorator : null;\n  if (normalizedDecorator && normalizedDecorator['type']?.displayName === 'AILabel') {\n    normalizedDecorator = /*#__PURE__*/react.cloneElement(normalizedDecorator, {\n      size: 'mini'\n    });\n  }\n  const itemsSelectedText = selectedItems.length > 0 && selectedItems.map(item => item?.text);\n  const selectedItemsLength = selectAll ? selectedItems.filter(item => !item.isSelectAll).length : selectedItems.length;\n\n  // Memoize the value of getMenuProps to avoid an infinite loop\n  const menuProps = (0,react.useMemo)(() => getMenuProps({\n    ref: enableFloatingStyles ? refs.setFloating : null\n  }), [enableFloatingStyles, getMenuProps, refs.setFloating]);\n  const allLabelProps = getLabelProps();\n  const labelProps = /*#__PURE__*/ /*#__PURE__*/(0,react.isValidElement)(titleText) ? {\n    id: allLabelProps.id\n  } : allLabelProps;\n  const getSelectionStats = (0,react.useCallback)((selectedItems, filteredItems) => {\n    const hasIndividualSelections = selectedItems.some(selected => !selected.isSelectAll);\n    const nonSelectAllSelectedCount = selectedItems.filter(selected => !selected.isSelectAll).length;\n    const totalSelectableCount = filteredItems.filter(item => !item.isSelectAll && !item.disabled).length;\n    return {\n      hasIndividualSelections,\n      nonSelectAllSelectedCount,\n      totalSelectableCount\n    };\n  }, [selectedItems, filteredItems]);\n  return /*#__PURE__*/react.createElement(\"div\", {\n    className: wrapperClasses\n  }, /*#__PURE__*/react.createElement(\"label\", _extends({\n    className: titleClasses\n  }, labelProps), titleText && titleText, selectedItems.length > 0 && /*#__PURE__*/react.createElement(\"span\", {\n    className: `${prefix}--visually-hidden`\n  }, clearSelectionDescription, \" \", selectedItems.length, ' ', itemsSelectedText, \",\", clearSelectionText)), /*#__PURE__*/react.createElement(ListBox_ListBox, {\n    onFocus: isFluid ? handleFocus : undefined,\n    onBlur: isFluid ? handleFocus : undefined,\n    type: type,\n    size: size$1,\n    className: className,\n    disabled: disabled,\n    light: light,\n    invalid: invalid,\n    invalidText: invalidText,\n    warn: warn,\n    warnText: warnText,\n    isOpen: isOpen,\n    id: id\n  }, invalid && /*#__PURE__*/react.createElement(bucket_18/* WarningFilled */.BF, {\n    className: `${prefix}--list-box__invalid-icon`\n  }), showWarning && /*#__PURE__*/react.createElement(bucket_18/* WarningAltFilled */.OR, {\n    className: `${prefix}--list-box__invalid-icon ${prefix}--list-box__invalid-icon--warning`\n  }), /*#__PURE__*/react.createElement(\"div\", {\n    className: multiSelectFieldWrapperClasses,\n    ref: enableFloatingStyles ? refs.setReference : null\n  }, selectedItems.length > 0 && /*#__PURE__*/react.createElement(ListBox_ListBox.Selection, {\n    readOnly: readOnly,\n    clearSelection: !disabled && !readOnly ? clearSelection : noopFn,\n    selectionCount: selectedItemsLength\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    ,\n\n    translateWithId: translateWithId,\n    disabled: disabled\n  }), /*#__PURE__*/react.createElement(\"button\", _extends({\n    type: \"button\",\n    className: `${prefix}--list-box__field`,\n    disabled: disabled,\n    \"aria-disabled\": disabled || readOnly,\n    \"aria-describedby\": !inline && !invalid && !warn && helperText ? helperId : undefined\n  }, toggleButtonProps, {\n    ref: mergedRef\n  }, readOnlyEventHandlers), /*#__PURE__*/react.createElement(\"span\", {\n    id: fieldLabelId,\n    className: `${prefix}--list-box__label`\n  }, label), /*#__PURE__*/react.createElement(ListBox_ListBox.MenuIcon, {\n    isOpen: isOpen,\n    translateWithId: translateWithId\n  })), slug ? normalizedDecorator : decorator ? /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefix}--list-box__inner-wrapper--decorator`\n  }, normalizedDecorator) : ''), /*#__PURE__*/react.createElement(ListBox_ListBox.Menu, menuProps, isOpen && sortItems(filteredItems, sortOptions).map((item, index) => {\n    const isChecked = selectedItems.filter(selected => react_fast_compare_default()(selected, item)).length > 0;\n    const {\n      hasIndividualSelections,\n      nonSelectAllSelectedCount,\n      totalSelectableCount\n    } = getSelectionStats(selectedItems, filteredItems);\n    const isIndeterminate = item['isSelectAll'] && hasIndividualSelections && nonSelectAllSelectedCount < totalSelectableCount;\n    const itemProps = getItemProps({\n      item,\n      // we don't want Downshift to set aria-selected for us\n      // we also don't want to set 'false' for reader verbosity's sake\n      ['aria-selected']: isChecked\n    });\n    const itemText = itemToString(item);\n    return /*#__PURE__*/react.createElement(ListBox_ListBox.MenuItem, _extends({\n      key: itemProps.id,\n      isActive: isChecked && !item['isSelectAll'],\n      \"aria-label\": itemText,\n      isHighlighted: highlightedIndex === index,\n      title: itemText,\n      disabled: itemProps['aria-disabled']\n    }, itemProps), /*#__PURE__*/react.createElement(\"div\", {\n      className: `${prefix}--checkbox-wrapper`\n    }, /*#__PURE__*/react.createElement(Checkbox, {\n      id: `${itemProps.id}__checkbox`,\n      labelText: itemToElement ? /*#__PURE__*/react.createElement(ItemToElement, _extends({\n        key: itemProps.id\n      }, item)) : itemText,\n      checked: isChecked,\n      title: useTitleInItem ? itemText : undefined,\n      indeterminate: isIndeterminate,\n      disabled: disabled\n    })));\n  })), itemsCleared && /*#__PURE__*/react.createElement(\"span\", {\n    \"aria-live\": \"assertive\",\n    \"aria-label\": clearAnnouncement\n  })), !inline && !invalid && !warn && helperText && /*#__PURE__*/react.createElement(\"div\", {\n    id: helperId,\n    className: helperClasses\n  }, helperText));\n});\nMultiSelect.displayName = 'MultiSelect';\nMultiSelect.propTypes = {\n  ...sortingPropTypes,\n  /**\n   * **Experimental**: Will attempt to automatically align the floating\n   * element to avoid collisions with the viewport and being clipped by\n   * ancestor elements.\n   */\n  autoAlign: (prop_types_default()).bool,\n  /**\n   * Provide a custom class name to be added to the outermost node in the\n   * component\n   */\n  className: (prop_types_default()).string,\n  /**\n   * Specify the text that should be read for screen readers that describes total items selected\n   */\n  clearSelectionDescription: (prop_types_default()).string,\n  /**\n   * Specify the text that should be read for screen readers to clear selection.\n   */\n  clearSelectionText: (prop_types_default()).string,\n  /**\n   * Provide a compare function that is used to determine the ordering of\n   * options. See 'sortItems' for more control. Consider\n   * declaring function with `useCallback` to prevent unnecessary re-renders.\n   */\n  compareItems: (prop_types_default()).func,\n  /**\n   * **Experimental**: Provide a decorator component to be rendered inside the `MultiSelect` component\n   */\n  decorator: (prop_types_default()).node,\n  /**\n   * Specify the direction of the multiselect dropdown. Can be either top or bottom.\n   */\n  direction: prop_types_default().oneOf(['top', 'bottom']),\n  /**\n   * Disable the control\n   */\n  disabled: (prop_types_default()).bool,\n  /**\n   * Additional props passed to Downshift.\n   *\n   * **Use with caution:** anything you define here overrides the components'\n   * internal handling of that prop. Downshift APIs and internals are subject to\n   * change, and in some cases they can not be shimmed by Carbon to shield you\n   * from potentially breaking changes.\n   */\n  downshiftProps: (prop_types_default()).object,\n  /**\n   * Provide helper text that is used alongside the control label for\n   * additional help\n   */\n  helperText: (prop_types_default()).node,\n  /**\n   * Specify whether the title text should be hidden or not\n   */\n  hideLabel: (prop_types_default()).bool,\n  /**\n   * Specify a custom `id`\n   */\n  id: (prop_types_default()).string.isRequired,\n  /**\n   * Allow users to pass in arbitrary items from their collection that are\n   * pre-selected\n   */\n  initialSelectedItems: (prop_types_default()).array,\n  /**\n   * Is the current selection invalid?\n   */\n  invalid: (prop_types_default()).bool,\n  /**\n   * If invalid, what is the error?\n   */\n  invalidText: (prop_types_default()).node,\n  /**\n   * Function to render items as custom components instead of strings.\n   * Defaults to null and is overridden by a getter\n   */\n  itemToElement: (prop_types_default()).func,\n  /**\n   * Helper function passed to downshift that allows the library to render a\n   * given item to a string label. By default, it extracts the `label` field\n   * from a given item to serve as the item label in the list. Consider\n   * declaring function with `useCallback` to prevent unnecessary re-renders.\n   */\n  itemToString: (prop_types_default()).func,\n  /**\n   * We try to stay as generic as possible here to allow individuals to pass\n   * in a collection of whatever kind of data structure they prefer\n   */\n  items: (prop_types_default()).array.isRequired,\n  /**\n   * Generic `label` that will be used as the textual representation of what\n   * this field is for\n   */\n  label: (prop_types_default()).node.isRequired,\n  /**\n   * `true` to use the light version.\n   */\n  light: deprecate((prop_types_default()).bool, 'The `light` prop for `MultiSelect` has ' + 'been deprecated in favor of the new `Layer` component. It will be removed in the next major release.'),\n  /**\n   * Specify the locale of the control. Used for the default `compareItems`\n   * used for sorting the list of items in the control.\n   */\n  locale: (prop_types_default()).string,\n  /**\n   * `onChange` is a utility for this controlled component to communicate to a\n   * consuming component what kind of internal state changes are occurring.\n   */\n  onChange: (prop_types_default()).func,\n  /**\n   * `onMenuChange` is a utility for this controlled component to communicate to a\n   * consuming component that the menu was open(`true`)/closed(`false`).\n   */\n  onMenuChange: (prop_types_default()).func,\n  /**\n   * Initialize the component with an open(`true`)/closed(`false`) menu.\n   */\n  open: (prop_types_default()).bool,\n  /**\n   * Whether or not the Dropdown is readonly\n   */\n  readOnly: (prop_types_default()).bool,\n  /**\n   * For full control of the selected items\n   */\n  selectedItems: (prop_types_default()).array,\n  /**\n   * Specify feedback (mode) of the selection.\n   * `top`: selected item jumps to top\n   * `fixed`: selected item stays at it's position\n   * `top-after-reopen`: selected item jump to top after reopen dropdown\n   */\n  selectionFeedback: prop_types_default().oneOf(['top', 'fixed', 'top-after-reopen']),\n  /**\n   * Specify the size of the ListBox. Currently supports either `sm`, `md` or `lg` as an option.\n   */\n  size: ListBoxSizePropType,\n  slug: deprecate((prop_types_default()).node, 'The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead.'),\n  /**\n   * Provide a method that sorts all options in the control. Overriding this\n   * prop means that you also have to handle the sort logic for selected versus\n   * un-selected items. If you just want to control ordering, consider the\n   * `compareItems` prop instead.\n   *\n   * The return value should be a number whose sign indicates the relative order\n   * of the two elements: negative if a is less than b, positive if a is greater\n   * than b, and zero if they are equal.\n   *\n   * sortItems :\n   *   (items: Array<Item>, {\n   *     selectedItems: Array<Item>,\n   *     itemToString: Item => string,\n   *     compareItems: (itemA: string, itemB: string, {\n   *       locale: string\n   *     }) => number,\n   *     locale: string,\n   *   }) => Array<Item>\n   */\n  sortItems: (prop_types_default()).func,\n  /**\n   * Provide text to be used in a `<label>` element that is tied to the\n   * multiselect via ARIA attributes.\n   */\n  titleText: (prop_types_default()).node,\n  /**\n   * Callback function for translating ListBoxMenuIcon SVG title\n   */\n  translateWithId: (prop_types_default()).func,\n  /**\n   * Specify 'inline' to create an inline multi-select.\n   */\n  type: ListBoxTypePropType,\n  /**\n   * Specify title to show title on hover\n   */\n  useTitleInItem: (prop_types_default()).bool,\n  /**\n   * Specify whether the control is currently in warning state\n   */\n  warn: (prop_types_default()).bool,\n  /**\n   * Provide the text that is displayed when the control is in warning state\n   */\n  warnText: (prop_types_default()).node\n};\n\n// EXTERNAL MODULE: ./node_modules/@carbon/icons-react/es/generated/bucket-6.js\nvar bucket_6 = __webpack_require__(3861);\n// EXTERNAL MODULE: ./node_modules/@carbon/icons-react/es/generated/bucket-9.js\nvar bucket_9 = __webpack_require__(1032);\n// EXTERNAL MODULE: ./node_modules/tabbable/dist/index.esm.js\nvar index_esm = __webpack_require__(968);\n;// ./node_modules/@carbon/react/es/internal/keyboard/navigation.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n/**\n * A \"ring buffer\" function that takes an array and, depending on an ArrowRight\n * or ArrowLeft key input, loops from last index to first or first index to last.\n *\n * @param key - the left or right arrow key (KeyboardEvent, number, or string)\n * @param index - the current index in the array\n * @param arrayLength - the total length of the array\n *\n * @example\n *  getNextIndex(keyCodes.RIGHT, 0, 4)\n */\nconst getNextIndex = (key, index, arrayLength) => {\n  if (match(key, ArrowRight)) {\n    return (index + 1) % arrayLength;\n  }\n  if (match(key, ArrowLeft)) {\n    return (index + arrayLength - 1) % arrayLength;\n  }\n  return;\n};\n\n/**\n * CSS selector that selects major nodes that are sequentially focusable.\n */\nconst selectorTabbable = `\n  a[href], area[href], input:not([disabled]):not([tabindex='-1']),\n  button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']),\n  textarea:not([disabled]):not([tabindex='-1']),\n  iframe, object, embed, *[tabindex]:not([tabindex='-1']):not([disabled]), *[contenteditable=true]\n`;\n\n/**\n * CSS selector that selects major nodes that are click focusable.\n */\nconst selectorFocusable = (/* unused pure expression or super */ null && (`\n  a[href], area[href], input:not([disabled]),\n  button:not([disabled]),select:not([disabled]),\n  textarea:not([disabled]),\n  iframe, object, embed, *[tabindex]:not([disabled]), *[contenteditable=true]\n`));\n\n;// ./node_modules/@carbon/react/es/internal/wrapFocus.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n/**\n * A flag `node.compareDocumentPosition(target)` returns that indicates\n * `target` is located earlier than `node` in the document or `target` contains `node`.\n */\nconst DOCUMENT_POSITION_BROAD_PRECEDING = typeof Node !== 'undefined' ? Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINS : 0;\n\n/**\n * A flag `node.compareDocumentPosition(target)` returns that indicates\n * `target` is located later than `node` in the document or `node` contains `target`.\n */\nconst DOCUMENT_POSITION_BROAD_FOLLOWING = typeof Node !== 'undefined' ? Node.DOCUMENT_POSITION_FOLLOWING | Node.DOCUMENT_POSITION_CONTAINED_BY : 0;\n\n/**\n * Checks whether the given node or one of its ancestors matches any of the\n * specified floating menu selectors.\n *\n * @param {Node} node - A DOM node.\n * @param {string[]} selectorsFloatingMenus - Additional CSS selectors that\n * match floating menus.\n * @returns {boolean} Whether the node or one of its ancestors is in a floating\n * menu.\n */\nconst elementOrParentIsFloatingMenu = function (node) {\n  let selectorsFloatingMenus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  if (node instanceof Element && typeof node.closest === 'function') {\n    const allSelectorsFloatingMenus = ['.cds--overflow-menu-options', '.cds--tooltip', '.flatpickr-calendar', ...selectorsFloatingMenus];\n    return allSelectorsFloatingMenus.some(selector => !!node.closest(selector));\n  }\n  return false;\n};\n\n/**\n * Ensures the focus is kept within the given container by implementing\n * \"focus-wrap\" behavior.\n */\nconst wrapFocus = _ref => {\n  let {\n    bodyNode,\n    startTrapNode,\n    endTrapNode,\n    currentActiveNode,\n    oldActiveNode,\n    selectorsFloatingMenus\n  } = _ref;\n  if (bodyNode && currentActiveNode && oldActiveNode && !bodyNode.contains(currentActiveNode) && !elementOrParentIsFloatingMenu(currentActiveNode, selectorsFloatingMenus)) {\n    const comparisonResult = oldActiveNode.compareDocumentPosition(currentActiveNode);\n    if (currentActiveNode === startTrapNode || comparisonResult & DOCUMENT_POSITION_BROAD_PRECEDING) {\n      const tabbableElement = Array.from(bodyNode.querySelectorAll(selectorTabbable)).reverse().find(_ref2 => {\n        let {\n          offsetParent\n        } = _ref2;\n        return Boolean(offsetParent);\n      });\n      if (tabbableElement) {\n        tabbableElement.focus();\n      } else if (bodyNode !== oldActiveNode) {\n        bodyNode.focus();\n      }\n    } else if (currentActiveNode === endTrapNode || comparisonResult & DOCUMENT_POSITION_BROAD_FOLLOWING) {\n      const tabbableElement = Array.from(bodyNode.querySelectorAll(selectorTabbable)).find(_ref3 => {\n        let {\n          offsetParent\n        } = _ref3;\n        return Boolean(offsetParent);\n      });\n      if (tabbableElement) {\n        tabbableElement.focus();\n      } else if (bodyNode !== oldActiveNode) {\n        bodyNode.focus();\n      }\n    }\n  }\n};\n\n/**\n * Ensures the focus is kept in the given container, implementing \"focus-wrap\"\n * behavior.\n *\n * Note: This must be called *before* focus moves using `onKeyDown` or similar.\n */\nconst wrapFocusWithoutSentinels = _ref4 => {\n  let {\n    containerNode,\n    currentActiveNode,\n    event\n  } = _ref4;\n  if (!containerNode) return;\n  if (['blur', 'focusout', 'focusin', 'focus'].includes(event.type) && \"production\" !== 'production') {}\n\n  // Use `tabbable` to get the focusable elements in tab order.\n  // `selectorTabbable` returns elements in DOM order which is why it's not\n  // used.\n  const tabbables = (0,index_esm/* tabbable */.Kr)(containerNode);\n  const firstTabbable = tabbables[0];\n  const lastTabbable = tabbables[tabbables.length - 1];\n\n  // The shift key indicates if focus is moving forwards or backwards.\n  if (currentActiveNode === lastTabbable && !event.shiftKey) {\n    // Cancel the current movement of focus because we're going to place it ourselves\n    event.preventDefault();\n    firstTabbable.focus();\n  }\n  if (currentActiveNode === firstTabbable && event.shiftKey) {\n    // Cancel the current movement of focus because we're going to place it ourselves\n    event.preventDefault();\n    lastTabbable.focus();\n  }\n};\n\n;// ./node_modules/@carbon/react/es/components/Notification/Notification.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Conditionally call a callback when the escape key is pressed\n * @param {node} ref - ref of the container element to scope the functionality to\n * @param {func} callback - function to be called\n * @param {bool} override - escape hatch to conditionally call the callback\n */\nfunction useEscapeToClose(ref, callback) {\n  let override = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const handleKeyDown = event => {\n    // The callback should only be called when focus is on or within the container\n    const elementContainsFocus = ref.current && document.activeElement === ref.current || ref.current?.contains(document.activeElement);\n    if (matches(event, [Escape]) && override && elementContainsFocus) {\n      callback(event);\n    }\n  };\n  useIsomorphicEffect(() => {\n    if (ref.current !== null) {\n      document.addEventListener('keydown', handleKeyDown, false);\n    }\n    return () => document.removeEventListener('keydown', handleKeyDown, false);\n  });\n}\nfunction NotificationActionButton(_ref) {\n  let {\n    children,\n    className: customClassName,\n    onClick,\n    inline,\n    ...rest\n  } = _ref;\n  const prefix = usePrefix();\n  const className = classnames_default()(customClassName, {\n    [`${prefix}--actionable-notification__action-button`]: true\n  });\n  return /*#__PURE__*/react.createElement(Button, _extends({\n    className: className,\n    kind: inline ? 'ghost' : 'tertiary',\n    onClick: onClick,\n    size: \"sm\"\n  }, rest), children);\n}\nNotificationActionButton.propTypes = {\n  /**\n   * Specify the content of the notification action button.\n   */\n  children: (prop_types_default()).node,\n  /**\n   * Specify an optional className to be applied to the notification action button\n   */\n  className: (prop_types_default()).string,\n  /**\n   * Specify if the visual treatment of the button should be for an inline notification\n   */\n  inline: (prop_types_default()).bool,\n  /**\n   * Optionally specify a click handler for the notification action button.\n   */\n  onClick: (prop_types_default()).func\n};\n\n/**\n * NotificationButton\n * ==================\n */\n\nfunction NotificationButton(_ref2) {\n  let {\n    'aria-label': ariaLabel = 'close notification',\n    ariaLabel: deprecatedAriaLabel,\n    className,\n    type = 'button',\n    renderIcon: IconTag = bucket_3/* Close */.bm,\n    name,\n    notificationType = 'toast',\n    ...rest\n  } = _ref2;\n  const prefix = usePrefix();\n  const buttonClassName = classnames_default()(className, {\n    [`${prefix}--${notificationType}-notification__close-button`]: notificationType\n  });\n  const iconClassName = classnames_default()({\n    [`${prefix}--${notificationType}-notification__close-icon`]: notificationType\n  });\n  return /*#__PURE__*/react.createElement(\"button\", _extends({}, rest, {\n    // eslint-disable-next-line react/button-has-type\n    type: type,\n    \"aria-label\": deprecatedAriaLabel || ariaLabel,\n    title: deprecatedAriaLabel || ariaLabel,\n    className: buttonClassName\n  }), IconTag && /*#__PURE__*/react.createElement(IconTag, {\n    className: iconClassName,\n    name: name\n  }));\n}\nNotificationButton.propTypes = {\n  /**\n   * Specify a label to be read by screen readers on the container node\n   */\n  ['aria-label']: (prop_types_default()).string,\n  /**\n   * Deprecated, please use `aria-label` instead.\n   * Specify a label to be read by screen readers on the container note.\n   */\n  ariaLabel: deprecate((prop_types_default()).string, 'This prop syntax has been deprecated. Please use the new `aria-label`.'),\n  /**\n   * Specify an optional className to be applied to the notification button\n   */\n  className: (prop_types_default()).string,\n  /**\n   * Specify an optional icon for the Button through a string,\n   * if something but regular \"close\" icon is desirable\n   */\n  name: (prop_types_default()).string,\n  /**\n   * Specify the notification type\n   */\n  notificationType: prop_types_default().oneOf(['toast', 'inline', 'actionable']),\n  /**\n   * A component used to render an icon.\n   */\n  renderIcon: prop_types_default().oneOfType([(prop_types_default()).func, (prop_types_default()).object]),\n  /**\n   * Optional prop to specify the type of the Button\n   */\n  type: (prop_types_default()).string\n};\n\n/**\n * NotificationIcon\n * ================\n */\n\nconst iconTypes = {\n  error: bucket_6/* ErrorFilled */.x,\n  success: bucket_3/* CheckmarkFilled */._j,\n  warning: bucket_18/* WarningFilled */.BF,\n  ['warning-alt']: bucket_18/* WarningAltFilled */.OR,\n  info: bucket_9/* InformationFilled */.NM,\n  ['info-square']: bucket_9/* InformationSquareFilled */.mR\n};\nfunction NotificationIcon(_ref3) {\n  let {\n    iconDescription,\n    kind,\n    notificationType\n  } = _ref3;\n  const prefix = usePrefix();\n  const IconForKind = iconTypes[kind];\n  if (!IconForKind) {\n    return null;\n  }\n  return /*#__PURE__*/react.createElement(IconForKind, {\n    className: `${prefix}--${notificationType}-notification__icon`,\n    size: 20\n  }, /*#__PURE__*/react.createElement(\"title\", null, iconDescription));\n}\nNotificationIcon.propTypes = {\n  iconDescription: (prop_types_default()).string.isRequired,\n  kind: prop_types_default().oneOf(['error', 'success', 'warning', 'warning-alt', 'info', 'info-square']).isRequired,\n  notificationType: prop_types_default().oneOf(['inline', 'toast']).isRequired\n};\n\n/**\n * ToastNotification\n * =================\n */\n\nfunction ToastNotification(_ref4) {\n  let {\n    ['aria-label']: ariaLabel,\n    // @ts-expect-error: deprecated prop\n    ariaLabel: deprecatedAriaLabel,\n    role = 'status',\n    onClose,\n    onCloseButtonClick = noopFn,\n    statusIconDescription,\n    className,\n    children,\n    kind = 'error',\n    lowContrast,\n    hideCloseButton = false,\n    timeout = 0,\n    title,\n    caption,\n    subtitle,\n    ...rest\n  } = _ref4;\n  const [isOpen, setIsOpen] = (0,react.useState)(true);\n  const prefix = usePrefix();\n  const containerClassName = classnames_default()(className, {\n    [`${prefix}--toast-notification`]: true,\n    [`${prefix}--toast-notification--low-contrast`]: lowContrast,\n    [`${prefix}--toast-notification--${kind}`]: kind\n  });\n  const contentRef = (0,react.useRef)(null);\n  useNoInteractiveChildren(contentRef);\n  const handleClose = evt => {\n    if (!onClose || onClose(evt) !== false) {\n      setIsOpen(false);\n    }\n  };\n  const ref = (0,react.useRef)(null);\n  function handleCloseButtonClick(event) {\n    onCloseButtonClick(event);\n    handleClose(event);\n  }\n  const savedOnClose = (0,react.useRef)(onClose);\n  (0,react.useEffect)(() => {\n    savedOnClose.current = onClose;\n  });\n  (0,react.useEffect)(() => {\n    if (!timeout) {\n      return;\n    }\n    const timeoutId = window.setTimeout(event => {\n      setIsOpen(false);\n      if (savedOnClose.current) {\n        savedOnClose.current(event);\n      }\n    }, timeout);\n    return () => {\n      window.clearTimeout(timeoutId);\n    };\n  }, [timeout]);\n  if (!isOpen) {\n    return null;\n  }\n  return /*#__PURE__*/react.createElement(\"div\", _extends({\n    ref: ref\n  }, rest, {\n    role: role,\n    className: containerClassName\n  }), /*#__PURE__*/react.createElement(NotificationIcon, {\n    notificationType: \"toast\",\n    kind: kind,\n    iconDescription: statusIconDescription || `${kind} icon`\n  }), /*#__PURE__*/react.createElement(\"div\", {\n    ref: contentRef,\n    className: `${prefix}--toast-notification__details`\n  }, title && /*#__PURE__*/react.createElement(Text, {\n    as: \"div\",\n    className: `${prefix}--toast-notification__title`\n  }, title), subtitle && /*#__PURE__*/react.createElement(Text, {\n    as: \"div\",\n    className: `${prefix}--toast-notification__subtitle`\n  }, subtitle), caption && /*#__PURE__*/react.createElement(Text, {\n    as: \"div\",\n    className: `${prefix}--toast-notification__caption`\n  }, caption), children), !hideCloseButton && /*#__PURE__*/react.createElement(NotificationButton, {\n    notificationType: \"toast\",\n    onClick: handleCloseButtonClick,\n    \"aria-label\": deprecatedAriaLabel || ariaLabel\n  }));\n}\nToastNotification.propTypes = {\n  /**\n   * Provide a description for \"close\" icon button that can be read by screen readers\n   */\n  ['aria-label']: (prop_types_default()).string,\n  /**\n   * Deprecated, please use `aria-label` instead.\n   * Provide a description for \"close\" icon button that can be read by screen readers\n   */\n  ariaLabel: deprecate((prop_types_default()).string, 'This prop syntax has been deprecated. Please use the new `aria-label`.'),\n  /**\n   * Specify the caption\n   */\n  caption: (prop_types_default()).string,\n  /**\n   * Specify the content\n   */\n  children: (prop_types_default()).node,\n  /**\n   * Specify an optional className to be applied to the notification box\n   */\n  className: (prop_types_default()).string,\n  /**\n   * Specify the close button should be disabled, or not\n   */\n  hideCloseButton: (prop_types_default()).bool,\n  /**\n   * Specify what state the notification represents\n   */\n  kind: prop_types_default().oneOf(['error', 'info', 'info-square', 'success', 'warning', 'warning-alt']),\n  /**\n   * Specify whether you are using the low contrast variant of the ToastNotification.\n   */\n  lowContrast: (prop_types_default()).bool,\n  /**\n   * Provide a function that is called when menu is closed\n   */\n  onClose: (prop_types_default()).func,\n  /**\n   * Provide a function that is called when the close button is clicked\n   */\n  onCloseButtonClick: (prop_types_default()).func,\n  /**\n   * By default, this value is \"status\". You can also provide an alternate\n   * role if it makes sense from the accessibility-side\n   */\n  role: prop_types_default().oneOf(['alert', 'log', 'status']),\n  /**\n   * Provide a description for \"status\" icon that can be read by screen readers\n   */\n  statusIconDescription: (prop_types_default()).string,\n  /**\n   * Specify the subtitle\n   */\n  subtitle: (prop_types_default()).string,\n  /**\n   * Specify an optional duration the notification should be closed in\n   */\n  timeout: (prop_types_default()).number,\n  /**\n   * Specify the title\n   */\n  title: (prop_types_default()).string\n};\n\n/**\n * InlineNotification\n * ==================\n */\n\nfunction InlineNotification(_ref5) {\n  let {\n    ['aria-label']: ariaLabel,\n    children,\n    title,\n    subtitle,\n    role = 'status',\n    onClose,\n    onCloseButtonClick = noopFn,\n    statusIconDescription,\n    className,\n    kind = 'error',\n    lowContrast,\n    hideCloseButton = false,\n    ...rest\n  } = _ref5;\n  const [isOpen, setIsOpen] = (0,react.useState)(true);\n  const prefix = usePrefix();\n  const containerClassName = classnames_default()(className, {\n    [`${prefix}--inline-notification`]: true,\n    [`${prefix}--inline-notification--low-contrast`]: lowContrast,\n    [`${prefix}--inline-notification--${kind}`]: kind,\n    [`${prefix}--inline-notification--hide-close-button`]: hideCloseButton\n  });\n  const contentRef = (0,react.useRef)(null);\n  useNoInteractiveChildren(contentRef);\n  const handleClose = evt => {\n    if (!onClose || onClose(evt) !== false) {\n      setIsOpen(false);\n    }\n  };\n  const ref = (0,react.useRef)(null);\n  function handleCloseButtonClick(event) {\n    onCloseButtonClick(event);\n    handleClose(event);\n  }\n  if (!isOpen) {\n    return null;\n  }\n  return /*#__PURE__*/react.createElement(\"div\", _extends({\n    ref: ref\n  }, rest, {\n    role: role,\n    className: containerClassName\n  }), /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefix}--inline-notification__details`\n  }, /*#__PURE__*/react.createElement(NotificationIcon, {\n    notificationType: \"inline\",\n    kind: kind,\n    iconDescription: statusIconDescription || `${kind} icon`\n  }), /*#__PURE__*/react.createElement(\"div\", {\n    ref: contentRef,\n    className: `${prefix}--inline-notification__text-wrapper`\n  }, title && /*#__PURE__*/react.createElement(Text, {\n    as: \"div\",\n    className: `${prefix}--inline-notification__title`\n  }, title), subtitle && /*#__PURE__*/react.createElement(Text, {\n    as: \"div\",\n    className: `${prefix}--inline-notification__subtitle`\n  }, subtitle), children)), !hideCloseButton && /*#__PURE__*/react.createElement(NotificationButton, {\n    notificationType: \"inline\",\n    onClick: handleCloseButtonClick,\n    \"aria-label\": ariaLabel\n  }));\n}\nInlineNotification.propTypes = {\n  /**\n   * Provide a description for \"close\" icon button that can be read by screen readers\n   */\n  ['aria-label']: (prop_types_default()).string,\n  /**\n   * Specify the content\n   */\n  children: (prop_types_default()).node,\n  /**\n   * Specify an optional className to be applied to the notification box\n   */\n  className: (prop_types_default()).string,\n  /**\n   * Specify the close button should be disabled, or not\n   */\n  hideCloseButton: (prop_types_default()).bool,\n  /**\n   * Specify what state the notification represents\n   */\n  kind: prop_types_default().oneOf(['error', 'info', 'info-square', 'success', 'warning', 'warning-alt']),\n  /**\n   * Specify whether you are using the low contrast variant of the InlineNotification.\n   */\n  lowContrast: (prop_types_default()).bool,\n  /**\n   * Provide a function that is called when menu is closed\n   */\n  onClose: (prop_types_default()).func,\n  /**\n   * Provide a function that is called when the close button is clicked\n   */\n  onCloseButtonClick: (prop_types_default()).func,\n  /**\n   * By default, this value is \"status\". You can also provide an alternate\n   * role if it makes sense from the accessibility-side.\n   */\n  role: prop_types_default().oneOf(['alert', 'log', 'status']),\n  /**\n   * Provide a description for \"status\" icon that can be read by screen readers\n   */\n  statusIconDescription: (prop_types_default()).string,\n  /**\n   * Specify the subtitle\n   */\n  subtitle: (prop_types_default()).string,\n  /**\n   * Specify the title\n   */\n  title: (prop_types_default()).string\n};\n\n/**\n * ActionableNotification\n * ======================\n */\n\nfunction ActionableNotification(_ref6) {\n  let {\n    actionButtonLabel,\n    ['aria-label']: ariaLabel,\n    // @ts-expect-error: deprecated prop\n    ariaLabel: deprecatedAriaLabel,\n    children,\n    role = 'alertdialog',\n    onActionButtonClick,\n    onClose,\n    onCloseButtonClick = noopFn,\n    statusIconDescription,\n    className,\n    inline = false,\n    kind = 'error',\n    lowContrast,\n    hideCloseButton = false,\n    hasFocus = true,\n    closeOnEscape = true,\n    title,\n    subtitle,\n    ...rest\n  } = _ref6;\n  const [isOpen, setIsOpen] = (0,react.useState)(true);\n  const prefix = usePrefix();\n  const id = useId('actionable-notification');\n  const subtitleId = useId('actionable-notification-subtitle');\n  const containerClassName = classnames_default()(className, {\n    [`${prefix}--actionable-notification`]: true,\n    [`${prefix}--actionable-notification--toast`]: !inline,\n    [`${prefix}--actionable-notification--low-contrast`]: lowContrast,\n    [`${prefix}--actionable-notification--${kind}`]: kind,\n    [`${prefix}--actionable-notification--hide-close-button`]: hideCloseButton\n  });\n  const innerModal = (0,react.useRef)(null);\n  const startTrap = (0,react.useRef)(null);\n  const endTrap = (0,react.useRef)(null);\n  const ref = (0,react.useRef)(null);\n  const focusTrapWithoutSentinels = useFeatureFlag('enable-experimental-focus-wrap-without-sentinels');\n  useIsomorphicEffect(() => {\n    if (hasFocus && role === 'alertdialog') {\n      const button = document.querySelector('button.cds--actionable-notification__action-button');\n      button?.focus();\n    }\n  });\n  function handleBlur(_ref7) {\n    let {\n      target: oldActiveNode,\n      relatedTarget: currentActiveNode\n    } = _ref7;\n    if (isOpen && currentActiveNode && oldActiveNode && role === 'alertdialog') {\n      const {\n        current: bodyNode\n      } = innerModal;\n      const {\n        current: startTrapNode\n      } = startTrap;\n      const {\n        current: endTrapNode\n      } = endTrap;\n      wrapFocus({\n        bodyNode,\n        startTrapNode,\n        endTrapNode,\n        currentActiveNode,\n        oldActiveNode\n      });\n    }\n  }\n  function handleKeyDown(event) {\n    if (isOpen && match_match(event, Tab) && ref.current && role === 'alertdialog') {\n      wrapFocusWithoutSentinels({\n        containerNode: ref.current,\n        currentActiveNode: event.target,\n        event\n      });\n    }\n  }\n  const handleClose = evt => {\n    if (!onClose || onClose(evt) !== false) {\n      setIsOpen(false);\n    }\n  };\n  useEscapeToClose(ref, handleCloseButtonClick, closeOnEscape);\n  function handleCloseButtonClick(event) {\n    onCloseButtonClick(event);\n    handleClose(event);\n  }\n  if (!isOpen) {\n    return null;\n  }\n  return /*#__PURE__*/react.createElement(\"div\", _extends({}, rest, {\n    ref: ref,\n    role: role,\n    className: containerClassName,\n    \"aria-labelledby\": title ? id : subtitleId,\n    onBlur: !focusTrapWithoutSentinels ? handleBlur : () => {},\n    onKeyDown: focusTrapWithoutSentinels ? handleKeyDown : () => {}\n  }), !focusTrapWithoutSentinels && /*#__PURE__*/react.createElement(\"span\", {\n    ref: startTrap,\n    tabIndex: 0,\n    role: \"link\",\n    className: `${prefix}--visually-hidden`\n  }, \"Focus sentinel\"), /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefix}--actionable-notification__details`\n  }, /*#__PURE__*/react.createElement(NotificationIcon, {\n    notificationType: inline ? 'inline' : 'toast',\n    kind: kind,\n    iconDescription: statusIconDescription || `${kind} icon`\n  }), /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefix}--actionable-notification__text-wrapper`\n  }, /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefix}--actionable-notification__content`\n  }, title && /*#__PURE__*/react.createElement(Text, {\n    as: \"div\",\n    className: `${prefix}--actionable-notification__title`,\n    id: id\n  }, title), subtitle && /*#__PURE__*/react.createElement(Text, {\n    as: \"div\",\n    className: `${prefix}--actionable-notification__subtitle`,\n    id: subtitleId\n  }, subtitle), children))), /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefix}--actionable-notification__button-wrapper`,\n    ref: innerModal\n  }, actionButtonLabel && /*#__PURE__*/react.createElement(NotificationActionButton, {\n    onClick: onActionButtonClick,\n    inline: inline\n  }, actionButtonLabel), !hideCloseButton && /*#__PURE__*/react.createElement(NotificationButton, {\n    \"aria-label\": deprecatedAriaLabel || ariaLabel,\n    notificationType: \"actionable\",\n    onClick: handleCloseButtonClick\n  })), !focusTrapWithoutSentinels && /*#__PURE__*/react.createElement(\"span\", {\n    ref: endTrap,\n    tabIndex: 0,\n    role: \"link\",\n    className: `${prefix}--visually-hidden`\n  }, \"Focus sentinel\"));\n}\nActionableNotification.propTypes = {\n  /**\n   * Pass in the action button label that will be rendered within the ActionableNotification.\n   */\n  actionButtonLabel: (prop_types_default()).string,\n  /**\n   * Provide a description for \"close\" icon button that can be read by screen readers\n   */\n  ['aria-label']: (prop_types_default()).string,\n  /**\n   * Deprecated, please use `aria-label` instead.\n   * Provide a description for \"close\" icon button that can be read by screen readers\n   */\n  ariaLabel: deprecate((prop_types_default()).string, 'This prop syntax has been deprecated. Please use the new `aria-label`.'),\n  /**\n   * Specify the content\n   */\n  children: (prop_types_default()).node,\n  /**\n   * Specify an optional className to be applied to the notification box\n   */\n  className: (prop_types_default()).string,\n  /**\n   * Specify if pressing the escape key should close notifications\n   */\n  closeOnEscape: (prop_types_default()).bool,\n  /**\n   * Specify if focus should be moved to the component when the notification contains actions\n   */\n  hasFocus: deprecate((prop_types_default()).bool, 'hasFocus is deprecated. To conform to accessibility requirements hasFocus ' + 'should always be `true` for ActionableNotification. If you were ' + 'setting this prop to `false`, consider using the Callout component instead.'),\n  /**\n   * Specify the close button should be disabled, or not\n   */\n  hideCloseButton: (prop_types_default()).bool,\n  /*\n   * Specify if the notification should have inline styling applied instead of toast\n   */\n  inline: (prop_types_default()).bool,\n  /**\n   * Specify what state the notification represents\n   */\n  kind: prop_types_default().oneOf(['error', 'info', 'info-square', 'success', 'warning', 'warning-alt']),\n  /**\n   * Specify whether you are using the low contrast variant of the ActionableNotification.\n   */\n  lowContrast: (prop_types_default()).bool,\n  /**\n   * Provide a function that is called when the action is clicked\n   */\n  onActionButtonClick: (prop_types_default()).func,\n  /**\n   * Provide a function that is called when menu is closed\n   */\n  onClose: (prop_types_default()).func,\n  /**\n   * Provide a function that is called when the close button is clicked\n   */\n  onCloseButtonClick: (prop_types_default()).func,\n  /**\n   * Provide an accessible role to be used. Defaults to `alertdialog`. Any other\n   * value will disable the wrapping of focus. To remain accessible, additional\n   * work is required. See the storybook docs for more info:\n   * https://react.carbondesignsystem.com/?path=/docs/components-notifications-actionable--overview#using-the-role-prop\n   */\n  role: (prop_types_default()).string,\n  /**\n   * Provide a description for \"status\" icon that can be read by screen readers\n   */\n  statusIconDescription: (prop_types_default()).string,\n  /**\n   * Specify the subtitle\n   */\n  subtitle: (prop_types_default()).node,\n  /**\n   * Specify the title\n   */\n  title: (prop_types_default()).string\n};\n\n/**\n * Callout\n * ==================\n */\n\n/**\n * Deprecated callout kind values.\n * @deprecated Use NewKindProps instead.\n */\n\nconst propMappingFunction = deprecatedValue => {\n  const mapping = {\n    error: 'warning',\n    // only redirect error -> warning\n    success: 'info' // only redirect success -> info\n  };\n  return mapping[deprecatedValue];\n};\nfunction Callout(_ref8) {\n  let {\n    actionButtonLabel,\n    children,\n    onActionButtonClick,\n    title,\n    titleId,\n    subtitle,\n    statusIconDescription,\n    className,\n    kind = 'info',\n    lowContrast,\n    ...rest\n  } = _ref8;\n  const prefix = usePrefix();\n  const containerClassName = classnames_default()(className, {\n    [`${prefix}--actionable-notification`]: true,\n    [`${prefix}--actionable-notification--low-contrast`]: lowContrast,\n    [`${prefix}--actionable-notification--${kind}`]: kind,\n    [`${prefix}--actionable-notification--hide-close-button`]: true\n  });\n  const childrenContainer = (0,react.useRef)(null);\n  useInteractiveChildrenNeedDescription(childrenContainer, `interactive child node(s) should have an \\`aria-describedby\\` property with a value matching the value of \\`titleId\\``);\n  return /*#__PURE__*/react.createElement(\"div\", _extends({}, rest, {\n    className: containerClassName\n  }), /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefix}--actionable-notification__details`\n  }, /*#__PURE__*/react.createElement(NotificationIcon, {\n    notificationType: \"inline\",\n    kind: kind,\n    iconDescription: statusIconDescription || `${kind} icon`\n  }), /*#__PURE__*/react.createElement(\"div\", {\n    ref: childrenContainer,\n    className: `${prefix}--actionable-notification__text-wrapper`\n  }, title && /*#__PURE__*/react.createElement(Text, {\n    as: \"div\",\n    id: titleId,\n    className: `${prefix}--actionable-notification__title`\n  }, title), subtitle && /*#__PURE__*/react.createElement(Text, {\n    as: \"div\",\n    className: `${prefix}--actionable-notification__subtitle`\n  }, subtitle), children)), /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefix}--actionable-notification__button-wrapper`\n  }, actionButtonLabel && /*#__PURE__*/react.createElement(NotificationActionButton, {\n    onClick: onActionButtonClick,\n    \"aria-describedby\": titleId,\n    inline: true\n  }, actionButtonLabel)));\n}\nCallout.propTypes = {\n  /**\n   * Pass in the action button label that will be rendered within the ActionableNotification.\n   */\n  actionButtonLabel: (prop_types_default()).string,\n  /**\n   * Specify the content\n   */\n  children: (prop_types_default()).node,\n  /**\n   * Specify an optional className to be applied to the notification box\n   */\n  className: (prop_types_default()).string,\n  /**\n   * Specify what state the notification represents\n   */\n  kind: deprecateValuesWithin(prop_types_default().oneOf(['error', 'info', 'info-square', 'success', 'warning', 'warning-alt']), ['warning', 'info'], propMappingFunction),\n  /**\n   * Specify whether you are using the low contrast variant of the Callout.\n   */\n  lowContrast: (prop_types_default()).bool,\n  /**\n   * Provide a function that is called when the action is clicked\n   */\n  onActionButtonClick: (prop_types_default()).func,\n  /**\n   * Provide a description for \"status\" icon that can be read by screen readers\n   */\n  statusIconDescription: (prop_types_default()).string,\n  /**\n   * Specify the subtitle\n   */\n  subtitle: (prop_types_default()).node,\n  /**\n   * Specify the title\n   */\n  title: (prop_types_default()).string,\n  /**\n   * Specify the id for the element containing the title\n   */\n  titleId: (prop_types_default()).string\n};\n\n// In renaming StaticNotification to Callout, the legacy StaticNotification\n// export and it's types should remain usable until Callout is moved to stable.\n// The StaticNotification component below forwards props to Callout and inherits\n// CalloutProps to ensure consumer usage is not impacted, while providing them\n// a deprecation warning.\n// TODO: remove this when Callout moves to stable OR in v12, whichever is first\n/**\n * @deprecated Use `CalloutProps` instead.\n */\n\nlet Notification_didWarnAboutDeprecation = false;\nconst StaticNotification = props => {\n  if (false) {}\n  return /*#__PURE__*/React.createElement(Callout, props);\n};\n\n;// ./node_modules/@carbon/react/es/index.js\n/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDZ0Y7QUFDbkU7QUFDQztBQUNxQjtBQUNNO0FBQ3BCO0FBQytIO0FBQ25HO0FBQzVCO0FBQ1c7QUFDSjtBQUNtQjtBQUN0QztBQUNqQjtBQUNxQztBQUNpQjtBQUNSO0FBQ2dCO0FBQ3BCO0FBQ0k7QUFDNkI7QUFDZDtBQUNyQjtBQUNpQjtBQUNGO0FBQ3JCO0FBQ1Q7QUFDaUI7QUFDVTtBQUMzQjtBQUNpQjtBQUNMO0FBQ2U7QUFDVDtBQUNxQjtBQUNyQjtBQUNuQjtBQUNYO0FBQ0Y7QUFDRTtBQUNvSTtBQUMvRTtBQUN6QztBQUNRO0FBQ2tEO0FBQzlDO0FBQ0Q7QUFDcEI7QUFDc0I7QUFDQTtBQUNGO0FBQ0g7QUFDRjtBQUNpQjtBQUNkO0FBQ2lCO0FBQ3NEO0FBQ3ZFO0FBQ0c7QUFDa0I7QUFDekM7QUFDNEI7QUFDSTtBQUMwQztBQUN6RDtBQUNBO0FBQ0g7QUFDRjtBQUNrQjtBQUNNO0FBQ047QUFDVjtBQUNZO0FBQ0o7QUFDUjtBQUNZO0FBQ1Y7QUFDYztBQUNwQjtBQUNRO0FBQ007QUFDSjtBQUNaO0FBQ2M7QUFDQTtBQUNGO0FBQ0E7QUFDSjtBQUNBO0FBQ0U7QUFDRjtBQUNRO0FBQ1I7QUFDUTtBQUNBO0FBQ0U7QUFDVTtBQUNpQjtBQUNYO0FBQ2lCO0FBQ0Y7QUFDckI7QUFDaUI7QUFDUjtBQUNpQjtBQUNoQztBQUNpQjtBQUNqQjtBQUNpQjtBQUNYO0FBQ2lCO0FBQ2Q7QUFDekM7QUFDMEQ7QUFDWDtBQUNpQjtBQUNwQjtBQUNpQjtBQUNDO0FBQ3hEO0FBQ2M7QUFDakI7QUFDVztBQUNxQztBQUNTO0FBQ3RCO0FBQ3pCO0FBQ1M7QUFDb0g7QUFDdEc7QUFDRztBQUNWO0FBQ2lCO0FBQ3VDO0FBQ3JCO0FBQ0E7QUFDN0M7QUFDcEI7QUFDdEI7QUFDMkU7QUFDNUM7QUFDWDtBQUNnRDtBQUNKO0FBQ2E7QUFDMUI7QUFDSjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjYXJib24vcmVhY3QvZXMvZmVhdHVyZS1mbGFncy5qcz82YzlhIiwid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjYXJib24vcmVhY3QvZXMvX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5qcz9hMThjIiwid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjYXJib24vcmVhY3QvZXMvaW50ZXJuYWwvdXNlUHJlZml4LmpzPzI4MzQiLCJ3ZWJwYWNrOi8vQGlibS9haW9wcy11aS1leHRlbnNpb24tdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNhcmJvbi9yZWFjdC9lcy9jb21wb25lbnRzL0FjY29yZGlvbi9BY2NvcmRpb25Qcm92aWRlci5qcz83MDRkIiwid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjYXJib24vcmVhY3QvZXMvY29tcG9uZW50cy9BY2NvcmRpb24vQWNjb3JkaW9uLmpzP2Q2N2MiLCJ3ZWJwYWNrOi8vQGlibS9haW9wcy11aS1leHRlbnNpb24tdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNhcmJvbi9yZWFjdC9lcy9pbnRlcm5hbC9rZXlib2FyZC9rZXlzLmpzPzRiZmUiLCJ3ZWJwYWNrOi8vQGlibS9haW9wcy11aS1leHRlbnNpb24tdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNhcmJvbi9yZWFjdC9lcy9pbnRlcm5hbC9rZXlib2FyZC9tYXRjaC5qcz9kMjM5Iiwid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjYXJib24vcmVhY3QvZXMvdG9vbHMvc2V0dXBHZXRJbnN0YW5jZUlkLmpzPzM3YzEiLCJ3ZWJwYWNrOi8vQGlibS9haW9wcy11aS1leHRlbnNpb24tdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNhcmJvbi9yZWFjdC9lcy9pbnRlcm5hbC9lbnZpcm9ubWVudC5qcz83MzA2Iiwid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjYXJib24vcmVhY3QvZXMvaW50ZXJuYWwvdXNlSWRQcmVmaXguanM/NzM4MyIsIndlYnBhY2s6Ly9AaWJtL2Fpb3BzLXVpLWV4dGVuc2lvbi10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY2FyYm9uL3JlYWN0L2VzL2ludGVybmFsL3VzZUlkLmpzPzhjNmIiLCJ3ZWJwYWNrOi8vQGlibS9haW9wcy11aS1leHRlbnNpb24tdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNhcmJvbi9yZWFjdC9lcy9wcm9wLXR5cGVzL2RlcHJlY2F0ZS5qcz85NTUyIiwid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjYXJib24vcmVhY3QvZXMvY29tcG9uZW50cy9UZXh0L1RleHREaXJlY3Rpb25Db250ZXh0LmpzP2VlZTIiLCJ3ZWJwYWNrOi8vQGlibS9haW9wcy11aS1leHRlbnNpb24tdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNhcmJvbi9yZWFjdC9lcy9jb21wb25lbnRzL1RleHQvVGV4dC5qcz9jNTZhIiwid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjYXJib24vcmVhY3QvZXMvY29tcG9uZW50cy9BY2NvcmRpb24vQWNjb3JkaW9uSXRlbS5qcz80ZGJjIiwid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjYXJib24vcmVhY3QvZXMvaW50ZXJuYWwvdXNlSXNvbW9ycGhpY0VmZmVjdC5qcz80NGYyIiwid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjYXJib24vcmVhY3QvZXMvY29tcG9uZW50cy9Ta2VsZXRvblRleHQvU2tlbGV0b25UZXh0LmpzPzkwNTUiLCJ3ZWJwYWNrOi8vQGlibS9haW9wcy11aS1leHRlbnNpb24tdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNhcmJvbi9yZWFjdC9lcy9jb21wb25lbnRzL0FjY29yZGlvbi9BY2NvcmRpb24uU2tlbGV0b24uanM/NmFhZCIsIndlYnBhY2s6Ly9AaWJtL2Fpb3BzLXVpLWV4dGVuc2lvbi10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY2FyYm9uL3JlYWN0L2VzL3Byb3AtdHlwZXMvZGVwcmVjYXRlVmFsdWVzV2l0aGluLmpzPzdlMzQiLCJ3ZWJwYWNrOi8vQGlibS9haW9wcy11aS1leHRlbnNpb24tdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNhcmJvbi9yZWFjdC9lcy9pbnRlcm5hbC91c2VNZXJnZWRSZWZzLmpzP2RkZTMiLCJ3ZWJwYWNrOi8vQGlibS9haW9wcy11aS1leHRlbnNpb24tdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNhcmJvbi9yZWFjdC9lcy9pbnRlcm5hbC91c2VFdmVudC5qcz8xZDczIiwid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjYXJib24vcmVhY3QvZXMvdG9vbHMvbWFwUG9wb3ZlckFsaWduLmpzP2EwZDgiLCJ3ZWJwYWNrOi8vQGlibS9haW9wcy11aS1leHRlbnNpb24tdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNhcmJvbi9yZWFjdC9lcy9jb21wb25lbnRzL0ZlYXR1cmVGbGFncy9pbmRleC5qcz82ZDIzIiwid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjYXJib24vcmVhY3QvZXMvY29tcG9uZW50cy9Qb3BvdmVyL2luZGV4LmpzPzgwMzAiLCJ3ZWJwYWNrOi8vQGlibS9haW9wcy11aS1leHRlbnNpb24tdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNhcmJvbi9yZWFjdC9lcy9pbnRlcm5hbC91c2VEZWxheWVkU3RhdGUuanM/NmNhMSIsIndlYnBhY2s6Ly9AaWJtL2Fpb3BzLXVpLWV4dGVuc2lvbi10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY2FyYm9uL3JlYWN0L2VzL2ludGVybmFsL3VzZU5vSW50ZXJhY3RpdmVDaGlsZHJlbi5qcz9jMGI2Iiwid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjYXJib24vcmVhY3QvZXMvY29tcG9uZW50cy9Ub29sdGlwL1Rvb2x0aXAuanM/MzFmNSIsIndlYnBhY2s6Ly9AaWJtL2Fpb3BzLXVpLWV4dGVuc2lvbi10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY2FyYm9uL3JlYWN0L2VzL2NvbXBvbmVudHMvQnV0dG9uL0J1dHRvbkJhc2UuanM/NWZkOCIsIndlYnBhY2s6Ly9AaWJtL2Fpb3BzLXVpLWV4dGVuc2lvbi10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY2FyYm9uL3JlYWN0L2VzL2NvbXBvbmVudHMvQmFkZ2VJbmRpY2F0b3IvaW5kZXguanM/MzZkMyIsIndlYnBhY2s6Ly9AaWJtL2Fpb3BzLXVpLWV4dGVuc2lvbi10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY2FyYm9uL3JlYWN0L2VzL2NvbXBvbmVudHMvSWNvbkJ1dHRvbi9pbmRleC5qcz8yMDQwIiwid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjYXJib24vcmVhY3QvZXMvY29tcG9uZW50cy9CdXR0b24vQnV0dG9uLmpzPzFhMzkiLCJ3ZWJwYWNrOi8vQGlibS9haW9wcy11aS1leHRlbnNpb24tdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNhcmJvbi9yZWFjdC9lcy9pbnRlcm5hbC9ub29wRm4uanM/ZjMzZSIsIndlYnBhY2s6Ly9AaWJtL2Fpb3BzLXVpLWV4dGVuc2lvbi10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY2FyYm9uL3JlYWN0L2VzL2NvbXBvbmVudHMvQ2hlY2tib3gvQ2hlY2tib3guanM/YTY1NCIsIndlYnBhY2s6Ly9AaWJtL2Fpb3BzLXVpLWV4dGVuc2lvbi10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY2FyYm9uL3JlYWN0L2VzL2NvbXBvbmVudHMvRmx1aWRGb3JtL0Zvcm1Db250ZXh0LmpzP2IyMWIiLCJ3ZWJwYWNrOi8vQGlibS9haW9wcy11aS1leHRlbnNpb24tdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNhcmJvbi9yZWFjdC9lcy9jb21wb25lbnRzL0xpc3RCb3gvTGlzdEJveFByb3BUeXBlcy5qcz8wZmNkIiwid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjYXJib24vcmVhY3QvZXMvY29tcG9uZW50cy9MaXN0Qm94L0xpc3RCb3guanM/NDFkYSIsIndlYnBhY2s6Ly9AaWJtL2Fpb3BzLXVpLWV4dGVuc2lvbi10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY2FyYm9uL3JlYWN0L2VzL2NvbXBvbmVudHMvTGlzdEJveC9MaXN0Qm94RmllbGQuanM/ZmJiMCIsIndlYnBhY2s6Ly9AaWJtL2Fpb3BzLXVpLWV4dGVuc2lvbi10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY2FyYm9uL3JlYWN0L2VzL2NvbXBvbmVudHMvTGlzdEJveC9MaXN0Qm94TWVudUl0ZW0uanM/NzA4YSIsIndlYnBhY2s6Ly9AaWJtL2Fpb3BzLXVpLWV4dGVuc2lvbi10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY2FyYm9uL3JlYWN0L2VzL2NvbXBvbmVudHMvTGlzdEJveC9MaXN0Qm94TWVudS5qcz80NGEyIiwid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjYXJib24vcmVhY3QvZXMvY29tcG9uZW50cy9MaXN0Qm94L0xpc3RCb3hNZW51SWNvbi5qcz8xYTllIiwid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjYXJib24vcmVhY3QvZXMvY29tcG9uZW50cy9MaXN0Qm94L0xpc3RCb3hTZWxlY3Rpb24uanM/MmI3NSIsIndlYnBhY2s6Ly9AaWJtL2Fpb3BzLXVpLWV4dGVuc2lvbi10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY2FyYm9uL3JlYWN0L2VzL2NvbXBvbmVudHMvTGlzdEJveC9pbmRleC5qcz9iMGRiIiwid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjYXJib24vcmVhY3QvZXMvdG9vbHMvbWVyZ2VSZWZzLmpzPzliOWQiLCJ3ZWJwYWNrOi8vQGlibS9haW9wcy11aS1leHRlbnNpb24tdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNhcmJvbi9yZWFjdC9lcy9jb21wb25lbnRzL0Ryb3Bkb3duL0Ryb3Bkb3duLmpzP2NmMDEiLCJ3ZWJwYWNrOi8vQGlibS9haW9wcy11aS1leHRlbnNpb24tdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNhcmJvbi9yZWFjdC9lcy9jb21wb25lbnRzL0xvYWRpbmcvTG9hZGluZy5qcz9mMjliIiwid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjYXJib24vcmVhY3QvZXMvY29tcG9uZW50cy9NdWx0aVNlbGVjdC9NdWx0aVNlbGVjdFByb3BUeXBlcy5qcz85MDVmIiwid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjYXJib24vcmVhY3QvZXMvY29tcG9uZW50cy9NdWx0aVNlbGVjdC90b29scy9zb3J0aW5nLmpzPzllN2EiLCJ3ZWJwYWNrOi8vQGlibS9haW9wcy11aS1leHRlbnNpb24tdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNhcmJvbi9yZWFjdC9lcy9pbnRlcm5hbC9TZWxlY3Rpb24uanM/ZmQxOCIsIndlYnBhY2s6Ly9AaWJtL2Fpb3BzLXVpLWV4dGVuc2lvbi10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY2FyYm9uL3JlYWN0L2VzL2NvbXBvbmVudHMvTXVsdGlTZWxlY3QvTXVsdGlTZWxlY3QuanM/MTViOCIsIndlYnBhY2s6Ly9AaWJtL2Fpb3BzLXVpLWV4dGVuc2lvbi10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY2FyYm9uL3JlYWN0L2VzL2ludGVybmFsL2tleWJvYXJkL25hdmlnYXRpb24uanM/NTM5YyIsIndlYnBhY2s6Ly9AaWJtL2Fpb3BzLXVpLWV4dGVuc2lvbi10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY2FyYm9uL3JlYWN0L2VzL2ludGVybmFsL3dyYXBGb2N1cy5qcz9lMjk4Iiwid2VicGFjazovL0BpYm0vYWlvcHMtdWktZXh0ZW5zaW9uLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjYXJib24vcmVhY3QvZXMvY29tcG9uZW50cy9Ob3RpZmljYXRpb24vTm90aWZpY2F0aW9uLmpzPzNhMzQiLCJ3ZWJwYWNrOi8vQGlibS9haW9wcy11aS1leHRlbnNpb24tdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNhcmJvbi9yZWFjdC9lcy9pbmRleC5qcz9iZmM2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIzXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCAqIGFzIEZlYXR1cmVGbGFncyBmcm9tICdAY2FyYm9uL2ZlYXR1cmUtZmxhZ3MnO1xuXG5GZWF0dXJlRmxhZ3MubWVyZ2Uoe1xuICAnZW5hYmxlLWNzcy1jdXN0b20tcHJvcGVydGllcyc6IHRydWUsXG4gICdlbmFibGUtY3NzLWdyaWQnOiB0cnVlLFxuICAnZW5hYmxlLXYxMS1yZWxlYXNlJzogdHJ1ZSxcbiAgJ2VuYWJsZS1leHBlcmltZW50YWwtdGlsZS1jb250cmFzdCc6IGZhbHNlLFxuICAnZW5hYmxlLXYxMi10aWxlLXJhZGlvLWljb25zJzogZmFsc2UsXG4gICdlbmFibGUtdjEyLXN0cnVjdHVyZWQtbGlzdC12aXNpYmxlLWljb25zJzogZmFsc2UsXG4gICdlbmFibGUtdjEyLWR5bmFtaWMtZmxvYXRpbmctc3R5bGVzJzogZmFsc2Vcbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjNcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHtcbiAgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwge1xuICAgIHZhbHVlOiB0LFxuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgd3JpdGFibGU6ICEwXG4gIH0pIDogZVtyXSA9IHQsIGU7XG59XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgcmV0dXJuIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKG4pIHtcbiAgICBmb3IgKHZhciBlID0gMTsgZSA8IGFyZ3VtZW50cy5sZW5ndGg7IGUrKykge1xuICAgICAgdmFyIHQgPSBhcmd1bWVudHNbZV07XG4gICAgICBmb3IgKHZhciByIGluIHQpICh7fSkuaGFzT3duUHJvcGVydHkuY2FsbCh0LCByKSAmJiAobltyXSA9IHRbcl0pO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfSwgX2V4dGVuZHMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjtcbn1cblxuZXhwb3J0IHsgX2RlZmluZVByb3BlcnR5IGFzIGRlZmluZVByb3BlcnR5LCBfZXh0ZW5kcyBhcyBleHRlbmRzLCBfdG9QcmltaXRpdmUgYXMgdG9QcmltaXRpdmUsIF90b1Byb3BlcnR5S2V5IGFzIHRvUHJvcGVydHlLZXkgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIzXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IFByZWZpeENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCgnY2RzJyk7XG5mdW5jdGlvbiB1c2VQcmVmaXgoKSB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KFByZWZpeENvbnRleHQpO1xufVxuXG5leHBvcnQgeyBQcmVmaXhDb250ZXh0LCB1c2VQcmVmaXggfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIzXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuXG5jb25zdCBBY2NvcmRpb25Db250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoe1xuICBkaXNhYmxlZDogZmFsc2Vcbn0pO1xuY29uc3QgQWNjb3JkaW9uUHJvdmlkZXIgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBkaXNhYmxlZCxcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFjY29yZGlvbkNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZToge1xuICAgICAgZGlzYWJsZWRcbiAgICB9XG4gIH0sIGNoaWxkcmVuKTtcbn07XG5cbmV4cG9ydCB7IEFjY29yZGlvbkNvbnRleHQsIEFjY29yZGlvblByb3ZpZGVyIH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBleHRlbmRzIGFzIF9leHRlbmRzIH0gZnJvbSAnLi4vLi4vX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5qcyc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyB1c2VQcmVmaXggfSBmcm9tICcuLi8uLi9pbnRlcm5hbC91c2VQcmVmaXguanMnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBBY2NvcmRpb25Qcm92aWRlciB9IGZyb20gJy4vQWNjb3JkaW9uUHJvdmlkZXIuanMnO1xuXG5mdW5jdGlvbiBBY2NvcmRpb24oX3JlZikge1xuICBsZXQge1xuICAgIGFsaWduID0gJ2VuZCcsXG4gICAgY2hpbGRyZW4sXG4gICAgY2xhc3NOYW1lOiBjdXN0b21DbGFzc05hbWUsXG4gICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICBpc0ZsdXNoID0gZmFsc2UsXG4gICAgb3JkZXJlZCA9IGZhbHNlLFxuICAgIHNpemUsXG4gICAgLi4ucmVzdFxuICB9ID0gX3JlZjtcbiAgY29uc3QgcHJlZml4ID0gdXNlUHJlZml4KCk7XG4gIGNvbnN0IGNsYXNzTmFtZSA9IGN4KGAke3ByZWZpeH0tLWFjY29yZGlvbmAsIGN1c3RvbUNsYXNzTmFtZSwge1xuICAgIFtgJHtwcmVmaXh9LS1hY2NvcmRpb24tLSR7YWxpZ259YF06IGFsaWduLFxuICAgIFtgJHtwcmVmaXh9LS1hY2NvcmRpb24tLSR7c2l6ZX1gXTogc2l6ZSxcbiAgICAvLyBUT0RPOiBWMTIgLSBSZW1vdmUgdGhpcyBjbGFzc1xuICAgIFtgJHtwcmVmaXh9LS1sYXlvdXQtLXNpemUtJHtzaXplfWBdOiBzaXplLFxuICAgIFtgJHtwcmVmaXh9LS1hY2NvcmRpb24tLWZsdXNoYF06IGlzRmx1c2ggJiYgYWxpZ24gIT09ICdzdGFydCdcbiAgfSk7XG4gIGNvbnN0IExpc3RUYWcgPSBvcmRlcmVkID8gJ29sJyA6ICd1bCc7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBY2NvcmRpb25Qcm92aWRlciwge1xuICAgIGRpc2FibGVkOiBkaXNhYmxlZFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaXN0VGFnLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgfSwgcmVzdCksIGNoaWxkcmVuKSk7XG59XG5BY2NvcmRpb24ucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgYWxpZ25tZW50IG9mIHRoZSBhY2NvcmRpb24gaGVhZGluZyB0aXRsZSBhbmQgY2hldnJvbi5cbiAgICovXG4gIGFsaWduOiBQcm9wVHlwZXMub25lT2YoWydzdGFydCcsICdlbmQnXSksXG4gIC8qKlxuICAgKiBQYXNzIGluIHRoZSBjaGlsZHJlbiB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgd2l0aGluIHRoZSBBY2NvcmRpb25cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgLyoqXG4gICAqIFNwZWNpZnkgYW4gb3B0aW9uYWwgY2xhc3NOYW1lIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGNvbnRhaW5lciBub2RlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgYW4gaW5kaXZpZHVhbCBBY2NvcmRpb25JdGVtIHNob3VsZCBiZSBkaXNhYmxlZFxuICAgKi9cbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIEFjY29yZGlvbiB0ZXh0IHNob3VsZCBiZSBmbHVzaCwgZGVmYXVsdCBpcyBmYWxzZSwgZG9lcyBub3Qgd29yayB3aXRoIGFsaWduPVwic3RhcnRcIlxuICAgKi9cbiAgaXNGbHVzaDogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGlmIHRoZSBBY2NvcmRpb24gc2hvdWxkIGJlIGFuIG9yZGVyZWQgbGlzdCxcbiAgICogZGVmYXVsdCBpcyBgZmFsc2VgXG4gICAqL1xuICBvcmRlcmVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIHNpemUgb2YgdGhlIEFjY29yZGlvbi4gQ3VycmVudGx5IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmc6XG4gICAqL1xuICBzaXplOiBQcm9wVHlwZXMub25lT2YoWydzbScsICdtZCcsICdsZyddKVxufTtcblxuZXhwb3J0IHsgQWNjb3JkaW9uIGFzIGRlZmF1bHQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIzXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmNvbnN0IFRhYiA9IHtcbiAga2V5OiAnVGFiJyxcbiAgd2hpY2g6IDksXG4gIGtleUNvZGU6IDksXG4gIGNvZGU6ICdUYWInXG59O1xuY29uc3QgRW50ZXIgPSB7XG4gIGtleTogJ0VudGVyJyxcbiAgd2hpY2g6IDEzLFxuICBrZXlDb2RlOiAxMyxcbiAgY29kZTogJ0VudGVyJ1xufTtcbmNvbnN0IEVzY2FwZSA9IHtcbiAga2V5OiBbJ0VzY2FwZScsXG4gIC8vIElFMTEgRXNjYXBlXG4gICdFc2MnXSxcbiAgd2hpY2g6IDI3LFxuICBrZXlDb2RlOiAyNyxcbiAgY29kZTogJ0VzYydcbn07XG5jb25zdCBTcGFjZSA9IHtcbiAga2V5OiAnICcsXG4gIHdoaWNoOiAzMixcbiAga2V5Q29kZTogMzIsXG4gIGNvZGU6ICdTcGFjZSdcbn07XG5jb25zdCBFbmQgPSB7XG4gIGtleTogJ0VuZCcsXG4gIHdoaWNoOiAzNSxcbiAga2V5Q29kZTogMzUsXG4gIGNvZGU6ICdOdW1wYWQxJ1xufTtcbmNvbnN0IEhvbWUgPSB7XG4gIGtleTogJ0hvbWUnLFxuICB3aGljaDogMzYsXG4gIGtleUNvZGU6IDM2LFxuICBjb2RlOiAnTnVtcGFkNydcbn07XG5jb25zdCBBcnJvd0xlZnQgPSB7XG4gIGtleTogJ0Fycm93TGVmdCcsXG4gIHdoaWNoOiAzNyxcbiAga2V5Q29kZTogMzcsXG4gIGNvZGU6ICdBcnJvd0xlZnQnXG59O1xuY29uc3QgQXJyb3dVcCA9IHtcbiAga2V5OiAnQXJyb3dVcCcsXG4gIHdoaWNoOiAzOCxcbiAga2V5Q29kZTogMzgsXG4gIGNvZGU6ICdBcnJvd1VwJ1xufTtcbmNvbnN0IEFycm93UmlnaHQgPSB7XG4gIGtleTogJ0Fycm93UmlnaHQnLFxuICB3aGljaDogMzksXG4gIGtleUNvZGU6IDM5LFxuICBjb2RlOiAnQXJyb3dSaWdodCdcbn07XG5jb25zdCBBcnJvd0Rvd24gPSB7XG4gIGtleTogJ0Fycm93RG93bicsXG4gIHdoaWNoOiA0MCxcbiAga2V5Q29kZTogNDAsXG4gIGNvZGU6ICdBcnJvd0Rvd24nXG59O1xuY29uc3QgRGVsZXRlID0ge1xuICBrZXk6ICdEZWxldGUnLFxuICB3aGljaDogOCxcbiAga2V5Q29kZTogOCxcbiAgY29kZTogJ0Fycm93RGVjaW1hbCdcbn07XG5cbmV4cG9ydCB7IEFycm93RG93biwgQXJyb3dMZWZ0LCBBcnJvd1JpZ2h0LCBBcnJvd1VwLCBEZWxldGUsIEVuZCwgRW50ZXIsIEVzY2FwZSwgSG9tZSwgU3BhY2UsIFRhYiB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjNcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLyoqXG4gKiBDaGVjayB0byBzZWUgaWYgYXQgbGVhc3Qgb25lIGtleSBjb2RlIG1hdGNoZXMgdGhlIGtleSBjb2RlIG9mIHRoZVxuICogZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIGV2ZW50IC0gVGhlIGV2ZW50IHRvIHRlc3QuXG4gKiBAcGFyYW0ga2V5c1RvTWF0Y2ggLSBBbiBhcnJheSBvZiBrZXkgZGVmaW5pdGlvbnMgdG8gbWF0Y2ggYWdhaW5zdC5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiBvbmUgb2YgdGhlIGtleXMgbWF0Y2hlcy5cbiAqL1xuY29uc3QgbWF0Y2hlcyA9IChldmVudCwga2V5c1RvTWF0Y2gpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzVG9NYXRjaC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChtYXRjaChldmVudCwga2V5c1RvTWF0Y2hbaV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDaGVjayB0byBzZWUgaWYgdGhlIGdpdmVuIGtleSBtYXRjaGVzIHRoZSBjb3JyZXNwb25kaW5nIGtleWJvYXJkIGV2ZW50LiBBbHNvXG4gKiBzdXBwb3J0cyBwYXNzaW5nIGluIHRoZSB2YWx1ZSBkaXJlY3RseSBpZiB5b3UgY2FuJ3QgdXNlIHRoZSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0gZXZlbnRPckNvZGUgLSBBIGBLZXlib2FyZEV2ZW50YCwgYSBudW1iZXIsIG9yIGEgc3RyaW5nIHZhbHVlLlxuICogQHBhcmFtIGtleU9iaiAtIEFuIG9iamVjdCB3aXRoIGtleSBwcm9wZXJ0aWVzIHRvIG1hdGNoIGFnYWluc3QuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGV2ZW50IG9yIGNvZGUgbWF0Y2hlcyB0aGUga2V5IGRlZmluaXRpb24uXG4gKi9cbmNvbnN0IG1hdGNoID0gKGV2ZW50T3JDb2RlLCBfcmVmKSA9PiB7XG4gIGxldCB7XG4gICAga2V5LFxuICAgIHdoaWNoLFxuICAgIGtleUNvZGUsXG4gICAgY29kZVxuICB9ID0gX3JlZjtcbiAgaWYgKHR5cGVvZiBldmVudE9yQ29kZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZXZlbnRPckNvZGUgPT09IGtleTtcbiAgfVxuICBpZiAodHlwZW9mIGV2ZW50T3JDb2RlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBldmVudE9yQ29kZSA9PT0gd2hpY2ggfHwgZXZlbnRPckNvZGUgPT09IGtleUNvZGU7XG4gIH1cbiAgaWYgKGV2ZW50T3JDb2RlLmtleSAmJiBBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICByZXR1cm4ga2V5LmluY2x1ZGVzKGV2ZW50T3JDb2RlLmtleSk7XG4gIH1cbiAgcmV0dXJuIGV2ZW50T3JDb2RlLmtleSA9PT0ga2V5IHx8XG4gIC8vIFRPRE86IFdoZW4gY2FuIHRoZXNlIGNoZWNrcyBmb3IgZGVwcmVjYXRlZCBwcm9wZXJ0aWVzIGJlIGRlbGV0ZWQ/XG4gIC8vIFByZXN1bWFibHksIHRoZSBgS2V5YCB0eXBlIHNob3VsZCBhbHNvIGJlIHBydW5lZCBvZiB0aGVzZSBwcm9wZXJ0aWVzLlxuICBldmVudE9yQ29kZS53aGljaCA9PT0gd2hpY2ggfHwgZXZlbnRPckNvZGUua2V5Q29kZSA9PT0ga2V5Q29kZSB8fCBldmVudE9yQ29kZS5jb2RlID09PSBjb2RlO1xufTtcblxuZXhwb3J0IHsgbWF0Y2gsIG1hdGNoZXMgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIzXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBJRCBnZW5lcmF0b3IuXG4gKlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB1bmlxdWUgc2VxdWVudGlhbCBJRCBvbiBlYWNoIGNhbGwuXG4gKi9cbmNvbnN0IHNldHVwR2V0SW5zdGFuY2VJZCA9ICgpID0+IHtcbiAgbGV0IGluc3RhbmNlSWQgPSAwO1xuICByZXR1cm4gKCkgPT4gKytpbnN0YW5jZUlkO1xufTtcblxuZXhwb3J0IHsgc2V0dXBHZXRJbnN0YW5jZUlkIH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vKipcbiAqIEluZGljYXRlIHdoZXRoZXIgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQgY2FuIGFjY2VzcyB0aGUgRE9NLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi80ZDE3NTEzMTFkM2Y2N2FmMmRjY2UyZTQwZGY4NTEyYTIzYzdiOWM2L3BhY2thZ2VzL2ZianMvc3JjL2NvcmUvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMjTDEyXG4gKi9cbmNvbnN0IGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4vLyBUT0RPOiBgc3NyLWZyaWVuZGx5YCBkb2Vzbid0IHN1cHBvcnQgRVNMaW50IHY5LlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2tvcGlyby9lc2xpbnQtcGx1Z2luLXNzci1mcmllbmRseS9pc3N1ZXMvMzBcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXJib24tZGVzaWduLXN5c3RlbS9jYXJib24vaXNzdWVzLzE4OTkxXG4vKlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNzci1mcmllbmRseS9uby1kb20tZ2xvYmFscy1pbi1tb2R1bGUtc2NvcGVcbiovXG53aW5kb3cuZG9jdW1lbnQgJiZcbi8qXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc3NyLWZyaWVuZGx5L25vLWRvbS1nbG9iYWxzLWluLW1vZHVsZS1zY29wZVxuKi9cbndpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuZXhwb3J0IHsgY2FuVXNlRE9NIH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5jb25zdCBJZFByZWZpeENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmZ1bmN0aW9uIHVzZUlkUHJlZml4KCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChJZFByZWZpeENvbnRleHQpO1xufVxuXG5leHBvcnQgeyBJZFByZWZpeENvbnRleHQsIHVzZUlkUHJlZml4IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgc2V0dXBHZXRJbnN0YW5jZUlkIH0gZnJvbSAnLi4vdG9vbHMvc2V0dXBHZXRJbnN0YW5jZUlkLmpzJztcbmltcG9ydCB7IGNhblVzZURPTSB9IGZyb20gJy4vZW52aXJvbm1lbnQuanMnO1xuaW1wb3J0IHsgdXNlSWRQcmVmaXggfSBmcm9tICcuL3VzZUlkUHJlZml4LmpzJztcblxuLy8gVGhpcyBmaWxlIHdhcyBoZWF2aWx5IGluc3BpcmVkIGJ5OlxuXG4vLyBUaGlzIHRyaWNrcyBidW5kbGVycyBzbyB0aGV5IGNhbid0IHN0YXRpY2FsbHkgYW5hbHl6ZSB0aGlzIGFuZCBwcm9kdWNlXG4vLyBjb21waWxhdGlvbiB3YXJuaW5ncy9lcnJvcnMuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2lzc3Vlcy8xNDgxNFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL211aS9tYXRlcmlhbC11aS9pc3N1ZXMvNDExOTBcbmNvbnN0IF9SZWFjdCA9IHtcbiAgLi4uUmVhY3Rcbn07XG5jb25zdCBpbnN0YW5jZUlkID0gc2V0dXBHZXRJbnN0YW5jZUlkKCk7XG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gY2FuVXNlRE9NID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xubGV0IHNlcnZlckhhbmRvZmZDb21wbGV0ZWQgPSBmYWxzZTtcbmNvbnN0IGRlZmF1bHRJZCA9ICdpZCc7XG5cbi8qKlxuICogR2VuZXJhdGUgYSB1bmlxdWUgSUQgZm9yIFJlYWN0IDw9MTcgd2l0aCBhbiBvcHRpb25hbCBwcmVmaXggcHJlcGVuZGVkIHRvIGl0LlxuICogVGhpcyBpcyBhbiBpbnRlcm5hbCB1dGlsaXR5LCBub3QgaW50ZW5kZWQgZm9yIHB1YmxpYyB1c2FnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4XVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdXNlQ29tcGF0aWJsZUlkKCkge1xuICBsZXQgcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBkZWZhdWx0SWQ7XG4gIGNvbnN0IGNvbnRleHRQcmVmaXggPSB1c2VJZFByZWZpeCgpO1xuICBjb25zdCBbaWQsIHNldElkXSA9IHVzZVN0YXRlKCgpID0+IHtcbiAgICBpZiAoc2VydmVySGFuZG9mZkNvbXBsZXRlZCkge1xuICAgICAgcmV0dXJuIGAke2NvbnRleHRQcmVmaXggPyBgJHtjb250ZXh0UHJlZml4fS1gIDogYGB9JHtwcmVmaXh9LSR7aW5zdGFuY2VJZCgpfWA7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9KTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlkID09PSBudWxsKSB7XG4gICAgICBzZXRJZChgJHtjb250ZXh0UHJlZml4ID8gYCR7Y29udGV4dFByZWZpeH0tYCA6IGBgfSR7cHJlZml4fS0ke2luc3RhbmNlSWQoKX1gKTtcbiAgICB9XG4gIH0sIFtpbnN0YW5jZUlkXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHNlcnZlckhhbmRvZmZDb21wbGV0ZWQgPT09IGZhbHNlKSB7XG4gICAgICBzZXJ2ZXJIYW5kb2ZmQ29tcGxldGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGlkO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgdW5pcXVlIElEIGZvciBSZWFjdCA+PTE4IHdpdGggYW4gb3B0aW9uYWwgcHJlZml4IHByZXBlbmRlZCB0byBpdC5cbiAqIFRoaXMgaXMgYW4gaW50ZXJuYWwgdXRpbGl0eSwgbm90IGludGVuZGVkIGZvciBwdWJsaWMgdXNhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeF1cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHVzZVJlYWN0SWQoKSB7XG4gIGxldCBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGRlZmF1bHRJZDtcbiAgY29uc3QgY29udGV4dFByZWZpeCA9IHVzZUlkUHJlZml4KCk7XG4gIHJldHVybiBgJHtjb250ZXh0UHJlZml4ID8gYCR7Y29udGV4dFByZWZpeH0tYCA6IGBgfSR7cHJlZml4fS0ke19SZWFjdC51c2VJZCgpfWA7XG59XG5cbi8qKlxuICogVXNlcyBSZWFjdCAxOCdzIGJ1aWx0LWluIGB1c2VJZCgpYCB3aGVuIGF2YWlsYWJsZSwgb3IgZmFsbHMgYmFjayB0byBhXG4gKiBzbGlnaHRseSBsZXNzIHBlcmZvcm1hbnQgKHJlcXVpcmluZyBhIGRvdWJsZSByZW5kZXIpIGltcGxlbWVudGF0aW9uIGZvclxuICogZWFybGllciBSZWFjdCB2ZXJzaW9ucy5cbiAqL1xuY29uc3QgdXNlSWQgPSBfUmVhY3QudXNlSWQgPyB1c2VSZWFjdElkIDogdXNlQ29tcGF0aWJsZUlkO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgdW5pcXVlIGlkIGlmIGEgZ2l2ZW4gYGlkYCBpcyBub3QgcHJvdmlkZWRcbiAqIFRoaXMgaXMgYW4gaW50ZXJuYWwgdXRpbGl0eSwgbm90IGludGVuZGVkIGZvciBwdWJsaWMgdXNhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGlkXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB1c2VGYWxsYmFja0lkKGlkKSB7XG4gIGNvbnN0IGZhbGxiYWNrID0gdXNlSWQoKTtcbiAgcmV0dXJuIGlkID8/IGZhbGxiYWNrO1xufVxuXG5leHBvcnQgeyB1c2VDb21wYXRpYmxlSWQsIHVzZUZhbGxiYWNrSWQsIHVzZUlkIH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyB3YXJuaW5nIH0gZnJvbSAnLi4vaW50ZXJuYWwvd2FybmluZy5qcyc7XG5cbmNvbnN0IGRpZFdhcm5BYm91dERlcHJlY2F0aW9uID0ge307XG5mdW5jdGlvbiBkZXByZWNhdGUocHJvcFR5cGUsIG1lc3NhZ2UpIHtcbiAgZnVuY3Rpb24gY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGlvbltjb21wb25lbnROYW1lXSB8fCAhZGlkV2FybkFib3V0RGVwcmVjYXRpb25bY29tcG9uZW50TmFtZV1bcHJvcE5hbWVdKSB7XG4gICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGlvbltjb21wb25lbnROYW1lXSA9IHtcbiAgICAgICAgLi4uZGlkV2FybkFib3V0RGVwcmVjYXRpb25bY29tcG9uZW50TmFtZV0sXG4gICAgICAgIFtwcm9wTmFtZV06IHRydWVcbiAgICAgIH07XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBtZXNzYWdlIHx8IGBUaGUgcHJvcCBcXGAke3Byb3BOYW1lfVxcYCBoYXMgYmVlbiBkZXByZWNhdGVkIGZvciB0aGUgYCArIGAke2NvbXBvbmVudE5hbWV9IGNvbXBvbmVudC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIGAgKyBgcmVsZWFzZWApIDogdm9pZCAwO1xuICAgIH1cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuID4gMyA/IF9sZW4gLSAzIDogMCksIF9rZXkgPSAzOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICByZXN0W19rZXkgLSAzXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgLi4ucmVzdCk7XG4gIH1cbiAgcmV0dXJuIGNoZWNrZXI7XG59XG5cbmV4cG9ydCB7IGRlcHJlY2F0ZSBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuXG5jb25zdCBUZXh0RGlyZWN0aW9uQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KHtcbiAgZGlyZWN0aW9uOiAnYXV0bycsXG4gIGdldFRleHREaXJlY3Rpb246IHtcbiAgICBjdXJyZW50OiB1bmRlZmluZWRcbiAgfVxufSk7XG5cbmV4cG9ydCB7IFRleHREaXJlY3Rpb25Db250ZXh0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBleHRlbmRzIGFzIF9leHRlbmRzIH0gZnJvbSAnLi4vLi4vX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5qcyc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQsIENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICcuL2luZGV4LmpzJztcbmltcG9ydCB7IFRleHREaXJlY3Rpb25Db250ZXh0IH0gZnJvbSAnLi9UZXh0RGlyZWN0aW9uQ29udGV4dC5qcyc7XG5cbmNvbnN0IFRleHRCYXNlID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKF9yZWYsIHJlZikgPT4ge1xuICBsZXQge1xuICAgIGFzLFxuICAgIGNoaWxkcmVuLFxuICAgIGRpciA9ICdhdXRvJyxcbiAgICAuLi5yZXN0XG4gIH0gPSBfcmVmO1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChUZXh0RGlyZWN0aW9uQ29udGV4dCk7XG4gIGNvbnN0IHRleHRQcm9wcyA9IHt9O1xuICBjb25zdCBCYXNlQ29tcG9uZW50ID0gYXMgPz8gJ3NwYW4nO1xuICBjb25zdCB2YWx1ZSA9IHtcbiAgICAuLi5jb250ZXh0XG4gIH07XG4gIGlmICghY29udGV4dCkge1xuICAgIHRleHRQcm9wcy5kaXIgPSBkaXI7XG4gICAgdmFsdWUuZGlyZWN0aW9uID0gZGlyO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpcmVjdGlvbjogcGFyZW50RGlyZWN0aW9uLFxuICAgICAgZ2V0VGV4dERpcmVjdGlvblxuICAgIH0gPSBjb250ZXh0O1xuICAgIGlmIChnZXRUZXh0RGlyZWN0aW9uICYmIGdldFRleHREaXJlY3Rpb24uY3VycmVudCkge1xuICAgICAgY29uc3QgdGV4dCA9IGdldFRleHRGcm9tQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgICAgY29uc3Qgb3ZlcnJpZGUgPSBnZXRUZXh0RGlyZWN0aW9uLmN1cnJlbnQodGV4dCk7XG4gICAgICBpZiAocGFyZW50RGlyZWN0aW9uICE9PSBvdmVycmlkZSkge1xuICAgICAgICB0ZXh0UHJvcHMuZGlyID0gb3ZlcnJpZGU7XG4gICAgICAgIHZhbHVlLmRpcmVjdGlvbiA9IG92ZXJyaWRlO1xuICAgICAgfSBlbHNlIGlmIChwYXJlbnREaXJlY3Rpb24gPT09ICdhdXRvJykge1xuICAgICAgICB0ZXh0UHJvcHMuZGlyID0gb3ZlcnJpZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXJlbnREaXJlY3Rpb24gIT09IGRpcikge1xuICAgICAgdGV4dFByb3BzLmRpciA9IGRpcjtcbiAgICAgIHZhbHVlLmRpcmVjdGlvbiA9IGRpcjtcbiAgICB9IGVsc2UgaWYgKHBhcmVudERpcmVjdGlvbiA9PT0gJ2F1dG8nKSB7XG4gICAgICB0ZXh0UHJvcHMuZGlyID0gZGlyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dERpcmVjdGlvbkNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQmFzZUNvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmVmXG4gIH0sIHJlc3QsIHRleHRQcm9wcyksIGNoaWxkcmVuKSk7XG59KTtcbmNvbnN0IFRleHQgPSBUZXh0QmFzZTtcblRleHQucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogUHJvdmlkZSBhIGN1c3RvbSBlbGVtZW50IHR5cGUgdXNlZCB0byByZW5kZXIgdGhlIG91dGVybW9zdCBub2RlXG4gICAqL1xuICBhczogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5lbGVtZW50VHlwZV0pLFxuICAvKipcbiAgICogUHJvdmlkZSBjaGlsZCBlbGVtZW50cyBvciB0ZXh0IHRvIGJlIHJlbmRlcmVkIGluc2lkZSBvZiB0aGlzIGNvbXBvbmVudFxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLmlzUmVxdWlyZWQsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSB0ZXh0IGRpcmVjdGlvbiB0byBiZSB1c2VkIGZvciB0aGlzIGNvbXBvbmVudCBhbmQgYW55IG9mIGl0c1xuICAgKiBjaGlsZHJlblxuICAgKi9cbiAgZGlyOiBQcm9wVHlwZXMub25lT2YoWydsdHInLCAncnRsJywgJ2F1dG8nXSlcbn07XG5jb25zdCBnZXRUZXh0RnJvbUNoaWxkcmVuID0gY2hpbGRyZW4gPT4ge1xuICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICBjb25zdCB0ZXh0ID0gQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBjaGlsZCA9PiB7XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0pPy5maWx0ZXIodGV4dCA9PiB7XG4gICAgcmV0dXJuIHRleHQgIT09IG51bGw7XG4gIH0pO1xuICBpZiAodGV4dD8ubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRleHRbMF07XG4gIH1cbiAgcmV0dXJuIHRleHQ7XG59O1xuXG5leHBvcnQgeyBUZXh0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBleHRlbmRzIGFzIF9leHRlbmRzIH0gZnJvbSAnLi4vLi4vX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5qcyc7XG5pbXBvcnQgeyBDaGV2cm9uUmlnaHQgfSBmcm9tICdAY2FyYm9uL2ljb25zLXJlYWN0JztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgJy4uL1RleHQvaW5kZXguanMnO1xuaW1wb3J0IHsgRXNjYXBlIH0gZnJvbSAnLi4vLi4vaW50ZXJuYWwva2V5Ym9hcmQva2V5cy5qcyc7XG5pbXBvcnQgeyBtYXRjaCB9IGZyb20gJy4uLy4uL2ludGVybmFsL2tleWJvYXJkL21hdGNoLmpzJztcbmltcG9ydCB7IHVzZUlkIH0gZnJvbSAnLi4vLi4vaW50ZXJuYWwvdXNlSWQuanMnO1xuaW1wb3J0IGRlcHJlY2F0ZSBmcm9tICcuLi8uLi9wcm9wLXR5cGVzL2RlcHJlY2F0ZS5qcyc7XG5pbXBvcnQgeyB1c2VQcmVmaXggfSBmcm9tICcuLi8uLi9pbnRlcm5hbC91c2VQcmVmaXguanMnO1xuaW1wb3J0IHsgQWNjb3JkaW9uQ29udGV4dCB9IGZyb20gJy4vQWNjb3JkaW9uUHJvdmlkZXIuanMnO1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uL1RleHQvVGV4dC5qcyc7XG5cbmNvbnN0IGRlZmF1bHRSZW5kZXJUb2dnbGUgPSBwcm9wcyA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBfZXh0ZW5kcyh7XG4gIHR5cGU6IFwiYnV0dG9uXCJcbn0sIHByb3BzKSk7XG5mdW5jdGlvbiBBY2NvcmRpb25JdGVtKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlbixcbiAgICBjbGFzc05hbWU6IGN1c3RvbUNsYXNzTmFtZSA9ICcnLFxuICAgIG9wZW4gPSBmYWxzZSxcbiAgICBvbkhlYWRpbmdDbGljayxcbiAgICByZW5kZXJFeHBhbmRvID0gZGVmYXVsdFJlbmRlclRvZ2dsZSxcbiAgICAvLyByZW1vdmUgcmVuZGVyRXhwYW5kbyBpbiBuZXh0IG1ham9yIHJlbGVhc2VcbiAgICByZW5kZXJUb2dnbGUsXG4gICAgdGl0bGUgPSAndGl0bGUnLFxuICAgIGRpc2FibGVkOiBjb250cm9sbGVkRGlzYWJsZWQsXG4gICAgaGFuZGxlQW5pbWF0aW9uRW5kLFxuICAgIC4uLnJlc3RcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IFtpc09wZW4sIHNldElzT3Blbl0gPSB1c2VTdGF0ZShvcGVuKTtcbiAgY29uc3QgW3ByZXZJc09wZW4sIHNldFByZXZJc09wZW5dID0gdXNlU3RhdGUob3Blbik7XG4gIGNvbnN0IGFjY29yZGlvblN0YXRlID0gdXNlQ29udGV4dChBY2NvcmRpb25Db250ZXh0KTtcbiAgY29uc3QgZGlzYWJsZWRJc0NvbnRyb2xsZWQgPSB0eXBlb2YgY29udHJvbGxlZERpc2FibGVkID09PSAnYm9vbGVhbic7XG4gIGNvbnN0IGRpc2FibGVkID0gZGlzYWJsZWRJc0NvbnRyb2xsZWQgPyBjb250cm9sbGVkRGlzYWJsZWQgOiBhY2NvcmRpb25TdGF0ZS5kaXNhYmxlZDtcbiAgY29uc3QgaWQgPSB1c2VJZCgnYWNjb3JkaW9uLWl0ZW0nKTtcbiAgY29uc3QgcHJlZml4ID0gdXNlUHJlZml4KCk7XG4gIGNvbnN0IGNsYXNzTmFtZSA9IGN4KHtcbiAgICBbYCR7cHJlZml4fS0tYWNjb3JkaW9uX19pdGVtYF06IHRydWUsXG4gICAgW2Ake3ByZWZpeH0tLWFjY29yZGlvbl9faXRlbS0tYWN0aXZlYF06IGlzT3BlbiAmJiAhZGlzYWJsZWQsXG4gICAgW2Ake3ByZWZpeH0tLWFjY29yZGlvbl9faXRlbS0tZGlzYWJsZWRgXTogZGlzYWJsZWQsXG4gICAgW2N1c3RvbUNsYXNzTmFtZV06ICEhY3VzdG9tQ2xhc3NOYW1lXG4gIH0pO1xuICBjb25zdCBUb2dnbGUgPSByZW5kZXJUb2dnbGUgfHwgcmVuZGVyRXhwYW5kbzsgLy8gcmVtb3ZlIHJlbmRlckV4cGFuZG8gaW4gbmV4dCBtYWpvciByZWxlYXNlXG5cbiAgY29uc3QgY29udGVudCA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNPcGVuKSB7XG4gICAgICAvLyBhY2NvcmRpb24gY2xvc2VzXG4gICAgICBub2RlLnN0eWxlLm1heEJsb2NrU2l6ZSA9ICcnO1xuICAgIH1cbiAgfSwgW2lzT3Blbl0pO1xuICBpZiAob3BlbiAhPT0gcHJldklzT3Blbikge1xuICAgIHNldElzT3BlbihvcGVuKTtcbiAgICBzZXRQcmV2SXNPcGVuKG9wZW4pO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgQWNjb3JkaW9uSXRlbSBoZWFkaW5nIGlzIGNsaWNrZWQsIHRvZ2dsZSB0aGUgb3BlbiBzdGF0ZSBvZiB0aGVcbiAgLy8gcGFuZWxcbiAgZnVuY3Rpb24gb25DbGljayhldmVudCkge1xuICAgIGNvbnN0IG5leHRWYWx1ZSA9ICFpc09wZW47XG4gICAgc2V0SXNPcGVuKG5leHRWYWx1ZSk7XG4gICAgaWYgKG9uSGVhZGluZ0NsaWNrKSB7XG4gICAgICAvLyBUT0RPOiBub3JtYWxpemUgc2lnbmF0dXJlLCBwb3RlbnRpYWxseTpcbiAgICAgIC8vIG9uSGVhZGluZ0NsaWNrIDo6IChldmVudDogRXZlbnQsIHN0YXRlOiB7IGlzT3BlbjogQm9vbGVhbiB9KSA9PiBhbnlcbiAgICAgIG9uSGVhZGluZ0NsaWNrKHtcbiAgICAgICAgaXNPcGVuOiBuZXh0VmFsdWUsXG4gICAgICAgIGV2ZW50XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgQWNjb3JkaW9uSXRlbSBpcyBvcGVuLCBhbmQgdGhlIHVzZXIgaGl0cyB0aGUgRVNDIGtleSwgdGhlbiBjbG9zZSBpdFxuICBmdW5jdGlvbiBvbktleURvd24oZXZlbnQpIHtcbiAgICBpZiAoaXNPcGVuICYmIG1hdGNoKGV2ZW50LCBFc2NhcGUpKSB7XG4gICAgICBzZXRJc09wZW4oZmFsc2UpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvbkFuaW1hdGlvbkVuZChldmVudCkge1xuICAgIGlmIChoYW5kbGVBbmltYXRpb25FbmQpIHtcbiAgICAgIGhhbmRsZUFuaW1hdGlvbkVuZChldmVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpXCIsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICB9LCByZXN0KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVG9nZ2xlLCB7XG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgIFwiYXJpYS1jb250cm9sc1wiOiBpZCxcbiAgICBcImFyaWEtZXhwYW5kZWRcIjogaXNPcGVuLFxuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tYWNjb3JkaW9uX19oZWFkaW5nYCxcbiAgICBvbkNsaWNrOiBvbkNsaWNrLFxuICAgIG9uS2V5RG93bjogb25LZXlEb3duLFxuICAgIHR5cGU6IFwiYnV0dG9uXCJcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hldnJvblJpZ2h0LCB7XG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS1hY2NvcmRpb25fX2Fycm93YFxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dCwge1xuICAgIGFzOiBcImRpdlwiLFxuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tYWNjb3JkaW9uX190aXRsZWBcbiAgfSwgdGl0bGUpKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogY29udGVudCxcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeH0tLWFjY29yZGlvbl9fd3JhcHBlcmAsXG4gICAgb25UcmFuc2l0aW9uRW5kOiBvbkFuaW1hdGlvbkVuZFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgaWQ6IGlkLFxuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tYWNjb3JkaW9uX19jb250ZW50YFxuICB9LCBjaGlsZHJlbikpKTtcbn1cbkFjY29yZGlvbkl0ZW0ucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogUHJvdmlkZSB0aGUgY29udGVudHMgb2YgeW91ciBBY2NvcmRpb25JdGVtXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGFuIG9wdGlvbmFsIGNsYXNzTmFtZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBjb250YWluZXIgbm9kZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIGFuIGluZGl2aWR1YWwgQWNjb3JkaW9uSXRlbSBzaG91bGQgYmUgZGlzYWJsZWRcbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIFRoZSBoYW5kbGVyIG9mIHRoZSBtYXNzYWdlZCBgY2xpY2tgIGV2ZW50LlxuICAgKi9cbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gIC8qKlxuICAgKiBUaGUgaGFuZGxlciBvZiB0aGUgbWFzc2FnZWQgYGNsaWNrYCBldmVudCBvbiB0aGUgaGVhZGluZy5cbiAgICovXG4gIG9uSGVhZGluZ0NsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgLyoqXG4gICAqIGB0cnVlYCB0byBvcGVuIHRoZSBleHBhbmQuXG4gICAqL1xuICBvcGVuOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byByZW5kZXIgdGhlIGV4cGFuZCBidXR0b24uXG4gICAqIENhbiBiZSBhIFJlYWN0IGNvbXBvbmVudCBjbGFzcy5cbiAgICovXG4gIHJlbmRlckV4cGFuZG86IGRlcHJlY2F0ZShQcm9wVHlwZXMuZnVuYywgJ1RoZSBgcmVuZGVyRXhwYW5kb2AgcHJvcCBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZSBvZiBDYXJib24uIFVzZSB0aGUgYHJlbmRlclRvZ2dsZWAgcHJvcCBpbnN0ZWFkLicpLFxuICAvKipcbiAgICogVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJlbmRlciB0aGUgZXhwYW5kIGJ1dHRvbi5cbiAgICogQ2FuIGJlIGEgUmVhY3QgY29tcG9uZW50IGNsYXNzLlxuICAgKi9cbiAgcmVuZGVyVG9nZ2xlOiBQcm9wVHlwZXMuZnVuYyxcbiAgLyoqXG4gICAqIFRoZSBhY2NvcmRpb24gdGl0bGUuXG4gICAqL1xuICB0aXRsZTogUHJvcFR5cGVzLm5vZGVcbn07XG5cbmV4cG9ydCB7IEFjY29yZGlvbkl0ZW0gYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjNcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbi8qKiBgdXNlTGF5b3V0RWZmZWN0YCBvbiB0aGUgY2xpZW50LCBgdXNlRWZmZWN0YCBvbiB0aGUgc2VydmVyICovXG5jb25zdCB1c2VJc29tb3JwaGljRWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbmV4cG9ydCB7IHVzZUlzb21vcnBoaWNFZmZlY3QgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjNcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHsgZXh0ZW5kcyBhcyBfZXh0ZW5kcyB9IGZyb20gJy4uLy4uL192aXJ0dWFsL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuanMnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyB1c2VQcmVmaXggfSBmcm9tICcuLi8uLi9pbnRlcm5hbC91c2VQcmVmaXguanMnO1xuaW1wb3J0IHVzZUlzb21vcnBoaWNFZmZlY3QgZnJvbSAnLi4vLi4vaW50ZXJuYWwvdXNlSXNvbW9ycGhpY0VmZmVjdC5qcyc7XG5cbmNvbnN0IHJhbmRvbXMgPSBbMC45NzMwNTE0OTM1MDc0MzUsIDAuMTUzMzQ3MzcyMTM1NTg1NTgsIDAuNTY3MTAzNDU1MzA1Mzc2OV07XG5mdW5jdGlvbiBnZXRSYW5kb21JbnQobWluLCBtYXgsIG4pIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IocmFuZG9tc1tuICUgM10gKiAobWF4IC0gbWluICsgMSkpICsgbWluO1xufVxuY29uc3QgU2tlbGV0b25UZXh0ID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgcGFyYWdyYXBoID0gZmFsc2UsXG4gICAgbGluZUNvdW50ID0gMyxcbiAgICB3aWR0aCA9ICcxMDAlJyxcbiAgICBoZWFkaW5nID0gZmFsc2UsXG4gICAgY2xhc3NOYW1lID0gJycsXG4gICAgLi4ucmVzdFxuICB9ID0gX3JlZjtcbiAgY29uc3QgcHJlZml4ID0gdXNlUHJlZml4KCk7XG4gIGNvbnN0IHNrZWxldG9uVGV4dENsYXNzZXMgPSBjeCh7XG4gICAgW2Ake3ByZWZpeH0tLXNrZWxldG9uX190ZXh0YF06IHRydWUsXG4gICAgW2Ake3ByZWZpeH0tLXNrZWxldG9uX19oZWFkaW5nYF06IGhlYWRpbmcsXG4gICAgW2NsYXNzTmFtZV06IGNsYXNzTmFtZVxuICB9KTtcbiAgY29uc3Qgd2lkdGhOdW0gPSBwYXJzZUludCh3aWR0aCwgMTApO1xuICBjb25zdCB3aWR0aFB4ID0gd2lkdGguaW5jbHVkZXMoJ3B4Jyk7XG4gIGNvbnN0IHdpZHRoUGVyY2VudCA9IHdpZHRoLmluY2x1ZGVzKCclJyk7XG4gIGxldCBsaW5lQ291bnROdW1iZXIgPSAxO1xuICBpZiAocGFyYWdyYXBoKSB7XG4gICAgbGluZUNvdW50TnVtYmVyID0gbGluZUNvdW50O1xuICB9XG4gIGNvbnN0IHJlZnMgPSB1c2VSZWYoW10pO1xuICB1c2VJc29tb3JwaGljRWZmZWN0KCgpID0+IHtcbiAgICByZWZzLmN1cnJlbnQubWFwKChpdGVtLCBqKSA9PiB7XG4gICAgICBjb25zdCByYW5kb21QZXJjZW50V2lkdGggPSBnZXRSYW5kb21JbnQoMCwgNzUsIGopICsgJ3B4JztcbiAgICAgIGNvbnN0IHJhbmRvbVB4V2lkdGggPSBnZXRSYW5kb21JbnQoTWF0aC5tYXgod2lkdGhOdW0gLSA3NSwgMCksIHdpZHRoTnVtLCBqKSArICdweCc7XG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICBpZiAod2lkdGhQZXJjZW50ICYmIHBhcmFncmFwaCkge1xuICAgICAgICAgIGl0ZW0uc3R5bGUud2lkdGggPSBgY2FsYygke3dpZHRofSAtICR7cmFuZG9tUGVyY2VudFdpZHRofSlgO1xuICAgICAgICB9IGVsc2UgaWYgKHdpZHRoUHggJiYgcGFyYWdyYXBoKSB7XG4gICAgICAgICAgaXRlbS5zdHlsZS53aWR0aCA9IHJhbmRvbVB4V2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtsaW5lQ291bnROdW1iZXIsIHBhcmFncmFwaCwgcmVmcywgd2lkdGgsIHdpZHRoTnVtLCB3aWR0aFBlcmNlbnQsIHdpZHRoUHhdKTtcbiAgY29uc3QgbGluZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lQ291bnROdW1iZXI7IGkrKykge1xuICAgIGxpbmVzLnB1c2goLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIF9leHRlbmRzKHtcbiAgICAgIGNsYXNzTmFtZTogc2tlbGV0b25UZXh0Q2xhc3NlcyxcbiAgICAgIGtleTogaSxcbiAgICAgIHJlZjogZWwgPT4ge1xuICAgICAgICByZWZzLmN1cnJlbnQgPSBbLi4ucmVmcy5jdXJyZW50LCBlbF07XG4gICAgICB9XG4gICAgfSwgcmVzdCkpKTtcbiAgfVxuICBpZiAobGluZUNvdW50TnVtYmVyICE9PSAxKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsIGxpbmVzKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9qc3gtbm8tdXNlbGVzcy1mcmFnbWVudFxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGxpbmVzKTtcbn07XG5Ta2VsZXRvblRleHQucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogU3BlY2lmeSBhbiBvcHRpb25hbCBjbGFzc05hbWUgdG8gYmUgYXBwbGllZCB0byB0aGUgY29udGFpbmVyIG5vZGVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAqIGdlbmVyYXRlcyBza2VsZXRvbiB0ZXh0IGF0IGEgbGFyZ2VyIHNpemVcbiAgICovXG4gIGhlYWRpbmc6IFByb3BUeXBlcy5ib29sLFxuICAvKipcbiAgICogdGhlIG51bWJlciBvZiBsaW5lcyBzaG93biBpZiBwYXJhZ3JhcGggaXMgdHJ1ZVxuICAgKi9cbiAgbGluZUNvdW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICAvKipcbiAgICogd2lsbCBnZW5lcmF0ZSBtdWx0aXBsZSBsaW5lcyBvZiB0ZXh0XG4gICAqL1xuICBwYXJhZ3JhcGg6IFByb3BUeXBlcy5ib29sLFxuICAvKipcbiAgICogd2lkdGggKGluIHB4IG9yICUpIG9mIHNpbmdsZSBsaW5lIG9mIHRleHQgb3IgbWF4LXdpZHRoIG9mIHBhcmFncmFwaCBsaW5lc1xuICAgKi9cbiAgd2lkdGg6IFByb3BUeXBlcy5zdHJpbmdcbn07XG5cbmV4cG9ydCB7IFNrZWxldG9uVGV4dCBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBleHRlbmRzIGFzIF9leHRlbmRzIH0gZnJvbSAnLi4vLi4vX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5qcyc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IENoZXZyb25SaWdodCB9IGZyb20gJ0BjYXJib24vaWNvbnMtcmVhY3QnO1xuaW1wb3J0IFNrZWxldG9uVGV4dCBmcm9tICcuLi9Ta2VsZXRvblRleHQvU2tlbGV0b25UZXh0LmpzJztcbmltcG9ydCB7IHVzZVByZWZpeCB9IGZyb20gJy4uLy4uL2ludGVybmFsL3VzZVByZWZpeC5qcyc7XG5cbnZhciBfU2tlbGV0b25UZXh0LCBfU2tlbGV0b25UZXh0MiwgX1NrZWxldG9uVGV4dDM7XG5mdW5jdGlvbiBBY2NvcmRpb25Ta2VsZXRvbihfcmVmKSB7XG4gIGxldCB7XG4gICAgYWxpZ24gPSAnZW5kJyxcbiAgICBjbGFzc05hbWUsXG4gICAgY291bnQgPSA0LFxuICAgIGlzRmx1c2gsXG4gICAgb3BlbiA9IHRydWUsXG4gICAgb3JkZXJlZCA9IGZhbHNlLFxuICAgIC4uLnJlc3RcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHByZWZpeCA9IHVzZVByZWZpeCgpO1xuICBjb25zdCBjbGFzc2VzID0gY3goYCR7cHJlZml4fS0tYWNjb3JkaW9uYCwgYCR7cHJlZml4fS0tc2tlbGV0b25gLCBjbGFzc05hbWUsIHtcbiAgICBbYCR7cHJlZml4fS0tYWNjb3JkaW9uLS0ke2FsaWdufWBdOiBhbGlnbixcbiAgICBbYCR7cHJlZml4fS0tYWNjb3JkaW9uLS1mbHVzaGBdOiBpc0ZsdXNoICYmIGFsaWduICE9PSAnc3RhcnQnXG4gIH0pO1xuICBjb25zdCBudW1Ta2VsZXRvbkl0ZW1zID0gb3BlbiA/IGNvdW50IC0gMSA6IGNvdW50O1xuICBjb25zdCBMaXN0VGFnID0gb3JkZXJlZCA/ICdvbCcgOiAndWwnO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGlzdFRhZywgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xhc3Nlc1xuICB9LCByZXN0KSwgb3BlbiAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpXCIsIHtcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeH0tLWFjY29yZGlvbl9faXRlbSAke3ByZWZpeH0tLWFjY29yZGlvbl9faXRlbS0tYWN0aXZlYFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tYWNjb3JkaW9uX19oZWFkaW5nYFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDaGV2cm9uUmlnaHQsIHtcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeH0tLWFjY29yZGlvbl9fYXJyb3dgXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTa2VsZXRvblRleHQsIHtcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeH0tLWFjY29yZGlvbl9fdGl0bGVgXG4gIH0pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tYWNjb3JkaW9uX19jb250ZW50YFxuICB9LCBfU2tlbGV0b25UZXh0IHx8IChfU2tlbGV0b25UZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU2tlbGV0b25UZXh0LCB7XG4gICAgd2lkdGg6IFwiOTAlXCJcbiAgfSkpLCBfU2tlbGV0b25UZXh0MiB8fCAoX1NrZWxldG9uVGV4dDIgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTa2VsZXRvblRleHQsIHtcbiAgICB3aWR0aDogXCI4MCVcIlxuICB9KSksIF9Ta2VsZXRvblRleHQzIHx8IChfU2tlbGV0b25UZXh0MyA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFNrZWxldG9uVGV4dCwge1xuICAgIHdpZHRoOiBcIjk1JVwiXG4gIH0pKSkpLCBBcnJheS5mcm9tKHtcbiAgICBsZW5ndGg6IG51bVNrZWxldG9uSXRlbXNcbiAgfSkubWFwKChfLCBpKSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBY2NvcmRpb25Ta2VsZXRvbkl0ZW0sIHtcbiAgICBrZXk6IGlcbiAgfSkpKTtcbn1cbkFjY29yZGlvblNrZWxldG9uLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGFsaWdubWVudCBvZiB0aGUgYWNjb3JkaW9uIGhlYWRpbmcgdGl0bGUgYW5kIGNoZXZyb24uXG4gICAqL1xuICBhbGlnbjogUHJvcFR5cGVzLm9uZU9mKFsnc3RhcnQnLCAnZW5kJ10pLFxuICAvKipcbiAgICogU3BlY2lmeSBhbiBvcHRpb25hbCBjbGFzc05hbWUgdG8gYWRkLlxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvKipcbiAgICogU2V0IG51bWJlciBvZiBpdGVtcyB0byByZW5kZXJcbiAgICovXG4gIGNvdW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIGFuIGluZGl2aWR1YWwgQWNjb3JkaW9uSXRlbSBzaG91bGQgYmUgZmx1c2gsIGRlZmF1bHQgaXMgZmFsc2VcbiAgICovXG4gIGlzRmx1c2g6IFByb3BUeXBlcy5ib29sLFxuICAvKipcbiAgICogYGZhbHNlYCB0byBub3QgZGlzcGxheSB0aGUgZmlyc3QgaXRlbSBvcGVuZWRcbiAgICovXG4gIG9wZW46IFByb3BUeXBlcy5ib29sXG59O1xuZnVuY3Rpb24gQWNjb3JkaW9uU2tlbGV0b25JdGVtKCkge1xuICBjb25zdCBwcmVmaXggPSB1c2VQcmVmaXgoKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibGlcIiwge1xuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tYWNjb3JkaW9uX19pdGVtYFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tYWNjb3JkaW9uX19oZWFkaW5nYFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDaGV2cm9uUmlnaHQsIHtcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeH0tLWFjY29yZGlvbl9fYXJyb3dgXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTa2VsZXRvblRleHQsIHtcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeH0tLWFjY29yZGlvbl9fdGl0bGVgXG4gIH0pKSk7XG59XG5cbmV4cG9ydCB7IEFjY29yZGlvblNrZWxldG9uLCBBY2NvcmRpb25Ta2VsZXRvbiBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyB3YXJuaW5nIH0gZnJvbSAnLi4vaW50ZXJuYWwvd2FybmluZy5qcyc7XG5cbmNvbnN0IGRpZFdhcm5BYm91dERlcHJlY2F0aW9uID0ge307XG5mdW5jdGlvbiBkZXByZWNhdGVWYWx1ZXNXaXRoaW4ocHJvcFR5cGUsIGFsbG93ZWRWYWx1ZXMsIHByb3BNYXBwaW5nRnVuY3Rpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZGlkV2FybkFib3V0RGVwcmVjYXRpb25bY29tcG9uZW50TmFtZV0gfHwgIWRpZFdhcm5BYm91dERlcHJlY2F0aW9uW2NvbXBvbmVudE5hbWVdW3Byb3BOYW1lXSkge1xuICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRpb25bY29tcG9uZW50TmFtZV0gPSB7XG4gICAgICAgIC4uLmRpZFdhcm5BYm91dERlcHJlY2F0aW9uW2NvbXBvbmVudE5hbWVdLFxuICAgICAgICBbcHJvcE5hbWVdOiB0cnVlXG4gICAgICB9O1xuICAgICAgY29uc3QgZGVwcmVjYXRlZFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBwcm9wTWFwcGluZ0Z1bmN0aW9uID8gcHJvcE1hcHBpbmdGdW5jdGlvbihkZXByZWNhdGVkVmFsdWUpIDogbnVsbDtcbiAgICAgIGlmIChhbGxvd2VkVmFsdWVzICYmICFhbGxvd2VkVmFsdWVzLmluY2x1ZGVzKGRlcHJlY2F0ZWRWYWx1ZSkpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHByb3BNYXBwaW5nRnVuY3Rpb24gPyBgXCIke2RlcHJlY2F0ZWRWYWx1ZX1cIiBpcyBhIGRlcHJlY2F0ZWQgdmFsdWUgZm9yIHRoZSBcIiR7cHJvcE5hbWV9XCIgcHJvcCBvbiB0aGUgXCIke2NvbXBvbmVudE5hbWV9XCIgY29tcG9uZW50LiBVc2UgXCIke25ld1ZhbHVlfVwiIGluc3RlYWQuIFwiJHtkZXByZWNhdGVkVmFsdWV9XCIgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuYCA6IGBcIiR7ZGVwcmVjYXRlZFZhbHVlfVwiIGlzIGEgZGVwcmVjYXRlZCB2YWx1ZSBmb3IgdGhlIFwiJHtwcm9wTmFtZX1cIiBwcm9wIG9uIHRoZSBcIiR7Y29tcG9uZW50TmFtZX1cIiBjb21wb25lbnQuIEFsbG93ZWQgdmFsdWVzIGlzL2FyZTogJHthbGxvd2VkVmFsdWVzLmpvaW4oJywgJyl9LiAgXCIke2RlcHJlY2F0ZWRWYWx1ZX1cIiB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gYDtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgbWVzc2FnZSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4gPiAzID8gX2xlbiAtIDMgOiAwKSwgX2tleSA9IDM7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHJlc3RbX2tleSAtIDNdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCAuLi5yZXN0KTtcbiAgfTtcbn1cblxuZXhwb3J0IHsgZGVwcmVjYXRlVmFsdWVzV2l0aGluIGFzIGRlZmF1bHQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIzXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIE1lcmdlcyBtdWx0aXBsZSByZWZzIGludG8gYSBzaW5nbGUgY2FsbGJhY2sgcmVmLlxuICpcbiAqIFRoaXMgaG9vayBpcyB1c2VmdWwgd2hlbiB5b3UgbmVlZCB0byBhdHRhY2ggbXVsdGlwbGUgcmVmcyAoZm9yIGV4YW1wbGUsIGEgcmVmXG4gKiBwYXNzZWQgZnJvbSBgZm9yd2FyZFJlZmAgYW5kIGEgbG9jYWwgcmVmIGZyb20gYHVzZVJlZmApIHRvIHRoZSBzYW1lIG5vZGUuIEl0XG4gKiBhY2NlcHRzIGFuIGFycmF5IG9mIHJlZnMgYW5kIHJldHVybnMgYSBjYWxsYmFjayByZWYgdGhhdCwgd2hlbiBhdHRhY2hlZCB0byBhXG4gKiBub2RlLCBhc3NpZ25zIHRoYXQgbm9kZSB0byBldmVyeSByZWYgaW4gdGhlIGFycmF5LlxuICovXG5jb25zdCB1c2VNZXJnZWRSZWZzID0gcmVmcyA9PiB7XG4gIHJldHVybiB1c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICByZWZzLmZvckVhY2gocmVmID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlZihub2RlKTtcbiAgICAgIH0gZWxzZSBpZiAocmVmKSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW3JlZnNdKTtcbn07XG5cbmV4cG9ydCB7IHVzZU1lcmdlZFJlZnMgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIzXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCB7IHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG5jb25zdCB1c2VFdmVudCA9IChlbGVtZW50T3JSZWYsIGV2ZW50TmFtZSwgY2FsbGJhY2spID0+IHtcbiAgY29uc3Qgc2F2ZWRDYWxsYmFjayA9IHVzZVJlZihudWxsKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzYXZlZENhbGxiYWNrLmN1cnJlbnQgPSBjYWxsYmFjaztcbiAgfSwgW2NhbGxiYWNrXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgICAgIGlmIChzYXZlZENhbGxiYWNrLmN1cnJlbnQpIHtcbiAgICAgICAgc2F2ZWRDYWxsYmFjay5jdXJyZW50KGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGVsZW1lbnQgPSAnY3VycmVudCcgaW4gZWxlbWVudE9yUmVmID8gZWxlbWVudE9yUmVmLmN1cnJlbnQgOiBlbGVtZW50T3JSZWY7XG4gICAgZWxlbWVudD8uYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBlbGVtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfTtcbiAgfSwgW2VsZW1lbnRPclJlZiwgZXZlbnROYW1lXSk7XG59O1xuY29uc3QgdXNlV2luZG93RXZlbnQgPSAoZXZlbnROYW1lLCBjYWxsYmFjaykgPT4ge1xuICBjb25zdCBzYXZlZENhbGxiYWNrID0gdXNlUmVmKG51bGwpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNhdmVkQ2FsbGJhY2suY3VycmVudCA9IGNhbGxiYWNrO1xuICB9LCBbY2FsbGJhY2tdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKHNhdmVkQ2FsbGJhY2suY3VycmVudCkge1xuICAgICAgICBzYXZlZENhbGxiYWNrLmN1cnJlbnQoZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICB9O1xuICB9LCBbZXZlbnROYW1lXSk7XG59O1xuXG5leHBvcnQgeyB1c2VFdmVudCwgdXNlV2luZG93RXZlbnQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIzXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmNvbnN0IHBvcG92ZXJBbGlnbk1hcHBpbmcgPSB7XG4gICd0b3AtbGVmdCc6ICd0b3Atc3RhcnQnLFxuICAndG9wLXJpZ2h0JzogJ3RvcC1lbmQnLFxuICAnYm90dG9tLWxlZnQnOiAnYm90dG9tLXN0YXJ0JyxcbiAgJ2JvdHRvbS1yaWdodCc6ICdib3R0b20tZW5kJyxcbiAgJ2xlZnQtYm90dG9tJzogJ2xlZnQtZW5kJyxcbiAgJ2xlZnQtdG9wJzogJ2xlZnQtc3RhcnQnLFxuICAncmlnaHQtYm90dG9tJzogJ3JpZ2h0LWVuZCcsXG4gICdyaWdodC10b3AnOiAncmlnaHQtc3RhcnQnXG59O1xuXG4vKipcbiAqIE1hcHMgcG9wb3ZlciBhbGlnbm1lbnQgdmFsdWVzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgcmVwbGFjZW1lbnQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSBhbGlnbiAtIFRoZSBvcmlnaW5hbCBhbGlnbiB2YWx1ZS5cbiAqIEByZXR1cm5zIFRoZSBuZXcgYWxpZ24gdmFsdWUgYmFzZWQgb24gbWFwcGluZyBvciB0aGUgb3JpZ2luYWwgYWxpZ24gaWYgbm9cbiAqICAgICAgICAgIG1hcHBpbmcgZXhpc3RzLlxuICovXG5jb25zdCBtYXBQb3BvdmVyQWxpZ24gPSBhbGlnbiA9PiBwb3BvdmVyQWxpZ25NYXBwaW5nW2FsaWduXSA/PyBhbGlnbjtcblxuZXhwb3J0IHsgbWFwUG9wb3ZlckFsaWduIH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBjcmVhdGVTY29wZSwgRmVhdHVyZUZsYWdzIGFzIEZlYXR1cmVGbGFncyQxIH0gZnJvbSAnQGNhcmJvbi9mZWF0dXJlLWZsYWdzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZVJlZiwgdXNlRWZmZWN0LCBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGRlcHJlY2F0ZSBmcm9tICcuLi8uLi9wcm9wLXR5cGVzL2RlcHJlY2F0ZS5qcyc7XG5cbi8qKlxuICogT3VyIEZlYXR1cmVGbGFnQ29udGV4dCBpcyB1c2VkIGFsb25nc2lkZSB0aGUgRmVhdHVyZUZsYWdzIGNvbXBvbmVudCB0byBlbmFibGVcbiAqIG9yIGRpc2FibGUgZmVhdHVyZSBmbGFncyBpbiBhIGdpdmVuIFJlYWN0IHRyZWVcbiAqL1xuY29uc3QgRmVhdHVyZUZsYWdDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoRmVhdHVyZUZsYWdzJDEpO1xuXG4vKipcbiAqIFN1cHBvcnRzIGFuIG9iamVjdCBvZiBmZWF0dXJlIGZsYWcgdmFsdWVzIHdpdGggdGhlIGBmbGFnc2AgcHJvcCwgbWVyZ2luZyB0aGVtXG4gKiBhbG9uZyB3aXRoIHRoZSBjdXJyZW50IGBGZWF0dXJlRmxhZ0NvbnRleHRgIHRvIHByb3ZpZGUgY29uc3VtZXJzIHRvIGNoZWNrIGlmXG4gKiBhIGZlYXR1cmUgZmxhZyBpcyBlbmFibGVkIG9yIGRpc2FibGVkIGluIGEgZ2l2ZW4gUmVhY3QgdHJlZVxuICovXG5mdW5jdGlvbiBGZWF0dXJlRmxhZ3MoX3JlZikge1xuICBsZXQge1xuICAgIGNoaWxkcmVuLFxuICAgIGZsYWdzID0ge30sXG4gICAgZW5hYmxlVjEyVGlsZURlZmF1bHRJY29ucyA9IGZhbHNlLFxuICAgIGVuYWJsZVYxMlRpbGVSYWRpb0ljb25zID0gZmFsc2UsXG4gICAgZW5hYmxlVjEyT3ZlcmZsb3dtZW51ID0gZmFsc2UsXG4gICAgZW5hYmxlVHJlZXZpZXdDb250cm9sbGFibGUgPSBmYWxzZSxcbiAgICBlbmFibGVFeHBlcmltZW50YWxGb2N1c1dyYXBXaXRob3V0U2VudGluZWxzID0gZmFsc2UsXG4gICAgZW5hYmxlRGlhbG9nRWxlbWVudCA9IGZhbHNlLFxuICAgIGVuYWJsZVYxMkR5bmFtaWNGbG9hdGluZ1N0eWxlcyA9IGZhbHNlXG4gIH0gPSBfcmVmO1xuICBjb25zdCBwYXJlbnRTY29wZSA9IHVzZUNvbnRleHQoRmVhdHVyZUZsYWdDb250ZXh0KTtcbiAgY29uc3QgW3ByZXZQYXJlbnRTY29wZSwgc2V0UHJldlBhcmVudFNjb3BlXSA9IHVzZVN0YXRlKHBhcmVudFNjb3BlKTtcbiAgY29uc3QgY29tYmluZWRGbGFncyA9IHtcbiAgICAnZW5hYmxlLXYxMi10aWxlLWRlZmF1bHQtaWNvbnMnOiBlbmFibGVWMTJUaWxlRGVmYXVsdEljb25zLFxuICAgICdlbmFibGUtdjEyLXRpbGUtcmFkaW8taWNvbnMnOiBlbmFibGVWMTJUaWxlUmFkaW9JY29ucyxcbiAgICAnZW5hYmxlLXYxMi1vdmVyZmxvd21lbnUnOiBlbmFibGVWMTJPdmVyZmxvd21lbnUsXG4gICAgJ2VuYWJsZS10cmVldmlldy1jb250cm9sbGFibGUnOiBlbmFibGVUcmVldmlld0NvbnRyb2xsYWJsZSxcbiAgICAnZW5hYmxlLWV4cGVyaW1lbnRhbC1mb2N1cy13cmFwLXdpdGhvdXQtc2VudGluZWxzJzogZW5hYmxlRXhwZXJpbWVudGFsRm9jdXNXcmFwV2l0aG91dFNlbnRpbmVscyxcbiAgICAnZW5hYmxlLWRpYWxvZy1lbGVtZW50JzogZW5hYmxlRGlhbG9nRWxlbWVudCxcbiAgICAnZW5hYmxlLXYxMi1keW5hbWljLWZsb2F0aW5nLXN0eWxlcyc6IGVuYWJsZVYxMkR5bmFtaWNGbG9hdGluZ1N0eWxlcyxcbiAgICAuLi5mbGFnc1xuICB9O1xuICBjb25zdCBbc2NvcGUsIHVwZGF0ZVNjb3BlXSA9IHVzZVN0YXRlKCgpID0+IHtcbiAgICBjb25zdCBzY29wZSA9IGNyZWF0ZVNjb3BlKGNvbWJpbmVkRmxhZ3MpO1xuICAgIHNjb3BlLm1lcmdlV2l0aFNjb3BlKHBhcmVudFNjb3BlKTtcbiAgICByZXR1cm4gc2NvcGU7XG4gIH0pO1xuICBpZiAocGFyZW50U2NvcGUgIT09IHByZXZQYXJlbnRTY29wZSkge1xuICAgIGNvbnN0IHNjb3BlID0gY3JlYXRlU2NvcGUoY29tYmluZWRGbGFncyk7XG4gICAgc2NvcGUubWVyZ2VXaXRoU2NvcGUocGFyZW50U2NvcGUpO1xuICAgIHVwZGF0ZVNjb3BlKHNjb3BlKTtcbiAgICBzZXRQcmV2UGFyZW50U2NvcGUocGFyZW50U2NvcGUpO1xuICB9XG5cbiAgLy8gV2UgdXNlIGEgY3VzdG9tIGhvb2sgdG8gZGV0ZWN0IGlmIGFueSBvZiB0aGUga2V5cyBvciB0aGVpciB2YWx1ZXMgY2hhbmdlXG4gIC8vIGZvciBmbGFncyB0aGF0IGFyZSBwYXNzZWQgaW4uIElmIHRoZXkgaGF2ZSBjaGFuZ2VkLCB0aGVuIHdlIHJlLWNyZWF0ZSB0aGVcbiAgLy8gRmVhdHVyZUZsYWdTY29wZSB1c2luZyB0aGUgbmV3IGZsYWdzXG4gIHVzZUNoYW5nZWRWYWx1ZShjb21iaW5lZEZsYWdzLCBpc0VxdWFsLCBjaGFuZ2VkRmxhZ3MgPT4ge1xuICAgIGNvbnN0IHNjb3BlID0gY3JlYXRlU2NvcGUoY2hhbmdlZEZsYWdzKTtcbiAgICBzY29wZS5tZXJnZVdpdGhTY29wZShwYXJlbnRTY29wZSk7XG4gICAgdXBkYXRlU2NvcGUoc2NvcGUpO1xuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZlYXR1cmVGbGFnQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzY29wZVxuICB9LCBjaGlsZHJlbik7XG59XG5GZWF0dXJlRmxhZ3MucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIC8qKlxuICAgKiBQcm92aWRlIHRoZSBmZWF0dXJlIGZsYWdzIHRvIGVuYWJsZWQgb3IgZGlzYWJsZWQgaW4gdGhlIGN1cnJlbnQgUmVhLGN0IHRyZWVcbiAgICovXG4gIGZsYWdzOiBkZXByZWNhdGUoUHJvcFR5cGVzLm9iamVjdE9mKFByb3BUeXBlcy5ib29sKSwgJ1RoZSBgZmxhZ3NgIHByb3AgZm9yIGBGZWF0dXJlRmxhZ2AgaGFzICcgKyAnYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgcnVuIHRoZSBgZmVhdHVyZWZsYWctZGVwcmVjYXRlLWZsYWdzLXByb3BgIGNvZGVtb2QgdG8gbWlncmF0ZSB0byBpbmRpdmlkdWFsIGJvb2xlYW4gcHJvcHMuJyArIGBucHggQGNhcmJvbi91cGdyYWRlIG1pZ3JhdGUgZmVhdHVyZWZsYWctZGVwcmVjYXRlLWZsYWdzLXByb3AgLS13cml0ZWApLFxuICBlbmFibGVWMTJUaWxlRGVmYXVsdEljb25zOiBQcm9wVHlwZXMuYm9vbCxcbiAgZW5hYmxlVjEyVGlsZVJhZGlvSWNvbnM6IFByb3BUeXBlcy5ib29sLFxuICBlbmFibGVWMTJPdmVyZmxvd21lbnU6IFByb3BUeXBlcy5ib29sLFxuICBlbmFibGVUcmVldmlld0NvbnRyb2xsYWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gIGVuYWJsZUV4cGVyaW1lbnRhbEZvY3VzV3JhcFdpdGhvdXRTZW50aW5lbHM6IFByb3BUeXBlcy5ib29sLFxuICBlbmFibGVEaWFsb2dFbGVtZW50OiBQcm9wVHlwZXMuYm9vbCxcbiAgZW5hYmxlVjEyRHluYW1pY0Zsb2F0aW5nU3R5bGVzOiBQcm9wVHlwZXMuYm9vbFxufTtcblxuLyoqXG4gKiBUaGlzIGhvb2sgd2lsbCBzdG9yZSBwcmV2aW91cyB2ZXJzaW9ucyBvZiB0aGUgZ2l2ZW4gYHZhbHVlYCBhbmQgY29tcGFyZSB0aGVcbiAqIGN1cnJlbnQgdmFsdWUgdG8gdGhlIHByZXZpb3VzIG9uZSB1c2luZyB0aGUgYGNvbXBhcmVgIGZ1bmN0aW9uLiBJZiB0aGVcbiAqIGNvbXBhcmUgZnVuY3Rpb24gcmV0dXJucyB0cnVlLCB0aGVuIHRoZSBnaXZlbiBgY2FsbGJhY2tgIGlzIGludm9rZWQgaW4gYW5cbiAqIGVmZmVjdC5cbiAqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIHVzZUNoYW5nZWRWYWx1ZSh2YWx1ZSwgY29tcGFyZSwgY2FsbGJhY2spIHtcbiAgY29uc3QgaW5pdGlhbFJlbmRlciA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VSZWYoY2FsbGJhY2spO1xuICBjb25zdCBbcHJldlZhbHVlLCBzZXRQcmV2VmFsdWVdID0gdXNlU3RhdGUodmFsdWUpO1xuICBpZiAoIWNvbXBhcmUocHJldlZhbHVlLCB2YWx1ZSkpIHtcbiAgICBzZXRQcmV2VmFsdWUodmFsdWUpO1xuICB9XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2F2ZWRDYWxsYmFjay5jdXJyZW50ID0gY2FsbGJhY2s7XG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFdlIG9ubHkgd2FudCB0aGUgY2FsbGJhY2sgdHJpZ2dlcmVkIGFmdGVyIHRoZSBmaXJzdCByZW5kZXJcbiAgICBpZiAoaW5pdGlhbFJlbmRlci5jdXJyZW50KSB7XG4gICAgICBzYXZlZENhbGxiYWNrLmN1cnJlbnQocHJldlZhbHVlKTtcbiAgICB9XG4gIH0sIFtwcmV2VmFsdWVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpbml0aWFsUmVuZGVyLmN1cnJlbnQgPSB0cnVlO1xuICB9LCBbXSk7XG59XG5cbi8qKlxuICogQWNjZXNzIHdoZXRoZXIgYSBnaXZlbiBmbGFnIGlzIGVuYWJsZWQgb3IgZGlzYWJsZWQgaW4gYSBnaXZlblxuICogRmVhdHVyZUZsYWdDb250ZXh0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHVzZUZlYXR1cmVGbGFnKGZsYWcpIHtcbiAgY29uc3Qgc2NvcGUgPSB1c2VDb250ZXh0KEZlYXR1cmVGbGFnQ29udGV4dCk7XG4gIHJldHVybiBzY29wZS5lbmFibGVkKGZsYWcpO1xufVxuXG4vKipcbiAqIEFjY2VzcyBhbGwgZmVhdHVyZSBmbGFnIGluZm9ybWF0aW9uIGZvciB0aGUgZ2l2ZW4gRmVhdHVyZUZsYWdDb250ZXh0XG4gKlxuICogQHJldHVybnMge0ZlYXR1cmVGbGFnU2NvcGV9XG4gKi9cbmZ1bmN0aW9uIHVzZUZlYXR1cmVGbGFncygpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoRmVhdHVyZUZsYWdDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBDb21wYXJlIHR3byBvYmplY3RzIGFuZCBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1YWwuIFRoaXMgaXMgYSBzaGFsbG93XG4gKiBjb21wYXJpc29uIHNpbmNlIHRoZSBvYmplY3RzIHdlIGFyZSBjb21wYXJpbmcgYXJlIG9iamVjdHMgd2l0aCBib29sZWFuIGZsYWdzXG4gKiBmcm9tIHRoZSBmbGFncyBwcm9wIGluIHRoZSBgRmVhdHVyZUZsYWdzYCBjb21wb25lbnRcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYVxuICogQHBhcmFtIHtvYmplY3R9IGJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhhKSkge1xuICAgIGlmIChhW2tleV0gIT09IGJba2V5XSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhiKSkge1xuICAgIGlmIChiW2tleV0gIT09IGFba2V5XSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IHsgRmVhdHVyZUZsYWdDb250ZXh0LCBGZWF0dXJlRmxhZ3MsIHVzZUZlYXR1cmVGbGFnLCB1c2VGZWF0dXJlRmxhZ3MgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIzXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCB7IGV4dGVuZHMgYXMgX2V4dGVuZHMgfSBmcm9tICcuLi8uLi9fdmlydHVhbC9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLmpzJztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgZGVwcmVjYXRlVmFsdWVzV2l0aGluIGZyb20gJy4uLy4uL3Byb3AtdHlwZXMvZGVwcmVjYXRlVmFsdWVzV2l0aGluLmpzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VSZWYsIHVzZU1lbW8sIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VJc29tb3JwaGljRWZmZWN0IGZyb20gJy4uLy4uL2ludGVybmFsL3VzZUlzb21vcnBoaWNFZmZlY3QuanMnO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUmVmcyB9IGZyb20gJy4uLy4uL2ludGVybmFsL3VzZU1lcmdlZFJlZnMuanMnO1xuaW1wb3J0IHsgdXNlUHJlZml4IH0gZnJvbSAnLi4vLi4vaW50ZXJuYWwvdXNlUHJlZml4LmpzJztcbmltcG9ydCB7IHVzZVdpbmRvd0V2ZW50IH0gZnJvbSAnLi4vLi4vaW50ZXJuYWwvdXNlRXZlbnQuanMnO1xuaW1wb3J0IHsgbWFwUG9wb3ZlckFsaWduIH0gZnJvbSAnLi4vLi4vdG9vbHMvbWFwUG9wb3ZlckFsaWduLmpzJztcbmltcG9ydCB7IHVzZUZsb2F0aW5nLCBvZmZzZXQsIGZsaXAsIGFycm93LCBoaWRlLCBhdXRvVXBkYXRlIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3JlYWN0JztcbmltcG9ydCB7IHVzZUZlYXR1cmVGbGFnIH0gZnJvbSAnLi4vRmVhdHVyZUZsYWdzL2luZGV4LmpzJztcblxuY29uc3QgUG9wb3ZlckNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIHNldEZsb2F0aW5nOiB7XG4gICAgY3VycmVudDogbnVsbFxuICB9LFxuICBjYXJldFJlZjoge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfSxcbiAgYXV0b0FsaWduOiBudWxsXG59KTtcblxuLyoqXG4gKiBEZXByZWNhdGVkIHBvcG92ZXIgYWxpZ25tZW50IHZhbHVlcy5cbiAqIEBkZXByZWNhdGVkIFVzZSBOZXdQb3BvdmVyQWxpZ25tZW50IGluc3RlYWQuXG4gKi9cblxuY29uc3QgUG9wb3ZlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFBvcG92ZXJSZW5kZXJGdW5jdGlvbihfcmVmLFxuLy90aGlzIGlzIGEgd29ya2Fyb3VuZCwgaGF2ZSB0byBjb21lIGJhY2sgYW5kIGZpeCB0aGlzLlxuZm9yd2FyZFJlZikge1xuICBsZXQge1xuICAgIGlzVGFiVGlwLFxuICAgIGFsaWduOiBpbml0aWFsQWxpZ24gPSBpc1RhYlRpcCA/ICdib3R0b20tc3RhcnQnIDogJ2JvdHRvbScsXG4gICAgYXM6IEJhc2VDb21wb25lbnQgPSAnc3BhbicsXG4gICAgYXV0b0FsaWduID0gZmFsc2UsXG4gICAgYXV0b0FsaWduQm91bmRhcnksXG4gICAgY2FyZXQgPSBpc1RhYlRpcCA/IGZhbHNlIDogdHJ1ZSxcbiAgICBjbGFzc05hbWU6IGN1c3RvbUNsYXNzTmFtZSxcbiAgICBjaGlsZHJlbixcbiAgICBkcm9wU2hhZG93ID0gdHJ1ZSxcbiAgICBoaWdoQ29udHJhc3QgPSBmYWxzZSxcbiAgICBvblJlcXVlc3RDbG9zZSxcbiAgICBvcGVuLFxuICAgIGFsaWdubWVudEF4aXNPZmZzZXQsXG4gICAgLi4ucmVzdFxuICB9ID0gX3JlZjtcbiAgY29uc3QgcHJlZml4ID0gdXNlUHJlZml4KCk7XG4gIGNvbnN0IGZsb2F0aW5nID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBjYXJldFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgcG9wb3ZlciA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgZW5hYmxlRmxvYXRpbmdTdHlsZXMgPSB1c2VGZWF0dXJlRmxhZygnZW5hYmxlLXYxMi1keW5hbWljLWZsb2F0aW5nLXN0eWxlcycpIHx8IGF1dG9BbGlnbjtcbiAgbGV0IGFsaWduID0gbWFwUG9wb3ZlckFsaWduKGluaXRpYWxBbGlnbik7XG5cbiAgLy8gSWYgdGhlIGBQb3BvdmVyYCBpcyB0aGUgbGFzdCBmb2N1c2FibGUgaXRlbSBpbiB0aGUgdGFiIG9yZGVyLCBpdCBzaG91bGQgYWxzbyBjbG9zZSB3aGVuIHRoZSBicm93c2VyIHdpbmRvdyBsb3NlcyBmb2N1cyAgKCMxMjkyMilcbiAgdXNlV2luZG93RXZlbnQoJ2JsdXInLCAoKSA9PiB7XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIG9uUmVxdWVzdENsb3NlPy4oKTtcbiAgICB9XG4gIH0pO1xuICB1c2VXaW5kb3dFdmVudCgnY2xpY2snLCBfcmVmMiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHRhcmdldFxuICAgIH0gPSBfcmVmMjtcbiAgICBpZiAob3BlbiAmJiB0YXJnZXQgaW5zdGFuY2VvZiBOb2RlICYmICFwb3BvdmVyLmN1cnJlbnQ/LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgIG9uUmVxdWVzdENsb3NlPy4oKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFNsdWcgc3R5bGluZyBwbGFjZXMgYSBib3JkZXIgYXJvdW5kIHRoZSBwb3BvdmVyIGNvbnRlbnQgc28gdGhlIGNhcmV0XG4gIC8vIG5lZWRzIHRvIGJlIHBsYWNlZCAxcHggZnVydGhlciBvdXRzaWRlIHRoZSBwb3BvdmVyIGNvbnRlbnQuIFRvIGRvIHNvLFxuICAvLyB3ZSBsb29rIHRvIHNlZSBpZiBhbnkgb2YgdGhlIGNoaWxkcmVuIGhhcyBhIGNsYXNzTmFtZSBjb250YWluaW5nIFwic2x1Z1wiXG4gIGNvbnN0IGluaXRpYWxDYXJldEhlaWdodCA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pLnNvbWUoeCA9PiB7XG4gICAgcmV0dXJuIHg/LnByb3BzPy5jbGFzc05hbWU/LmluY2x1ZGVzKCdzbHVnJykgfHwgeD8ucHJvcHM/LmNsYXNzTmFtZT8uaW5jbHVkZXMoJ2FpLWxhYmVsJyk7XG4gIH0pID8gNyA6IDY7XG4gIC8vIFRoZXNlIGRlZmF1bHRzIG1hdGNoIHRoZSBkZWZhdWx0cyBkZWZpbmVkIGluIHBhY2thZ2VzL3N0eWxlcy9zY3NzL2NvbXBvbmVudHMvcG9wb3Zlci9fcG9wb3Zlci5zY3NzXG4gIGNvbnN0IHBvcG92ZXJEaW1lbnNpb25zID0gdXNlUmVmKHtcbiAgICBvZmZzZXQ6IDEwLFxuICAgIGNhcmV0SGVpZ2h0OiBpbml0aWFsQ2FyZXRIZWlnaHRcbiAgfSk7XG4gIHVzZUlzb21vcnBoaWNFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFRoZSBwb3BvdmVyIGlzIG9ubHkgb2Zmc2V0IHdoZW4gYSBjYXJldCBpcyBwcmVzZW50LiBUZWNobmljYWxseSwgdGhlIGN1c3RvbSBwcm9wZXJ0aWVzXG4gICAgLy8gYWNjZXNzZWQgYmVsb3cgY2FuIGJlIHNldCBieSBhIHVzZXIgZXZlbiBpZiBjYXJldD1mYWxzZSwgYnV0IGRvaW5nIHNvIGRvZXMgbm90IGZvbGxvd1xuICAgIC8vIHRoZSBkZXNpZ24gc3BlY2lmaWNhdGlvbiBmb3IgUG9wb3Zlci5cbiAgICBpZiAoY2FyZXQgJiYgcG9wb3Zlci5jdXJyZW50KSB7XG4gICAgICAvLyBHYXRoZXIgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGNhcmV0IGFuZCBwcmVmZXIgdGhlIHZhbHVlcyBzZXQgdmlhIGN1c3RvbSBwcm9wZXJ0aWVzLlxuICAgICAgLy8gSWYgYSB2YWx1ZSBpcyBub3Qgc2V0IHZpYSBhIGN1c3RvbSBwcm9wZXJ0eSwgcHJvdmlkZSBhIGRlZmF1bHQgdmFsdWUgdGhhdCBtYXRjaGVzIHRoZVxuICAgICAgLy8gZGVmYXVsdCB2YWx1ZXMgZGVmaW5lZCBpbiB0aGUgc2FzcyBzdHlsZSBmaWxlXG4gICAgICBjb25zdCBnZXRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBvcG92ZXIuY3VycmVudCwgbnVsbCk7XG4gICAgICBjb25zdCBvZmZzZXRQcm9wZXJ0eSA9IGdldFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJy0tY2RzLXBvcG92ZXItb2Zmc2V0Jyk7XG4gICAgICBjb25zdCBjYXJldFByb3BlcnR5ID0gZ2V0U3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnLS1jZHMtcG9wb3Zlci1jYXJldC1oZWlnaHQnKTtcblxuICAgICAgLy8gSGFuZGxlIGlmIHRoZSBwcm9wZXJ0eSB2YWx1ZXMgYXJlIGluIHB4IG9yIHJlbS5cbiAgICAgIC8vIFdlIHdhbnQgdG8gc3RvcmUganVzdCB0aGUgYmFzZSBudW1iZXIgdmFsdWUgd2l0aG91dCBhIHVuaXQgc3VmZml4XG4gICAgICBpZiAob2Zmc2V0UHJvcGVydHkpIHtcbiAgICAgICAgcG9wb3ZlckRpbWVuc2lvbnMuY3VycmVudC5vZmZzZXQgPSBvZmZzZXRQcm9wZXJ0eS5pbmNsdWRlcygncHgnKSA/IE51bWJlcihvZmZzZXRQcm9wZXJ0eS5zcGxpdCgncHgnLCAxKVswXSkgKiAxIDogTnVtYmVyKG9mZnNldFByb3BlcnR5LnNwbGl0KCdyZW0nLCAxKVswXSkgKiAxNjtcbiAgICAgIH1cbiAgICAgIGlmIChjYXJldFByb3BlcnR5KSB7XG4gICAgICAgIHBvcG92ZXJEaW1lbnNpb25zLmN1cnJlbnQuY2FyZXRIZWlnaHQgPSBjYXJldFByb3BlcnR5LmluY2x1ZGVzKCdweCcpID8gTnVtYmVyKGNhcmV0UHJvcGVydHkuc3BsaXQoJ3B4JywgMSlbMF0pICogMSA6IE51bWJlcihjYXJldFByb3BlcnR5LnNwbGl0KCdyZW0nLCAxKVswXSkgKiAxNjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBjb25zdCB7XG4gICAgcmVmcyxcbiAgICBmbG9hdGluZ1N0eWxlcyxcbiAgICBwbGFjZW1lbnQsXG4gICAgbWlkZGxld2FyZURhdGFcbiAgfSA9IHVzZUZsb2F0aW5nKGVuYWJsZUZsb2F0aW5nU3R5bGVzID8ge1xuICAgIHBsYWNlbWVudDogYWxpZ24sXG4gICAgLy8gVGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgcG9zaXRpb25lZCByZWxhdGl2ZSB0byBpdHMgbmVhcmVzdFxuICAgIC8vIGNvbnRhaW5pbmcgYmxvY2sgKHVzdWFsbHkgdGhlIHZpZXdwb3J0KS4gSXQgd2lsbCBpbiBtYW55IGNhc2VzIGFsc29cbiAgICAvLyDigJxicmVha+KAnSB0aGUgZmxvYXRpbmcgZWxlbWVudCBvdXQgb2YgYSBjbGlwcGluZyBhbmNlc3Rvci5cbiAgICAvLyBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL21pc2MjY2xpcHBpbmdcbiAgICBzdHJhdGVneTogJ2ZpeGVkJyxcbiAgICAvLyBNaWRkbGV3YXJlIG9yZGVyIG1hdHRlcnMsIGFycm93IHNob3VsZCBiZSBsYXN0XG4gICAgbWlkZGxld2FyZTogW29mZnNldCghaXNUYWJUaXAgPyB7XG4gICAgICBhbGlnbm1lbnRBeGlzOiBhbGlnbm1lbnRBeGlzT2Zmc2V0LFxuICAgICAgbWFpbkF4aXM6IHBvcG92ZXJEaW1lbnNpb25zPy5jdXJyZW50Py5vZmZzZXRcbiAgICB9IDogMCksIGF1dG9BbGlnbiAmJiBmbGlwKHtcbiAgICAgIGZhbGxiYWNrUGxhY2VtZW50czogaXNUYWJUaXAgPyBhbGlnbi5pbmNsdWRlcygnYm90dG9tJykgPyBbJ2JvdHRvbS1zdGFydCcsICdib3R0b20tZW5kJywgJ3RvcC1zdGFydCcsICd0b3AtZW5kJ10gOiBbJ3RvcC1zdGFydCcsICd0b3AtZW5kJywgJ2JvdHRvbS1zdGFydCcsICdib3R0b20tZW5kJ10gOiBhbGlnbi5pbmNsdWRlcygnYm90dG9tJykgPyBbJ2JvdHRvbScsICdib3R0b20tc3RhcnQnLCAnYm90dG9tLWVuZCcsICdyaWdodCcsICdyaWdodC1zdGFydCcsICdyaWdodC1lbmQnLCAnbGVmdCcsICdsZWZ0LXN0YXJ0JywgJ2xlZnQtZW5kJywgJ3RvcCcsICd0b3Atc3RhcnQnLCAndG9wLWVuZCddIDogWyd0b3AnLCAndG9wLXN0YXJ0JywgJ3RvcC1lbmQnLCAnbGVmdCcsICdsZWZ0LXN0YXJ0JywgJ2xlZnQtZW5kJywgJ3JpZ2h0JywgJ3JpZ2h0LXN0YXJ0JywgJ3JpZ2h0LWVuZCcsICdib3R0b20nLCAnYm90dG9tLXN0YXJ0JywgJ2JvdHRvbS1lbmQnXSxcbiAgICAgIGZhbGxiYWNrU3RyYXRlZ3k6ICdpbml0aWFsUGxhY2VtZW50JyxcbiAgICAgIGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb246ICdzdGFydCcsXG4gICAgICBib3VuZGFyeTogYXV0b0FsaWduQm91bmRhcnlcbiAgICB9KSwgYXJyb3coe1xuICAgICAgZWxlbWVudDogY2FyZXRSZWZcbiAgICB9KSwgYXV0b0FsaWduICYmIGhpZGUoKV0sXG4gICAgd2hpbGVFbGVtZW50c01vdW50ZWQ6IGF1dG9VcGRhdGVcbiAgfSA6IHt9XG4gIC8vIFdoZW4gYXV0b0FsaWduIGlzIHR1cm5lZCBvZmYgJiB0aGUgYGVuYWJsZS12MTItZHluYW1pYy1mbG9hdGluZy1zdHlsZXNgIGZlYXR1cmUgZmxhZyBpcyBub3RcbiAgLy8gZW5hYmxlZCwgZmxvYXRpbmctdWkgd2lsbCBub3QgYmUgdXNlZFxuICApO1xuICBjb25zdCB2YWx1ZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBmbG9hdGluZyxcbiAgICAgIHNldEZsb2F0aW5nOiByZWZzLnNldEZsb2F0aW5nLFxuICAgICAgY2FyZXRSZWYsXG4gICAgICBhdXRvQWxpZ246IGF1dG9BbGlnblxuICAgIH07XG4gIH0sIFtyZWZzLnNldEZsb2F0aW5nLCBhdXRvQWxpZ25dKTtcbiAgaWYgKGlzVGFiVGlwKSB7XG4gICAgY29uc3QgdGFiVGlwQWxpZ25tZW50cyA9IFsnYm90dG9tLXN0YXJ0JywgJ2JvdHRvbS1lbmQnXTtcbiAgICBpZiAoIXRhYlRpcEFsaWdubWVudHMuaW5jbHVkZXMoYWxpZ24pKSB7XG4gICAgICBhbGlnbiA9ICdib3R0b20tc3RhcnQnO1xuICAgIH1cbiAgfVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlbmFibGVGbG9hdGluZ1N0eWxlcykge1xuICAgICAgY29uc3QgdXBkYXRlZEZsb2F0aW5nU3R5bGVzID0ge1xuICAgICAgICAuLi5mbG9hdGluZ1N0eWxlcyxcbiAgICAgICAgdmlzaWJpbGl0eTogbWlkZGxld2FyZURhdGEuaGlkZT8ucmVmZXJlbmNlSGlkZGVuID8gJ2hpZGRlbicgOiAndmlzaWJsZSdcbiAgICAgIH07XG4gICAgICBPYmplY3Qua2V5cyh1cGRhdGVkRmxvYXRpbmdTdHlsZXMpLmZvckVhY2goc3R5bGUgPT4ge1xuICAgICAgICBpZiAocmVmcy5mbG9hdGluZy5jdXJyZW50KSB7XG4gICAgICAgICAgcmVmcy5mbG9hdGluZy5jdXJyZW50LnN0eWxlW3N0eWxlXSA9IHVwZGF0ZWRGbG9hdGluZ1N0eWxlc1tzdHlsZV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGNhcmV0ICYmIG1pZGRsZXdhcmVEYXRhICYmIG1pZGRsZXdhcmVEYXRhLmFycm93ICYmIGNhcmV0UmVmPy5jdXJyZW50KSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfSA9IG1pZGRsZXdhcmVEYXRhLmFycm93O1xuICAgICAgICBjb25zdCBzdGF0aWNTaWRlID0ge1xuICAgICAgICAgIHRvcDogJ2JvdHRvbScsXG4gICAgICAgICAgcmlnaHQ6ICdsZWZ0JyxcbiAgICAgICAgICBib3R0b206ICd0b3AnLFxuICAgICAgICAgIGxlZnQ6ICdyaWdodCdcbiAgICAgICAgfVtwbGFjZW1lbnQuc3BsaXQoJy0nKVswXV07XG4gICAgICAgIGNhcmV0UmVmLmN1cnJlbnQuc3R5bGUubGVmdCA9IHggIT0gbnVsbCA/IGAke3h9cHhgIDogJyc7XG4gICAgICAgIGNhcmV0UmVmLmN1cnJlbnQuc3R5bGUudG9wID0geSAhPSBudWxsID8gYCR7eX1weGAgOiAnJztcblxuICAgICAgICAvLyBFbnN1cmUgdGhlIHN0YXRpYyBzaWRlIGdldHMgdW5zZXQgd2hlbiBmbGlwcGluZyB0byBvdGhlciBwbGFjZW1lbnRzJyBheGVzLlxuICAgICAgICBjYXJldFJlZi5jdXJyZW50LnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgICAgIGNhcmV0UmVmLmN1cnJlbnQuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgICAgIGlmIChzdGF0aWNTaWRlKSB7XG4gICAgICAgICAgY2FyZXRSZWYuY3VycmVudC5zdHlsZVtzdGF0aWNTaWRlXSA9IGAkey1wb3BvdmVyRGltZW5zaW9ucz8uY3VycmVudD8uY2FyZXRIZWlnaHR9cHhgO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCBbZmxvYXRpbmdTdHlsZXMsIHJlZnMuZmxvYXRpbmcsIGVuYWJsZUZsb2F0aW5nU3R5bGVzLCBtaWRkbGV3YXJlRGF0YSwgcGxhY2VtZW50LCBjYXJldF0pO1xuICBjb25zdCByZWYgPSB1c2VNZXJnZWRSZWZzKFtmb3J3YXJkUmVmLCBwb3BvdmVyXSk7XG4gIGNvbnN0IGN1cnJlbnRBbGlnbm1lbnQgPSBhdXRvQWxpZ24gJiYgcGxhY2VtZW50ICE9PSBhbGlnbiA/IHBsYWNlbWVudCA6IGFsaWduO1xuICBjb25zdCBjbGFzc05hbWUgPSBjeCh7XG4gICAgW2Ake3ByZWZpeH0tLXBvcG92ZXItY29udGFpbmVyYF06IHRydWUsXG4gICAgW2Ake3ByZWZpeH0tLXBvcG92ZXItLWNhcmV0YF06IGNhcmV0LFxuICAgIFtgJHtwcmVmaXh9LS1wb3BvdmVyLS1kcm9wLXNoYWRvd2BdOiBkcm9wU2hhZG93LFxuICAgIFtgJHtwcmVmaXh9LS1wb3BvdmVyLS1oaWdoLWNvbnRyYXN0YF06IGhpZ2hDb250cmFzdCxcbiAgICBbYCR7cHJlZml4fS0tcG9wb3Zlci0tb3BlbmBdOiBvcGVuLFxuICAgIFtgJHtwcmVmaXh9LS1wb3BvdmVyLS1hdXRvLWFsaWduICR7cHJlZml4fS0tYXV0b2FsaWduYF06IGVuYWJsZUZsb2F0aW5nU3R5bGVzLFxuICAgIFtgJHtwcmVmaXh9LS1wb3BvdmVyLS0ke2N1cnJlbnRBbGlnbm1lbnR9YF06IHRydWUsXG4gICAgW2Ake3ByZWZpeH0tLXBvcG92ZXItLXRhYi10aXBgXTogaXNUYWJUaXBcbiAgfSwgY3VzdG9tQ2xhc3NOYW1lKTtcbiAgY29uc3QgbWFwcGVkQ2hpbGRyZW4gPSBSZWFjdC5DaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGNoaWxkID0+IHtcbiAgICBjb25zdCBpdGVtID0gY2hpbGQ7XG4gICAgY29uc3QgZGlzcGxheU5hbWUgPSBpdGVtPy50eXBlPy5kaXNwbGF5TmFtZTtcblxuICAgIC8qKlxuICAgICAqIE9ubHkgdHJpZ2dlciBlbGVtZW50cyAoYnV0dG9uKSBvciB0cmlnZ2VyIGNvbXBvbmVudHMgKFRvZ2dsZXRpcEJ1dHRvbikgc2hvdWxkIGJlXG4gICAgICogY2xvbmVkIGJlY2F1c2UgdGhlc2Ugd2lsbCBiZSBkZWNvcmF0ZWQgd2l0aCBhIHRyaWdnZXItc3BlY2lmaWMgY2xhc3NOYW1lIGFuZCByZWYuXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgYWxzbyBzb21lIHNwZWNpZmljIGNvbXBvbmVudHMgdGhhdCBzaG91bGQgbm90IGJlIGNsb25lZCB3aGVuIGF1dG9BbGlnblxuICAgICAqIGlzIG9uLCBldmVuIGlmIHRoZXkgYXJlIGEgdHJpZ2dlciBlbGVtZW50LlxuICAgICAqL1xuICAgIGNvbnN0IGlzVHJpZ2dlckVsZW1lbnQgPSBpdGVtPy50eXBlID09PSAnYnV0dG9uJztcbiAgICBjb25zdCBpc1RyaWdnZXJDb21wb25lbnQgPSBlbmFibGVGbG9hdGluZ1N0eWxlcyAmJiBkaXNwbGF5TmFtZSAmJiBbJ1RvZ2dsZXRpcEJ1dHRvbiddLmluY2x1ZGVzKGRpc3BsYXlOYW1lKTtcbiAgICBjb25zdCBpc0FsbG93ZWRUcmlnZ2VyQ29tcG9uZW50ID0gZW5hYmxlRmxvYXRpbmdTdHlsZXMgJiYgIVsnVG9nZ2xldGlwQ29udGVudCcsICdQb3BvdmVyQ29udGVudCddLmluY2x1ZGVzKGRpc3BsYXlOYW1lKTtcbiAgICBpZiAoLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KGl0ZW0pICYmIChpc1RyaWdnZXJFbGVtZW50IHx8IGlzVHJpZ2dlckNvbXBvbmVudCB8fCBpc0FsbG93ZWRUcmlnZ2VyQ29tcG9uZW50KSkge1xuICAgICAgY29uc3QgY2xhc3NOYW1lID0gaXRlbT8ucHJvcHM/LmNsYXNzTmFtZTtcbiAgICAgIGNvbnN0IHJlZiA9IChpdGVtPy5wcm9wcykucmVmO1xuICAgICAgY29uc3QgdGFiVGlwQ2xhc3NlcyA9IGN4KGAke3ByZWZpeH0tLXBvcG92ZXItLXRhYi10aXBfX2J1dHRvbmAsIGNsYXNzTmFtZSk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChpdGVtLCB7XG4gICAgICAgIGNsYXNzTmFtZTogaXNUYWJUaXAgJiYgaXRlbT8udHlwZSA9PT0gJ2J1dHRvbicgPyB0YWJUaXBDbGFzc2VzIDogY2xhc3NOYW1lIHx8ICcnLFxuICAgICAgICAvLyBXaXRoIGNsb25lRWxlbWVudCwgaWYgeW91IHBhc3MgYSBgcmVmYCwgaXQgb3ZlcnJpZGVzIHRoZSBvcmlnaW5hbCByZWYuXG4gICAgICAgIC8vIGh0dHBzOi8vcmVhY3QuZGV2L3JlZmVyZW5jZS9yZWFjdC9jbG9uZUVsZW1lbnQjcGFyYW1ldGVyc1xuICAgICAgICAvLyBUaGUgYmxvY2sgYmVsb3cgd29ya3MgYXJvdW5kIHRoaXMgYW5kIGVuc3VyZXMgdGhhdCB0aGUgb3JpZ2luYWwgcmVmIGlzIHN0aWxsXG4gICAgICAgIC8vIGNhbGxlZCB3aGlsZSBhbGxvd2luZyB0aGUgZmxvYXRpbmctdWkgcmVmZXJlbmNlIGVsZW1lbnQgdG8gYmUgc2V0IGFzIHdlbGwuXG4gICAgICAgIC8vIGB1c2VNZXJnZWRSZWZzYCBjYW4ndCBiZSB1c2VkIGhlcmUgYmVjYXVzZSBob29rcyBjYW4ndCBiZSBjYWxsZWQgZnJvbSB3aXRoaW4gYSBjYWxsYmFjay5cbiAgICAgICAgLy8gTW9yZSBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzg4NzMjaXNzdWVjb21tZW50LTQ4OTU3OTg3OFxuICAgICAgICByZWY6IG5vZGUgPT4ge1xuICAgICAgICAgIC8vIEZvciBhIHBvcG92ZXIsIHRoZXJlIGlzbid0IGFuIGV4cGxpY2l0IHRyaWdnZXIgY29tcG9uZW50LCBpdCdzIGp1c3QgdGhlIGZpcnN0IGNoaWxkIHRoYXQnc1xuICAgICAgICAgIC8vIHBhc3NlZCBpbiB3aGljaCBzaG91bGQgKm5vdCogYmUgUG9wb3ZlckNvbnRlbnQuXG4gICAgICAgICAgLy8gRm9yIGEgdG9nZ2xldGlwIHRoZXJlIGlzIGEgc3BlY2lmaWMgdHJpZ2dlciBjb21wb25lbnQsIFRvZ2dsZXRpcEJ1dHRvbi5cbiAgICAgICAgICAvLyBJbiBlaXRoZXIgb2YgdGhlc2UgY2FzZXMgd2Ugd2FudCB0byBzZXQgdGhpcyBhcyB0aGUgcmVmZXJlbmNlIG5vZGUgZm9yIGZsb2F0aW5nLXVpIGF1dG9BbGlnblxuICAgICAgICAgIC8vIHBvc2l0aW9uaW5nLlxuICAgICAgICAgIGlmIChlbmFibGVGbG9hdGluZ1N0eWxlcyAmJiBpdGVtPy50eXBlPy5kaXNwbGF5TmFtZSAhPT0gJ1BvcG92ZXJDb250ZW50JyB8fCBlbmFibGVGbG9hdGluZ1N0eWxlcyAmJiBpdGVtPy50eXBlPy5kaXNwbGF5TmFtZSA9PT0gJ1RvZ2dsZXRpcEJ1dHRvbicpIHtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgZm9yIGZsb2F0aW5nLXVpXG4gICAgICAgICAgICByZWZzLnNldFJlZmVyZW5jZShub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDYWxsIHRoZSBvcmlnaW5hbCByZWYsIGlmIGFueVxuICAgICAgICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZWYobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWYgIT09IG51bGwgJiYgcmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBCYXNlQ29tcG9uZW50QXNBbnkgPSBCYXNlQ29tcG9uZW50O1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUG9wb3ZlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQmFzZUNvbXBvbmVudEFzQW55LCBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIHJlZjogcmVmXG4gIH0pLCBlbmFibGVGbG9hdGluZ1N0eWxlcyB8fCBpc1RhYlRpcCA/IG1hcHBlZENoaWxkcmVuIDogY2hpbGRyZW4pKTtcbn0pO1xuXG4vLyBOb3RlOiB0aGlzIGRpc3BsYXlOYW1lIGlzIHRlbXBvcmFyaWx5IHNldCBzbyB0aGF0IFN0b3J5Ym9vayBBcmdUYWJsZVxuLy8gY29ycmVjdGx5IGRpc3BsYXlzIHRoZSBuYW1lIG9mIHRoaXMgY29tcG9uZW50XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBQb3BvdmVyLmRpc3BsYXlOYW1lID0gJ1BvcG92ZXInO1xufVxuUG9wb3Zlci5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IGhvdyB0aGUgcG9wb3ZlciBzaG91bGQgYWxpZ24gd2l0aCB0aGUgdHJpZ2dlciBlbGVtZW50XG4gICAqL1xuICBhbGlnbjogZGVwcmVjYXRlVmFsdWVzV2l0aGluKFByb3BUeXBlcy5vbmVPZihbJ3RvcCcsICd0b3AtbGVmdCcsXG4gIC8vIGRlcHJlY2F0ZWQgdXNlIHRvcC1zdGFydCBpbnN0ZWFkXG4gICd0b3AtcmlnaHQnLFxuICAvLyBkZXByZWNhdGVkIHVzZSB0b3AtZW5kIGluc3RlYWRcblxuICAnYm90dG9tJywgJ2JvdHRvbS1sZWZ0JyxcbiAgLy8gZGVwcmVjYXRlZCB1c2UgYm90dG9tLXN0YXJ0IGluc3RlYWRcbiAgJ2JvdHRvbS1yaWdodCcsXG4gIC8vIGRlcHJlY2F0ZWQgdXNlIGJvdHRvbS1lbmQgaW5zdGVhZFxuXG4gICdsZWZ0JywgJ2xlZnQtYm90dG9tJyxcbiAgLy8gZGVwcmVjYXRlZCB1c2UgbGVmdC1lbmQgaW5zdGVhZFxuICAnbGVmdC10b3AnLFxuICAvLyBkZXByZWNhdGVkIHVzZSBsZWZ0LXN0YXJ0IGluc3RlYWRcblxuICAncmlnaHQnLCAncmlnaHQtYm90dG9tJyxcbiAgLy8gZGVwcmVjYXRlZCB1c2UgcmlnaHQtZW5kIGluc3RlYWRcbiAgJ3JpZ2h0LXRvcCcsXG4gIC8vIGRlcHJlY2F0ZWQgdXNlIHJpZ2h0LXN0YXJ0IGluc3RlYWRcblxuICAvLyBuZXcgdmFsdWVzIHRvIG1hdGNoIGZsb2F0aW5nLXVpXG4gICd0b3Atc3RhcnQnLCAndG9wLWVuZCcsICdib3R0b20tc3RhcnQnLCAnYm90dG9tLWVuZCcsICdsZWZ0LWVuZCcsICdsZWZ0LXN0YXJ0JywgJ3JpZ2h0LWVuZCcsICdyaWdodC1zdGFydCddKSwgWyd0b3AnLCAndG9wLXN0YXJ0JywgJ3RvcC1lbmQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdib3R0b20tZW5kJywgJ2xlZnQnLCAnbGVmdC1zdGFydCcsICdsZWZ0LWVuZCcsICdyaWdodCcsICdyaWdodC1zdGFydCcsICdyaWdodC1lbmQnXSwgbWFwUG9wb3ZlckFsaWduKSxcbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBjdXN0b20gZWxlbWVudCBvciBjb21wb25lbnQgdG8gcmVuZGVyIHRoZSB0b3AtbGV2ZWwgbm9kZSBmb3IgdGhlXG4gICAqIGNvbXBvbmVudC5cbiAgICovXG4gIGFzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZWxlbWVudFR5cGVdKSxcbiAgLyoqXG4gICAqIFdpbGwgYXV0by1hbGlnbiB0aGUgcG9wb3ZlciBvbiBmaXJzdCByZW5kZXIgaWYgaXQgaXMgbm90IHZpc2libGUuIFRoaXMgcHJvcCBpcyBjdXJyZW50bHkgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGZ1dHVyZSBjaGFuZ2VzLlxuICAgKi9cbiAgYXV0b0FsaWduOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIFNwZWNpZnkgYSBib3VuZGluZyBlbGVtZW50IHRvIGJlIHVzZWQgZm9yIGF1dG9BbGlnbiBjYWxjdWxhdGlvbnMuIFRoZSB2aWV3cG9ydCBpcyB1c2VkIGJ5IGRlZmF1bHQuIFRoaXMgcHJvcCBpcyBjdXJyZW50bHkgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGZ1dHVyZSBjaGFuZ2VzLlxuICAgKi9cbiAgYXV0b0FsaWduQm91bmRhcnk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vbmVPZihbJ2NsaXBwaW5nQW5jZXN0b3JzJ10pLCBQcm9wVHlwZXMuZWxlbWVudFR5cGUsIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5lbGVtZW50VHlwZSksIFByb3BUeXBlcy5leGFjdCh7XG4gICAgeDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIHk6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICB3aWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gIH0pXSksXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgYSBjYXJldCBzaG91bGQgYmUgcmVuZGVyZWRcbiAgICovXG4gIGNhcmV0OiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIFByb3ZpZGUgZWxlbWVudHMgdG8gYmUgcmVuZGVyZWQgaW5zaWRlIG9mIHRoZSBjb21wb25lbnRcbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBjdXN0b20gY2xhc3MgbmFtZSB0byBiZSBhZGRlZCB0byB0aGUgb3V0ZXJtb3N0IG5vZGUgaW4gdGhlXG4gICAqIGNvbXBvbmVudFxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIGEgZHJvcCBzaGFkb3cgc2hvdWxkIGJlIHJlbmRlcmVkIG9uIHRoZSBwb3BvdmVyXG4gICAqL1xuICBkcm9wU2hhZG93OiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgY29tcG9uZW50IHVzaW5nIHRoZSBoaWdoLWNvbnRyYXN0IHZhcmlhbnRcbiAgICovXG4gIGhpZ2hDb250cmFzdDogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGNvbXBvbmVudCB1c2luZyB0aGUgdGFiIHRpcCB2YXJpYW50XG4gICAqL1xuICBpc1RhYlRpcDogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGEgaGFuZGxlciBmb3IgY2xvc2luZyBwb3BvdmVyLlxuICAgKiBUaGUgaGFuZGxlciBzaG91bGQgdGFrZSBjYXJlIG9mIGNsb3NpbmcgdGhlIHBvcG92ZXIsIGUuZy4gY2hhbmdpbmcgdGhlIGBvcGVuYCBwcm9wLlxuICAgKi9cbiAgb25SZXF1ZXN0Q2xvc2U6IFByb3BUeXBlcy5mdW5jLFxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIHRoZSBjb21wb25lbnQgaXMgY3VycmVudGx5IG9wZW4gb3IgY2xvc2VkXG4gICAqL1xuICBvcGVuOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkXG59O1xuZnVuY3Rpb24gUG9wb3ZlckNvbnRlbnRSZW5kZXJGdW5jdGlvbigvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvcHJvcC10eXBlc1xuX3JlZjMsIGZvcndhcmRSZWYpIHtcbiAgbGV0IHtcbiAgICBjbGFzc05hbWUsXG4gICAgY2hpbGRyZW4sXG4gICAgLi4ucmVzdFxuICB9ID0gX3JlZjM7XG4gIGNvbnN0IHByZWZpeCA9IHVzZVByZWZpeCgpO1xuICBjb25zdCB7XG4gICAgc2V0RmxvYXRpbmcsXG4gICAgY2FyZXRSZWYsXG4gICAgYXV0b0FsaWduXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFBvcG92ZXJDb250ZXh0KTtcbiAgY29uc3QgcmVmID0gdXNlTWVyZ2VkUmVmcyhbc2V0RmxvYXRpbmcsIGZvcndhcmRSZWZdKTtcbiAgY29uc3QgZW5hYmxlRmxvYXRpbmdTdHlsZXMgPSB1c2VGZWF0dXJlRmxhZygnZW5hYmxlLXYxMi1keW5hbWljLWZsb2F0aW5nLXN0eWxlcycpIHx8IGF1dG9BbGlnbjtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tcG9wb3ZlcmBcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBjeChgJHtwcmVmaXh9LS1wb3BvdmVyLWNvbnRlbnRgLCBjbGFzc05hbWUpLFxuICAgIHJlZjogcmVmXG4gIH0sIGNoaWxkcmVuLCBlbmFibGVGbG9hdGluZ1N0eWxlcyAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogY3goe1xuICAgICAgW2Ake3ByZWZpeH0tLXBvcG92ZXItY2FyZXRgXTogdHJ1ZSxcbiAgICAgIFtgJHtwcmVmaXh9LS1wb3BvdmVyLS1hdXRvLWFsaWduYF06IHRydWVcbiAgICB9KSxcbiAgICByZWY6IGNhcmV0UmVmXG4gIH0pKSwgIWVuYWJsZUZsb2F0aW5nU3R5bGVzICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBjeCh7XG4gICAgICBbYCR7cHJlZml4fS0tcG9wb3Zlci1jYXJldGBdOiB0cnVlXG4gICAgfSksXG4gICAgcmVmOiBjYXJldFJlZlxuICB9KSk7XG59XG5jb25zdCBQb3BvdmVyQ29udGVudCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKFBvcG92ZXJDb250ZW50UmVuZGVyRnVuY3Rpb24pO1xuUG9wb3ZlckNvbnRlbnQuZGlzcGxheU5hbWUgPSAnUG9wb3ZlckNvbnRlbnQnO1xuUG9wb3ZlckNvbnRlbnQucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogUHJvdmlkZSBlbGVtZW50cyB0byBiZSByZW5kZXJlZCBpbnNpZGUgb2YgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAvKipcbiAgICogUHJvdmlkZSBhIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGJlIGFkZGVkIHRvIHRoZSBvdXRlcm1vc3Qgbm9kZSBpbiB0aGVcbiAgICogY29tcG9uZW50XG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmdcbn07XG5cbmV4cG9ydCB7IFBvcG92ZXIsIFBvcG92ZXJDb250ZW50IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIGB1c2VEZWxheWVkU3RhdGVgIG1pcnJvcnMgYHVzZVN0YXRlYCBidXQgYWxzbyBhbGxvd3MgeW91IHRvIGFkZCBhIGRlbGF5IHRvXG4gKiB3aGVuIHlvdXIgc3RhdGUgdXBkYXRlcy4gWW91IGNhbiBwcm92aWRlIGEgc2Vjb25kIGFyZ3VtZW50IHRvIGBzZXRTdGF0ZWAsXG4gKiBgZGVsYXlNc2AsIHdoaWNoIHdpbGwgYmUgdGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIHRoZSBzdGF0ZSBpc1xuICogdXBkYXRlZC5cbiAqXG4gKiBUaGlzIGhvb2sgd2lsbCBjbGVhbiB1cCBwZW5kaW5nIHRpbWVycyBpbiBgdXNlRWZmZWN0YCBhbmQgd2lsbCBjYW5jZWwgYW55XG4gKiBwZW5kaW5nIHRpbWVycyB3aGVuIGEgYHNldFN0YXRlYCBpcyBjYWxsZWQgYmVmb3JlIHRoZSBzdGF0ZSBpcyB1cGRhdGVkIGZyb21cbiAqIGEgcHJldmlvdXMgY2FsbFxuICovXG5cbmZ1bmN0aW9uIHVzZURlbGF5ZWRTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xuICBjb25zdCB0aW1lb3V0SWQgPSB1c2VSZWYobnVsbCk7XG4gIC8vIFdlIHVzZSBgdXNlQ2FsbGJhY2tgIHRvIG1hdGNoIHRoZSBzaWduYXR1cmUgb2YgUmVhY3QncyBgdXNlU3RhdGVgIHdoaWNoIHdpbGxcbiAgLy8gYWx3YXlzIHJldHVybiB0aGUgc2FtZSByZWZlcmVuY2UgZm9yIHRoZSBgc2V0U3RhdGVgIHVwZGF0ZXJcbiAgY29uc3Qgc2V0U3RhdGVXaXRoRGVsYXkgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoc3RhdGVUb1NldCkge1xuICAgIGxldCBkZWxheU1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElkLmN1cnJlbnQgPz8gdW5kZWZpbmVkKTtcbiAgICB0aW1lb3V0SWQuY3VycmVudCA9IG51bGw7XG4gICAgaWYgKGRlbGF5TXMgPT09IDApIHtcbiAgICAgIHNldFN0YXRlKHN0YXRlVG9TZXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aW1lb3V0SWQuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNldFN0YXRlKHN0YXRlVG9TZXQpO1xuICAgICAgdGltZW91dElkLmN1cnJlbnQgPSBudWxsO1xuICAgIH0sIGRlbGF5TXMpO1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElkLmN1cnJlbnQgPz8gdW5kZWZpbmVkKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBbc3RhdGUsIHNldFN0YXRlV2l0aERlbGF5XTtcbn1cblxuZXhwb3J0IHsgdXNlRGVsYXllZFN0YXRlIH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbmZ1bmN0aW9uIHVzZU5vSW50ZXJhY3RpdmVDaGlsZHJlbihyZWYpIHtcbiAgbGV0IG1lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdjb21wb25lbnQgc2hvdWxkIGhhdmUgbm8gaW50ZXJhY3RpdmUgY2hpbGQgbm9kZXMnO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRPRE86IGh0dHBzOi8vZ2l0aHViLmNvbS9jYXJib24tZGVzaWduLXN5c3RlbS9jYXJib24vaXNzdWVzLzE5MDA1XG4gICAgLypcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAqL1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gcmVmLmN1cnJlbnQgPyBnZXRJbnRlcmFjdGl2ZUNvbnRlbnQocmVmLmN1cnJlbnQpIDogZmFsc2U7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgRXJyb3I6ICR7bWVzc2FnZX0uXFxuXFxuSW5zdGVhZCBmb3VuZDogJHtub2RlLm91dGVySFRNTH1gO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0sIFtdKTtcbiAgfVxufVxuZnVuY3Rpb24gdXNlSW50ZXJhY3RpdmVDaGlsZHJlbk5lZWREZXNjcmlwdGlvbihyZWYpIHtcbiAgbGV0IG1lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGBpbnRlcmFjdGl2ZSBjaGlsZCBub2RlKHMpIHNob3VsZCBoYXZlIGFuIFxcYGFyaWEtZGVzY3JpYmVkYnlcXGAgcHJvcGVydHlgO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRPRE86IGh0dHBzOi8vZ2l0aHViLmNvbS9jYXJib24tZGVzaWduLXN5c3RlbS9jYXJib24vaXNzdWVzLzE5MDA1XG4gICAgLypcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAqL1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gcmVmLmN1cnJlbnQgPyBnZXRJbnRlcmFjdGl2ZUNvbnRlbnQocmVmLmN1cnJlbnQpIDogZmFsc2U7XG4gICAgICBpZiAobm9kZSAmJiAhbm9kZS5oYXNBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yOiAke21lc3NhZ2V9Llxcblxcbkluc3RlYWQgZm91bmQ6ICR7bm9kZS5vdXRlckhUTUx9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gRE9NIG5vZGUgaGFzIGludGVyYWN0aXZlIGNvbnRlbnQsIG9yIGlzIGl0c2VsZlxuICogaW50ZXJhY3RpdmUuIEl0IHJldHVybnMgdGhlIGludGVyYWN0aXZlIG5vZGUgaWYgb25lIGlzIGZvdW5kXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICovXG5mdW5jdGlvbiBnZXRJbnRlcmFjdGl2ZUNvbnRlbnQobm9kZSkge1xuICBpZiAoIW5vZGUgfHwgIW5vZGUuY2hpbGROb2Rlcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChpc0ZvY3VzYWJsZShub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGZvciAoY29uc3QgY2hpbGROb2RlIG9mIG5vZGUuY2hpbGROb2Rlcykge1xuICAgIGNvbnN0IGludGVyYWN0aXZlTm9kZSA9IGdldEludGVyYWN0aXZlQ29udGVudChjaGlsZE5vZGUpO1xuICAgIGlmIChpbnRlcmFjdGl2ZU5vZGUpIHtcbiAgICAgIHJldHVybiBpbnRlcmFjdGl2ZU5vZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiBET00gbm9kZSBoYXMgYSByb2xlLCBvciBoYXMgaXRzZWxmIGEgcm9sZS5cbiAqIEl0IHJldHVybnMgdGhlIG5vZGUgd2l0aCBhIHJvbGUgaWYgb25lIGlzIGZvdW5kXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICovXG5mdW5jdGlvbiBnZXRSb2xlQ29udGVudChub2RlKSB7XG4gIGlmICghbm9kZSB8fCAhbm9kZS5jaGlsZE5vZGVzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG5vZGU/LmdldEF0dHJpYnV0ZT8uKCdyb2xlJykgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSAhPT0gJycpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBmb3IgKGNvbnN0IGNoaWxkTm9kZSBvZiBub2RlLmNoaWxkTm9kZXMpIHtcbiAgICBjb25zdCByb2xlTm9kZSA9IGdldFJvbGVDb250ZW50KGNoaWxkTm9kZSk7XG4gICAgaWYgKHJvbGVOb2RlKSB7XG4gICAgICByZXR1cm4gcm9sZU5vZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgZm9jdXNhYmxlLCBvciBub3RcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3czYy9hcmlhLXByYWN0aWNlcy9ibG9iLzA1NTNiYjUxNTg4ZmZhNTE3NTA2ZTJhMWIyY2ExNDIyZWQ0MzhjNWYvZXhhbXBsZXMvanMvdXRpbHMuanMjTDY4XG4gKi9cbmZ1bmN0aW9uIGlzRm9jdXNhYmxlKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQudGFiSW5kZXggPT09IHVuZGVmaW5lZCB8fCBlbGVtZW50LnRhYkluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZWxlbWVudC5kaXNhYmxlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzd2l0Y2ggKGVsZW1lbnQubm9kZU5hbWUpIHtcbiAgICBjYXNlICdBJzpcbiAgICAgIHJldHVybiAhIWVsZW1lbnQuaHJlZiAmJiBlbGVtZW50LnJlbCAhPT0gJ2lnbm9yZSc7XG4gICAgY2FzZSAnSU5QVVQnOlxuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZSAhPT0gJ2hpZGRlbic7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCB7IGdldEludGVyYWN0aXZlQ29udGVudCwgZ2V0Um9sZUNvbnRlbnQsIHVzZUludGVyYWN0aXZlQ2hpbGRyZW5OZWVkRGVzY3JpcHRpb24sIHVzZU5vSW50ZXJhY3RpdmVDaGlsZHJlbiB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjNcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHsgZXh0ZW5kcyBhcyBfZXh0ZW5kcyB9IGZyb20gJy4uLy4uL192aXJ0dWFsL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuanMnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUG9wb3ZlciwgUG9wb3ZlckNvbnRlbnQgfSBmcm9tICcuLi9Qb3BvdmVyL2luZGV4LmpzJztcbmltcG9ydCB7IEVzY2FwZSwgRW50ZXIsIFNwYWNlIH0gZnJvbSAnLi4vLi4vaW50ZXJuYWwva2V5Ym9hcmQva2V5cy5qcyc7XG5pbXBvcnQgeyBtYXRjaCB9IGZyb20gJy4uLy4uL2ludGVybmFsL2tleWJvYXJkL21hdGNoLmpzJztcbmltcG9ydCB7IHVzZURlbGF5ZWRTdGF0ZSB9IGZyb20gJy4uLy4uL2ludGVybmFsL3VzZURlbGF5ZWRTdGF0ZS5qcyc7XG5pbXBvcnQgeyB1c2VJZCB9IGZyb20gJy4uLy4uL2ludGVybmFsL3VzZUlkLmpzJztcbmltcG9ydCB7IHVzZU5vSW50ZXJhY3RpdmVDaGlsZHJlbiB9IGZyb20gJy4uLy4uL2ludGVybmFsL3VzZU5vSW50ZXJhY3RpdmVDaGlsZHJlbi5qcyc7XG5pbXBvcnQgeyB1c2VQcmVmaXggfSBmcm9tICcuLi8uLi9pbnRlcm5hbC91c2VQcmVmaXguanMnO1xuaW1wb3J0IHVzZUlzb21vcnBoaWNFZmZlY3QgZnJvbSAnLi4vLi4vaW50ZXJuYWwvdXNlSXNvbW9ycGhpY0VmZmVjdC5qcyc7XG5cbi8qKlxuICogRXZlbnQgdHlwZXMgdGhhdCB0cmlnZ2VyIGEgXCJkcmFnXCIgdG8gc3RvcC5cbiAqL1xuY29uc3QgRFJBR19TVE9QX0VWRU5UX1RZUEVTID0gbmV3IFNldChbJ21vdXNldXAnLCAndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnXSk7XG5jb25zdCBUb29sdGlwID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKF9yZWYsIHJlZikgPT4ge1xuICBsZXQge1xuICAgIGFzLFxuICAgIGFsaWduID0gJ3RvcCcsXG4gICAgY2xhc3NOYW1lOiBjdXN0b21DbGFzc05hbWUsXG4gICAgY2hpbGRyZW4sXG4gICAgbGFiZWwsXG4gICAgZGVzY3JpcHRpb24sXG4gICAgZW50ZXJEZWxheU1zID0gMTAwLFxuICAgIGxlYXZlRGVsYXlNcyA9IDMwMCxcbiAgICBkZWZhdWx0T3BlbiA9IGZhbHNlLFxuICAgIGNsb3NlT25BY3RpdmF0aW9uID0gZmFsc2UsXG4gICAgZHJvcFNoYWRvdyA9IGZhbHNlLFxuICAgIGhpZ2hDb250cmFzdCA9IHRydWUsXG4gICAgLi4ucmVzdFxuICB9ID0gX3JlZjtcbiAgY29uc3QgdG9vbHRpcFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW29wZW4sIHNldE9wZW5dID0gdXNlRGVsYXllZFN0YXRlKGRlZmF1bHRPcGVuKTtcbiAgY29uc3QgW2lzRHJhZ2dpbmcsIHNldElzRHJhZ2dpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZm9jdXNCeU1vdXNlLCBzZXRGb2N1c0J5TW91c2VdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNQb2ludGVySW50ZXJzZWN0aW5nLCBzZXRJc1BvaW50ZXJJbnRlcnNlY3RpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBpZCA9IHVzZUlkKCd0b29sdGlwJyk7XG4gIGNvbnN0IHByZWZpeCA9IHVzZVByZWZpeCgpO1xuICBjb25zdCBjaGlsZCA9IFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuICBjb25zdCB7XG4gICAgJ2FyaWEtbGFiZWwnOiBhcmlhTGFiZWwsXG4gICAgJ2FyaWEtbGFiZWxsZWRieSc6IGFyaWFMYWJlbGxlZEJ5LFxuICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogYXJpYURlc2NyaWJlZEJ5XG4gIH0gPSBjaGlsZD8ucHJvcHMgPz8ge307XG4gIGNvbnN0IGhhc0xhYmVsID0gISFsYWJlbDtcbiAgY29uc3QgaGFzQXJpYUxhYmVsID0gdHlwZW9mIGFyaWFMYWJlbCA9PT0gJ3N0cmluZycgPyBhcmlhTGFiZWwudHJpbSgpICE9PSAnJyA6IGZhbHNlO1xuXG4gIC8vIEFuIGBhcmlhLWxhYmVsYCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYGFyaWEtZGVzY3JpYmVkYnlgLCBidXQgd2hlbiBpdCdzXG4gIC8vIG5lZWRlZCBhbmQgdGhlIHVzZXIgZG9lc24ndCBzcGVjaWZ5IG9uZSwgdGhlIGZhbGxiYWNrIGBpZGAgaXMgdXNlZC5cbiAgY29uc3QgbGFiZWxsZWRCeSA9IGhhc0FyaWFMYWJlbCA/IG51bGwgOiBoYXNMYWJlbCA/IGFyaWFMYWJlbGxlZEJ5ID8/IGlkIDogdW5kZWZpbmVkO1xuXG4gIC8vIElmIGBhcmlhLWxhYmVsYCBpcyBwcmVzZW50LCB1c2UgYW55IHByb3ZpZGVkIGBhcmlhLWRlc2NyaWJlZGJ5YC5cbiAgLy8gSWYgbm90LCBmYWxsYmFjayB0byBjaGlsZCdzIGBhcmlhLWRlc2NyaWJlZGJ5YCBvciB0aGUgdG9vbHRpcCBgaWRgIGlmIG5lZWRlZC5cbiAgY29uc3QgZGVzY3JpYmVkQnkgPSBoYXNBcmlhTGFiZWwgPyBhcmlhRGVzY3JpYmVkQnkgOiBhcmlhRGVzY3JpYmVkQnkgPz8gKCFoYXNMYWJlbCAmJiAhYXJpYUxhYmVsbGVkQnkgPyBpZCA6IHVuZGVmaW5lZCk7XG4gIGNvbnN0IHRyaWdnZXJQcm9wcyA9IHtcbiAgICBvbkZvY3VzOiAoKSA9PiAhZm9jdXNCeU1vdXNlICYmIHNldE9wZW4odHJ1ZSksXG4gICAgb25CbHVyOiAoKSA9PiB7XG4gICAgICBzZXRPcGVuKGZhbHNlKTtcbiAgICAgIHNldEZvY3VzQnlNb3VzZShmYWxzZSk7XG4gICAgfSxcbiAgICBvbkNsaWNrOiAoKSA9PiBjbG9zZU9uQWN0aXZhdGlvbiAmJiBzZXRPcGVuKGZhbHNlKSxcbiAgICAvLyBUaGlzIHNob3VsZCBiZSBwbGFjZWQgb24gdGhlIHRyaWdnZXIgaW4gY2FzZSB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZFxuICAgIG9uTW91c2VFbnRlcixcbiAgICBvbk1vdXNlTGVhdmUsXG4gICAgb25Nb3VzZURvd24sXG4gICAgb25Nb3VzZU1vdmU6IG9uTW91c2VNb3ZlLFxuICAgIG9uVG91Y2hTdGFydDogb25EcmFnU3RhcnQsXG4gICAgJ2FyaWEtbGFiZWxsZWRieSc6IGxhYmVsbGVkQnksXG4gICAgJ2FyaWEtZGVzY3JpYmVkYnknOiBkZXNjcmliZWRCeVxuICB9O1xuICBmdW5jdGlvbiBnZXRDaGlsZEV2ZW50SGFuZGxlcnMoY2hpbGRQcm9wcykge1xuICAgIGNvbnN0IGV2ZW50SGFuZGxlckZ1bmN0aW9ucyA9IE9iamVjdC5rZXlzKHRyaWdnZXJQcm9wcykuZmlsdGVyKHByb3AgPT4gcHJvcC5zdGFydHNXaXRoKCdvbicpKTtcbiAgICBjb25zdCBldmVudEhhbmRsZXJzID0ge307XG4gICAgZXZlbnRIYW5kbGVyRnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb25OYW1lID0+IHtcbiAgICAgIGV2ZW50SGFuZGxlcnNbZnVuY3Rpb25OYW1lXSA9IGV2dCA9PiB7XG4gICAgICAgIHRyaWdnZXJQcm9wc1tmdW5jdGlvbk5hbWVdKGV2dCk7XG4gICAgICAgIGlmIChjaGlsZFByb3BzPy5bZnVuY3Rpb25OYW1lXSkge1xuICAgICAgICAgIGNoaWxkUHJvcHM/LltmdW5jdGlvbk5hbWVdKGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGV2ZW50SGFuZGxlcnM7XG4gIH1cbiAgY29uc3Qgb25LZXlEb3duID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgIGlmIChvcGVuICYmIG1hdGNoKGV2ZW50LCBFc2NhcGUpKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHNldE9wZW4oZmFsc2UpO1xuICAgIH1cbiAgICBpZiAob3BlbiAmJiBjbG9zZU9uQWN0aXZhdGlvbiAmJiAobWF0Y2goZXZlbnQsIEVudGVyKSB8fCBtYXRjaChldmVudCwgU3BhY2UpKSkge1xuICAgICAgc2V0T3BlbihmYWxzZSk7XG4gICAgfVxuICB9LCBbY2xvc2VPbkFjdGl2YXRpb24sIG9wZW4sIHNldE9wZW5dKTtcbiAgdXNlSXNvbW9ycGhpY0VmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgICBpZiAobWF0Y2goZXZlbnQsIEVzY2FwZSkpIHtcbiAgICAgICAgb25LZXlEb3duKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93bik7XG4gICAgfTtcbiAgfSwgW29wZW4sIG9uS2V5RG93bl0pO1xuICBmdW5jdGlvbiBvbk1vdXNlRW50ZXIoKSB7XG4gICAgLy8gSW50ZXJhY3RpdmUgVGFncyBzaG91bGQgbm90IHN1cHBvcnQgb25Nb3VzZUVudGVyXG4gICAgaWYgKCFyZXN0Py5vbk1vdXNlRW50ZXIpIHtcbiAgICAgIHNldElzUG9pbnRlckludGVyc2VjdGluZyh0cnVlKTtcbiAgICAgIHNldE9wZW4odHJ1ZSwgZW50ZXJEZWxheU1zKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25Nb3VzZURvd24oKSB7XG4gICAgc2V0Rm9jdXNCeU1vdXNlKHRydWUpO1xuICAgIG9uRHJhZ1N0YXJ0KCk7XG4gIH1cbiAgZnVuY3Rpb24gb25Nb3VzZUxlYXZlKCkge1xuICAgIHNldElzUG9pbnRlckludGVyc2VjdGluZyhmYWxzZSk7XG4gICAgaWYgKGlzRHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0T3BlbihmYWxzZSwgbGVhdmVEZWxheU1zKTtcbiAgfVxuICBmdW5jdGlvbiBvbk1vdXNlTW92ZShldnQpIHtcbiAgICBpZiAoZXZ0LmJ1dHRvbnMgPT09IDEpIHtcbiAgICAgIHNldElzRHJhZ2dpbmcodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldElzRHJhZ2dpbmcoZmFsc2UpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvbkRyYWdTdGFydCgpIHtcbiAgICBzZXRJc0RyYWdnaW5nKHRydWUpO1xuICB9XG4gIGNvbnN0IG9uRHJhZ1N0b3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0SXNEcmFnZ2luZyhmYWxzZSk7XG4gICAgLy8gQ2xvc2UgdGhlIHRvb2x0aXAsIHVubGVzcyB0aGUgbW91c2UgcG9pbnRlciBpcyB3aXRoaW4gdGhlIGJvdW5kcyBvZiB0aGVcbiAgICAvLyB0cmlnZ2VyLlxuICAgIGlmICghaXNQb2ludGVySW50ZXJzZWN0aW5nKSB7XG4gICAgICBzZXRPcGVuKGZhbHNlLCBsZWF2ZURlbGF5TXMpO1xuICAgIH1cbiAgfSwgW2lzUG9pbnRlckludGVyc2VjdGluZywgbGVhdmVEZWxheU1zLCBzZXRPcGVuXSk7XG4gIHVzZU5vSW50ZXJhY3RpdmVDaGlsZHJlbih0b29sdGlwUmVmLCAnVGhlIFRvb2x0aXAgY29tcG9uZW50IG11c3QgaGF2ZSBubyBpbnRlcmFjdGl2ZSBjb250ZW50IHJlbmRlcmVkIGJ5IHRoZScgKyAnYGxhYmVsYCBvciBgZGVzY3JpcHRpb25gIHByb3AnKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaXNEcmFnZ2luZykge1xuICAgICAgLy8gUmVnaXN0ZXIgZHJhZyBzdG9wIGhhbmRsZXJzLlxuICAgICAgRFJBR19TVE9QX0VWRU5UX1RZUEVTLmZvckVhY2goZXZlbnRUeXBlID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIG9uRHJhZ1N0b3ApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBEUkFHX1NUT1BfRVZFTlRfVFlQRVMuZm9yRWFjaChldmVudFR5cGUgPT4ge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgb25EcmFnU3RvcCk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbaXNEcmFnZ2luZywgb25EcmFnU3RvcF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUG9wb3ZlciwgX2V4dGVuZHMoe1xuICAgIGFzOiBhcyxcbiAgICByZWY6IHJlZlxuICB9LCByZXN0LCB7XG4gICAgYWxpZ246IGFsaWduLFxuICAgIGNsYXNzTmFtZTogY3goYCR7cHJlZml4fS0tdG9vbHRpcGAsIGN1c3RvbUNsYXNzTmFtZSksXG4gICAgZHJvcFNoYWRvdzogZHJvcFNoYWRvdyxcbiAgICBoaWdoQ29udHJhc3Q6IGhpZ2hDb250cmFzdCxcbiAgICBvbktleURvd246IG9uS2V5RG93bixcbiAgICBvbk1vdXNlTGVhdmU6IG9uTW91c2VMZWF2ZSxcbiAgICBvcGVuOiBvcGVuXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS10b29sdGlwLXRyaWdnZXJfX3dyYXBwZXJgXG4gIH0sIGNoaWxkICE9PSB1bmRlZmluZWQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgLi4udHJpZ2dlclByb3BzLFxuICAgIC4uLmdldENoaWxkRXZlbnRIYW5kbGVycyhjaGlsZC5wcm9wcylcbiAgfSkgOiBudWxsKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUG9wb3ZlckNvbnRlbnQsIHtcbiAgICBcImFyaWEtaGlkZGVuXCI6IG9wZW4gPyAnZmFsc2UnIDogJ3RydWUnLFxuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tdG9vbHRpcC1jb250ZW50YCxcbiAgICBpZDogaWQsXG4gICAgb25Nb3VzZUVudGVyOiBvbk1vdXNlRW50ZXIsXG4gICAgcm9sZTogXCJ0b29sdGlwXCJcbiAgfSwgbGFiZWwgfHwgZGVzY3JpcHRpb24pKTtcbn0pO1xuVG9vbHRpcC5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IGhvdyB0aGUgdHJpZ2dlciBzaG91bGQgYWxpZ24gd2l0aCB0aGUgdG9vbHRpcFxuICAgKi9cbiAgYWxpZ246IFByb3BUeXBlcy5vbmVPZihbJ3RvcCcsICd0b3AtbGVmdCcsXG4gIC8vIGRlcHJlY2F0ZWQgdXNlIHRvcC1zdGFydCBpbnN0ZWFkXG4gICd0b3AtcmlnaHQnLFxuICAvLyBkZXByZWNhdGVkIHVzZSB0b3AtZW5kIGluc3RlYWRcblxuICAnYm90dG9tJywgJ2JvdHRvbS1sZWZ0JyxcbiAgLy8gZGVwcmVjYXRlZCB1c2UgYm90dG9tLXN0YXJ0IGluc3RlYWRcbiAgJ2JvdHRvbS1yaWdodCcsXG4gIC8vIGRlcHJlY2F0ZWQgdXNlIGJvdHRvbS1lbmQgaW5zdGVhZFxuXG4gICdsZWZ0JywgJ2xlZnQtYm90dG9tJyxcbiAgLy8gZGVwcmVjYXRlZCB1c2UgbGVmdC1lbmQgaW5zdGVhZFxuICAnbGVmdC10b3AnLFxuICAvLyBkZXByZWNhdGVkIHVzZSBsZWZ0LXN0YXJ0IGluc3RlYWRcblxuICAncmlnaHQnLCAncmlnaHQtYm90dG9tJyxcbiAgLy8gZGVwcmVjYXRlZCB1c2UgcmlnaHQtZW5kIGluc3RlYWRcbiAgJ3JpZ2h0LXRvcCcsXG4gIC8vIGRlcHJlY2F0ZWQgdXNlIHJpZ2h0LXN0YXJ0IGluc3RlYWRcblxuICAvLyBuZXcgdmFsdWVzIHRvIG1hdGNoIGZsb2F0aW5nLXVpXG4gICd0b3Atc3RhcnQnLCAndG9wLWVuZCcsICdib3R0b20tc3RhcnQnLCAnYm90dG9tLWVuZCcsICdsZWZ0LWVuZCcsICdsZWZ0LXN0YXJ0JywgJ3JpZ2h0LWVuZCcsICdyaWdodC1zdGFydCddKSxcbiAgLyoqXG4gICAqIFBhc3MgaW4gdGhlIGNoaWxkIHRvIHdoaWNoIHRoZSB0b29sdGlwIHdpbGwgYmUgYXBwbGllZFxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAvKipcbiAgICogU3BlY2lmeSBhbiBvcHRpb25hbCBjbGFzc05hbWUgdG8gYmUgYXBwbGllZCB0byB0aGUgY29udGFpbmVyIG5vZGVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAqIERldGVybWluZXMgd2V0aGVyIHRoZSB0b29sdGlwIHNob3VsZCBjbG9zZSB3aGVuIGlubmVyIGNvbnRlbnQgaXMgYWN0aXZhdGVkIChjbGljaywgRW50ZXIgb3IgU3BhY2UpXG4gICAqL1xuICBjbG9zZU9uQWN0aXZhdGlvbjogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgdGhlIHRvb2x0aXAgc2hvdWxkIGJlIG9wZW4gd2hlbiBpdCBmaXJzdCByZW5kZXJzXG4gICAqL1xuICBkZWZhdWx0T3BlbjogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBQcm92aWRlIHRoZSBkZXNjcmlwdGlvbiB0byBiZSByZW5kZXJlZCBpbnNpZGUgb2YgdGhlIFRvb2x0aXAuIFRoZVxuICAgKiBkZXNjcmlwdGlvbiB3aWxsIHVzZSBgYXJpYS1kZXNjcmliZWRieWAgYW5kIHdpbGwgZGVzY3JpYmUgdGhlIGNoaWxkIG5vZGVcbiAgICogaW4gYWRkaXRpb24gdG8gdGhlIHRleHQgcmVuZGVyZWQgaW5zaWRlIG9mIHRoZSBjaGlsZC4gVGhpcyBtZWFucyB0aGF0IGlmIHlvdVxuICAgKiBoYXZlIHRleHQgaW4gdGhlIGNoaWxkIG5vZGUsIHRoYXQgaXQgd2lsbCBiZSBhbm5vdW5jZWQgYWxvbmdzaWRlIHRoZVxuICAgKiBkZXNjcmlwdGlvbiB0byB0aGUgc2NyZWVuIHJlYWRlci5cbiAgICpcbiAgICogTm90ZTogaWYgbGFiZWwgYW5kIGRlc2NyaXB0aW9uIGFyZSBib3RoIHByb3ZpZGVkLCBsYWJlbCB3aWxsIGJlIHVzZWQgYW5kXG4gICAqIGRlc2NyaXB0aW9uIHdpbGwgbm90IGJlIHVzZWRcbiAgICovXG4gIGRlc2NyaXB0aW9uOiBQcm9wVHlwZXMubm9kZSxcbiAgLyoqXG4gICAqIFNwZWNpZnkgd2hldGhlciBhIGRyb3Agc2hhZG93IHNob3VsZCBiZSByZW5kZXJlZFxuICAgKi9cbiAgZHJvcFNoYWRvdzogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgYmVmb3JlIGRpc3BsYXlpbmcgdGhlIHRvb2x0aXBcbiAgICovXG4gIGVudGVyRGVsYXlNczogUHJvcFR5cGVzLm51bWJlcixcbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgY29tcG9uZW50IHVzaW5nIHRoZSBoaWdoLWNvbnRyYXN0IHRoZW1lXG4gICAqL1xuICBoaWdoQ29udHJhc3Q6IFByb3BUeXBlcy5ib29sLFxuICAvKipcbiAgICogUHJvdmlkZSB0aGUgbGFiZWwgdG8gYmUgcmVuZGVyZWQgaW5zaWRlIG9mIHRoZSBUb29sdGlwLiBUaGUgbGFiZWwgd2lsbCB1c2VcbiAgICogYGFyaWEtbGFiZWxsZWRieWAgYW5kIHdpbGwgZnVsbHkgZGVzY3JpYmUgdGhlIGNoaWxkIG5vZGUgdGhhdCBpcyBwcm92aWRlZC5cbiAgICogVGhpcyBtZWFucyB0aGF0IGlmIHlvdSBoYXZlIHRleHQgaW4gdGhlIGNoaWxkIG5vZGUsIHRoYXQgaXQgd2lsbCBub3QgYmVcbiAgICogYW5ub3VuY2VkIHRvIHRoZSBzY3JlZW4gcmVhZGVyLlxuICAgKlxuICAgKiBOb3RlOiBpZiBsYWJlbCBhbmQgZGVzY3JpcHRpb24gYXJlIGJvdGggcHJvdmlkZWQsIGRlc2NyaXB0aW9uIHdpbGwgbm90IGJlXG4gICAqIHVzZWRcbiAgICovXG4gIGxhYmVsOiBQcm9wVHlwZXMubm9kZSxcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyB0byBkZWxheSBiZWZvcmUgaGlkaW5nIHRoZSB0b29sdGlwXG4gICAqL1xuICBsZWF2ZURlbGF5TXM6IFByb3BUeXBlcy5udW1iZXJcbn07XG5cbmV4cG9ydCB7IFRvb2x0aXAgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIzXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyB1c2VQcmVmaXggfSBmcm9tICcuLi8uLi9pbnRlcm5hbC91c2VQcmVmaXguanMnO1xuaW1wb3J0IHsgdXNlSWQgfSBmcm9tICcuLi8uLi9pbnRlcm5hbC91c2VJZC5qcyc7XG5cbmNvbnN0IEJ1dHRvbkJhc2UgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBCdXR0b25CYXNlKF9yZWYsIHJlZikge1xuICBsZXQge1xuICAgIGFzLFxuICAgIGNoaWxkcmVuLFxuICAgIGNsYXNzTmFtZSxcbiAgICBkYW5nZXJEZXNjcmlwdGlvbiA9ICdkYW5nZXInLFxuICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgaGFzSWNvbk9ubHkgPSBmYWxzZSxcbiAgICBocmVmLFxuICAgIGljb25EZXNjcmlwdGlvbixcbiAgICBpc0V4cHJlc3NpdmUgPSBmYWxzZSxcbiAgICBpc1NlbGVjdGVkLFxuICAgIGtpbmQgPSAncHJpbWFyeScsXG4gICAgb25CbHVyLFxuICAgIG9uQ2xpY2ssXG4gICAgb25Gb2N1cyxcbiAgICBvbk1vdXNlRW50ZXIsXG4gICAgb25Nb3VzZUxlYXZlLFxuICAgIHJlbmRlckljb246IEJ1dHRvbkltYWdlRWxlbWVudCxcbiAgICBzaXplLFxuICAgIHRhYkluZGV4LFxuICAgIHR5cGUgPSAnYnV0dG9uJyxcbiAgICAuLi5yZXN0XG4gIH0gPSBfcmVmO1xuICBjb25zdCBwcmVmaXggPSB1c2VQcmVmaXgoKTtcbiAgY29uc3QgYnV0dG9uQ2xhc3NlcyA9IGN4KGNsYXNzTmFtZSwge1xuICAgIFtgJHtwcmVmaXh9LS1idG5gXTogdHJ1ZSxcbiAgICBbYCR7cHJlZml4fS0tYnRuLS1zbWBdOiBzaXplID09PSAnc20nICYmICFpc0V4cHJlc3NpdmUsXG4gICAgLy8gVE9ETzogVjEyIC0gUmVtb3ZlIHRoaXMgY2xhc3NcbiAgICBbYCR7cHJlZml4fS0tYnRuLS1tZGBdOiBzaXplID09PSAnbWQnICYmICFpc0V4cHJlc3NpdmUsXG4gICAgLy8gVE9ETzogVjEyIC0gUmVtb3ZlIHRoaXMgY2xhc3NcbiAgICBbYCR7cHJlZml4fS0tYnRuLS1sZ2BdOiBzaXplID09PSAnbGcnICYmICFpc0V4cHJlc3NpdmUsXG4gICAgLy8gVE9ETzogVjEyIC0gUmVtb3ZlIHRoaXMgY2xhc3NcbiAgICBbYCR7cHJlZml4fS0tYnRuLS14bGBdOiBzaXplID09PSAneGwnLFxuICAgIC8vIFRPRE86IFYxMiAtIFJlbW92ZSB0aGlzIGNsYXNzXG4gICAgW2Ake3ByZWZpeH0tLWJ0bi0tMnhsYF06IHNpemUgPT09ICcyeGwnLFxuICAgIC8vIFRPRE86IFYxMiAtIFJlbW92ZSB0aGlzIGNsYXNzXG4gICAgW2Ake3ByZWZpeH0tLWxheW91dC0tc2l6ZS0ke3NpemV9YF06IHNpemUsXG4gICAgW2Ake3ByZWZpeH0tLWJ0bi0tJHtraW5kfWBdOiBraW5kLFxuICAgIFtgJHtwcmVmaXh9LS1idG4tLWRpc2FibGVkYF06IGRpc2FibGVkLFxuICAgIFtgJHtwcmVmaXh9LS1idG4tLWV4cHJlc3NpdmVgXTogaXNFeHByZXNzaXZlLFxuICAgIFtgJHtwcmVmaXh9LS1idG4tLWljb24tb25seWBdOiBoYXNJY29uT25seSxcbiAgICBbYCR7cHJlZml4fS0tYnRuLS1zZWxlY3RlZGBdOiBoYXNJY29uT25seSAmJiBpc1NlbGVjdGVkICYmIGtpbmQgPT09ICdnaG9zdCdcbiAgfSk7XG4gIGNvbnN0IGNvbW1vblByb3BzID0ge1xuICAgIHRhYkluZGV4LFxuICAgIGNsYXNzTmFtZTogYnV0dG9uQ2xhc3NlcyxcbiAgICByZWZcbiAgfTtcbiAgY29uc3QgYnV0dG9uSW1hZ2UgPSAhQnV0dG9uSW1hZ2VFbGVtZW50ID8gbnVsbCA6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEJ1dHRvbkltYWdlRWxlbWVudCwge1xuICAgIFwiYXJpYS1sYWJlbFwiOiBpY29uRGVzY3JpcHRpb24sXG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS1idG5fX2ljb25gLFxuICAgIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCJcbiAgfSk7XG4gIGNvbnN0IGRhbmdlckJ1dHRvblZhcmlhbnRzID0gWydkYW5nZXInLCAnZGFuZ2VyLS10ZXJ0aWFyeScsICdkYW5nZXItLWdob3N0J107XG4gIGxldCBjb21wb25lbnQgPSAnYnV0dG9uJztcbiAgY29uc3QgYXNzaXN0aXZlSWQgPSB1c2VJZCgnZGFuZ2VyLWRlc2NyaXB0aW9uJyk7XG4gIGNvbnN0IHtcbiAgICAnYXJpYS1wcmVzc2VkJzogYXJpYVByZXNzZWQsXG4gICAgJ2FyaWEtZGVzY3JpYmVkYnknOiBhcmlhRGVzY3JpYmVkQnlcbiAgfSA9IHJlc3Q7XG4gIGxldCBvdGhlclByb3BzID0ge1xuICAgIGRpc2FibGVkLFxuICAgIHR5cGUsXG4gICAgJ2FyaWEtZGVzY3JpYmVkYnknOiBkYW5nZXJCdXR0b25WYXJpYW50cy5pbmNsdWRlcyhraW5kKSA/IGFzc2lzdGl2ZUlkIDogYXJpYURlc2NyaWJlZEJ5IHx8IHVuZGVmaW5lZCxcbiAgICAnYXJpYS1wcmVzc2VkJzogYXJpYVByZXNzZWQgPz8gKGhhc0ljb25Pbmx5ICYmIGtpbmQgPT09ICdnaG9zdCcgPyBpc1NlbGVjdGVkIDogdW5kZWZpbmVkKVxuICB9O1xuICBjb25zdCBhbmNob3JQcm9wcyA9IHtcbiAgICBocmVmXG4gIH07XG4gIGxldCBhc3Npc3RpdmVUZXh0ID0gbnVsbDtcbiAgaWYgKGRhbmdlckJ1dHRvblZhcmlhbnRzLmluY2x1ZGVzKGtpbmQpKSB7XG4gICAgYXNzaXN0aXZlVGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICBpZDogYXNzaXN0aXZlSWQsXG4gICAgICBjbGFzc05hbWU6IGAke3ByZWZpeH0tLXZpc3VhbGx5LWhpZGRlbmBcbiAgICB9LCBkYW5nZXJEZXNjcmlwdGlvbik7XG4gIH1cbiAgaWYgKGFzKSB7XG4gICAgY29tcG9uZW50ID0gYXM7XG4gICAgb3RoZXJQcm9wcyA9IHtcbiAgICAgIC4uLm90aGVyUHJvcHMsXG4gICAgICAuLi5hbmNob3JQcm9wc1xuICAgIH07XG4gIH0gZWxzZSBpZiAoaHJlZiAmJiAhZGlzYWJsZWQpIHtcbiAgICBjb21wb25lbnQgPSAnYSc7XG4gICAgb3RoZXJQcm9wcyA9IGFuY2hvclByb3BzO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHtcbiAgICBvbk1vdXNlRW50ZXIsXG4gICAgb25Nb3VzZUxlYXZlLFxuICAgIG9uRm9jdXMsXG4gICAgb25CbHVyLFxuICAgIG9uQ2xpY2ssXG4gICAgLi4ucmVzdCxcbiAgICAuLi5jb21tb25Qcm9wcyxcbiAgICAuLi5vdGhlclByb3BzXG4gIH0sIGFzc2lzdGl2ZVRleHQsIGNoaWxkcmVuLCBidXR0b25JbWFnZSk7XG59KTtcblxuZXhwb3J0IHsgQnV0dG9uQmFzZSBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBleHRlbmRzIGFzIF9leHRlbmRzIH0gZnJvbSAnLi4vLi4vX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5qcyc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IHVzZVByZWZpeCB9IGZyb20gJy4uLy4uL2ludGVybmFsL3VzZVByZWZpeC5qcyc7XG5cbmNvbnN0IEJhZGdlSW5kaWNhdG9yID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gQmFkZ2VJbmRpY2F0b3JDb250ZW50KF9yZWYsIHJlZikge1xuICBsZXQge1xuICAgIGNsYXNzTmFtZTogY3VzdG9tQ2xhc3NOYW1lLFxuICAgIGNvdW50LFxuICAgIC4uLnJlc3RcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHByZWZpeCA9IHVzZVByZWZpeCgpO1xuICBjb25zdCBjbGFzc05hbWVzID0gY3goYCR7cHJlZml4fS0tYmFkZ2UtaW5kaWNhdG9yYCwgY3VzdG9tQ2xhc3NOYW1lLCB7XG4gICAgW2Ake3ByZWZpeH0tLWJhZGdlLWluZGljYXRvci0tY291bnRgXTogY291bnRcbiAgfSk7XG4gIGNvbnN0IGRpc3BsYXlDb3VudCA9IGNvdW50ICYmIGNvdW50ID4gOTk5ID8gJzk5OSsnIDogY291bnQ7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzLFxuICAgIHJlZjogcmVmXG4gIH0sIHJlc3QpLCBkaXNwbGF5Q291bnQpO1xufSk7XG5CYWRnZUluZGljYXRvci5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IGFuIG9wdGlvbmFsIGNsYXNzTmFtZSB0byBhZGQuXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8qKlxuICAgKiBDb3VudCBvZiBiYWRnZSBpbmRpY2F0b3JcbiAgICovXG4gIGNvdW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICAvKipcbiAgICogUHJvdmlkZSBhbiBgaWRgIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoZSBCYWRnZUluZGlkY2F0b3JcbiAgICovXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5leHBvcnQgeyBCYWRnZUluZGljYXRvciwgQmFkZ2VJbmRpY2F0b3IgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjNcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHsgZXh0ZW5kcyBhcyBfZXh0ZW5kcyB9IGZyb20gJy4uLy4uL192aXJ0dWFsL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuanMnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgJy4uL1Rvb2x0aXAvRGVmaW5pdGlvblRvb2x0aXAuanMnO1xuaW1wb3J0IHsgVG9vbHRpcCB9IGZyb20gJy4uL1Rvb2x0aXAvVG9vbHRpcC5qcyc7XG5pbXBvcnQgeyB1c2VJZCB9IGZyb20gJy4uLy4uL2ludGVybmFsL3VzZUlkLmpzJztcbmltcG9ydCB7IHVzZVByZWZpeCB9IGZyb20gJy4uLy4uL2ludGVybmFsL3VzZVByZWZpeC5qcyc7XG5pbXBvcnQgQnV0dG9uQmFzZSBmcm9tICcuLi9CdXR0b24vQnV0dG9uQmFzZS5qcyc7XG5pbXBvcnQgZGVwcmVjYXRlVmFsdWVzV2l0aGluIGZyb20gJy4uLy4uL3Byb3AtdHlwZXMvZGVwcmVjYXRlVmFsdWVzV2l0aGluLmpzJztcbmltcG9ydCB7IEJhZGdlSW5kaWNhdG9yIH0gZnJvbSAnLi4vQmFkZ2VJbmRpY2F0b3IvaW5kZXguanMnO1xuaW1wb3J0IHsgbWFwUG9wb3ZlckFsaWduIH0gZnJvbSAnLi4vLi4vdG9vbHMvbWFwUG9wb3ZlckFsaWduLmpzJztcblxuY29uc3QgSWNvbkJ1dHRvbktpbmRzID0gWydwcmltYXJ5JywgJ3NlY29uZGFyeScsICdnaG9zdCcsICd0ZXJ0aWFyeSddO1xuY29uc3QgSWNvbkJ1dHRvbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEljb25CdXR0b24oX3JlZiwgcmVmKSB7XG4gIGxldCB7XG4gICAgYWxpZ24sXG4gICAgYXV0b0FsaWduID0gZmFsc2UsXG4gICAgYmFkZ2VDb3VudCxcbiAgICBjaGlsZHJlbixcbiAgICBjbGFzc05hbWUsXG4gICAgY2xvc2VPbkFjdGl2YXRpb24gPSB0cnVlLFxuICAgIGRlZmF1bHRPcGVuID0gZmFsc2UsXG4gICAgZGlzYWJsZWQsXG4gICAgZHJvcFNoYWRvdyA9IGZhbHNlLFxuICAgIGVudGVyRGVsYXlNcyA9IDEwMCxcbiAgICBoaWdoQ29udHJhc3QgPSB0cnVlLFxuICAgIGtpbmQsXG4gICAgbGFiZWwsXG4gICAgbGVhdmVEZWxheU1zID0gMTAwLFxuICAgIHdyYXBwZXJDbGFzc2VzLFxuICAgIHNpemUsXG4gICAgaXNTZWxlY3RlZCxcbiAgICAuLi5yZXN0XG4gIH0gPSBfcmVmO1xuICBjb25zdCBwcmVmaXggPSB1c2VQcmVmaXgoKTtcbiAgY29uc3QgdG9vbHRpcENsYXNzZXMgPSBjeCh3cmFwcGVyQ2xhc3NlcywgYCR7cHJlZml4fS0taWNvbi10b29sdGlwYCwge1xuICAgIFtgJHtwcmVmaXh9LS1pY29uLXRvb2x0aXAtLWRpc2FibGVkYF06IGRpc2FibGVkXG4gIH0pO1xuICBpZiAoYmFkZ2VDb3VudCAmJiAoa2luZCAhPT0gJ2dob3N0JyB8fCBzaXplICE9PSAnbGcnKSkge1xuICAgIGNvbnNvbGUud2FybihcIlRoZSBwcm9wIEJhZGdlQ291bnQgbXVzdCBiZSB1c2VkIHdpdGggaGFzSWNvbk9ubHk9dHJ1ZSwga2luZD0nZ2hvc3QnIGFuZCBzaXplPSdsZydcIik7XG4gIH1cbiAgY29uc3QgYmFkZ2VJZCA9IHVzZUlkKCdiYWRnZS1pbmRpY2F0b3InKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRvb2x0aXAsIHtcbiAgICBhbGlnbjogYWxpZ24sXG4gICAgYXV0b0FsaWduOiBhdXRvQWxpZ24sXG4gICAgY2xvc2VPbkFjdGl2YXRpb246IGNsb3NlT25BY3RpdmF0aW9uLFxuICAgIGNsYXNzTmFtZTogdG9vbHRpcENsYXNzZXMsXG4gICAgZGVmYXVsdE9wZW46IGRlZmF1bHRPcGVuLFxuICAgIGRyb3BTaGFkb3c6IGRyb3BTaGFkb3csXG4gICAgZW50ZXJEZWxheU1zOiBlbnRlckRlbGF5TXMsXG4gICAgaGlnaENvbnRyYXN0OiBoaWdoQ29udHJhc3QsXG4gICAgbGFiZWw6IGxhYmVsLFxuICAgIGxlYXZlRGVsYXlNczogbGVhdmVEZWxheU1zXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEJ1dHRvbkJhc2UsIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgIGtpbmQ6IGtpbmQsXG4gICAgcmVmOiByZWYsXG4gICAgc2l6ZTogc2l6ZSxcbiAgICBpc1NlbGVjdGVkOiBpc1NlbGVjdGVkLFxuICAgIGhhc0ljb25Pbmx5OiB0cnVlLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIFwiYXJpYS1kZXNjcmliZWRieVwiOiByZXN0WydhcmlhLWRlc2NyaWJlZGJ5J10gfHwgYmFkZ2VDb3VudCAmJiBiYWRnZUlkXG4gIH0pLCBjaGlsZHJlbiwgIWRpc2FibGVkICYmIGJhZGdlQ291bnQgIT09IHVuZGVmaW5lZCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChCYWRnZUluZGljYXRvciwge1xuICAgIGlkOiBiYWRnZUlkLFxuICAgIGNvdW50OiBiYWRnZUNvdW50ID4gMCA/IGJhZGdlQ291bnQgOiB1bmRlZmluZWRcbiAgfSkpKTtcbn0pO1xuSWNvbkJ1dHRvbi5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IGhvdyB0aGUgdHJpZ2dlciBzaG91bGQgYWxpZ24gd2l0aCB0aGUgdG9vbHRpcFxuICAgKi9cbiAgYWxpZ246IGRlcHJlY2F0ZVZhbHVlc1dpdGhpbihQcm9wVHlwZXMub25lT2YoWyd0b3AnLCAndG9wLWxlZnQnLFxuICAvLyBkZXByZWNhdGVkIHVzZSB0b3Atc3RhcnQgaW5zdGVhZFxuICAndG9wLXJpZ2h0JyxcbiAgLy8gZGVwcmVjYXRlZCB1c2UgdG9wLWVuZCBpbnN0ZWFkXG5cbiAgJ2JvdHRvbScsICdib3R0b20tbGVmdCcsXG4gIC8vIGRlcHJlY2F0ZWQgdXNlIGJvdHRvbS1zdGFydCBpbnN0ZWFkXG4gICdib3R0b20tcmlnaHQnLFxuICAvLyBkZXByZWNhdGVkIHVzZSBib3R0b20tZW5kIGluc3RlYWRcblxuICAnbGVmdCcsICdsZWZ0LWJvdHRvbScsXG4gIC8vIGRlcHJlY2F0ZWQgdXNlIGxlZnQtZW5kIGluc3RlYWRcbiAgJ2xlZnQtdG9wJyxcbiAgLy8gZGVwcmVjYXRlZCB1c2UgbGVmdC1zdGFydCBpbnN0ZWFkXG5cbiAgJ3JpZ2h0JywgJ3JpZ2h0LWJvdHRvbScsXG4gIC8vIGRlcHJlY2F0ZWQgdXNlIHJpZ2h0LWVuZCBpbnN0ZWFkXG4gICdyaWdodC10b3AnLFxuICAvLyBkZXByZWNhdGVkIHVzZSByaWdodC1zdGFydCBpbnN0ZWFkXG5cbiAgLy8gbmV3IHZhbHVlcyB0byBtYXRjaCBmbG9hdGluZy11aVxuICAndG9wLXN0YXJ0JywgJ3RvcC1lbmQnLCAnYm90dG9tLXN0YXJ0JywgJ2JvdHRvbS1lbmQnLCAnbGVmdC1lbmQnLCAnbGVmdC1zdGFydCcsICdyaWdodC1lbmQnLCAncmlnaHQtc3RhcnQnXSksIFsndG9wJywgJ3RvcC1zdGFydCcsICd0b3AtZW5kJywgJ2JvdHRvbScsICdib3R0b20tc3RhcnQnLCAnYm90dG9tLWVuZCcsICdsZWZ0JywgJ2xlZnQtc3RhcnQnLCAnbGVmdC1lbmQnLCAncmlnaHQnLCAncmlnaHQtc3RhcnQnLCAncmlnaHQtZW5kJ10sIG1hcFBvcG92ZXJBbGlnbiksXG4gIC8qKlxuICAgKiAqKkV4cGVyaW1lbnRhbCoqOiBXaWxsIGF0dGVtcHQgdG8gYXV0b21hdGljYWxseSBhbGlnbiB0aGUgdG9vbHRpcFxuICAgKi9cbiAgYXV0b0FsaWduOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqICoqRXhwZXJpbWVudGFsKio6IERpc3BsYXkgYSBiYWRnZSBvbiB0aGUgYnV0dG9uLiBBbiBlbXB0eS9kb3QgYmFkZ2UgaWYgMCwgYSBudW1iZXJlZCBiYWRnZSBpZiA+IDAuXG4gICAqIE11c3QgYmUgdXNlZCB3aXRoIHNpemU9XCJsZ1wiLCBraW5kPVwiZ2hvc3RcIiBhbmQgaGFzSWNvbk9ubHk9dHJ1ZVxuICAgKi9cbiAgYmFkZ2VDb3VudDogUHJvcFR5cGVzLm51bWJlcixcbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgc3BlY2lmeSBhbiBocmVmIGZvciB5b3VyIEljb25CdXR0b24gdG8gYmVjb21lIGFuIGA8YT5gIGVsZW1lbnRcbiAgICovXG4gIGhyZWY6IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8qKlxuICAgKiBQcm92aWRlIGFuIGljb24gb3IgYXNzZXQgdG8gYmUgcmVuZGVyZWQgaW5zaWRlIG9mIHRoZSBJY29uQnV0dG9uXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGFuIG9wdGlvbmFsIGNsYXNzTmFtZSB0byBiZSBhZGRlZCB0byB5b3VyIEJ1dHRvblxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB0b29sdGlwIHNob3VsZCBjbG9zZSB3aGVuIGlubmVyIGNvbnRlbnQgaXMgYWN0aXZhdGVkIChjbGljaywgRW50ZXIgb3IgU3BhY2UpXG4gICAqL1xuICBjbG9zZU9uQWN0aXZhdGlvbjogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgdGhlIHRvb2x0aXAgc2hvdWxkIGJlIG9wZW4gd2hlbiBpdCBmaXJzdCByZW5kZXJzXG4gICAqL1xuICBkZWZhdWx0T3BlbjogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgYSBkcm9wIHNoYWRvdyBzaG91bGQgYmUgcmVuZGVyZWQgb24gdGhlIHRvb2x0aXBcbiAgICovXG4gIGRyb3BTaGFkb3c6IFByb3BUeXBlcy5ib29sLFxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIHRoZSBCdXR0b24gc2hvdWxkIGJlIGRpc2FibGVkLCBvciBub3RcbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyB0byBkZWxheSBiZWZvcmUgZGlzcGxheWluZyB0aGUgdG9vbHRpcFxuICAgKi9cbiAgZW50ZXJEZWxheU1zOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIHRoZSBJY29uQnV0dG9uIGlzIGN1cnJlbnRseSBzZWxlY3RlZFxuICAgKi9cbiAgaXNTZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIHRvb2x0aXAgdXNpbmcgdGhlIGhpZ2gtY29udHJhc3QgdGhlbWVcbiAgICovXG4gIGhpZ2hDb250cmFzdDogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSB0eXBlIG9mIGJ1dHRvbiB0byBiZSB1c2VkIGFzIHRoZSBiYXNlIGZvciB0aGUgSWNvbkJ1dHRvblxuICAgKi9cbiAga2luZDogUHJvcFR5cGVzLm9uZU9mKEljb25CdXR0b25LaW5kcyksXG4gIC8qKlxuICAgKiBQcm92aWRlIHRoZSBsYWJlbCB0byBiZSByZW5kZXJlZCBpbnNpZGUgb2YgdGhlIFRvb2x0aXAuIFRoZSBsYWJlbCB3aWxsIHVzZVxuICAgKiBgYXJpYS1sYWJlbGxlZGJ5YCBhbmQgd2lsbCBmdWxseSBkZXNjcmliZSB0aGUgY2hpbGQgbm9kZSB0aGF0IGlzIHByb3ZpZGVkLlxuICAgKiBJZiB0aGUgY2hpbGQgbm9kZSBhbHJlYWR5IGhhcyBhbiBgYXJpYS1sYWJlbGAsIHRoZSB0b29sdGlwIHdpbGwgbm90IGFwcGx5XG4gICAqIGBhcmlhLWxhYmVsbGVkYnlgLiBJZiB0aGUgY2hpbGQgbm9kZSBoYXMgYGFyaWEtbGFiZWxsZWRieWAsIHRoYXQgdmFsdWUgd2lsbFxuICAgKiBiZSB1c2VkIGluc3RlYWQuIE90aGVyd2lzZSwgdGhlIHRvb2x0aXAgd2lsbCB1c2UgaXRzIG93biBJRCBhcyB0aGUgbGFiZWwuXG4gICAqIFRoaXMgbWVhbnMgdGhhdCBpZiB5b3UgaGF2ZSB0ZXh0IGluIHRoZSBjaGlsZCBub2RlIGl0IHdpbGwgbm90IGJlXG4gICAqIGFubm91bmNlZCB0byB0aGUgc2NyZWVuIHJlYWRlci5cbiAgICogSWYgdXNpbmcgYGJhZGdlQ291bnQ9ezB9YCwgbWFrZSBzdXJlIHRoZSBsYWJlbCBleHBsYWlucyB0aGF0IHRoZXJlIGlzIGFcbiAgICogbmV3IG5vdGlmaWNhdGlvbi5cbiAgICovXG4gIGxhYmVsOiBQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkLFxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGJlZm9yZSBoaWRpbmcgdGhlIHRvb2x0aXBcbiAgICovXG4gIGxlYXZlRGVsYXlNczogUHJvcFR5cGVzLm51bWJlcixcbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgc3BlY2lmeSBhIGByZWxgIHdoZW4gdXNpbmcgYW4gYDxhPmAgZWxlbWVudC5cbiAgICovXG4gIHJlbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIHNpemUgb2YgdGhlIEJ1dHRvbi5cbiAgICovXG4gIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3NtJywgJ21kJywgJ2xnJ10pLFxuICAvKipcbiAgICogT3B0aW9uYWxseSBzcGVjaWZ5IGEgYHRhcmdldGAgd2hlbiB1c2luZyBhbiBgPGE+YCBlbGVtZW50LlxuICAgKi9cbiAgdGFyZ2V0OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvKipcbiAgICogU3BlY2lmeSBhbiBvcHRpb25hbCBjbGFzc05hbWUgdG8gYmUgYWRkZWQgdG8geW91ciBUb29sdGlwIHdyYXBwZXJcbiAgICovXG4gIHdyYXBwZXJDbGFzc2VzOiBQcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5leHBvcnQgeyBJY29uQnV0dG9uLCBJY29uQnV0dG9uS2luZHMgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIzXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCB7IGV4dGVuZHMgYXMgX2V4dGVuZHMgfSBmcm9tICcuLi8uLi9fdmlydHVhbC9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLmpzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgSWNvbkJ1dHRvbiwgSWNvbkJ1dHRvbktpbmRzIH0gZnJvbSAnLi4vSWNvbkJ1dHRvbi9pbmRleC5qcyc7XG5pbXBvcnQgQnV0dG9uQmFzZSBmcm9tICcuL0J1dHRvbkJhc2UuanMnO1xuXG5jb25zdCBCdXR0b25LaW5kcyA9IFsncHJpbWFyeScsICdzZWNvbmRhcnknLCAnZGFuZ2VyJywgJ2dob3N0JywgJ2Rhbmdlci0tcHJpbWFyeScsICdkYW5nZXItLWdob3N0JywgJ2Rhbmdlci0tdGVydGlhcnknLCAndGVydGlhcnknXTtcbmNvbnN0IEJ1dHRvblNpemVzID0gWydzbScsICdtZCcsICdsZycsICd4bCcsICcyeGwnXTtcbmNvbnN0IEJ1dHRvblRvb2x0aXBBbGlnbm1lbnRzID0gWydzdGFydCcsICdjZW50ZXInLCAnZW5kJ107XG5jb25zdCBCdXR0b25Ub29sdGlwUG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcbmZ1bmN0aW9uIGlzSWNvbk9ubHlCdXR0b24oaGFzSWNvbk9ubHksIF9raW5kKSB7XG4gIGlmIChoYXNJY29uT25seSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IEJ1dHRvbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBhcyxcbiAgICBhdXRvQWxpZ24gPSBmYWxzZSxcbiAgICBjaGlsZHJlbixcbiAgICBoYXNJY29uT25seSA9IGZhbHNlLFxuICAgIHRvb2x0aXBIaWdoQ29udHJhc3QgPSB0cnVlLFxuICAgIHRvb2x0aXBEcm9wU2hhZG93ID0gZmFsc2UsXG4gICAgaWNvbkRlc2NyaXB0aW9uLFxuICAgIGtpbmQgPSAncHJpbWFyeScsXG4gICAgb25CbHVyLFxuICAgIG9uQ2xpY2ssXG4gICAgb25Gb2N1cyxcbiAgICBvbk1vdXNlRW50ZXIsXG4gICAgb25Nb3VzZUxlYXZlLFxuICAgIHJlbmRlckljb246IEJ1dHRvbkltYWdlRWxlbWVudCxcbiAgICBzaXplLFxuICAgIHRvb2x0aXBBbGlnbm1lbnQgPSAnY2VudGVyJyxcbiAgICB0b29sdGlwUG9zaXRpb24gPSAndG9wJyxcbiAgICAuLi5yZXN0XG4gIH0gPSBwcm9wcztcbiAgaWYgKEJ1dHRvbkltYWdlRWxlbWVudCAmJiAhY2hpbGRyZW4gJiYgIWljb25EZXNjcmlwdGlvbikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0J1dHRvbjogcmVuZGVySWNvbiBwcm9wZXJ0eSBzcGVjaWZpZWQgd2l0aG91dCBhbHNvIHByb3ZpZGluZyBhbiBpY29uRGVzY3JpcHRpb24gcHJvcGVydHkuICcgKyAnVGhpcyBtYXkgaW1wYWN0IGFjY2Vzc2liaWxpdHkgZm9yIHNjcmVlbiByZWFkZXIgdXNlcnMuJyk7XG4gIH1cbiAgY29uc3QgaWNvbk9ubHlJbWFnZSA9ICFCdXR0b25JbWFnZUVsZW1lbnQgPyBudWxsIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uSW1hZ2VFbGVtZW50LCBudWxsKTtcbiAgaWYgKCFpc0ljb25Pbmx5QnV0dG9uKGhhc0ljb25Pbmx5KSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBjb25zdCB7XG4gICAgICB0b29sdGlwQWxpZ25tZW50LFxuICAgICAgLi4ucHJvcHNXaXRob3V0VG9vbHRpcEFsaWdubWVudFxuICAgIH0gPSBwcm9wcztcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uQmFzZSwgX2V4dGVuZHMoe1xuICAgICAgcmVmOiByZWZcbiAgICB9LCBwcm9wc1dpdGhvdXRUb29sdGlwQWxpZ25tZW50KSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGFsaWduID0gdW5kZWZpbmVkO1xuICAgIGlmICh0b29sdGlwUG9zaXRpb24gPT09ICd0b3AnIHx8IHRvb2x0aXBQb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIGlmICh0b29sdGlwQWxpZ25tZW50ID09PSAnY2VudGVyJykge1xuICAgICAgICBhbGlnbiA9IHRvb2x0aXBQb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmICh0b29sdGlwQWxpZ25tZW50ID09PSAnZW5kJykge1xuICAgICAgICBhbGlnbiA9IGAke3Rvb2x0aXBQb3NpdGlvbn0tZW5kYDtcbiAgICAgIH1cbiAgICAgIGlmICh0b29sdGlwQWxpZ25tZW50ID09PSAnc3RhcnQnKSB7XG4gICAgICAgIGFsaWduID0gYCR7dG9vbHRpcFBvc2l0aW9ufS1zdGFydGA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0b29sdGlwUG9zaXRpb24gPT09ICdyaWdodCcgfHwgdG9vbHRpcFBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGFsaWduID0gdG9vbHRpcFBvc2l0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIGBJY29uQnV0dG9uYCBkb2VzIG5vdCBzdXBwb3J0IGFsbCBgc2l6ZWBzIHRoYXRcbiAgICAgIC8vIGBCdXR0b25gIHN1cHBvcnRzLlxuICAgICAgLy9cbiAgICAgIC8vIFRPRE86IFdoYXQgc2hvdWxkIGJlIGRvbmUgaGVyZT9cbiAgICAgIC8vIDEuIFNob3VsZCB0aGUgYEljb25CdXR0b25gIG5vdCBiZSByZW5kZXJlZCBpZiB0aGUgYHNpemVgIGlzIG5vdFxuICAgICAgLy8gICAgc3VwcG9ydGVkP1xuICAgICAgLy8gMi4gU2hvdWxkIGFuIGVycm9yIGJlIHRocm93bj9cbiAgICAgIC8vIDMuIFNvbWV0aGluZyBlbHNlP1xuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQnV0dG9uLCBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgICAgICByZWY6IHJlZixcbiAgICAgICAgYXM6IGFzLFxuICAgICAgICBhbGlnbjogYWxpZ24sXG4gICAgICAgIGxhYmVsOiBpY29uRGVzY3JpcHRpb24sXG4gICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgIGhpZ2hDb250cmFzdDogdG9vbHRpcEhpZ2hDb250cmFzdCxcbiAgICAgICAgZHJvcFNoYWRvdzogdG9vbHRpcERyb3BTaGFkb3csXG4gICAgICAgIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVyLFxuICAgICAgICBvbk1vdXNlTGVhdmU6IG9uTW91c2VMZWF2ZSxcbiAgICAgICAgb25Gb2N1czogb25Gb2N1cyxcbiAgICAgICAgb25CbHVyOiBvbkJsdXIsXG4gICAgICAgIGF1dG9BbGlnbjogYXV0b0FsaWduLFxuICAgICAgICBvbkNsaWNrOiBvbkNsaWNrLFxuICAgICAgICByZW5kZXJJY29uOiBpY29uT25seUltYWdlID8gbnVsbCA6IEJ1dHRvbkltYWdlRWxlbWVudCAvLyBhdm9pZCBkb3VibGluZyB0aGUgaWNvbi5cbiAgICAgIH0pLCBpY29uT25seUltYWdlID8/IGNoaWxkcmVuKVxuICAgICk7XG4gIH1cbn0pO1xuQnV0dG9uLmRpc3BsYXlOYW1lID0gJ0J1dHRvbic7XG5CdXR0b24ucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogU3BlY2lmeSBob3cgdGhlIGJ1dHRvbiBpdHNlbGYgc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgKiBNYWtlIHN1cmUgdG8gYXBwbHkgYWxsIHByb3BzIHRvIHRoZSByb290IG5vZGUgYW5kIHJlbmRlciBjaGlsZHJlbiBhcHByb3ByaWF0ZWx5XG4gICAqL1xuICBhczogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5lbGVtZW50VHlwZV0pLFxuICAvKipcbiAgICogKipFeHBlcmltZW50YWwqKjogV2lsbCBhdHRlbXB0IHRvIGF1dG9tYXRpY2FsbHkgYWxpZ24gdGhlIHRvb2x0aXBcbiAgICovXG4gIGF1dG9BbGlnbjogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBjb250ZW50IG9mIHlvdXIgQnV0dG9uXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGFuIG9wdGlvbmFsIGNsYXNzTmFtZSB0byBiZSBhZGRlZCB0byB5b3VyIEJ1dHRvblxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgbWVzc2FnZSByZWFkIGJ5IHNjcmVlbiByZWFkZXJzIGZvciB0aGUgZGFuZ2VyIGJ1dHRvbiB2YXJpYW50XG4gICAqL1xuICBkYW5nZXJEZXNjcmlwdGlvbjogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAqIFNwZWNpZnkgd2hldGhlciB0aGUgQnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZCwgb3Igbm90XG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGlmIHRoZSBidXR0b24gaXMgYW4gaWNvbi1vbmx5IGJ1dHRvblxuICAgKi9cbiAgaGFzSWNvbk9ubHk6IFByb3BUeXBlcy5ib29sLFxuICAvKipcbiAgICogT3B0aW9uYWxseSBzcGVjaWZ5IGFuIGhyZWYgZm9yIHlvdXIgQnV0dG9uIHRvIGJlY29tZSBhbiBgPGE+YCBlbGVtZW50XG4gICAqL1xuICBocmVmOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvKipcbiAgICogSWYgc3BlY2lmeWluZyB0aGUgYHJlbmRlckljb25gIHByb3AsIHByb3ZpZGUgYSBkZXNjcmlwdGlvbiBmb3IgdGhhdCBpY29uIHRoYXQgY2FuXG4gICAqIGJlIHJlYWQgYnkgc2NyZWVuIHJlYWRlcnNcbiAgICovXG4gIGljb25EZXNjcmlwdGlvbjogcHJvcHMgPT4ge1xuICAgIGlmIChwcm9wcy5yZW5kZXJJY29uICYmICFwcm9wcy5jaGlsZHJlbiAmJiAhcHJvcHMuaWNvbkRlc2NyaXB0aW9uKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdyZW5kZXJJY29uIHByb3BlcnR5IHNwZWNpZmllZCB3aXRob3V0IGFsc28gcHJvdmlkaW5nIGFuIGljb25EZXNjcmlwdGlvbiBwcm9wZXJ0eS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgdGhlIEJ1dHRvbiBpcyBleHByZXNzaXZlLCBvciBub3RcbiAgICovXG4gIGlzRXhwcmVzc2l2ZTogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgdGhlIEJ1dHRvbiBpcyBjdXJyZW50bHkgc2VsZWN0ZWQuIE9ubHkgYXBwbGllcyB0byB0aGUgR2hvc3QgdmFyaWFudC5cbiAgICovXG4gIGlzU2VsZWN0ZWQ6IFByb3BUeXBlcy5ib29sLFxuICAvKipcbiAgICogU3BlY2lmeSB0aGUga2luZCBvZiBCdXR0b24geW91IHdhbnQgdG8gY3JlYXRlXG4gICAqL1xuICBraW5kOiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgaGFzSWNvbk9ubHlcbiAgICB9ID0gcHJvcHM7XG4gICAgY29uc3QgdmFsaWRLaW5kcyA9IGhhc0ljb25Pbmx5ID8gSWNvbkJ1dHRvbktpbmRzIDogQnV0dG9uS2luZHM7XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCF2YWxpZEtpbmRzLmluY2x1ZGVzKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoYEludmFsaWQgcHJvcCBcXGAke3Byb3BOYW1lfVxcYCBzdXBwbGllZCB0byBcXGAke2NvbXBvbmVudE5hbWV9XFxgLiBFeHBlY3RlZCBvbmUgb2YgJHt2YWxpZEtpbmRzLmpvaW4oJywgJyl9LmApO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgLyoqXG4gICAqIFByb3ZpZGUgYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGJ1dHRvbiBlbGVtZW50XG4gICAqIGxvc2VzIGZvY3VzXG4gICAqL1xuICBvbkJsdXI6IFByb3BUeXBlcy5mdW5jLFxuICAvKipcbiAgICogUHJvdmlkZSBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgYnV0dG9uIGVsZW1lbnRcbiAgICogaXMgY2xpY2tlZFxuICAgKi9cbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gIC8qKlxuICAgKiBQcm92aWRlIGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBidXR0b24gZWxlbWVudFxuICAgKiByZWNlaXZlcyBmb2N1c1xuICAgKi9cbiAgb25Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG4gIC8qKlxuICAgKiBQcm92aWRlIGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBtb3VzZVxuICAgKiBlbnRlcnMgdGhlIGJ1dHRvbiBlbGVtZW50XG4gICAqL1xuICBvbk1vdXNlRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAvKipcbiAgICogUHJvdmlkZSBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgbW91c2VcbiAgICogbGVhdmVzIHRoZSBidXR0b24gZWxlbWVudFxuICAgKi9cbiAgb25Nb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgc3BlY2lmeSBhIGByZWxgIHdoZW4gdXNpbmcgYW4gYDxhPmAgZWxlbWVudC5cbiAgICovXG4gIHJlbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAqIEEgY29tcG9uZW50IHVzZWQgdG8gcmVuZGVyIGFuIGljb24uXG4gICAqL1xuICByZW5kZXJJY29uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm9iamVjdF0pLFxuICAvKipcbiAgICogT3B0aW9uYWwgcHJvcCB0byBzcGVjaWZ5IHRoZSByb2xlIG9mIHRoZSBCdXR0b25cbiAgICovXG4gIHJvbGU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBzaXplIG9mIHRoZSBidXR0b24sIGZyb20gdGhlIGZvbGxvd2luZyBsaXN0IG9mIHNpemVzOlxuICAgKi9cbiAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsnc20nLCAnbWQnLCAnbGcnLCAneGwnLCAnMnhsJ10pLFxuICAvKipcbiAgICogT3B0aW9uYWwgcHJvcCB0byBzcGVjaWZ5IHRoZSB0YWJJbmRleCBvZiB0aGUgQnV0dG9uXG4gICAqL1xuICB0YWJJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgc3BlY2lmeSBhIGB0YXJnZXRgIHdoZW4gdXNpbmcgYW4gYDxhPmAgZWxlbWVudC5cbiAgICovXG4gIHRhcmdldDogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGFsaWdubWVudCBvZiB0aGUgdG9vbHRpcCB0byB0aGUgaWNvbi1vbmx5IGJ1dHRvbi5cbiAgICogQ2FuIGJlIG9uZSBvZjogc3RhcnQsIGNlbnRlciwgb3IgZW5kLlxuICAgKi9cbiAgdG9vbHRpcEFsaWdubWVudDogUHJvcFR5cGVzLm9uZU9mKFsnc3RhcnQnLCAnY2VudGVyJywgJ2VuZCddKSxcbiAgLyoqXG4gICAqIEVuYWJsZSBkcm9wIHNoYWRvdyBmb3IgdG9vbHRpcHMgZm9yIGljb24tb25seSBidXR0b25zLlxuICAgKi9cbiAgdG9vbHRpcERyb3BTaGFkb3c6IFByb3BUeXBlcy5ib29sLFxuICAvKipcbiAgICogRW5hYmxlIGhpZ2gtY29udHJhc3QgdGhlbWUgZm9yIHRvb2x0aXBzIGZvciBpY29uLW9ubHkgYnV0dG9ucy5cbiAgICogRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICovXG4gIHRvb2x0aXBIaWdoQ29udHJhc3Q6IFByb3BUeXBlcy5ib29sLFxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgZGlyZWN0aW9uIG9mIHRoZSB0b29sdGlwIGZvciBpY29uLW9ubHkgYnV0dG9ucy5cbiAgICogQ2FuIGJlIGVpdGhlciB0b3AsIHJpZ2h0LCBib3R0b20sIG9yIGxlZnQuXG4gICAqL1xuICB0b29sdGlwUG9zaXRpb246IFByb3BUeXBlcy5vbmVPZihbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddKSxcbiAgLyoqXG4gICAqIE9wdGlvbmFsIHByb3AgdG8gc3BlY2lmeSB0aGUgdHlwZSBvZiB0aGUgQnV0dG9uXG4gICAqL1xuICB0eXBlOiBQcm9wVHlwZXMub25lT2YoWydidXR0b24nLCAncmVzZXQnLCAnc3VibWl0J10pXG59O1xuXG5leHBvcnQgeyBCdXR0b25LaW5kcywgQnV0dG9uU2l6ZXMsIEJ1dHRvblRvb2x0aXBBbGlnbm1lbnRzLCBCdXR0b25Ub29sdGlwUG9zaXRpb25zLCBCdXR0b24gYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjNcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuY29uc3Qgbm9vcEZuID0gKCkgPT4ge307XG5cbmV4cG9ydCB7IG5vb3BGbiB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjNcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHsgZXh0ZW5kcyBhcyBfZXh0ZW5kcyB9IGZyb20gJy4uLy4uL192aXJ0dWFsL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuanMnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgJy4uL1RleHQvaW5kZXguanMnO1xuaW1wb3J0IGRlcHJlY2F0ZSBmcm9tICcuLi8uLi9wcm9wLXR5cGVzL2RlcHJlY2F0ZS5qcyc7XG5pbXBvcnQgeyB1c2VQcmVmaXggfSBmcm9tICcuLi8uLi9pbnRlcm5hbC91c2VQcmVmaXguanMnO1xuaW1wb3J0IHsgV2FybmluZ0ZpbGxlZCwgV2FybmluZ0FsdEZpbGxlZCB9IGZyb20gJ0BjYXJib24vaWNvbnMtcmVhY3QnO1xuaW1wb3J0IHsgdXNlSWQgfSBmcm9tICcuLi8uLi9pbnRlcm5hbC91c2VJZC5qcyc7XG5pbXBvcnQgeyBub29wRm4gfSBmcm9tICcuLi8uLi9pbnRlcm5hbC9ub29wRm4uanMnO1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uL1RleHQvVGV4dC5qcyc7XG5cbmNvbnN0IENoZWNrYm94ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKF9yZWYsIHJlZikgPT4ge1xuICBsZXQge1xuICAgIGNsYXNzTmFtZSxcbiAgICBkZWNvcmF0b3IsXG4gICAgaGVscGVyVGV4dCxcbiAgICBpZCxcbiAgICBsYWJlbFRleHQsXG4gICAgb25DaGFuZ2UgPSBub29wRm4sXG4gICAgb25DbGljayxcbiAgICBpbmRldGVybWluYXRlID0gZmFsc2UsXG4gICAgaW52YWxpZCxcbiAgICBpbnZhbGlkVGV4dCxcbiAgICBoaWRlTGFiZWwsXG4gICAgcmVhZE9ubHksXG4gICAgdGl0bGUgPSAnJyxcbiAgICB3YXJuLFxuICAgIHdhcm5UZXh0LFxuICAgIHNsdWcsXG4gICAgLi4ub3RoZXJcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHByZWZpeCA9IHVzZVByZWZpeCgpO1xuICBjb25zdCBzaG93V2FybmluZyA9ICFyZWFkT25seSAmJiAhaW52YWxpZCAmJiB3YXJuO1xuICBjb25zdCBzaG93SGVscGVyID0gIWludmFsaWQgJiYgIXdhcm47XG4gIGNvbnN0IGNoZWNrYm94R3JvdXBJbnN0YW5jZUlkID0gdXNlSWQoKTtcbiAgY29uc3QgaGVscGVySWQgPSAhaGVscGVyVGV4dCA/IHVuZGVmaW5lZCA6IGBjaGVja2JveC1oZWxwZXItdGV4dC0ke2NoZWNrYm94R3JvdXBJbnN0YW5jZUlkfWA7XG4gIGNvbnN0IGhlbHBlciA9IGhlbHBlclRleHQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgaWQ6IGhlbHBlcklkLFxuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tZm9ybV9faGVscGVyLXRleHRgXG4gIH0sIGhlbHBlclRleHQpIDogbnVsbDtcbiAgY29uc3Qgd3JhcHBlckNsYXNzZXMgPSBjeChgJHtwcmVmaXh9LS1mb3JtLWl0ZW1gLCBgJHtwcmVmaXh9LS1jaGVja2JveC13cmFwcGVyYCwgY2xhc3NOYW1lLCB7XG4gICAgW2Ake3ByZWZpeH0tLWNoZWNrYm94LXdyYXBwZXItLXJlYWRvbmx5YF06IHJlYWRPbmx5LFxuICAgIFtgJHtwcmVmaXh9LS1jaGVja2JveC13cmFwcGVyLS1pbnZhbGlkYF06ICFyZWFkT25seSAmJiBpbnZhbGlkLFxuICAgIFtgJHtwcmVmaXh9LS1jaGVja2JveC13cmFwcGVyLS13YXJuaW5nYF06IHNob3dXYXJuaW5nLFxuICAgIFtgJHtwcmVmaXh9LS1jaGVja2JveC13cmFwcGVyLS1zbHVnYF06IHNsdWcsXG4gICAgW2Ake3ByZWZpeH0tLWNoZWNrYm94LXdyYXBwZXItLWRlY29yYXRvcmBdOiBkZWNvcmF0b3JcbiAgfSk7XG4gIGNvbnN0IGlubmVyTGFiZWxDbGFzc2VzID0gY3goYCR7cHJlZml4fS0tY2hlY2tib3gtbGFiZWwtdGV4dGAsIHtcbiAgICBbYCR7cHJlZml4fS0tdmlzdWFsbHktaGlkZGVuYF06IGhpZGVMYWJlbFxuICB9KTtcbiAgbGV0IG5vcm1hbGl6ZWREZWNvcmF0b3IgPSAvKiNfX1BVUkVfXyovUmVhY3QuaXNWYWxpZEVsZW1lbnQoc2x1ZyA/PyBkZWNvcmF0b3IpID8gc2x1ZyA/PyBkZWNvcmF0b3IgOiBudWxsO1xuICBpZiAobm9ybWFsaXplZERlY29yYXRvciAmJiBub3JtYWxpemVkRGVjb3JhdG9yWyd0eXBlJ10/LmRpc3BsYXlOYW1lID09PSAnQUlMYWJlbCcpIHtcbiAgICBjb25zdCBzaXplID0gbm9ybWFsaXplZERlY29yYXRvci5wcm9wcz8uWydraW5kJ10gPT09ICdpbmxpbmUnID8gJ21kJyA6ICdtaW5pJztcbiAgICBub3JtYWxpemVkRGVjb3JhdG9yID0gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChub3JtYWxpemVkRGVjb3JhdG9yLCB7XG4gICAgICBzaXplXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IHdyYXBwZXJDbGFzc2VzXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgX2V4dGVuZHMoe30sIG90aGVyLCB7XG4gICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgIFwiZGF0YS1pbnZhbGlkXCI6IGludmFsaWQgPyB0cnVlIDogdW5kZWZpbmVkLFxuICAgIG9uQ2hhbmdlOiBldnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiBvbkNoYW5nZSkge1xuICAgICAgICBvbkNoYW5nZShldnQsIHtcbiAgICAgICAgICBjaGVja2VkOiBldnQudGFyZ2V0LmNoZWNrZWQsXG4gICAgICAgICAgaWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeH0tLWNoZWNrYm94YCxcbiAgICBpZDogaWQsXG4gICAgcmVmOiBlbCA9PiB7XG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgZWwuaW5kZXRlcm1pbmF0ZSA9IGluZGV0ZXJtaW5hdGUgPz8gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZWYoZWwpO1xuICAgICAgfSBlbHNlIGlmIChyZWYgJiYgJ2N1cnJlbnQnIGluIHJlZikge1xuICAgICAgICByZWYuY3VycmVudCA9IGVsO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZWFkb25seSBhdHRyaWJ1dGUgbm90IGFwcGxpY2FibGUgdG8gdHlwZT1cImNoZWNrYm94XCJcbiAgICAvLyBzZWUgLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW5wdXQvY2hlY2tib3hcbiAgICAsXG4gICAgXCJhcmlhLXJlYWRvbmx5XCI6IHJlYWRPbmx5LFxuICAgIG9uQ2xpY2s6IGV2dCA9PiB7XG4gICAgICBpZiAocmVhZE9ubHkpIHtcbiAgICAgICAgLy8gcHJldmVudCBkZWZhdWx0IHN0b3BzIHRoZSBjaGVja2JveCBiZWluZyB1cGRhdGVkXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgLy8gcGFzcyBvbkNsaWNrIGV2ZW50IG9uIHRvIHRoZSB1c2VyIGV2ZW4gaWYgcmVhZG9ubHlcbiAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgIG9uQ2xpY2soZXZ0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiLCB7XG4gICAgaHRtbEZvcjogaWQsXG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS1jaGVja2JveC1sYWJlbGAsXG4gICAgdGl0bGU6IHRpdGxlXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRleHQsIHtcbiAgICBjbGFzc05hbWU6IGlubmVyTGFiZWxDbGFzc2VzXG4gIH0sIGxhYmVsVGV4dCwgc2x1ZyA/IG5vcm1hbGl6ZWREZWNvcmF0b3IgOiBkZWNvcmF0b3IgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS1jaGVja2JveC13cmFwcGVyLWlubmVyLS1kZWNvcmF0b3JgXG4gIH0sIG5vcm1hbGl6ZWREZWNvcmF0b3IpIDogJycpKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tY2hlY2tib3hfX3ZhbGlkYXRpb24tbXNnYFxuICB9LCAhcmVhZE9ubHkgJiYgaW52YWxpZCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoV2FybmluZ0ZpbGxlZCwge1xuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tY2hlY2tib3hfX2ludmFsaWQtaWNvbmBcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeH0tLWZvcm0tcmVxdWlyZW1lbnRgXG4gIH0sIGludmFsaWRUZXh0KSksIHNob3dXYXJuaW5nICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChXYXJuaW5nQWx0RmlsbGVkLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS1jaGVja2JveF9faW52YWxpZC1pY29uICR7cHJlZml4fS0tY2hlY2tib3hfX2ludmFsaWQtaWNvbi0td2FybmluZ2BcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeH0tLWZvcm0tcmVxdWlyZW1lbnRgXG4gIH0sIHdhcm5UZXh0KSkpLCBzaG93SGVscGVyICYmIGhlbHBlcik7XG59KTtcbkNoZWNrYm94LnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgd2hldGhlciB0aGUgdW5kZXJseWluZyBpbnB1dCBzaG91bGQgYmUgY2hlY2tlZFxuICAgKi9cbiAgY2hlY2tlZDogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGFuIG9wdGlvbmFsIGNsYXNzTmFtZSB0byBiZSBhcHBsaWVkIHRvIHRoZSA8bGFiZWw+IG5vZGVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAqICoqRXhwZXJpbWVudGFsKio6IFByb3ZpZGUgYSBkZWNvcmF0b3IgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgYENoZWNrYm94YCBjb21wb25lbnRcbiAgICovXG4gIGRlY29yYXRvcjogUHJvcFR5cGVzLm5vZGUsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgdGhlIHVuZGVybHlpbmcgaW5wdXQgc2hvdWxkIGJlIGNoZWNrZWQgYnkgZGVmYXVsdFxuICAgKi9cbiAgZGVmYXVsdENoZWNrZWQ6IFByb3BUeXBlcy5ib29sLFxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIHRoZSBDaGVja2JveCBzaG91bGQgYmUgZGlzYWJsZWRcbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIFByb3ZpZGUgdGV4dCBmb3IgdGhlIGZvcm0gZ3JvdXAgZm9yIGFkZGl0aW9uYWwgaGVscFxuICAgKi9cbiAgaGVscGVyVGV4dDogUHJvcFR5cGVzLm5vZGUsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgdGhlIGxhYmVsIHNob3VsZCBiZSBoaWRkZW4sIG9yIG5vdFxuICAgKi9cbiAgaGlkZUxhYmVsOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIFByb3ZpZGUgYW4gYGlkYCB0byB1bmlxdWVseSBpZGVudGlmeSB0aGUgQ2hlY2tib3ggaW5wdXRcbiAgICovXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgdGhlIENoZWNrYm94IGlzIGluIGFuIGluZGV0ZXJtaW5hdGUgc3RhdGVcbiAgICovXG4gIGluZGV0ZXJtaW5hdGU6IFByb3BUeXBlcy5ib29sLFxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIHRoZSBDaGVja2JveCBpcyBjdXJyZW50bHkgaW52YWxpZFxuICAgKi9cbiAgaW52YWxpZDogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBQcm92aWRlIHRoZSB0ZXh0IHRoYXQgaXMgZGlzcGxheWVkIHdoZW4gdGhlIENoZWNrYm94IGlzIGluIGFuIGludmFsaWQgc3RhdGVcbiAgICovXG4gIGludmFsaWRUZXh0OiBQcm9wVHlwZXMubm9kZSxcbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBsYWJlbCB0byBwcm92aWRlIGEgZGVzY3JpcHRpb24gb2YgdGhlIENoZWNrYm94IGlucHV0IHRoYXQgeW91IGFyZVxuICAgKiBleHBvc2luZyB0byB0aGUgdXNlclxuICAgKi9cbiAgbGFiZWxUZXh0OiBQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkLFxuICAvKipcbiAgICogUHJvdmlkZSBhbiBvcHRpb25hbCBoYW5kbGVyIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGludGVybmFsIHN0YXRlIG9mXG4gICAqIENoZWNrYm94IGNoYW5nZXMuIFRoaXMgaGFuZGxlciBpcyBjYWxsZWQgd2l0aCBldmVudCBhbmQgc3RhdGUgaW5mby5cbiAgICogYChldmVudCwgeyBjaGVja2VkLCBpZCB9KSA9PiB2b2lkYFxuICAgKi9cbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIHRoZSBDaGVja2JveCBpcyByZWFkLW9ubHlcbiAgICovXG4gIHJlYWRPbmx5OiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqICoqRXhwZXJpbWVudGFsKio6IFByb3ZpZGUgYSBgU2x1Z2AgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgYENoZWNrYm94YCBjb21wb25lbnRcbiAgICovXG4gIHNsdWc6IGRlcHJlY2F0ZShQcm9wVHlwZXMubm9kZSwgJ1RoZSBgc2x1Z2AgcHJvcCBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi4gVXNlIHRoZSBkZWNvcmF0b3IgcHJvcCBpbnN0ZWFkLicpLFxuICAvKipcbiAgICogU3BlY2lmeSBhIHRpdGxlIGZvciB0aGUgPGxhYmVsPiBub2RlIGZvciB0aGUgQ2hlY2tib3hcbiAgICovXG4gIHRpdGxlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIHRoZSBDaGVja2JveCBpcyBjdXJyZW50bHkgaW4gd2FybmluZyBzdGF0ZVxuICAgKi9cbiAgd2FybjogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBQcm92aWRlIHRoZSB0ZXh0IHRoYXQgaXMgZGlzcGxheWVkIHdoZW4gdGhlIENoZWNrYm94IGlzIGluIHdhcm5pbmcgc3RhdGVcbiAgICovXG4gIHdhcm5UZXh0OiBQcm9wVHlwZXMubm9kZVxufTtcbkNoZWNrYm94LmRpc3BsYXlOYW1lID0gJ0NoZWNrYm94JztcblxuZXhwb3J0IHsgQ2hlY2tib3ggYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjNcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcblxuY29uc3QgRm9ybUNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dCh7XG4gIGlzRmx1aWQ6IGZhbHNlXG59KTtcblxuZXhwb3J0IHsgRm9ybUNvbnRleHQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIzXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNvbnN0IGxpc3RCb3hUeXBlcyA9IFsnZGVmYXVsdCcsICdpbmxpbmUnXTtcbmNvbnN0IGxpc3RCb3hTaXplcyA9IFsnc20nLCAnbWQnLCAnbGcnXTtcbmNvbnN0IExpc3RCb3hUeXBlUHJvcFR5cGUgPSBQcm9wVHlwZXMub25lT2YobGlzdEJveFR5cGVzKTtcbmNvbnN0IExpc3RCb3hTaXplUHJvcFR5cGUgPSBQcm9wVHlwZXMub25lT2YobGlzdEJveFNpemVzKTtcblxuZXhwb3J0IHsgTGlzdEJveFNpemVQcm9wVHlwZSwgTGlzdEJveFR5cGVQcm9wVHlwZSB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjNcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHsgZXh0ZW5kcyBhcyBfZXh0ZW5kcyB9IGZyb20gJy4uLy4uL192aXJ0dWFsL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuanMnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFJlYWN0LCB7IGZvcndhcmRSZWYsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGRlcHJlY2F0ZSBmcm9tICcuLi8uLi9wcm9wLXR5cGVzL2RlcHJlY2F0ZS5qcyc7XG5pbXBvcnQgJy4vaW5kZXguanMnO1xuaW1wb3J0IHsgdXNlUHJlZml4IH0gZnJvbSAnLi4vLi4vaW50ZXJuYWwvdXNlUHJlZml4LmpzJztcbmltcG9ydCAnLi4vRmx1aWRGb3JtL0ZsdWlkRm9ybS5qcyc7XG5pbXBvcnQgeyBGb3JtQ29udGV4dCB9IGZyb20gJy4uL0ZsdWlkRm9ybS9Gb3JtQ29udGV4dC5qcyc7XG5pbXBvcnQgeyBMaXN0Qm94U2l6ZVByb3BUeXBlLCBMaXN0Qm94VHlwZVByb3BUeXBlIH0gZnJvbSAnLi9MaXN0Qm94UHJvcFR5cGVzLmpzJztcblxuY29uc3QgaGFuZGxlT25LZXlEb3duID0gZXZlbnQgPT4ge1xuICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxufTtcbmNvbnN0IGhhbmRsZUNsaWNrID0gZXZlbnQgPT4ge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn07XG4vKipcbiAqIGBMaXN0Qm94YCBpcyBhIGdlbmVyaWMgY29udGFpbmVyIGNvbXBvbmVudCB0aGF0IGhhbmRsZXMgY3JlYXRpbmcgdGhlXG4gKiBjb250YWluZXIgY2xhc3MgbmFtZSBpbiByZXNwb25zZSB0byBjZXJ0YWluIHByb3BzLlxuICovXG5jb25zdCBMaXN0Qm94ID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIGNsYXNzTmFtZTogY29udGFpbmVyQ2xhc3NOYW1lLFxuICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgdHlwZSA9ICdkZWZhdWx0JyxcbiAgICBzaXplLFxuICAgIGludmFsaWQsXG4gICAgaW52YWxpZFRleHQsXG4gICAgaW52YWxpZFRleHRJZCxcbiAgICB3YXJuLFxuICAgIHdhcm5UZXh0LFxuICAgIHdhcm5UZXh0SWQsXG4gICAgbGlnaHQsXG4gICAgaXNPcGVuLFxuICAgIC4uLnJlc3RcbiAgfSA9IHByb3BzO1xuICBjb25zdCBwcmVmaXggPSB1c2VQcmVmaXgoKTtcbiAgY29uc3Qge1xuICAgIGlzRmx1aWRcbiAgfSA9IHVzZUNvbnRleHQoRm9ybUNvbnRleHQpO1xuICBjb25zdCBzaG93V2FybmluZyA9ICFpbnZhbGlkICYmIHdhcm47XG4gIGNvbnN0IGNsYXNzTmFtZSA9IGN4KHtcbiAgICAuLi4oY29udGFpbmVyQ2xhc3NOYW1lICYmIHtcbiAgICAgIFtjb250YWluZXJDbGFzc05hbWVdOiB0cnVlXG4gICAgfSksXG4gICAgW2Ake3ByZWZpeH0tLWxpc3QtYm94YF06IHRydWUsXG4gICAgW2Ake3ByZWZpeH0tLWxpc3QtYm94LS0ke3NpemV9YF06IHNpemUsXG4gICAgW2Ake3ByZWZpeH0tLWxpc3QtYm94LS1pbmxpbmVgXTogdHlwZSA9PT0gJ2lubGluZScsXG4gICAgW2Ake3ByZWZpeH0tLWxpc3QtYm94LS1kaXNhYmxlZGBdOiBkaXNhYmxlZCxcbiAgICBbYCR7cHJlZml4fS0tbGlzdC1ib3gtLWxpZ2h0YF06IGxpZ2h0LFxuICAgIFtgJHtwcmVmaXh9LS1saXN0LWJveC0tZXhwYW5kZWRgXTogaXNPcGVuLFxuICAgIFtgJHtwcmVmaXh9LS1saXN0LWJveC0taW52YWxpZGBdOiBpbnZhbGlkLFxuICAgIFtgJHtwcmVmaXh9LS1saXN0LWJveC0td2FybmluZ2BdOiBzaG93V2FybmluZ1xuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIHJlZjogcmVmLFxuICAgIG9uS2V5RG93bjogaGFuZGxlT25LZXlEb3duLFxuICAgIG9uQ2xpY2s6IGhhbmRsZUNsaWNrLFxuICAgIFwiZGF0YS1pbnZhbGlkXCI6IGludmFsaWQgfHwgdW5kZWZpbmVkXG4gIH0pLCBjaGlsZHJlbiksIGlzRmx1aWQgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoclwiLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS1saXN0LWJveF9fZGl2aWRlcmBcbiAgfSksIGludmFsaWQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS1mb3JtLXJlcXVpcmVtZW50YCxcbiAgICBpZDogaW52YWxpZFRleHRJZFxuICB9LCBpbnZhbGlkVGV4dCkgOiBudWxsLCBzaG93V2FybmluZyA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeH0tLWZvcm0tcmVxdWlyZW1lbnRgLFxuICAgIGlkOiB3YXJuVGV4dElkXG4gIH0sIHdhcm5UZXh0KSA6IG51bGwpO1xufSk7XG5MaXN0Qm94LmRpc3BsYXlOYW1lID0gJ0xpc3RCb3gnO1xuTGlzdEJveC5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBQcm92aWRlIHRoZSBjb250ZW50cyBvZiB5b3VyIExpc3RCb3hcbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgLyoqXG4gICAqIFNwZWNpZnkgYSBjbGFzcyBuYW1lIHRvIGJlIGFwcGxpZWQgb24gdGhlIGNvbnRhaW5pbmcgbGlzdCBib3ggbm9kZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIHRoZSBMaXN0Qm94IGlzIGN1cnJlbnRseSBkaXNhYmxlZFxuICAgKi9cbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIHRoZSBjb250cm9sIGlzIGN1cnJlbnRseSBpbnZhbGlkXG4gICAqL1xuICBpbnZhbGlkOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIHRleHQgdG8gYmUgZGlzcGxheWVkIHdoZW4gdGhlIGNvbnRyb2wgaXMgaW52YWxpZFxuICAgKi9cbiAgaW52YWxpZFRleHQ6IFByb3BUeXBlcy5ub2RlLFxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgaWQgdG8gYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudCBjb250YWluaW5nIHRoZSBpbnZhbGlkIHRleHRcbiAgICovXG4gIGludmFsaWRUZXh0SWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGlmIHRoZSBjb250cm9sIHNob3VsZCByZW5kZXIgb3BlblxuICAgKi9cbiAgaXNPcGVuOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIGB0cnVlYCB0byB1c2UgdGhlIGxpZ2h0IHZlcnNpb24uIEZvciB1c2Ugb24gJHVpLTAxIGJhY2tncm91bmRzIG9ubHkuXG4gICAqIERvbid0IHVzZSB0aGlzIHRvIG1ha2UgdGlsZSBiYWNrZ3JvdW5kIGNvbG9yIHNhbWUgYXMgY29udGFpbmVyIGJhY2tncm91bmQgY29sb3IuXG4gICAqL1xuICBsaWdodDogZGVwcmVjYXRlKFByb3BUeXBlcy5ib29sLCAnVGhlIGBsaWdodGAgcHJvcCBmb3IgYExpc3RCb3hgIGhhcyAnICsgJ2JlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiB0aGUgbmV3IGBMYXllcmAgY29tcG9uZW50LiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4nKSxcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIHNpemUgb2YgdGhlIExpc3RCb3guIEN1cnJlbnRseSBzdXBwb3J0cyBlaXRoZXIgYHNtYCwgYG1kYCBvciBgbGdgIGFzIGFuIG9wdGlvbi5cbiAgICovXG4gIHNpemU6IExpc3RCb3hTaXplUHJvcFR5cGUsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBcInR5cGVcIiBvZiB0aGUgTGlzdEJveC4gQ3VycmVudGx5IHN1cHBvcnRzIGVpdGhlciBgZGVmYXVsdGAgb3JcbiAgICogYGlubGluZWAgYXMgYW4gb3B0aW9uLlxuICAgKi9cbiAgdHlwZTogTGlzdEJveFR5cGVQcm9wVHlwZSxcbiAgLyoqXG4gICAqIFNwZWNpZnkgd2hldGhlciB0aGUgY29udHJvbCBpcyBjdXJyZW50bHkgaW4gd2FybmluZyBzdGF0ZVxuICAgKi9cbiAgd2FybjogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBQcm92aWRlIHRoZSB0ZXh0IHRoYXQgaXMgZGlzcGxheWVkIHdoZW4gdGhlIGNvbnRyb2wgaXMgaW4gd2FybmluZyBzdGF0ZVxuICAgKi9cbiAgd2FyblRleHQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBpZCB0byBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIHdhcm4gdGV4dFxuICAgKi9cbiAgd2FyblRleHRJZDogUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuZXhwb3J0IHsgTGlzdEJveCBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBleHRlbmRzIGFzIF9leHRlbmRzIH0gZnJvbSAnLi4vLi4vX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IHVzZVByZWZpeCB9IGZyb20gJy4uLy4uL2ludGVybmFsL3VzZVByZWZpeC5qcyc7XG5cbi8qKlxuICogYExpc3RCb3hGaWVsZGAgaXMgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoZSBjb250YWluaW5nIG5vZGUgZm9yIHZhbGlkXG4gKiBlbGVtZW50cyBpbnNpZGUgb2YgYSBmaWVsZC4gSXQgYWxzbyBwcm92aWRlcyBhMTF5LXJlbGF0ZWQgYXR0cmlidXRlcyBsaWtlXG4gKiBgcm9sZWAgdG8gbWFrZSBzdXJlIGEgdXNlciBjYW4gZm9jdXMgdGhlIGdpdmVuIGZpZWxkLlxuICovXG5mdW5jdGlvbiBMaXN0Qm94RmllbGQoX3JlZikge1xuICBsZXQge1xuICAgIGNoaWxkcmVuLFxuICAgIGRpc2FibGVkLFxuICAgIHRhYkluZGV4LFxuICAgIC4uLnJlc3RcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHByZWZpeCA9IHVzZVByZWZpeCgpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tbGlzdC1ib3hfX2ZpZWxkYCxcbiAgICB0YWJJbmRleDogIWRpc2FibGVkICYmIHRhYkluZGV4IHx8IC0xXG4gIH0sIHJlc3QpLCBjaGlsZHJlbik7XG59XG5MaXN0Qm94RmllbGQucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogVHlwaWNhbGx5IHNldCBieSBgZ2V0VG9nZ2xlQnV0dG9uUHJvcHNgLCB0aGlzIHNob3VsZCBzcGVjaWZ5IHdoZXRoZXIgdGhlXG4gICAqIGZpZWxkIGhhcyBhIHBvcHVwLlxuICAgKi9cbiAgJ2FyaWEtaGFzcG9wdXAnOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYm9vbF0pLFxuICAvKipcbiAgICogUHJvdmlkZSB0aGUgY29udGVudHMgb2YgeW91ciBMaXN0Qm94RmllbGRcbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgLyoqXG4gICAqIFNwZWNpZnkgaWYgdGhlIHBhcmVudCA8TGlzdEJveD4gaXMgZGlzYWJsZWRcbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIFRoZSByb2xlIGZvciB0aGUgY29tcG9uZW50LCBzaG91bGQgYmUgc2V0IGJ5IGBnZXRUb2dnbGVCdXR0b25Qcm9wc2AgY29taW5nXG4gICAqIGZyb20gRG93bnNoaWZ0XG4gICAqL1xuICByb2xlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvKipcbiAgICogT3B0aW9uYWwgcHJvcCB0byBzcGVjaWZ5IHRoZSB0YWJJbmRleCBvZiB0aGUgPExpc3RCb3g+IHRyaWdnZXIgYnV0dG9uXG4gICAqL1xuICB0YWJJbmRleDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pXG59O1xuXG5leHBvcnQgeyBMaXN0Qm94RmllbGQgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjNcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHsgZXh0ZW5kcyBhcyBfZXh0ZW5kcyB9IGZyb20gJy4uLy4uL192aXJ0dWFsL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuanMnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFJlYWN0LCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyB1c2VQcmVmaXggfSBmcm9tICcuLi8uLi9pbnRlcm5hbC91c2VQcmVmaXguanMnO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUmVmcyB9IGZyb20gJy4uLy4uL2ludGVybmFsL3VzZU1lcmdlZFJlZnMuanMnO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGNvbnRlbnQgb2YgYW4gZWxlbWVudCBpcyB0cnVuY2F0ZWQuXG4gKlxuICogTWVyZ2VzIGEgZm9yd2FyZGVkIHJlZiB3aXRoIGEgbG9jYWwgcmVmIHRvIGNoZWNrIHRoZSBlbGVtZW50J3MgZGltZW5zaW9ucy5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIGZvcndhcmRlZFJlZiAtIEEgcmVmIHBhc3NlZCBmcm9tIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICogQHBhcmFtIGRlcHMgLSBEZXBlbmRlbmNpZXMgdG8gcmUtcnVuIHRoZSB0cnVuY2F0aW9uIGNoZWNrLlxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHRydW5jYXRpb24gc3RhdGUgYW5kIHRoZSBtZXJnZWQgcmVmLlxuICovXG5jb25zdCB1c2VJc1RydW5jYXRlZCA9IGZ1bmN0aW9uIChmb3J3YXJkZWRSZWYpIHtcbiAgbGV0IGRlcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICBjb25zdCBsb2NhbFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgbWVyZ2VkUmVmID0gdXNlTWVyZ2VkUmVmcyhbLi4uKGZvcndhcmRlZFJlZiA/IFtmb3J3YXJkZWRSZWZdIDogW10pLCBsb2NhbFJlZl0pO1xuICBjb25zdCBbaXNUcnVuY2F0ZWQsIHNldElzVHJ1bmNhdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBlbGVtZW50ID0gbG9jYWxSZWYuY3VycmVudDtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBvZmZzZXRXaWR0aCxcbiAgICAgICAgc2Nyb2xsV2lkdGhcbiAgICAgIH0gPSBlbGVtZW50O1xuICAgICAgc2V0SXNUcnVuY2F0ZWQob2Zmc2V0V2lkdGggPCBzY3JvbGxXaWR0aCk7XG4gICAgfVxuICB9LCBbbG9jYWxSZWYsIC4uLmRlcHNdKTtcbiAgcmV0dXJuIHtcbiAgICBpc1RydW5jYXRlZCxcbiAgICByZWY6IG1lcmdlZFJlZlxuICB9O1xufTtcbi8qKlxuICogYExpc3RCb3hNZW51SXRlbWAgaXMgYSBoZWxwZXIgY29tcG9uZW50IGZvciBtYW5hZ2luZyB0aGUgY29udGFpbmVyIGNsYXNzXG4gKiBuYW1lLCBhbG9uZ3NpZGUgYW55IGNsYXNzZXMgZm9yIGFueSBjb3JyZXNwb25kaW5nIHN0YXRlcywgZm9yIGEgZ2VuZXJpYyBsaXN0XG4gKiBib3ggbWVudSBpdGVtLlxuICovXG5jb25zdCBMaXN0Qm94TWVudUl0ZW0gPSAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZigoX3JlZiwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgaXNBY3RpdmUgPSBmYWxzZSxcbiAgICBpc0hpZ2hsaWdodGVkID0gZmFsc2UsXG4gICAgdGl0bGUsXG4gICAgLi4ucmVzdFxuICB9ID0gX3JlZjtcbiAgY29uc3QgcHJlZml4ID0gdXNlUHJlZml4KCk7XG4gIGNvbnN0IG1lbnVJdGVtT3B0aW9uUmVmUHJvcCA9IGZvcndhcmRlZFJlZiAmJiB0eXBlb2YgZm9yd2FyZGVkUmVmICE9PSAnZnVuY3Rpb24nID8gZm9yd2FyZGVkUmVmLm1lbnVJdGVtT3B0aW9uUmVmIDogdW5kZWZpbmVkO1xuICBjb25zdCB7XG4gICAgaXNUcnVuY2F0ZWQsXG4gICAgcmVmOiBtZW51SXRlbU9wdGlvblJlZlxuICB9ID0gdXNlSXNUcnVuY2F0ZWQobWVudUl0ZW1PcHRpb25SZWZQcm9wLCBbY2hpbGRyZW5dKTtcbiAgY29uc3QgY2xhc3NOYW1lID0gY3goYCR7cHJlZml4fS0tbGlzdC1ib3hfX21lbnUtaXRlbWAsIHtcbiAgICBbYCR7cHJlZml4fS0tbGlzdC1ib3hfX21lbnUtaXRlbS0tYWN0aXZlYF06IGlzQWN0aXZlLFxuICAgIFtgJHtwcmVmaXh9LS1saXN0LWJveF9fbWVudS1pdGVtLS1oaWdobGlnaHRlZGBdOiBpc0hpZ2hsaWdodGVkXG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIHRpdGxlOiBpc1RydW5jYXRlZCA/IHRpdGxlIDogdW5kZWZpbmVkXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS1saXN0LWJveF9fbWVudS1pdGVtX19vcHRpb25gLFxuICAgIHJlZjogbWVudUl0ZW1PcHRpb25SZWZcbiAgfSwgY2hpbGRyZW4pKTtcbn0pO1xuTGlzdEJveE1lbnVJdGVtLmRpc3BsYXlOYW1lID0gJ0xpc3RCb3hNZW51SXRlbSc7XG5MaXN0Qm94TWVudUl0ZW0ucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogU3BlY2lmeSBhbnkgY2hpbGRyZW4gbm9kZXMgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQgaW5zaWRlIG9mIHRoZSBMaXN0Qm94XG4gICAqIE1lbnUgSXRlbVxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAvKipcbiAgICogU3BlY2lmeSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgZGlzYWJsZWRcbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIFNwZWNpZnkgd2hldGhlciB0aGUgY3VycmVudCBtZW51IGl0ZW0gaXMgXCJhY3RpdmVcIi5cbiAgICovXG4gIGlzQWN0aXZlOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIFNwZWNpZnkgd2hldGhlciB0aGUgY3VycmVudCBtZW51IGl0ZW0gaXMgXCJoaWdobGlnaHRlZFwiLlxuICAgKi9cbiAgaXNIaWdobGlnaHRlZDogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBQcm92aWRlIGFuIG9wdGlvbmFsIHRvb2x0aXAgZm9yIHRoZSBMaXN0Qm94TWVudUl0ZW1cbiAgICovXG4gIHRpdGxlOiBQcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5leHBvcnQgeyBMaXN0Qm94TWVudUl0ZW0gYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjNcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHsgZXh0ZW5kcyBhcyBfZXh0ZW5kcyB9IGZyb20gJy4uLy4uL192aXJ0dWFsL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuanMnO1xuaW1wb3J0IFJlYWN0LCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VQcmVmaXggfSBmcm9tICcuLi8uLi9pbnRlcm5hbC91c2VQcmVmaXguanMnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBMaXN0Qm94TWVudUl0ZW0gZnJvbSAnLi9MaXN0Qm94TWVudUl0ZW0uanMnO1xuXG5jb25zdCBmckZuID0gZm9yd2FyZFJlZjtcblxuLyoqXG4gKiBgTGlzdEJveE1lbnVgIGlzIGEgc2ltcGxlIGNvbnRhaW5lciBub2RlIHRoYXQgaXNvbGF0ZXMgdGhlIGBsaXN0LWJveF9fbWVudWBcbiAqIGNsYXNzIGludG8gYSBzaW5nbGUgY29tcG9uZW50LiBJdCBpcyBhbHNvIGJlaW5nIHVzZWQgdG8gdmFsaWRhdGUgZ2l2ZW5cbiAqIGBjaGlsZHJlbmAgY29tcG9uZW50cy5cbiAqL1xuY29uc3QgTGlzdEJveE1lbnUgPSBmckZuKChfcmVmLCByZWYpID0+IHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlbixcbiAgICBpZCxcbiAgICAuLi5yZXN0XG4gIH0gPSBfcmVmO1xuICBjb25zdCBwcmVmaXggPSB1c2VQcmVmaXgoKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwidWxcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmVmLFxuICAgIGlkOiBpZCxcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeH0tLWxpc3QtYm94X19tZW51YCxcbiAgICByb2xlOiBcImxpc3Rib3hcIlxuICB9LCByZXN0KSwgY2hpbGRyZW4pO1xufSk7XG5MaXN0Qm94TWVudS5kaXNwbGF5TmFtZSA9ICdMaXN0Qm94TWVudSc7XG5MaXN0Qm94TWVudS5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBQcm92aWRlIHRoZSBjb250ZW50cyBvZiB5b3VyIExpc3RCb3hNZW51XG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm5vZGUsIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vbmVPZihbTGlzdEJveE1lbnVJdGVtXSkpLFxuICAvKipcbiAgICogYWxsb3cgc2luZ2xlIGl0ZW0gdXNpbmcgdGhlIHdvcmthcm91bmQgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAgKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzI5NzkjaXNzdWVjb21tZW50LTIyMjM3OTkxNlxuICAgKi9cbiAgUHJvcFR5cGVzLnNoYXBlKHtcbiAgICB0eXBlOiBQcm9wVHlwZXMub25lT2YoW0xpc3RCb3hNZW51SXRlbV0pXG4gIH0pLCBQcm9wVHlwZXMuYm9vbCAvLyB1c2VkIGluIERyb3Bkb3duIGZvciBjbG9zZWQgc3RhdGVcbiAgXSksXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGEgY3VzdG9tIGBpZGBcbiAgICovXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWRcbn07XG5cbmV4cG9ydCB7IExpc3RCb3hNZW51IGFzIGRlZmF1bHQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIzXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgQ2hldnJvbkRvd24gfSBmcm9tICdAY2FyYm9uL2ljb25zLXJlYWN0JztcbmltcG9ydCB7IHVzZVByZWZpeCB9IGZyb20gJy4uLy4uL2ludGVybmFsL3VzZVByZWZpeC5qcyc7XG5cbmNvbnN0IGRlZmF1bHRUcmFuc2xhdGlvbnMgPSB7XG4gICdjbG9zZS5tZW51JzogJ0Nsb3NlIG1lbnUnLFxuICAnb3Blbi5tZW51JzogJ09wZW4gbWVudSdcbn07XG5jb25zdCBkZWZhdWx0VHJhbnNsYXRlV2l0aElkID0gaWQgPT4gZGVmYXVsdFRyYW5zbGF0aW9uc1tpZF07XG4vKipcbiAqIGBMaXN0Qm94TWVudUljb25gIGlzIHVzZWQgdG8gb3JpZW50IHRoZSBpY29uIHVwIG9yIGRvd24gZGVwZW5kaW5nIG9uIHRoZVxuICogc3RhdGUgb2YgdGhlIG1lbnUgZm9yIGEgZ2l2ZW4gYExpc3RCb3hgXG4gKi9cbmNvbnN0IExpc3RCb3hNZW51SWNvbiA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGlzT3BlbixcbiAgICB0cmFuc2xhdGVXaXRoSWQ6IHQgPSBkZWZhdWx0VHJhbnNsYXRlV2l0aElkXG4gIH0gPSBfcmVmO1xuICBjb25zdCBwcmVmaXggPSB1c2VQcmVmaXgoKTtcbiAgY29uc3QgY2xhc3NOYW1lID0gY3goYCR7cHJlZml4fS0tbGlzdC1ib3hfX21lbnUtaWNvbmAsIHtcbiAgICBbYCR7cHJlZml4fS0tbGlzdC1ib3hfX21lbnUtaWNvbi0tb3BlbmBdOiBpc09wZW5cbiAgfSk7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gaXNPcGVuID8gdCgnY2xvc2UubWVudScpIDogdCgnb3Blbi5tZW51Jyk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hldnJvbkRvd24sIHtcbiAgICBuYW1lOiBcImNoZXZyb24tLWRvd25cIixcbiAgICBcImFyaWEtbGFiZWxcIjogZGVzY3JpcHRpb25cbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCBudWxsLCBkZXNjcmlwdGlvbikpKTtcbn07XG5MaXN0Qm94TWVudUljb24ucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIHRoZSBtZW51IGlzIGN1cnJlbnRseSBvcGVuLCB3aGljaCB3aWxsIGluZmx1ZW5jZSB0aGVcbiAgICogZGlyZWN0aW9uIG9mIHRoZSBtZW51IGljb25cbiAgICovXG4gIGlzT3BlbjogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLyoqXG4gICAqIGkxOG4gaG9vayB1c2VkIHRvIHByb3ZpZGUgdGhlIGFwcHJvcHJpYXRlIGRlc2NyaXB0aW9uIGZvciB0aGUgZ2l2ZW4gbWVudVxuICAgKiBpY29uLiBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgTGlzdEJveE1lbnVJY29uVHJhbnNsYXRpb25LZXkgYW5kIHNob3VsZFxuICAgKiByZXR1cm4gYSBzdHJpbmcgbWVzc2FnZSBmb3IgdGhhdCBnaXZlbiBtZXNzYWdlIGlkLlxuICAgKi9cbiAgdHJhbnNsYXRlV2l0aElkOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZXhwb3J0IHsgTGlzdEJveE1lbnVJY29uIGFzIGRlZmF1bHQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIzXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgQ2xvc2UgfSBmcm9tICdAY2FyYm9uL2ljb25zLXJlYWN0JztcbmltcG9ydCB7IHVzZVByZWZpeCB9IGZyb20gJy4uLy4uL2ludGVybmFsL3VzZVByZWZpeC5qcyc7XG5cbnZhciBfQ2xvc2UsIF9DbG9zZTI7XG5jb25zdCB0cmFuc2xhdGlvbklkcyA9IHtcbiAgJ2NsZWFyLmFsbCc6ICdjbGVhci5hbGwnLFxuICAnY2xlYXIuc2VsZWN0aW9uJzogJ2NsZWFyLnNlbGVjdGlvbidcbn07XG5cbi8qKlxuICogTWVzc2FnZSBpZHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0cmFuc2xhdGVXaXRoSWQoKS5cbiAqL1xuXG5jb25zdCBkZWZhdWx0VHJhbnNsYXRpb25zID0ge1xuICBbdHJhbnNsYXRpb25JZHNbJ2NsZWFyLmFsbCddXTogJ0NsZWFyIGFsbCBzZWxlY3RlZCBpdGVtcycsXG4gIFt0cmFuc2xhdGlvbklkc1snY2xlYXIuc2VsZWN0aW9uJ11dOiAnQ2xlYXIgc2VsZWN0ZWQgaXRlbSdcbn07XG5jb25zdCBkZWZhdWx0VHJhbnNsYXRlV2l0aElkID0gaWQgPT4gZGVmYXVsdFRyYW5zbGF0aW9uc1tpZF07XG5cbi8qKlxuICogYExpc3RCb3hTZWxlY3Rpb25gIGlzIHVzZWQgdG8gcHJvdmlkZSBjb250cm9scyBmb3IgY2xlYXJpbmcgYSBzZWxlY3Rpb24sIGluXG4gKiBhZGRpdGlvbiB0byBjb25kaXRpb25hbGx5IHJlbmRlcmluZyBhIGJhZGdlIGlmIHRoZSBjb250cm9sIGhhcyBtb3JlIHRoYW4gb25lXG4gKiBzZWxlY3Rpb24uXG4gKi9cbmNvbnN0IExpc3RCb3hTZWxlY3Rpb24gPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBjbGVhclNlbGVjdGlvbixcbiAgICBzZWxlY3Rpb25Db3VudCxcbiAgICB0cmFuc2xhdGVXaXRoSWQ6IHQgPSBkZWZhdWx0VHJhbnNsYXRlV2l0aElkLFxuICAgIGRpc2FibGVkLFxuICAgIG9uQ2xlYXJTZWxlY3Rpb24sXG4gICAgcmVhZE9ubHlcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHByZWZpeCA9IHVzZVByZWZpeCgpO1xuICBjb25zdCBjbGFzc05hbWUgPSBjeChgJHtwcmVmaXh9LS1saXN0LWJveF9fc2VsZWN0aW9uYCwge1xuICAgIFtgJHtwcmVmaXh9LS10YWctLWZpbHRlcmBdOiBzZWxlY3Rpb25Db3VudCxcbiAgICBbYCR7cHJlZml4fS0tbGlzdC1ib3hfX3NlbGVjdGlvbi0tbXVsdGlgXTogc2VsZWN0aW9uQ291bnRcbiAgfSk7XG4gIGNvbnN0IGhhbmRsZU9uQ2xpY2sgPSBldmVudCA9PiB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKGRpc2FibGVkIHx8IHJlYWRPbmx5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyU2VsZWN0aW9uKGV2ZW50KTtcbiAgICBpZiAob25DbGVhclNlbGVjdGlvbikge1xuICAgICAgb25DbGVhclNlbGVjdGlvbihldmVudCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IHNlbGVjdGlvbkNvdW50ID8gdCgnY2xlYXIuYWxsJykgOiB0KCdjbGVhci5zZWxlY3Rpb24nKTtcbiAgY29uc3QgdGFnQ2xhc3NlcyA9IGN4KGAke3ByZWZpeH0tLXRhZ2AsIGAke3ByZWZpeH0tLXRhZy0tZmlsdGVyYCwgYCR7cHJlZml4fS0tdGFnLS1oaWdoLWNvbnRyYXN0YCwge1xuICAgIFtgJHtwcmVmaXh9LS10YWctLWRpc2FibGVkYF06IGRpc2FibGVkXG4gIH0pO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIGpzeC1hMTF5L2NsaWNrLWV2ZW50cy1oYXZlLWtleS1ldmVudHMgKi9cbiAgcmV0dXJuIHNlbGVjdGlvbkNvdW50ID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogdGFnQ2xhc3Nlc1xuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tdGFnX19sYWJlbGAsXG4gICAgdGl0bGU6IGAke3NlbGVjdGlvbkNvdW50fWBcbiAgfSwgc2VsZWN0aW9uQ291bnQpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcm9sZTogXCJidXR0b25cIixcbiAgICB0YWJJbmRleDogLTEsXG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS10YWdfX2Nsb3NlLWljb25gLFxuICAgIG9uQ2xpY2s6IGhhbmRsZU9uQ2xpY2ssXG4gICAgXCJhcmlhLWxhYmVsXCI6IHQoJ2NsZWFyLmFsbCcpLFxuICAgIHRpdGxlOiBkZXNjcmlwdGlvbixcbiAgICBcImFyaWEtZGlzYWJsZWRcIjogcmVhZE9ubHkgPyB0cnVlIDogdW5kZWZpbmVkXG4gIH0sIF9DbG9zZSB8fCAoX0Nsb3NlID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2xvc2UsIG51bGwpKSkpIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJvbGU6IFwiYnV0dG9uXCIsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgdGFiSW5kZXg6IC0xLFxuICAgIG9uQ2xpY2s6IGhhbmRsZU9uQ2xpY2ssXG4gICAgXCJhcmlhLWxhYmVsXCI6IGRlc2NyaXB0aW9uLFxuICAgIHRpdGxlOiBkZXNjcmlwdGlvblxuICB9LCBzZWxlY3Rpb25Db3VudCwgX0Nsb3NlMiB8fCAoX0Nsb3NlMiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENsb3NlLCBudWxsKSkpO1xufTtcbkxpc3RCb3hTZWxlY3Rpb24ucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogU3BlY2lmeSBhIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiBhIHVzZXIgaW50ZXJhY3RzIHdpdGggdGhlIGNsZWFyXG4gICAqIHNlbGVjdGlvbiBlbGVtZW50LlxuICAgKi9cbiAgY2xlYXJTZWxlY3Rpb246IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgb3Igbm90IHRoZSBjbGVhciBzZWxlY3Rpb24gZWxlbWVudCBzaG91bGQgYmUgZGlzYWJsZWRcbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIFNwZWNpZnkgYW4gb3B0aW9uYWwgYG9uQ2xlYXJTZWxlY3Rpb25gIGhhbmRsZXIgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgdW5kZXJseWluZ1xuICAgKiBlbGVtZW50IGlzIGNsZWFyZWRcbiAgICovXG4gIG9uQ2xlYXJTZWxlY3Rpb246IFByb3BUeXBlcy5mdW5jLFxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdGhlIERyb3Bkb3duIGlzIHJlYWRvbmx5XG4gICAqL1xuICByZWFkT25seTogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGFuIG9wdGlvbmFsIGBzZWxlY3Rpb25Db3VudGAgdmFsdWUgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lXG4gICAqIHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBzaG91bGQgZGlzcGxheSBhIGJhZGdlIG9yIGEgc2luZ2xlIGNsZWFyIGljb24uXG4gICAqL1xuICBzZWxlY3Rpb25Db3VudDogUHJvcFR5cGVzLm51bWJlcixcbiAgLyoqXG4gICAqIGkxOG4gaG9vayB1c2VkIHRvIHByb3ZpZGUgdGhlIGFwcHJvcHJpYXRlIGRlc2NyaXB0aW9uIGZvciB0aGUgZ2l2ZW4gbWVudVxuICAgKiBpY29uLiBUaGlzIGZ1bmN0aW9uIHRha2VzIGluIGFuIGlkIGRlZmluZWQgaW4gYHRyYW5zbGF0aW9uSWRzYCBhbmQgc2hvdWxkXG4gICAqIHJldHVybiBhIHN0cmluZyBtZXNzYWdlIGZvciB0aGF0IGdpdmVuIG1lc3NhZ2UgaWQuXG4gICAqL1xuICB0cmFuc2xhdGVXaXRoSWQ6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5leHBvcnQgeyBMaXN0Qm94U2VsZWN0aW9uIGFzIGRlZmF1bHQsIHRyYW5zbGF0aW9uSWRzIH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5leHBvcnQgeyBMaXN0Qm94U2l6ZVByb3BUeXBlLCBMaXN0Qm94VHlwZVByb3BUeXBlIH0gZnJvbSAnLi9MaXN0Qm94UHJvcFR5cGVzLmpzJztcbmltcG9ydCBMaXN0Qm94JDEgZnJvbSAnLi9MaXN0Qm94LmpzJztcbmltcG9ydCBMaXN0Qm94RmllbGQgZnJvbSAnLi9MaXN0Qm94RmllbGQuanMnO1xuaW1wb3J0IExpc3RCb3hNZW51IGZyb20gJy4vTGlzdEJveE1lbnUuanMnO1xuaW1wb3J0IExpc3RCb3hNZW51SWNvbiBmcm9tICcuL0xpc3RCb3hNZW51SWNvbi5qcyc7XG5pbXBvcnQgTGlzdEJveE1lbnVJdGVtIGZyb20gJy4vTGlzdEJveE1lbnVJdGVtLmpzJztcbmltcG9ydCBMaXN0Qm94U2VsZWN0aW9uIGZyb20gJy4vTGlzdEJveFNlbGVjdGlvbi5qcyc7XG5cbmNvbnN0IExpc3RCb3ggPSBPYmplY3QuYXNzaWduKExpc3RCb3gkMSwge1xuICBGaWVsZDogTGlzdEJveEZpZWxkLFxuICBNZW51OiBMaXN0Qm94TWVudSxcbiAgTWVudUljb246IExpc3RCb3hNZW51SWNvbixcbiAgTWVudUl0ZW06IExpc3RCb3hNZW51SXRlbSxcbiAgU2VsZWN0aW9uOiBMaXN0Qm94U2VsZWN0aW9uXG59KTtcblxuZXhwb3J0IHsgTGlzdEJveCBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7Li4uUmVmPEVsZW1lbnQ+fSByZWZzIExpc3Qgb2YgUmVhY3QgcmVmcyB0byBtZXJnZS5cbiAqIEByZXR1cm5zIHtSZWY8RWxlbWVudD59IE1lcmdlZCBSZWFjdCByZWYuXG4gKi9cbmNvbnN0IG1lcmdlUmVmcyA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlZnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcmVmc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gZWwgPT4ge1xuICAgIHJlZnMuZm9yRWFjaChyZWYgPT4ge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzAyOSNpc3N1ZWNvbW1lbnQtNDEwMDAyMzE2XG4gICAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZWYoZWwpO1xuICAgICAgfSBlbHNlIGlmIChPYmplY3QocmVmKSA9PT0gcmVmKSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gZWw7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59O1xudmFyIG1lcmdlUmVmcyQxID0gbWVyZ2VSZWZzO1xuXG5leHBvcnQgeyBtZXJnZVJlZnMkMSBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBleHRlbmRzIGFzIF9leHRlbmRzIH0gZnJvbSAnLi4vLi4vX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5qcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VDb250ZXh0LCB1c2VDYWxsYmFjaywgdXNlTWVtbywgdXNlU3RhdGUsIGlzVmFsaWRFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlU2VsZWN0IH0gZnJvbSAnZG93bnNoaWZ0JztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBXYXJuaW5nRmlsbGVkLCBXYXJuaW5nQWx0RmlsbGVkLCBDaGVja21hcmsgfSBmcm9tICdAY2FyYm9uL2ljb25zLXJlYWN0JztcbmltcG9ydCBMaXN0Qm94IGZyb20gJy4uL0xpc3RCb3gvaW5kZXguanMnO1xuaW1wb3J0IG1lcmdlUmVmcyBmcm9tICcuLi8uLi90b29scy9tZXJnZVJlZnMuanMnO1xuaW1wb3J0IGRlcHJlY2F0ZSBmcm9tICcuLi8uLi9wcm9wLXR5cGVzL2RlcHJlY2F0ZS5qcyc7XG5pbXBvcnQgeyB1c2VQcmVmaXggfSBmcm9tICcuLi8uLi9pbnRlcm5hbC91c2VQcmVmaXguanMnO1xuaW1wb3J0ICcuLi9GbHVpZEZvcm0vRmx1aWRGb3JtLmpzJztcbmltcG9ydCB7IEZvcm1Db250ZXh0IH0gZnJvbSAnLi4vRmx1aWRGb3JtL0Zvcm1Db250ZXh0LmpzJztcbmltcG9ydCB7IHVzZUlkIH0gZnJvbSAnLi4vLi4vaW50ZXJuYWwvdXNlSWQuanMnO1xuaW1wb3J0IHsgdXNlRmxvYXRpbmcsIHNpemUsIGZsaXAsIGhpZGUsIGF1dG9VcGRhdGUgfSBmcm9tICdAZmxvYXRpbmctdWkvcmVhY3QnO1xuaW1wb3J0IHsgdXNlRmVhdHVyZUZsYWcgfSBmcm9tICcuLi9GZWF0dXJlRmxhZ3MvaW5kZXguanMnO1xuaW1wb3J0IHsgTGlzdEJveFNpemVQcm9wVHlwZSwgTGlzdEJveFR5cGVQcm9wVHlwZSB9IGZyb20gJy4uL0xpc3RCb3gvTGlzdEJveFByb3BUeXBlcy5qcyc7XG5cbmNvbnN0IHtcbiAgSXRlbU1vdXNlTW92ZSxcbiAgTWVudU1vdXNlTGVhdmVcbn0gPSB1c2VTZWxlY3Quc3RhdGVDaGFuZ2VUeXBlcztcbmNvbnN0IGRlZmF1bHRJdGVtVG9TdHJpbmcgPSBpdGVtID0+IHtcbiAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBpdGVtO1xuICB9XG4gIGlmICh0eXBlb2YgaXRlbSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gYCR7aXRlbX1gO1xuICB9XG4gIGlmIChpdGVtICE9PSBudWxsICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJiAnbGFiZWwnIGluIGl0ZW0gJiYgdHlwZW9mIGl0ZW1bJ2xhYmVsJ10gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGl0ZW1bJ2xhYmVsJ107XG4gIH1cbiAgcmV0dXJuICcnO1xufTtcbi8qKlxuICogQ3VzdG9tIHN0YXRlIHJlZHVjZXIgZm9yIGB1c2VTZWxlY3RgIGluIERvd25zaGlmdCwgcHJvdmlkaW5nIGNvbnRyb2wgb3ZlclxuICogc3RhdGUgY2hhbmdlcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBlYWNoIHRpbWUgYHVzZVNlbGVjdGAgdXBkYXRlcyBpdHMgaW50ZXJuYWwgc3RhdGUgb3JcbiAqIHRyaWdnZXJzIGBvblN0YXRlQ2hhbmdlYC4gSXQgYWxsb3dzIGZvciBmaW5lLWdyYWluZWQgY29udHJvbCBvZiBzdGF0ZVxuICogdXBkYXRlcyBieSBtb2RpZnlpbmcgb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdCBjaGFuZ2VzIGZyb20gRG93bnNoaWZ0J3NcbiAqIHJlZHVjZXIuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZG93bnNoaWZ0LWpzL2Rvd25zaGlmdC90cmVlL21hc3Rlci9zcmMvaG9va3MvdXNlU2VsZWN0I3N0YXRlcmVkdWNlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSAtIFRoZSBjdXJyZW50IGZ1bGwgc3RhdGUgb2YgdGhlIERvd25zaGlmdCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uQW5kQ2hhbmdlcyAtIENvbnRhaW5zIHRoZSBhY3Rpb24gdHlwZSBhbmQgcHJvcG9zZWRcbiAqIGNoYW5nZXMgZnJvbSB0aGUgZGVmYXVsdCBEb3duc2hpZnQgcmVkdWNlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb25BbmRDaGFuZ2VzLmNoYW5nZXMgLSBTdWdnZXN0ZWQgc3RhdGUgY2hhbmdlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb25BbmRDaGFuZ2VzLnR5cGUgLSBUaGUgYWN0aW9uIHR5cGUgZm9yIHRoZSBzdGF0ZVxuICogY2hhbmdlIChlLmcuLCBpdGVtIHNlbGVjdGlvbikuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIFRoZSBtb2RpZmllZCBzdGF0ZSBiYXNlZCBvbiBjdXN0b20gbG9naWMgb3IgZGVmYXVsdFxuICogY2hhbmdlcyBpZiBubyBjdXN0b20gbG9naWMgYXBwbGllcy5cbiAqL1xuZnVuY3Rpb24gc3RhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb25BbmRDaGFuZ2VzKSB7XG4gIGNvbnN0IHtcbiAgICBjaGFuZ2VzLFxuICAgIHR5cGVcbiAgfSA9IGFjdGlvbkFuZENoYW5nZXM7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgSXRlbU1vdXNlTW92ZTpcbiAgICBjYXNlIE1lbnVNb3VzZUxlYXZlOlxuICAgICAgaWYgKGNoYW5nZXMuaGlnaGxpZ2h0ZWRJbmRleCA9PT0gc3RhdGUuaGlnaGxpZ2h0ZWRJbmRleCkge1xuICAgICAgICAvLyBQcmV2ZW50IHN0YXRlIHVwZGF0ZSBpZiBoaWdobGlnaHRlZEluZGV4IGhhc24ndCBjaGFuZ2VkXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFuZ2VzO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gY2hhbmdlcztcbiAgfVxufVxuY29uc3QgRHJvcGRvd24gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigoX3JlZiwgcmVmKSA9PiB7XG4gIGxldCB7XG4gICAgYXV0b0FsaWduID0gZmFsc2UsXG4gICAgY2xhc3NOYW1lOiBjb250YWluZXJDbGFzc05hbWUsXG4gICAgZGVjb3JhdG9yLFxuICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgZGlyZWN0aW9uID0gJ2JvdHRvbScsXG4gICAgaXRlbXM6IGl0ZW1zUHJvcCxcbiAgICBsYWJlbCxcbiAgICBbJ2FyaWEtbGFiZWwnXTogYXJpYUxhYmVsLFxuICAgIGFyaWFMYWJlbDogZGVwcmVjYXRlZEFyaWFMYWJlbCxcbiAgICBpdGVtVG9TdHJpbmcgPSBkZWZhdWx0SXRlbVRvU3RyaW5nLFxuICAgIGl0ZW1Ub0VsZW1lbnQgPSBudWxsLFxuICAgIHJlbmRlclNlbGVjdGVkSXRlbSxcbiAgICB0eXBlID0gJ2RlZmF1bHQnLFxuICAgIHNpemU6IHNpemUkMSxcbiAgICBvbkNoYW5nZSxcbiAgICBpZCxcbiAgICB0aXRsZVRleHQgPSAnJyxcbiAgICBoaWRlTGFiZWwsXG4gICAgaGVscGVyVGV4dCA9ICcnLFxuICAgIHRyYW5zbGF0ZVdpdGhJZCxcbiAgICBsaWdodCxcbiAgICBpbnZhbGlkLFxuICAgIGludmFsaWRUZXh0LFxuICAgIHdhcm4sXG4gICAgd2FyblRleHQsXG4gICAgaW5pdGlhbFNlbGVjdGVkSXRlbSxcbiAgICBzZWxlY3RlZEl0ZW06IGNvbnRyb2xsZWRTZWxlY3RlZEl0ZW0sXG4gICAgZG93bnNoaWZ0UHJvcHMsXG4gICAgcmVhZE9ubHksXG4gICAgc2x1ZyxcbiAgICAuLi5vdGhlclxuICB9ID0gX3JlZjtcbiAgY29uc3QgZW5hYmxlRmxvYXRpbmdTdHlsZXMgPSB1c2VGZWF0dXJlRmxhZygnZW5hYmxlLXYxMi1keW5hbWljLWZsb2F0aW5nLXN0eWxlcycpO1xuICBjb25zdCB7XG4gICAgcmVmcyxcbiAgICBmbG9hdGluZ1N0eWxlcyxcbiAgICBtaWRkbGV3YXJlRGF0YVxuICB9ID0gdXNlRmxvYXRpbmcoZW5hYmxlRmxvYXRpbmdTdHlsZXMgfHwgYXV0b0FsaWduID8ge1xuICAgIHBsYWNlbWVudDogZGlyZWN0aW9uLFxuICAgIC8vIFRoZSBmbG9hdGluZyBlbGVtZW50IGlzIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gaXRzIG5lYXJlc3RcbiAgICAvLyBjb250YWluaW5nIGJsb2NrICh1c3VhbGx5IHRoZSB2aWV3cG9ydCkuIEl0IHdpbGwgaW4gbWFueSBjYXNlcyBhbHNvXG4gICAgLy8g4oCcYnJlYWvigJ0gdGhlIGZsb2F0aW5nIGVsZW1lbnQgb3V0IG9mIGEgY2xpcHBpbmcgYW5jZXN0b3IuXG4gICAgLy8gaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9taXNjI2NsaXBwaW5nXG4gICAgc3RyYXRlZ3k6ICdmaXhlZCcsXG4gICAgLy8gTWlkZGxld2FyZSBvcmRlciBtYXR0ZXJzLCBhcnJvdyBzaG91bGQgYmUgbGFzdFxuICAgIG1pZGRsZXdhcmU6IFtzaXplKHtcbiAgICAgIGFwcGx5KF9yZWYyKSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgcmVjdHMsXG4gICAgICAgICAgZWxlbWVudHNcbiAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnRzLmZsb2F0aW5nLnN0eWxlLCB7XG4gICAgICAgICAgd2lkdGg6IGAke3JlY3RzLnJlZmVyZW5jZS53aWR0aH1weGBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSksIGF1dG9BbGlnbiAmJiBmbGlwKCksIGF1dG9BbGlnbiAmJiBoaWRlKCldLFxuICAgIHdoaWxlRWxlbWVudHNNb3VudGVkOiBhdXRvVXBkYXRlXG4gIH0gOiB7fVxuICAvLyBXaGVuIGF1dG9BbGlnbiBpcyB0dXJuZWQgb2ZmICYgdGhlIGBlbmFibGUtdjEyLWR5bmFtaWMtZmxvYXRpbmctc3R5bGVzYCBmZWF0dXJlIGZsYWcgaXMgbm90XG4gIC8vIGVuYWJsZWQsIGZsb2F0aW5nLXVpIHdpbGwgbm90IGJlIHVzZWRcbiAgKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZW5hYmxlRmxvYXRpbmdTdHlsZXMgfHwgYXV0b0FsaWduKSB7XG4gICAgICBjb25zdCB1cGRhdGVkRmxvYXRpbmdTdHlsZXMgPSB7XG4gICAgICAgIC4uLmZsb2F0aW5nU3R5bGVzLFxuICAgICAgICB2aXNpYmlsaXR5OiBtaWRkbGV3YXJlRGF0YS5oaWRlPy5yZWZlcmVuY2VIaWRkZW4gPyAnaGlkZGVuJyA6ICd2aXNpYmxlJ1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5rZXlzKHVwZGF0ZWRGbG9hdGluZ1N0eWxlcykuZm9yRWFjaChzdHlsZSA9PiB7XG4gICAgICAgIGlmIChyZWZzLmZsb2F0aW5nLmN1cnJlbnQpIHtcbiAgICAgICAgICByZWZzLmZsb2F0aW5nLmN1cnJlbnQuc3R5bGVbc3R5bGVdID0gdXBkYXRlZEZsb2F0aW5nU3R5bGVzW3N0eWxlXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbZmxvYXRpbmdTdHlsZXMsIGF1dG9BbGlnbiwgcmVmcy5mbG9hdGluZ10pO1xuICBjb25zdCBwcmVmaXggPSB1c2VQcmVmaXgoKTtcbiAgY29uc3Qge1xuICAgIGlzRmx1aWRcbiAgfSA9IHVzZUNvbnRleHQoRm9ybUNvbnRleHQpO1xuICBjb25zdCBvblNlbGVjdGVkSXRlbUNoYW5nZSA9IHVzZUNhbGxiYWNrKF9yZWYzID0+IHtcbiAgICBsZXQge1xuICAgICAgc2VsZWN0ZWRJdGVtXG4gICAgfSA9IF9yZWYzO1xuICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICBzZWxlY3RlZEl0ZW06IHNlbGVjdGVkSXRlbSA/PyBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtvbkNoYW5nZV0pO1xuICBjb25zdCBpc0l0ZW1EaXNhYmxlZCA9IHVzZUNhbGxiYWNrKChpdGVtLCBfaW5kZXgpID0+IHtcbiAgICBjb25zdCBpc09iamVjdCA9IGl0ZW0gIT09IG51bGwgJiYgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnO1xuICAgIHJldHVybiBpc09iamVjdCAmJiAnZGlzYWJsZWQnIGluIGl0ZW0gJiYgaXRlbS5kaXNhYmxlZCA9PT0gdHJ1ZTtcbiAgfSwgW10pO1xuICBjb25zdCBvbkhpZ2hsaWdodGVkSW5kZXhDaGFuZ2UgPSB1c2VDYWxsYmFjayhjaGFuZ2VzID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBoaWdobGlnaHRlZEluZGV4XG4gICAgfSA9IGNoYW5nZXM7XG4gICAgaWYgKGhpZ2hsaWdodGVkSW5kZXggIT09IHVuZGVmaW5lZCAmJiBoaWdobGlnaHRlZEluZGV4ID4gLTEgJiYgdHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBpdGVtQXJyYXkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGBsaS4ke3ByZWZpeH0tLWxpc3QtYm94X19tZW51LWl0ZW1bcm9sZT1cIm9wdGlvblwiXWApO1xuICAgICAgY29uc3QgaGlnaGxpZ2h0ZWRJdGVtID0gaXRlbUFycmF5W2hpZ2hsaWdodGVkSW5kZXhdO1xuICAgICAgaWYgKGhpZ2hsaWdodGVkSXRlbSkge1xuICAgICAgICBoaWdobGlnaHRlZEl0ZW0uc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJyxcbiAgICAgICAgICBibG9jazogJ25lYXJlc3QnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW3ByZWZpeF0pO1xuICBjb25zdCBpdGVtcyA9IHVzZU1lbW8oKCkgPT4gaXRlbXNQcm9wLCBbaXRlbXNQcm9wXSk7XG4gIGNvbnN0IHNlbGVjdFByb3BzID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGl0ZW1zLFxuICAgIGl0ZW1Ub1N0cmluZyxcbiAgICBpbml0aWFsU2VsZWN0ZWRJdGVtLFxuICAgIG9uU2VsZWN0ZWRJdGVtQ2hhbmdlLFxuICAgIHN0YXRlUmVkdWNlcixcbiAgICBpc0l0ZW1EaXNhYmxlZCxcbiAgICBvbkhpZ2hsaWdodGVkSW5kZXhDaGFuZ2UsXG4gICAgLi4uZG93bnNoaWZ0UHJvcHNcbiAgfSksIFtpdGVtcywgaXRlbVRvU3RyaW5nLCBpbml0aWFsU2VsZWN0ZWRJdGVtLCBvblNlbGVjdGVkSXRlbUNoYW5nZSwgc3RhdGVSZWR1Y2VyLCBpc0l0ZW1EaXNhYmxlZCwgb25IaWdobGlnaHRlZEluZGV4Q2hhbmdlLCBkb3duc2hpZnRQcm9wc10pO1xuICBjb25zdCBkcm9wZG93bkluc3RhbmNlSWQgPSB1c2VJZCgpO1xuXG4gIC8vIG9ubHkgc2V0IHNlbGVjdGVkSXRlbSBpZiB0aGUgcHJvcCBpcyBkZWZpbmVkLiBTZXR0aW5nIGlmIGl0IGlzIHVuZGVmaW5lZFxuICAvLyB3aWxsIG92ZXJ3cml0ZSBkZWZhdWx0IHNlbGVjdGVkIGl0ZW1zIGZyb20gdXNlU2VsZWN0XG4gIGlmIChjb250cm9sbGVkU2VsZWN0ZWRJdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZWxlY3RQcm9wcy5zZWxlY3RlZEl0ZW0gPSBjb250cm9sbGVkU2VsZWN0ZWRJdGVtO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpc09wZW4sXG4gICAgZ2V0VG9nZ2xlQnV0dG9uUHJvcHMsXG4gICAgZ2V0TGFiZWxQcm9wcyxcbiAgICBnZXRNZW51UHJvcHMsXG4gICAgZ2V0SXRlbVByb3BzLFxuICAgIHNlbGVjdGVkSXRlbSxcbiAgICBoaWdobGlnaHRlZEluZGV4XG4gIH0gPSB1c2VTZWxlY3Qoc2VsZWN0UHJvcHMpO1xuICBjb25zdCBpbmxpbmUgPSB0eXBlID09PSAnaW5saW5lJztcbiAgY29uc3Qgc2hvd1dhcm5pbmcgPSAhaW52YWxpZCAmJiB3YXJuO1xuICBjb25zdCBbaXNGb2N1c2VkLCBzZXRJc0ZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBjbGFzc05hbWUgPSBjeChgJHtwcmVmaXh9LS1kcm9wZG93bmAsIHtcbiAgICBbYCR7cHJlZml4fS0tZHJvcGRvd24tLWludmFsaWRgXTogaW52YWxpZCxcbiAgICBbYCR7cHJlZml4fS0tZHJvcGRvd24tLXdhcm5pbmdgXTogc2hvd1dhcm5pbmcsXG4gICAgW2Ake3ByZWZpeH0tLWRyb3Bkb3duLS1vcGVuYF06IGlzT3BlbixcbiAgICBbYCR7cHJlZml4fS0tZHJvcGRvd24tLWZvY3VzYF06IGlzRm9jdXNlZCxcbiAgICBbYCR7cHJlZml4fS0tZHJvcGRvd24tLWlubGluZWBdOiBpbmxpbmUsXG4gICAgW2Ake3ByZWZpeH0tLWRyb3Bkb3duLS1kaXNhYmxlZGBdOiBkaXNhYmxlZCxcbiAgICBbYCR7cHJlZml4fS0tZHJvcGRvd24tLWxpZ2h0YF06IGxpZ2h0LFxuICAgIFtgJHtwcmVmaXh9LS1kcm9wZG93bi0tcmVhZG9ubHlgXTogcmVhZE9ubHksXG4gICAgW2Ake3ByZWZpeH0tLWRyb3Bkb3duLS0ke3NpemUkMX1gXTogc2l6ZSQxLFxuICAgIFtgJHtwcmVmaXh9LS1saXN0LWJveC0tdXBgXTogZGlyZWN0aW9uID09PSAndG9wJyxcbiAgICBbYCR7cHJlZml4fS0tYXV0b2FsaWduYF06IGF1dG9BbGlnblxuICB9KTtcbiAgY29uc3QgdGl0bGVDbGFzc2VzID0gY3goYCR7cHJlZml4fS0tbGFiZWxgLCB7XG4gICAgW2Ake3ByZWZpeH0tLWxhYmVsLS1kaXNhYmxlZGBdOiBkaXNhYmxlZCxcbiAgICBbYCR7cHJlZml4fS0tdmlzdWFsbHktaGlkZGVuYF06IGhpZGVMYWJlbFxuICB9KTtcbiAgY29uc3QgaGVscGVyQ2xhc3NlcyA9IGN4KGAke3ByZWZpeH0tLWZvcm1fX2hlbHBlci10ZXh0YCwge1xuICAgIFtgJHtwcmVmaXh9LS1mb3JtX19oZWxwZXItdGV4dC0tZGlzYWJsZWRgXTogZGlzYWJsZWRcbiAgfSk7XG4gIGNvbnN0IHdyYXBwZXJDbGFzc2VzID0gY3goYCR7cHJlZml4fS0tZHJvcGRvd25fX3dyYXBwZXJgLCBgJHtwcmVmaXh9LS1saXN0LWJveF9fd3JhcHBlcmAsIGNvbnRhaW5lckNsYXNzTmFtZSwge1xuICAgIFtgJHtwcmVmaXh9LS1kcm9wZG93bl9fd3JhcHBlci0taW5saW5lYF06IGlubGluZSxcbiAgICBbYCR7cHJlZml4fS0tbGlzdC1ib3hfX3dyYXBwZXItLWlubGluZWBdOiBpbmxpbmUsXG4gICAgW2Ake3ByZWZpeH0tLWRyb3Bkb3duX193cmFwcGVyLS1pbmxpbmUtLWludmFsaWRgXTogaW5saW5lICYmIGludmFsaWQsXG4gICAgW2Ake3ByZWZpeH0tLWxpc3QtYm94X193cmFwcGVyLS1pbmxpbmUtLWludmFsaWRgXTogaW5saW5lICYmIGludmFsaWQsXG4gICAgW2Ake3ByZWZpeH0tLWxpc3QtYm94X193cmFwcGVyLS1mbHVpZC0taW52YWxpZGBdOiBpc0ZsdWlkICYmIGludmFsaWQsXG4gICAgW2Ake3ByZWZpeH0tLWxpc3QtYm94X193cmFwcGVyLS1zbHVnYF06IHNsdWcsXG4gICAgW2Ake3ByZWZpeH0tLWxpc3QtYm94X193cmFwcGVyLS1kZWNvcmF0b3JgXTogZGVjb3JhdG9yXG4gIH0pO1xuICBjb25zdCBoZWxwZXJJZCA9ICFoZWxwZXJUZXh0ID8gdW5kZWZpbmVkIDogYGRyb3Bkb3duLWhlbHBlci10ZXh0LSR7ZHJvcGRvd25JbnN0YW5jZUlkfWA7XG5cbiAgLy8gbmVlZHMgdG8gYmUgQ2FwaXRhbGl6ZWQgZm9yIHJlYWN0IHRvIHJlbmRlciBpdCBjb3JyZWN0bHlcbiAgY29uc3QgSXRlbVRvRWxlbWVudCA9IGl0ZW1Ub0VsZW1lbnQ7XG4gIGNvbnN0IHRvZ2dsZUJ1dHRvblByb3BzID0gZ2V0VG9nZ2xlQnV0dG9uUHJvcHMoe1xuICAgICdhcmlhLWxhYmVsJzogYXJpYUxhYmVsIHx8IGRlcHJlY2F0ZWRBcmlhTGFiZWxcbiAgfSk7XG4gIGNvbnN0IGhlbHBlciA9IGhlbHBlclRleHQgJiYgIWlzRmx1aWQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgaWQ6IGhlbHBlcklkLFxuICAgIGNsYXNzTmFtZTogaGVscGVyQ2xhc3Nlc1xuICB9LCBoZWxwZXJUZXh0KSA6IG51bGw7XG4gIGNvbnN0IGhhbmRsZUZvY3VzID0gZXZ0ID0+IHtcbiAgICBzZXRJc0ZvY3VzZWQoZXZ0LnR5cGUgPT09ICdmb2N1cycgJiYgIXNlbGVjdGVkSXRlbSA/IHRydWUgOiBmYWxzZSk7XG4gIH07XG4gIGNvbnN0IG1lcmdlZFJlZiA9IG1lcmdlUmVmcyh0b2dnbGVCdXR0b25Qcm9wcy5yZWYsIHJlZik7XG4gIGNvbnN0IFtjdXJyVGltZXIsIHNldEN1cnJUaW1lcl0gPSB1c2VTdGF0ZSgpO1xuICBjb25zdCBbaXNUeXBpbmcsIHNldElzVHlwaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3Qgb25LZXlEb3duSGFuZGxlciA9IHVzZUNhbGxiYWNrKGV2dCA9PiB7XG4gICAgaWYgKGV2dC5jb2RlICE9PSAnU3BhY2UnIHx8ICFbJ0Fycm93RG93bicsICdBcnJvd1VwJywgJyAnLCAnRW50ZXInXS5pbmNsdWRlcyhldnQua2V5KSkge1xuICAgICAgc2V0SXNUeXBpbmcodHJ1ZSk7XG4gICAgfVxuICAgIGlmIChpc1R5cGluZyAmJiBldnQuY29kZSA9PT0gJ1NwYWNlJyB8fCAhWydBcnJvd0Rvd24nLCAnQXJyb3dVcCcsICcgJywgJ0VudGVyJ10uaW5jbHVkZXMoZXZ0LmtleSkpIHtcbiAgICAgIGlmIChjdXJyVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGN1cnJUaW1lcik7XG4gICAgICB9XG4gICAgICBzZXRDdXJyVGltZXIoc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNldElzVHlwaW5nKGZhbHNlKTtcbiAgICAgIH0sIDMwMDApKTtcbiAgICB9XG4gICAgaWYgKFsnQXJyb3dEb3duJ10uaW5jbHVkZXMoZXZ0LmtleSkpIHtcbiAgICAgIHNldElzRm9jdXNlZChmYWxzZSk7XG4gICAgfVxuICAgIGlmIChbJ0VudGVyJ10uaW5jbHVkZXMoZXZ0LmtleSkgJiYgIXNlbGVjdGVkSXRlbSAmJiAhaXNPcGVuKSB7XG4gICAgICBzZXRJc0ZvY3VzZWQodHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gRm9yIERyb3Bkb3ducyB0aGUgYXJyb3cgdXAga2V5IGlzIG9ubHkgYWxsb3dlZCBpZiB0aGUgRHJvcGRvd24gaXMgb3BlblxuICAgIGlmICh0b2dnbGVCdXR0b25Qcm9wcy5vbktleURvd24gJiYgKGV2dC5rZXkgIT09ICdBcnJvd1VwJyB8fCBpc09wZW4gJiYgZXZ0LmtleSA9PT0gJ0Fycm93VXAnKSkge1xuICAgICAgdG9nZ2xlQnV0dG9uUHJvcHMub25LZXlEb3duKGV2dCk7XG4gICAgfVxuICB9LCBbaXNUeXBpbmcsIGN1cnJUaW1lciwgdG9nZ2xlQnV0dG9uUHJvcHNdKTtcbiAgY29uc3QgcmVhZE9ubHlFdmVudEhhbmRsZXJzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHJlYWRPbmx5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvbkNsaWNrOiBldnQgPT4ge1xuICAgICAgICAgIC8vIE5PVEU6IGRvZXMgbm90IHByZXZlbnQgY2xpY2tcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAvLyBmb2N1cyBvbiB0aGUgZWxlbWVudCBhcyBwZXIgcmVhZG9ubHkgaW5wdXQgYmVoYXZpb3JcbiAgICAgICAgICBtZXJnZWRSZWY/LmN1cnJlbnQ/LmZvY3VzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uS2V5RG93bjogZXZ0ID0+IHtcbiAgICAgICAgICBjb25zdCBzZWxlY3RBY2Nlc3NLZXlzID0gWydBcnJvd0Rvd24nLCAnQXJyb3dVcCcsICcgJywgJ0VudGVyJ107XG4gICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyB0aGUgc2VsZWN0IGZyb20gb3BlbmluZyBmb3IgdGhlIGFib3ZlIGtleXNcbiAgICAgICAgICBpZiAoc2VsZWN0QWNjZXNzS2V5cy5pbmNsdWRlcyhldnQua2V5KSkge1xuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvbktleURvd246IG9uS2V5RG93bkhhbmRsZXJcbiAgICAgIH07XG4gICAgfVxuICB9LCBbcmVhZE9ubHksIG9uS2V5RG93bkhhbmRsZXJdKTtcbiAgY29uc3QgbWVudVByb3BzID0gdXNlTWVtbygoKSA9PiBnZXRNZW51UHJvcHMoe1xuICAgIHJlZjogZW5hYmxlRmxvYXRpbmdTdHlsZXMgfHwgYXV0b0FsaWduID8gcmVmcy5zZXRGbG9hdGluZyA6IG51bGxcbiAgfSksIFthdXRvQWxpZ24sIGdldE1lbnVQcm9wcywgcmVmcy5zZXRGbG9hdGluZywgZW5hYmxlRmxvYXRpbmdTdHlsZXNdKTtcblxuICAvLyBBSUxhYmVsIGlzIGFsd2F5cyBzaXplIGBtaW5pYFxuICBjb25zdCBub3JtYWxpemVkRGVjb3JhdG9yID0gdXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IGVsZW1lbnQgPSBzbHVnID8/IGRlY29yYXRvcjtcbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Wyd0eXBlJ10/LmRpc3BsYXlOYW1lID09PSAnQUlMYWJlbCcpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGVsZW1lbnQsIHtcbiAgICAgICAgc2l6ZTogJ21pbmknXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQgOiBudWxsO1xuICB9LCBbc2x1ZywgZGVjb3JhdG9yXSk7XG4gIGNvbnN0IGFsbExhYmVsUHJvcHMgPSBnZXRMYWJlbFByb3BzKCk7XG4gIGNvbnN0IGxhYmVsUHJvcHMgPSAvKiNfX1BVUkVfXyovaXNWYWxpZEVsZW1lbnQodGl0bGVUZXh0KSA/IHtcbiAgICBpZDogYWxsTGFiZWxQcm9wcy5pZFxuICB9IDogYWxsTGFiZWxQcm9wcztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IHdyYXBwZXJDbGFzc2VzXG4gIH0sIG90aGVyKSwgdGl0bGVUZXh0ICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIiwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogdGl0bGVDbGFzc2VzXG4gIH0sIGxhYmVsUHJvcHMpLCB0aXRsZVRleHQpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaXN0Qm94LCB7XG4gICAgb25Gb2N1czogaGFuZGxlRm9jdXMsXG4gICAgb25CbHVyOiBoYW5kbGVGb2N1cyxcbiAgICBzaXplOiBzaXplJDEsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgaW52YWxpZDogaW52YWxpZCxcbiAgICBpbnZhbGlkVGV4dDogaW52YWxpZFRleHQsXG4gICAgd2Fybjogd2FybixcbiAgICB3YXJuVGV4dDogd2FyblRleHQsXG4gICAgbGlnaHQ6IGxpZ2h0LFxuICAgIGlzT3BlbjogaXNPcGVuLFxuICAgIHJlZjogZW5hYmxlRmxvYXRpbmdTdHlsZXMgfHwgYXV0b0FsaWduID8gcmVmcy5zZXRSZWZlcmVuY2UgOiBudWxsLFxuICAgIGlkOiBpZFxuICB9LCBpbnZhbGlkICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFdhcm5pbmdGaWxsZWQsIHtcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeH0tLWxpc3QtYm94X19pbnZhbGlkLWljb25gXG4gIH0pLCBzaG93V2FybmluZyAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChXYXJuaW5nQWx0RmlsbGVkLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS1saXN0LWJveF9faW52YWxpZC1pY29uICR7cHJlZml4fS0tbGlzdC1ib3hfX2ludmFsaWQtaWNvbi0td2FybmluZ2BcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIF9leHRlbmRzKHtcbiAgICB0eXBlOiBcImJ1dHRvblwiXG4gICAgLy8gYXJpYS1leHBhbmRlZCBpcyBhbHJlYWR5IGJlaW5nIHBhc3NlZCB0aHJvdWdoIHsuLi50b2dnbGVCdXR0b25Qcm9wc31cbiAgICAsXG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS1saXN0LWJveF9fZmllbGRgLFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICBcImFyaWEtZGlzYWJsZWRcIjogcmVhZE9ubHkgPyB0cnVlIDogdW5kZWZpbmVkIC8vIGFyaWEtZGlzYWJsZWQgdG8gcmVtYWluIGZvY3VzYWJsZVxuICAgICxcbiAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogIWlubGluZSAmJiAhaW52YWxpZCAmJiAhd2FybiAmJiBoZWxwZXIgPyBoZWxwZXJJZCA6IHVuZGVmaW5lZCxcbiAgICB0aXRsZTogc2VsZWN0ZWRJdGVtICYmIGl0ZW1Ub1N0cmluZyAhPT0gdW5kZWZpbmVkID8gaXRlbVRvU3RyaW5nKHNlbGVjdGVkSXRlbSkgOiBkZWZhdWx0SXRlbVRvU3RyaW5nKGxhYmVsKVxuICB9LCB0b2dnbGVCdXR0b25Qcm9wcywgcmVhZE9ubHlFdmVudEhhbmRsZXJzLCB7XG4gICAgcmVmOiBtZXJnZWRSZWZcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS1saXN0LWJveF9fbGFiZWxgXG4gIH0sIHNlbGVjdGVkSXRlbSA/IHJlbmRlclNlbGVjdGVkSXRlbSA/IHJlbmRlclNlbGVjdGVkSXRlbShzZWxlY3RlZEl0ZW0pIDogaXRlbVRvU3RyaW5nKHNlbGVjdGVkSXRlbSkgOiBsYWJlbCksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExpc3RCb3guTWVudUljb24sIHtcbiAgICBpc09wZW46IGlzT3BlbixcbiAgICB0cmFuc2xhdGVXaXRoSWQ6IHRyYW5zbGF0ZVdpdGhJZFxuICB9KSksIHNsdWcgPyBub3JtYWxpemVkRGVjb3JhdG9yIDogZGVjb3JhdG9yID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tbGlzdC1ib3hfX2lubmVyLXdyYXBwZXItLWRlY29yYXRvcmBcbiAgfSwgbm9ybWFsaXplZERlY29yYXRvcikgOiAnJywgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGlzdEJveC5NZW51LCBtZW51UHJvcHMsIGlzT3BlbiAmJiBpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgY29uc3QgaXNPYmplY3QgPSBpdGVtICE9PSBudWxsICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JztcbiAgICBjb25zdCBpdGVtUHJvcHMgPSBnZXRJdGVtUHJvcHMoe1xuICAgICAgaXRlbSxcbiAgICAgIGluZGV4XG4gICAgfSk7XG4gICAgY29uc3QgdGl0bGUgPSBpc09iamVjdCAmJiAndGV4dCcgaW4gaXRlbSAmJiBpdGVtVG9FbGVtZW50ID8gaXRlbS50ZXh0IDogaXRlbVRvU3RyaW5nKGl0ZW0pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaXN0Qm94Lk1lbnVJdGVtLCBfZXh0ZW5kcyh7XG4gICAgICBrZXk6IGl0ZW1Qcm9wcy5pZCxcbiAgICAgIGlzQWN0aXZlOiBzZWxlY3RlZEl0ZW0gPT09IGl0ZW0sXG4gICAgICBpc0hpZ2hsaWdodGVkOiBoaWdobGlnaHRlZEluZGV4ID09PSBpbmRleCxcbiAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgIGRpc2FibGVkOiBpdGVtUHJvcHNbJ2FyaWEtZGlzYWJsZWQnXVxuICAgIH0sIGl0ZW1Qcm9wcyksIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJiBJdGVtVG9FbGVtZW50ICE9PSB1bmRlZmluZWQgJiYgSXRlbVRvRWxlbWVudCAhPT0gbnVsbCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEl0ZW1Ub0VsZW1lbnQsIF9leHRlbmRzKHtcbiAgICAgIGtleTogaXRlbVByb3BzLmlkXG4gICAgfSwgaXRlbSkpIDogaXRlbVRvU3RyaW5nKGl0ZW0pLCBzZWxlY3RlZEl0ZW0gPT09IGl0ZW0gJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hlY2ttYXJrLCB7XG4gICAgICBjbGFzc05hbWU6IGAke3ByZWZpeH0tLWxpc3QtYm94X19tZW51LWl0ZW1fX3NlbGVjdGVkLWljb25gXG4gICAgfSkpO1xuICB9KSkpLCAhaW5saW5lICYmICFpbnZhbGlkICYmICF3YXJuICYmIGhlbHBlcik7XG59KTtcblxuLy8gV29ya2Fyb3VuZCBwcm9ibGVtcyB3aXRoIGZvcndhcmRSZWYoKSBhbmQgZ2VuZXJpY3MuICBJbiB0aGUgbG9uZyB0ZXJtLCBzaG91bGQgc3RvcCB1c2luZyBmb3J3YXJkUmVmKCkuXG4vLyBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTg0NjkyMjkvcmVhY3Qtd2l0aC10eXBlc2NyaXB0LWdlbmVyaWNzLXdoaWxlLXVzaW5nLXJlYWN0LWZvcndhcmRyZWYuXG5cbkRyb3Bkb3duLmRpc3BsYXlOYW1lID0gJ0Ryb3Bkb3duJztcbkRyb3Bkb3duLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqICdhcmlhLWxhYmVsJyBvZiB0aGUgTGlzdEJveCBjb21wb25lbnQuXG4gICAqIFNwZWNpZnkgYSBsYWJlbCB0byBiZSByZWFkIGJ5IHNjcmVlbiByZWFkZXJzIG9uIHRoZSBjb250YWluZXIgbm9kZVxuICAgKi9cbiAgWydhcmlhLWxhYmVsJ106IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkLCBwbGVhc2UgdXNlIGBhcmlhLWxhYmVsYCBpbnN0ZWFkLlxuICAgKiBTcGVjaWZ5IGEgbGFiZWwgdG8gYmUgcmVhZCBieSBzY3JlZW4gcmVhZGVycyBvbiB0aGUgY29udGFpbmVyIG5vdGUuXG4gICAqL1xuICBhcmlhTGFiZWw6IGRlcHJlY2F0ZShQcm9wVHlwZXMuc3RyaW5nLCAnVGhpcyBwcm9wIHN5bnRheCBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRoZSBuZXcgYGFyaWEtbGFiZWxgLicpLFxuICAvKipcbiAgICogKipFeHBlcmltZW50YWwqKjogV2lsbCBhdHRlbXB0IHRvIGF1dG9tYXRpY2FsbHkgYWxpZ24gdGhlIGZsb2F0aW5nIGVsZW1lbnQgdG8gYXZvaWQgY29sbGlzaW9ucyB3aXRoIHRoZSB2aWV3cG9ydCBhbmQgYmVpbmcgY2xpcHBlZCBieSBhbmNlc3RvciBlbGVtZW50cy5cbiAgICovXG4gIGF1dG9BbGlnbjogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgY3VzdG9tIGNsYXNzTmFtZSB0byBiZSBhcHBsaWVkIG9uIHRoZSBjZHMtLWRyb3Bkb3duIG5vZGVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAqICoqRXhwZXJpbWVudGFsKio6IFByb3ZpZGUgYSBgZGVjb3JhdG9yYCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBgRHJvcGRvd25gIGNvbXBvbmVudFxuICAgKi9cbiAgZGVjb3JhdG9yOiBQcm9wVHlwZXMubm9kZSxcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGRpcmVjdGlvbiBvZiB0aGUgZHJvcGRvd24uIENhbiBiZSBlaXRoZXIgdG9wIG9yIGJvdHRvbS5cbiAgICovXG4gIGRpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsndG9wJywgJ2JvdHRvbSddKSxcbiAgLyoqXG4gICAqIERpc2FibGUgdGhlIGNvbnRyb2xcbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIEFkZGl0aW9uYWwgcHJvcHMgcGFzc2VkIHRvIERvd25zaGlmdC5cbiAgICpcbiAgICogKipVc2Ugd2l0aCBjYXV0aW9uOioqIGFueXRoaW5nIHlvdSBkZWZpbmUgaGVyZSBvdmVycmlkZXMgdGhlIGNvbXBvbmVudHMnXG4gICAqIGludGVybmFsIGhhbmRsaW5nIG9mIHRoYXQgcHJvcC4gRG93bnNoaWZ0IEFQSXMgYW5kIGludGVybmFscyBhcmUgc3ViamVjdCB0b1xuICAgKiBjaGFuZ2UsIGFuZCBpbiBzb21lIGNhc2VzIHRoZXkgY2FuIG5vdCBiZSBzaGltbWVkIGJ5IENhcmJvbiB0byBzaGllbGQgeW91XG4gICAqIGZyb20gcG90ZW50aWFsbHkgYnJlYWtpbmcgY2hhbmdlcy5cbiAgICovXG4gIGRvd25zaGlmdFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAvKipcbiAgICogUHJvdmlkZSBoZWxwZXIgdGV4dCB0aGF0IGlzIHVzZWQgYWxvbmdzaWRlIHRoZSBjb250cm9sIGxhYmVsIGZvclxuICAgKiBhZGRpdGlvbmFsIGhlbHBcbiAgICovXG4gIGhlbHBlclRleHQ6IFByb3BUeXBlcy5ub2RlLFxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIHRoZSB0aXRsZSB0ZXh0IHNob3VsZCBiZSBoaWRkZW4gb3Igbm90XG4gICAqL1xuICBoaWRlTGFiZWw6IFByb3BUeXBlcy5ib29sLFxuICAvKipcbiAgICogU3BlY2lmeSBhIGN1c3RvbSBgaWRgXG4gICAqL1xuICBpZDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAvKipcbiAgICogQWxsb3cgdXNlcnMgdG8gcGFzcyBpbiBhbiBhcmJpdHJhcnkgaXRlbSBvciBhIHN0cmluZyAoaW4gY2FzZSB0aGVpciBpdGVtcyBhcmUgYW4gYXJyYXkgb2Ygc3RyaW5ncylcbiAgICogZnJvbSB0aGVpciBjb2xsZWN0aW9uIHRoYXQgYXJlIHByZS1zZWxlY3RlZFxuICAgKi9cbiAgaW5pdGlhbFNlbGVjdGVkSXRlbTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICAvKipcbiAgICogU3BlY2lmeSBpZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHZhbHVlIGlzIGludmFsaWQuXG4gICAqL1xuICBpbnZhbGlkOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIE1lc3NhZ2Ugd2hpY2ggaXMgZGlzcGxheWVkIGlmIHRoZSB2YWx1ZSBpcyBpbnZhbGlkLlxuICAgKi9cbiAgaW52YWxpZFRleHQ6IFByb3BUeXBlcy5ub2RlLFxuICAvKipcbiAgICogRnVuY3Rpb24gdG8gcmVuZGVyIGl0ZW1zIGFzIGN1c3RvbSBjb21wb25lbnRzIGluc3RlYWQgb2Ygc3RyaW5ncy5cbiAgICogRGVmYXVsdHMgdG8gbnVsbCBhbmQgaXMgb3ZlcnJpZGRlbiBieSBhIGdldHRlclxuICAgKi9cbiAgaXRlbVRvRWxlbWVudDogUHJvcFR5cGVzLmZ1bmMsXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gcGFzc2VkIHRvIGRvd25zaGlmdCB0aGF0IGFsbG93cyB0aGUgbGlicmFyeSB0byByZW5kZXIgYVxuICAgKiBnaXZlbiBpdGVtIHRvIGEgc3RyaW5nIGxhYmVsLiBCeSBkZWZhdWx0LCBpdCBleHRyYWN0cyB0aGUgYGxhYmVsYCBmaWVsZFxuICAgKiBmcm9tIGEgZ2l2ZW4gaXRlbSB0byBzZXJ2ZSBhcyB0aGUgaXRlbSBsYWJlbCBpbiB0aGUgbGlzdC5cbiAgICovXG4gIGl0ZW1Ub1N0cmluZzogUHJvcFR5cGVzLmZ1bmMsXG4gIC8qKlxuICAgKiBXZSB0cnkgdG8gc3RheSBhcyBnZW5lcmljIGFzIHBvc3NpYmxlIGhlcmUgdG8gYWxsb3cgaW5kaXZpZHVhbHMgdG8gcGFzc1xuICAgKiBpbiBhIGNvbGxlY3Rpb24gb2Ygd2hhdGV2ZXIga2luZCBvZiBkYXRhIHN0cnVjdHVyZSB0aGV5IHByZWZlclxuICAgKi9cbiAgaXRlbXM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICAvKipcbiAgICogR2VuZXJpYyBgbGFiZWxgIHRoYXQgd2lsbCBiZSB1c2VkIGFzIHRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHdoYXRcbiAgICogdGhpcyBmaWVsZCBpcyBmb3JcbiAgICovXG4gIGxhYmVsOiBQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkLFxuICAvKipcbiAgICogYHRydWVgIHRvIHVzZSB0aGUgbGlnaHQgdmVyc2lvbi5cbiAgICovXG4gIGxpZ2h0OiBkZXByZWNhdGUoUHJvcFR5cGVzLmJvb2wsICdUaGUgYGxpZ2h0YCBwcm9wIGZvciBgRHJvcGRvd25gIGhhcyAnICsgJ2JlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiB0aGUgbmV3IGBMYXllcmAgY29tcG9uZW50LiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4nKSxcbiAgLyoqXG4gICAqIGBvbkNoYW5nZWAgaXMgYSB1dGlsaXR5IGZvciB0aGlzIGNvbnRyb2xsZWQgY29tcG9uZW50IHRvIGNvbW11bmljYXRlIHRvIGFcbiAgICogY29uc3VtaW5nIGNvbXBvbmVudCB3aGF0IGtpbmQgb2YgaW50ZXJuYWwgc3RhdGUgY2hhbmdlcyBhcmUgb2NjdXJyaW5nLlxuICAgKi9cbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdGhlIERyb3Bkb3duIGlzIHJlYWRvbmx5XG4gICAqL1xuICByZWFkT25seTogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBjYWxsYmFjayB0byByZW5kZXIgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtIGFzIGEgcmVhY3QgZWxlbWVudCBpbnN0ZWFkIG9mIG9ubHlcbiAgICogYXMgYSBzdHJpbmcuXG4gICAqL1xuICByZW5kZXJTZWxlY3RlZEl0ZW06IFByb3BUeXBlcy5mdW5jLFxuICAvKipcbiAgICogSW4gdGhlIGNhc2UgeW91IHdhbnQgdG8gY29udHJvbCB0aGUgZHJvcGRvd24gc2VsZWN0aW9uIGVudGlyZWx5LlxuICAgKi9cbiAgc2VsZWN0ZWRJdGVtOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBzaXplIG9mIHRoZSBMaXN0Qm94LiBDdXJyZW50bHkgc3VwcG9ydHMgZWl0aGVyIGBzbWAsIGBtZGAgb3IgYGxnYCBhcyBhbiBvcHRpb24uXG4gICAqL1xuICBzaXplOiBMaXN0Qm94U2l6ZVByb3BUeXBlLFxuICAvKipcbiAgICogKipFeHBlcmltZW50YWwqKjogUHJvdmlkZSBhIGBTbHVnYCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBgRHJvcGRvd25gIGNvbXBvbmVudFxuICAgKi9cbiAgc2x1ZzogZGVwcmVjYXRlKFByb3BUeXBlcy5ub2RlLCAnVGhlIGBzbHVnYCBwcm9wIGZvciBgRHJvcGRvd25gIGhhcyAnICsgJ2JlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiB0aGUgbmV3IGBkZWNvcmF0b3JgIHByb3AuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLicpLFxuICAvKipcbiAgICogUHJvdmlkZSB0aGUgdGl0bGUgdGV4dCB0aGF0IHdpbGwgYmUgcmVhZCBieSBhIHNjcmVlbiByZWFkZXIgd2hlblxuICAgKiB2aXNpdGluZyB0aGlzIGNvbnRyb2xcbiAgICovXG4gIHRpdGxlVGV4dDogUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcbiAgLyoqXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciB0cmFuc2xhdGluZyBMaXN0Qm94TWVudUljb24gU1ZHIHRpdGxlXG4gICAqL1xuICB0cmFuc2xhdGVXaXRoSWQ6IFByb3BUeXBlcy5mdW5jLFxuICAvKipcbiAgICogVGhlIGRyb3Bkb3duIHR5cGUsIGBkZWZhdWx0YCBvciBgaW5saW5lYFxuICAgKi9cbiAgdHlwZTogTGlzdEJveFR5cGVQcm9wVHlwZSxcbiAgLyoqXG4gICAqIFNwZWNpZnkgd2hldGhlciB0aGUgY29udHJvbCBpcyBjdXJyZW50bHkgaW4gd2FybmluZyBzdGF0ZVxuICAgKi9cbiAgd2FybjogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBQcm92aWRlIHRoZSB0ZXh0IHRoYXQgaXMgZGlzcGxheWVkIHdoZW4gdGhlIGNvbnRyb2wgaXMgaW4gd2FybmluZyBzdGF0ZVxuICAgKi9cbiAgd2FyblRleHQ6IFByb3BUeXBlcy5ub2RlXG59O1xuXG5leHBvcnQgeyBEcm9wZG93biBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBleHRlbmRzIGFzIF9leHRlbmRzIH0gZnJvbSAnLi4vLi4vX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5qcyc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVByZWZpeCB9IGZyb20gJy4uLy4uL2ludGVybmFsL3VzZVByZWZpeC5qcyc7XG5pbXBvcnQgZGVwcmVjYXRlIGZyb20gJy4uLy4uL3Byb3AtdHlwZXMvZGVwcmVjYXRlLmpzJztcblxuZnVuY3Rpb24gTG9hZGluZyhfcmVmKSB7XG4gIGxldCB7XG4gICAgYWN0aXZlID0gdHJ1ZSxcbiAgICBjbGFzc05hbWU6IGN1c3RvbUNsYXNzTmFtZSxcbiAgICB3aXRoT3ZlcmxheSA9IHRydWUsXG4gICAgc21hbGwgPSBmYWxzZSxcbiAgICBkZXNjcmlwdGlvbiA9ICdsb2FkaW5nJyxcbiAgICAuLi5yZXN0XG4gIH0gPSBfcmVmO1xuICBjb25zdCBwcmVmaXggPSB1c2VQcmVmaXgoKTtcbiAgY29uc3QgbG9hZGluZ0NsYXNzTmFtZSA9IGN4KGN1c3RvbUNsYXNzTmFtZSwge1xuICAgIFtgJHtwcmVmaXh9LS1sb2FkaW5nYF06IHRydWUsXG4gICAgW2Ake3ByZWZpeH0tLWxvYWRpbmctLXNtYWxsYF06IHNtYWxsLFxuICAgIFtgJHtwcmVmaXh9LS1sb2FkaW5nLS1zdG9wYF06ICFhY3RpdmVcbiAgfSk7XG4gIGNvbnN0IG92ZXJsYXlDbGFzc05hbWUgPSBjeCh7XG4gICAgW2Ake3ByZWZpeH0tLWxvYWRpbmctb3ZlcmxheWBdOiB0cnVlLFxuICAgIFtgJHtwcmVmaXh9LS1sb2FkaW5nLW92ZXJsYXktLXN0b3BgXTogIWFjdGl2ZVxuICB9KTtcbiAgY29uc3QgbG9hZGluZyA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgXCJhcmlhLWF0b21pY1wiOiBcInRydWVcIixcbiAgICBcImFyaWEtbGl2ZVwiOiBhY3RpdmUgPyAnYXNzZXJ0aXZlJyA6ICdvZmYnLFxuICAgIGNsYXNzTmFtZTogbG9hZGluZ0NsYXNzTmFtZVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwge1xuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tbG9hZGluZ19fc3ZnYCxcbiAgICB2aWV3Qm94OiBcIjAgMCAxMDAgMTAwXCJcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCBudWxsLCBkZXNjcmlwdGlvbiksIHNtYWxsID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwge1xuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tbG9hZGluZ19fYmFja2dyb3VuZGAsXG4gICAgY3g6IFwiNTAlXCIsXG4gICAgY3k6IFwiNTAlXCIsXG4gICAgcjogXCI0MlwiXG4gIH0pIDogbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwge1xuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tbG9hZGluZ19fc3Ryb2tlYCxcbiAgICBjeDogXCI1MCVcIixcbiAgICBjeTogXCI1MCVcIixcbiAgICByOiBzbWFsbCA/ICc0MicgOiAnNDQnXG4gIH0pKSk7XG4gIHJldHVybiB3aXRoT3ZlcmxheSA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IG92ZXJsYXlDbGFzc05hbWVcbiAgfSwgbG9hZGluZykgOiBsb2FkaW5nO1xufVxuTG9hZGluZy5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgeW91IHdhbnQgdGhlIGxvYWRpbmcgaW5kaWNhdG9yIHRvIGJlIHNwaW5uaW5nIG9yIG5vdFxuICAgKi9cbiAgYWN0aXZlOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIFByb3ZpZGUgYW4gb3B0aW9uYWwgY2xhc3NOYW1lIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGNvbnRhaW5pbmcgbm9kZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvKipcbiAgICogU3BlY2lmeSBhIGRlc2NyaXB0aW9uIHRoYXQgd291bGQgYmUgdXNlZCB0byBiZXN0IGRlc2NyaWJlIHRoZSBsb2FkaW5nIHN0YXRlXG4gICAqL1xuICBkZXNjcmlwdGlvbjogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAqIFByb3ZpZGUgYW4gYGlkYCB0byB1bmlxdWVseSBpZGVudGlmeSB0aGUgbGFiZWxcbiAgICovXG4gIGlkOiBkZXByZWNhdGUoUHJvcFR5cGVzLnN0cmluZywgYFxcblRoZSBwcm9wIFxcYGlkXFxgIGlzIG5vIGxvbmdlciBuZWVkZWQuYCksXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgeW91IHdvdWxkIGxpa2UgdGhlIHNtYWxsIHZhcmlhbnQgb2YgPExvYWRpbmc+XG4gICAqL1xuICBzbWFsbDogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgeW91IHdhbnQgdGhlIGxvYWRlciB0byBiZSBhcHBsaWVkIHdpdGggYW4gb3ZlcmxheVxuICAgKi9cbiAgd2l0aE92ZXJsYXk6IFByb3BUeXBlcy5ib29sXG59O1xuXG5leHBvcnQgeyBMb2FkaW5nIGFzIGRlZmF1bHQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIzXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNvbnN0IHNvcnRpbmdQcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBQcm92aWRlIGEgY29tcGFyZSBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBvcmRlcmluZyBvZlxuICAgKiBvcHRpb25zLiBgY29tcGFyZUl0ZW1zYCBoYXMgdGhlIGZvbGxvd2luZyBmdW5jdGlvbiBzaWduYXR1cmU6XG4gICAqXG4gICAqIGNvbXBhcmVGdW5jdGlvbiA6XG4gICAqICAoaXRlbUE6IHN0cmluZywgaXRlbUI6IHN0cmluZywgeyBsb2NhbGU6IHN0cmluZyB9KSA9PiBudW1iZXJcbiAgICovXG4gIGNvbXBhcmVJdGVtczogUHJvcFR5cGVzLmZ1bmMsXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgbWV0aG9kIHRoYXQgc29ydHMgYWxsIG9wdGlvbnMgaW4gdGhlIGNvbnRyb2wuIE92ZXJyaWRpbmcgdGhpc1xuICAgKiBwcm9wIG1lYW5zIHRoYXQgeW91IGFsc28gaGF2ZSB0byBoYW5kbGUgdGhlIHNvcnQgbG9naWMgZm9yIHNlbGVjdGVkIHZlcnN1c1xuICAgKiB1bi1zZWxlY3RlZCBpdGVtcy4gSWYgeW91IGp1c3Qgd2FudCB0byBjb250cm9sIG9yZGVyaW5nLCBjb25zaWRlciB0aGVcbiAgICogYGNvbXBhcmVJdGVtc2AgcHJvcCBpbnN0ZWFkLlxuICAgKlxuICAgKiBgc29ydEl0ZW1zYCBoYXMgdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gICAqXG4gICAqIHNvcnRJdGVtcyA6XG4gICAqICAgKGl0ZW1zOiBBcnJheTxJdGVtPiwge1xuICAgKiAgICAgc2VsZWN0ZWRJdGVtczogQXJyYXk8SXRlbT4sXG4gICAqICAgICBpdGVtVG9TdHJpbmc6IEl0ZW0gPT4gc3RyaW5nLFxuICAgKiAgICAgY29tcGFyZUl0ZW1zOiAoaXRlbUE6IHN0cmluZywgaXRlbUI6IHN0cmluZywge1xuICAgKiAgICAgICBsb2NhbGU6IHN0cmluZ1xuICAgKiAgICAgfSkgPT4gbnVtYmVyLFxuICAgKiAgICAgbG9jYWxlOiBzdHJpbmcsXG4gICAqICAgfSkgPT4gQXJyYXk8SXRlbT5cbiAgICovXG4gIHNvcnRJdGVtczogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmV4cG9ydCB7IHNvcnRpbmdQcm9wVHlwZXMgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIzXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8qKlxuICogVXNlIHRoZSBsb2NhbGUgYGxvY2FsZUNvbXBhcmVgIHdpdGggdGhlIGBudW1lcmljYCBvcHRpb24gdG8gc29ydCB0d29cbiAqIGFscGhhLW51bWVyaWMgc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaXRlbUEgLSBUaGUgZmlyc3Qgc3RyaW5nIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gaXRlbUIgLSBUaGUgc2Vjb25kIHN0cmluZyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciBjb21wYXJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sb2NhbGUgLSBUaGUgbG9jYWxlIHRvIHVzZSBmb3IgY29tcGFyaXNvbi5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IEEgbmVnYXRpdmUgbnVtYmVyIGlmIGl0ZW1BIGNvbWVzIGJlZm9yZSBpdGVtQiwgYSBwb3NpdGl2ZVxuICogICBudW1iZXIgaWYgaXRlbUEgY29tZXMgYWZ0ZXIgaXRlbUIsIG9yIDAgaWYgdGhleSBhcmUgZXF1YWwuXG4gKi9cbmNvbnN0IGRlZmF1bHRDb21wYXJlSXRlbXMgPSAoaXRlbUEsIGl0ZW1CLCBfcmVmKSA9PiB7XG4gIGxldCB7XG4gICAgbG9jYWxlXG4gIH0gPSBfcmVmO1xuICByZXR1cm4gaXRlbUEubG9jYWxlQ29tcGFyZShpdGVtQiwgbG9jYWxlLCB7XG4gICAgbnVtZXJpYzogdHJ1ZVxuICB9KTtcbn07XG5cbi8qKlxuICogRGVmYXVsdCBzb3J0aW5nIGFsZ29yaXRobSBmb3Igb3B0aW9ucyBpbiBhIHNlbGVjdGlvbiBjb250cm9sXG4gKi9cbmNvbnN0IGRlZmF1bHRTb3J0SXRlbXMgPSAoaXRlbXMsIF9yZWYyKSA9PiB7XG4gIGxldCB7XG4gICAgc2VsZWN0ZWRJdGVtcyA9IFtdLFxuICAgIGl0ZW1Ub1N0cmluZyxcbiAgICBjb21wYXJlSXRlbXMsXG4gICAgbG9jYWxlID0gJ2VuJ1xuICB9ID0gX3JlZjI7XG4gIHJldHVybiBpdGVtcy5zb3J0KChpdGVtQSwgaXRlbUIpID0+IHtcbiAgICAvLyBBbHdheXMgcGxhY2UgXCJzZWxlY3QgYWxsXCIgb3B0aW9uIGF0IHRoZSBiZWdpbm5pbmdcbiAgICBpZiAoaXRlbUEuaXNTZWxlY3RBbGwpIHJldHVybiAtMTtcbiAgICBpZiAoaXRlbUIuaXNTZWxlY3RBbGwpIHJldHVybiAxO1xuICAgIGNvbnN0IGhhc0l0ZW1BID0gc2VsZWN0ZWRJdGVtcy5pbmNsdWRlcyhpdGVtQSk7XG4gICAgY29uc3QgaGFzSXRlbUIgPSBzZWxlY3RlZEl0ZW1zLmluY2x1ZGVzKGl0ZW1CKTtcbiAgICBpZiAoaGFzSXRlbUEgJiYgIWhhc0l0ZW1CKSByZXR1cm4gLTE7XG4gICAgaWYgKGhhc0l0ZW1CICYmICFoYXNJdGVtQSkgcmV0dXJuIDE7XG4gICAgcmV0dXJuIGNvbXBhcmVJdGVtcyhpdGVtVG9TdHJpbmcoaXRlbUEpLCBpdGVtVG9TdHJpbmcoaXRlbUIpLCB7XG4gICAgICBsb2NhbGVcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5leHBvcnQgeyBkZWZhdWx0Q29tcGFyZUl0ZW1zLCBkZWZhdWx0U29ydEl0ZW1zIH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSAncmVhY3QtZmFzdC1jb21wYXJlJztcblxuY29uc3QgY2FsbE9uQ2hhbmdlSGFuZGxlciA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGlzQ29udHJvbGxlZCxcbiAgICBpc01vdW50ZWQsXG4gICAgb25DaGFuZ2VIYW5kbGVyQ29udHJvbGxlZCxcbiAgICBvbkNoYW5nZUhhbmRsZXJVbmNvbnRyb2xsZWQsXG4gICAgc2VsZWN0ZWRJdGVtc1xuICB9ID0gX3JlZjtcbiAgaWYgKGlzQ29udHJvbGxlZCkge1xuICAgIGlmIChpc01vdW50ZWQgJiYgb25DaGFuZ2VIYW5kbGVyQ29udHJvbGxlZCkge1xuICAgICAgb25DaGFuZ2VIYW5kbGVyQ29udHJvbGxlZCh7XG4gICAgICAgIHNlbGVjdGVkSXRlbXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvbkNoYW5nZUhhbmRsZXJVbmNvbnRyb2xsZWQoc2VsZWN0ZWRJdGVtcyk7XG4gIH1cbn07XG5jb25zdCB1c2VTZWxlY3Rpb24gPSBfcmVmMiA9PiB7XG4gIGxldCB7XG4gICAgZGlzYWJsZWQsXG4gICAgb25DaGFuZ2UsXG4gICAgaW5pdGlhbFNlbGVjdGVkSXRlbXMgPSBbXSxcbiAgICBzZWxlY3RlZEl0ZW1zOiBjb250cm9sbGVkSXRlbXMsXG4gICAgc2VsZWN0QWxsID0gZmFsc2UsXG4gICAgZmlsdGVyZWRJdGVtcyA9IFtdXG4gIH0gPSBfcmVmMjtcbiAgY29uc3QgaXNNb3VudGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3Qgc2F2ZWRPbkNoYW5nZSA9IHVzZVJlZihvbkNoYW5nZSk7XG4gIGNvbnN0IFt1bmNvbnRyb2xsZWRJdGVtcywgc2V0VW5jb250cm9sbGVkSXRlbXNdID0gdXNlU3RhdGUoaW5pdGlhbFNlbGVjdGVkSXRlbXMpO1xuICBjb25zdCBpc0NvbnRyb2xsZWQgPSAhIWNvbnRyb2xsZWRJdGVtcztcbiAgY29uc3Qgc2VsZWN0ZWRJdGVtcyA9IGlzQ29udHJvbGxlZCA/IGNvbnRyb2xsZWRJdGVtcyA6IHVuY29udHJvbGxlZEl0ZW1zO1xuICBjb25zdCBvbkl0ZW1DaGFuZ2UgPSB1c2VDYWxsYmFjayhpdGVtID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcblxuICAgIC8vIEFzc2VydCBzcGVjaWFsIHByb3BlcnRpZXMgKGUuZy4sIGBkaXNhYmxlZGAsIGBpc1NlbGVjdEFsbGAsIGV0Yy4pIGFyZVxuICAgIC8vIGBhbnlgIHNpbmNlIHRob3NlIHByb3BlcnRpZXMgYXJlbuKAmXQgcGFydCBvZiB0aGUgZ2VuZXJpYyB0eXBlLlxuICAgIGNvbnN0IGFsbFNlbGVjdGFibGVJdGVtcyA9IGZpbHRlcmVkSXRlbXMuZmlsdGVyKGl0ZW0gPT4gIWl0ZW0/LmRpc2FibGVkKTtcbiAgICBjb25zdCBkaXNhYmxlZEl0ZW1Db3VudCA9IGZpbHRlcmVkSXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbT8uZGlzYWJsZWQpLmxlbmd0aDtcbiAgICBsZXQgbmV3U2VsZWN0ZWRJdGVtcztcblxuICAgIC8vIGRlc2VsZWN0IGFsbCBvbiBjbGljayB0byBBbGwvaW5kZXRlcm1pbmF0ZSBvcHRpb25cbiAgICBpZiAoaXRlbT8uaXNTZWxlY3RBbGwgJiYgc2VsZWN0ZWRJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICBuZXdTZWxlY3RlZEl0ZW1zID0gW107XG4gICAgfVxuICAgIC8vIHNlbGVjdCBhbGwgb3B0aW9uc1xuICAgIGVsc2UgaWYgKGl0ZW0/LmlzU2VsZWN0QWxsICYmIHNlbGVjdGVkSXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBuZXdTZWxlY3RlZEl0ZW1zID0gYWxsU2VsZWN0YWJsZUl0ZW1zO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzZWxlY3RlZEluZGV4ID0gc2VsZWN0ZWRJdGVtcy5maW5kTGFzdEluZGV4KHNlbGVjdGVkSXRlbSA9PiBpc0VxdWFsKHNlbGVjdGVkSXRlbSwgaXRlbSkpO1xuICAgICAgaWYgKHNlbGVjdGVkSW5kZXggPT09IC0xKSB7XG4gICAgICAgIG5ld1NlbGVjdGVkSXRlbXMgPSBzZWxlY3RlZEl0ZW1zLmNvbmNhdChpdGVtKTtcbiAgICAgICAgLy8gY2hlY2tpbmcgaWYgYWxsIGl0ZW1zIGFyZSBzZWxlY3RlZCB0aGVuIFdlIHNob3VsZCBzZWxlY3QgbWFyayB0aGUgJ3NlbGVjdCBBbGwnIG9wdGlvbiBhcyB3ZWxsXG4gICAgICAgIGlmIChzZWxlY3RBbGwgJiYgZmlsdGVyZWRJdGVtcy5sZW5ndGggLSAxID09PSBuZXdTZWxlY3RlZEl0ZW1zLmxlbmd0aCArIGRpc2FibGVkSXRlbUNvdW50KSB7XG4gICAgICAgICAgbmV3U2VsZWN0ZWRJdGVtcyA9IGFsbFNlbGVjdGFibGVJdGVtcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3U2VsZWN0ZWRJdGVtcyA9IHJlbW92ZUF0SW5kZXgoc2VsZWN0ZWRJdGVtcywgc2VsZWN0ZWRJbmRleCk7XG4gICAgICAgIG5ld1NlbGVjdGVkSXRlbXMgPSBuZXdTZWxlY3RlZEl0ZW1zLmZpbHRlcihpdGVtID0+ICFpdGVtPy5pc1NlbGVjdEFsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNhbGxPbkNoYW5nZUhhbmRsZXIoe1xuICAgICAgaXNDb250cm9sbGVkLFxuICAgICAgaXNNb3VudGVkOiBpc01vdW50ZWQuY3VycmVudCxcbiAgICAgIG9uQ2hhbmdlSGFuZGxlckNvbnRyb2xsZWQ6IHNhdmVkT25DaGFuZ2UuY3VycmVudCxcbiAgICAgIG9uQ2hhbmdlSGFuZGxlclVuY29udHJvbGxlZDogc2V0VW5jb250cm9sbGVkSXRlbXMsXG4gICAgICBzZWxlY3RlZEl0ZW1zOiBuZXdTZWxlY3RlZEl0ZW1zXG4gICAgfSk7XG4gIH0sIFtkaXNhYmxlZCwgc2VsZWN0ZWRJdGVtcywgZmlsdGVyZWRJdGVtcywgc2VsZWN0QWxsLCBpc0NvbnRyb2xsZWRdKTtcbiAgY29uc3QgY2xlYXJTZWxlY3Rpb24gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkKSByZXR1cm47XG4gICAgY2FsbE9uQ2hhbmdlSGFuZGxlcih7XG4gICAgICBpc0NvbnRyb2xsZWQsXG4gICAgICBpc01vdW50ZWQ6IGlzTW91bnRlZC5jdXJyZW50LFxuICAgICAgb25DaGFuZ2VIYW5kbGVyQ29udHJvbGxlZDogc2F2ZWRPbkNoYW5nZS5jdXJyZW50LFxuICAgICAgb25DaGFuZ2VIYW5kbGVyVW5jb250cm9sbGVkOiBzZXRVbmNvbnRyb2xsZWRJdGVtcyxcbiAgICAgIHNlbGVjdGVkSXRlbXM6IFtdXG4gICAgfSk7XG4gIH0sIFtkaXNhYmxlZCwgaXNDb250cm9sbGVkXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2F2ZWRPbkNoYW5nZS5jdXJyZW50ID0gb25DaGFuZ2U7XG4gIH0sIFtvbkNoYW5nZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpc01vdW50ZWQuY3VycmVudCAmJiBzYXZlZE9uQ2hhbmdlLmN1cnJlbnQgJiYgIWlzQ29udHJvbGxlZCkge1xuICAgICAgc2F2ZWRPbkNoYW5nZS5jdXJyZW50KHtcbiAgICAgICAgc2VsZWN0ZWRJdGVtc1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBbaXNDb250cm9sbGVkLCBzZWxlY3RlZEl0ZW1zXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHtcbiAgICBjbGVhclNlbGVjdGlvbixcbiAgICBvbkl0ZW1DaGFuZ2UsXG4gICAgc2VsZWN0ZWRJdGVtc1xuICB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmljIHV0aWxpdHkgZm9yIHNhZmVseSByZW1vdmluZyBhbiBlbGVtZW50IGF0IGEgZ2l2ZW4gaW5kZXggZnJvbSBhblxuICogYXJyYXkuXG4gKi9cbmNvbnN0IHJlbW92ZUF0SW5kZXggPSAoYXJyYXksIGluZGV4KSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IGFycmF5LnNsaWNlKCk7XG4gIHJlc3VsdC5zcGxpY2UoaW5kZXgsIDEpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IHsgdXNlU2VsZWN0aW9uIH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBleHRlbmRzIGFzIF9leHRlbmRzIH0gZnJvbSAnLi4vLi4vX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5qcyc7XG5pbXBvcnQgeyBXYXJuaW5nRmlsbGVkLCBXYXJuaW5nQWx0RmlsbGVkIH0gZnJvbSAnQGNhcmJvbi9pY29ucy1yZWFjdCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyB1c2VTZWxlY3QgfSBmcm9tICdkb3duc2hpZnQnO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSAncmVhY3QtZmFzdC1jb21wYXJlJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlTWVtbywgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUxheW91dEVmZmVjdCwgaXNWYWxpZEVsZW1lbnQsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IExpc3RCb3ggZnJvbSAnLi4vTGlzdEJveC9pbmRleC5qcyc7XG5pbXBvcnQgeyBzb3J0aW5nUHJvcFR5cGVzIH0gZnJvbSAnLi9NdWx0aVNlbGVjdFByb3BUeXBlcy5qcyc7XG5pbXBvcnQgeyBkZWZhdWx0U29ydEl0ZW1zLCBkZWZhdWx0Q29tcGFyZUl0ZW1zIH0gZnJvbSAnLi90b29scy9zb3J0aW5nLmpzJztcbmltcG9ydCB7IHVzZVNlbGVjdGlvbiB9IGZyb20gJy4uLy4uL2ludGVybmFsL1NlbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyB1c2VJZCB9IGZyb20gJy4uLy4uL2ludGVybmFsL3VzZUlkLmpzJztcbmltcG9ydCBtZXJnZVJlZnMgZnJvbSAnLi4vLi4vdG9vbHMvbWVyZ2VSZWZzLmpzJztcbmltcG9ydCBkZXByZWNhdGUgZnJvbSAnLi4vLi4vcHJvcC10eXBlcy9kZXByZWNhdGUuanMnO1xuaW1wb3J0IHsgRGVsZXRlLCBFc2NhcGUsIFNwYWNlLCBBcnJvd0Rvd24sIEVudGVyIH0gZnJvbSAnLi4vLi4vaW50ZXJuYWwva2V5Ym9hcmQva2V5cy5qcyc7XG5pbXBvcnQgeyBtYXRjaCB9IGZyb20gJy4uLy4uL2ludGVybmFsL2tleWJvYXJkL21hdGNoLmpzJztcbmltcG9ydCB7IHVzZVByZWZpeCB9IGZyb20gJy4uLy4uL2ludGVybmFsL3VzZVByZWZpeC5qcyc7XG5pbXBvcnQgJy4uL0ZsdWlkRm9ybS9GbHVpZEZvcm0uanMnO1xuaW1wb3J0IHsgRm9ybUNvbnRleHQgfSBmcm9tICcuLi9GbHVpZEZvcm0vRm9ybUNvbnRleHQuanMnO1xuaW1wb3J0IENoZWNrYm94IGZyb20gJy4uL0NoZWNrYm94L0NoZWNrYm94LmpzJztcbmltcG9ydCAnLi4vQ2hlY2tib3gvQ2hlY2tib3guU2tlbGV0b24uanMnO1xuaW1wb3J0IHsgbm9vcEZuIH0gZnJvbSAnLi4vLi4vaW50ZXJuYWwvbm9vcEZuLmpzJztcbmltcG9ydCB7IHVzZUZsb2F0aW5nLCBmbGlwLCBzaXplLCBoaWRlLCBhdXRvVXBkYXRlIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3JlYWN0JztcbmltcG9ydCB7IHVzZUZlYXR1cmVGbGFnIH0gZnJvbSAnLi4vRmVhdHVyZUZsYWdzL2luZGV4LmpzJztcbmltcG9ydCB7IExpc3RCb3hTaXplUHJvcFR5cGUsIExpc3RCb3hUeXBlUHJvcFR5cGUgfSBmcm9tICcuLi9MaXN0Qm94L0xpc3RCb3hQcm9wVHlwZXMuanMnO1xuXG5jb25zdCB7XG4gIEl0ZW1DbGljayxcbiAgVG9nZ2xlQnV0dG9uQmx1cixcbiAgVG9nZ2xlQnV0dG9uS2V5RG93bkFycm93RG93bixcbiAgVG9nZ2xlQnV0dG9uS2V5RG93bkFycm93VXAsXG4gIFRvZ2dsZUJ1dHRvbktleURvd25FbnRlcixcbiAgVG9nZ2xlQnV0dG9uS2V5RG93bkVzY2FwZSxcbiAgVG9nZ2xlQnV0dG9uS2V5RG93blNwYWNlQnV0dG9uLFxuICBJdGVtTW91c2VNb3ZlLFxuICBNZW51TW91c2VMZWF2ZSxcbiAgVG9nZ2xlQnV0dG9uQ2xpY2ssXG4gIFRvZ2dsZUJ1dHRvbktleURvd25QYWdlRG93bixcbiAgVG9nZ2xlQnV0dG9uS2V5RG93blBhZ2VVcCxcbiAgRnVuY3Rpb25TZXRIaWdobGlnaHRlZEluZGV4XG59ID0gdXNlU2VsZWN0LnN0YXRlQ2hhbmdlVHlwZXM7XG5jb25zdCBkZWZhdWx0SXRlbVRvU3RyaW5nID0gaXRlbSA9PiB7XG4gIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuICBpZiAodHlwZW9mIGl0ZW0gPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGAke2l0ZW19YDtcbiAgfVxuICBpZiAoaXRlbSAhPT0gbnVsbCAmJiB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcgJiYgJ2xhYmVsJyBpbiBpdGVtICYmIHR5cGVvZiBpdGVtWydsYWJlbCddID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBpdGVtWydsYWJlbCddO1xuICB9XG4gIHJldHVybiAnJztcbn07XG5jb25zdCBNdWx0aVNlbGVjdCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChfcmVmLCByZWYpID0+IHtcbiAgbGV0IHtcbiAgICBhdXRvQWxpZ24gPSBmYWxzZSxcbiAgICBjbGFzc05hbWU6IGNvbnRhaW5lckNsYXNzTmFtZSxcbiAgICBkZWNvcmF0b3IsXG4gICAgaWQsXG4gICAgaXRlbXMsXG4gICAgaXRlbVRvRWxlbWVudCxcbiAgICBpdGVtVG9TdHJpbmcgPSBkZWZhdWx0SXRlbVRvU3RyaW5nLFxuICAgIHRpdGxlVGV4dCA9IGZhbHNlLFxuICAgIGhpZGVMYWJlbCxcbiAgICBoZWxwZXJUZXh0LFxuICAgIGxhYmVsLFxuICAgIHR5cGUgPSAnZGVmYXVsdCcsXG4gICAgc2l6ZTogc2l6ZSQxLFxuICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgaW5pdGlhbFNlbGVjdGVkSXRlbXMgPSBbXSxcbiAgICBzb3J0SXRlbXMgPSBkZWZhdWx0U29ydEl0ZW1zLFxuICAgIGNvbXBhcmVJdGVtcyA9IGRlZmF1bHRDb21wYXJlSXRlbXMsXG4gICAgY2xlYXJTZWxlY3Rpb25UZXh0ID0gJ1RvIGNsZWFyIHNlbGVjdGlvbiwgcHJlc3MgRGVsZXRlIG9yIEJhY2tzcGFjZScsXG4gICAgY2xlYXJBbm5vdW5jZW1lbnQgPSAnYWxsIGl0ZW1zIGhhdmUgYmVlbiBjbGVhcmVkJyxcbiAgICBjbGVhclNlbGVjdGlvbkRlc2NyaXB0aW9uID0gJ1RvdGFsIGl0ZW1zIHNlbGVjdGVkOiAnLFxuICAgIGxpZ2h0LFxuICAgIGludmFsaWQsXG4gICAgaW52YWxpZFRleHQsXG4gICAgd2FybixcbiAgICB3YXJuVGV4dCxcbiAgICB1c2VUaXRsZUluSXRlbSxcbiAgICB0cmFuc2xhdGVXaXRoSWQsXG4gICAgZG93bnNoaWZ0UHJvcHMsXG4gICAgb3BlbiA9IGZhbHNlLFxuICAgIHNlbGVjdGlvbkZlZWRiYWNrID0gJ3RvcC1hZnRlci1yZW9wZW4nLFxuICAgIG9uQ2hhbmdlLFxuICAgIG9uTWVudUNoYW5nZSxcbiAgICBkaXJlY3Rpb24gPSAnYm90dG9tJyxcbiAgICBzZWxlY3RlZEl0ZW1zOiBzZWxlY3RlZCxcbiAgICByZWFkT25seSxcbiAgICBsb2NhbGUgPSAnZW4nLFxuICAgIHNsdWdcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGZpbHRlcmVkSXRlbXMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gaXRlbXMuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJiBpdGVtICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGl0ZW0pIHtcbiAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihpdGVtLCBrZXkpICYmIGl0ZW1ba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFJldHVybiBmYWxzZSBpZiBhbnkgcHJvcGVydHkgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7IC8vIFJldHVybiB0cnVlIGlmIGl0ZW0gaXMgbm90IGFuIG9iamVjdCB3aXRoIHVuZGVmaW5lZCB2YWx1ZXNcbiAgICB9KTtcbiAgfSwgW2l0ZW1zXSk7XG4gIGxldCBzZWxlY3RBbGwgPSBmaWx0ZXJlZEl0ZW1zLnNvbWUoaXRlbSA9PiBpdGVtLmlzU2VsZWN0QWxsKTtcbiAgaWYgKChzZWxlY3RlZCA/PyBbXSkubGVuZ3RoID4gMCAmJiBzZWxlY3RBbGwpIHtcbiAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IGBzZWxlY3RBbGxgIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGBzZWxlY3RlZEl0ZW1zYCBpcyBwcm92aWRlZC4gUGxlYXNlIHBhc3MgZWl0aGVyIGBzZWxlY3RBbGxgIG9yIGBzZWxlY3RlZEl0ZW1zYCwgbm90IGJvdGguJyk7XG4gICAgc2VsZWN0QWxsID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgcHJlZml4ID0gdXNlUHJlZml4KCk7XG4gIGNvbnN0IHtcbiAgICBpc0ZsdWlkXG4gIH0gPSB1c2VDb250ZXh0KEZvcm1Db250ZXh0KTtcbiAgY29uc3QgbXVsdGlTZWxlY3RJbnN0YW5jZUlkID0gdXNlSWQoKTtcbiAgY29uc3QgW2lzRm9jdXNlZCwgc2V0SXNGb2N1c2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lucHV0Rm9jdXNlZCwgc2V0SW5wdXRGb2N1c2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzT3Blbiwgc2V0SXNPcGVuXSA9IHVzZVN0YXRlKG9wZW4gfHwgZmFsc2UpO1xuICBjb25zdCBbcHJldk9wZW5Qcm9wLCBzZXRQcmV2T3BlblByb3BdID0gdXNlU3RhdGUob3Blbik7XG4gIGNvbnN0IFt0b3BJdGVtcywgc2V0VG9wSXRlbXNdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbaXRlbXNDbGVhcmVkLCBzZXRJdGVtc0NsZWFyZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBlbmFibGVGbG9hdGluZ1N0eWxlcyA9IHVzZUZlYXR1cmVGbGFnKCdlbmFibGUtdjEyLWR5bmFtaWMtZmxvYXRpbmctc3R5bGVzJykgfHwgYXV0b0FsaWduO1xuICBjb25zdCB7XG4gICAgcmVmcyxcbiAgICBmbG9hdGluZ1N0eWxlcyxcbiAgICBtaWRkbGV3YXJlRGF0YVxuICB9ID0gdXNlRmxvYXRpbmcoZW5hYmxlRmxvYXRpbmdTdHlsZXMgPyB7XG4gICAgcGxhY2VtZW50OiBkaXJlY3Rpb24sXG4gICAgLy8gVGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgcG9zaXRpb25lZCByZWxhdGl2ZSB0byBpdHMgbmVhcmVzdFxuICAgIC8vIGNvbnRhaW5pbmcgYmxvY2sgKHVzdWFsbHkgdGhlIHZpZXdwb3J0KS4gSXQgd2lsbCBpbiBtYW55IGNhc2VzIGFsc29cbiAgICAvLyDigJxicmVha+KAnSB0aGUgZmxvYXRpbmcgZWxlbWVudCBvdXQgb2YgYSBjbGlwcGluZyBhbmNlc3Rvci5cbiAgICAvLyBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL21pc2MjY2xpcHBpbmdcbiAgICBzdHJhdGVneTogJ2ZpeGVkJyxcbiAgICAvLyBNaWRkbGV3YXJlIG9yZGVyIG1hdHRlcnMsIGFycm93IHNob3VsZCBiZSBsYXN0XG4gICAgbWlkZGxld2FyZTogW2F1dG9BbGlnbiAmJiBmbGlwKHtcbiAgICAgIGNyb3NzQXhpczogZmFsc2VcbiAgICB9KSwgc2l6ZSh7XG4gICAgICBhcHBseShfcmVmMikge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIHJlY3RzLFxuICAgICAgICAgIGVsZW1lbnRzXG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50cy5mbG9hdGluZy5zdHlsZSwge1xuICAgICAgICAgIHdpZHRoOiBgJHtyZWN0cy5yZWZlcmVuY2Uud2lkdGh9cHhgXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLCBhdXRvQWxpZ24gJiYgaGlkZSgpXSxcbiAgICB3aGlsZUVsZW1lbnRzTW91bnRlZDogYXV0b1VwZGF0ZVxuICB9IDoge30pO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlbmFibGVGbG9hdGluZ1N0eWxlcykge1xuICAgICAgY29uc3QgdXBkYXRlZEZsb2F0aW5nU3R5bGVzID0ge1xuICAgICAgICAuLi5mbG9hdGluZ1N0eWxlcyxcbiAgICAgICAgdmlzaWJpbGl0eTogbWlkZGxld2FyZURhdGEuaGlkZT8ucmVmZXJlbmNlSGlkZGVuID8gJ2hpZGRlbicgOiAndmlzaWJsZSdcbiAgICAgIH07XG4gICAgICBPYmplY3Qua2V5cyh1cGRhdGVkRmxvYXRpbmdTdHlsZXMpLmZvckVhY2goc3R5bGUgPT4ge1xuICAgICAgICBpZiAocmVmcy5mbG9hdGluZy5jdXJyZW50KSB7XG4gICAgICAgICAgcmVmcy5mbG9hdGluZy5jdXJyZW50LnN0eWxlW3N0eWxlXSA9IHVwZGF0ZWRGbG9hdGluZ1N0eWxlc1tzdHlsZV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2VuYWJsZUZsb2F0aW5nU3R5bGVzLCBmbG9hdGluZ1N0eWxlcywgcmVmcy5mbG9hdGluZywgbWlkZGxld2FyZURhdGEsIG9wZW5dKTtcbiAgY29uc3Qge1xuICAgIHNlbGVjdGVkSXRlbXM6IGNvbnRyb2xsZWRTZWxlY3RlZEl0ZW1zLFxuICAgIG9uSXRlbUNoYW5nZSxcbiAgICBjbGVhclNlbGVjdGlvblxuICB9ID0gdXNlU2VsZWN0aW9uKHtcbiAgICBkaXNhYmxlZCxcbiAgICBpbml0aWFsU2VsZWN0ZWRJdGVtcyxcbiAgICBvbkNoYW5nZSxcbiAgICBzZWxlY3RlZEl0ZW1zOiBzZWxlY3RlZCxcbiAgICBzZWxlY3RBbGwsXG4gICAgZmlsdGVyZWRJdGVtc1xuICB9KTtcbiAgY29uc3Qgc29ydE9wdGlvbnMgPSB7XG4gICAgc2VsZWN0ZWRJdGVtczogY29udHJvbGxlZFNlbGVjdGVkSXRlbXMsXG4gICAgaXRlbVRvU3RyaW5nLFxuICAgIGNvbXBhcmVJdGVtcyxcbiAgICBsb2NhbGVcbiAgfTtcbiAgY29uc3Qgc2VsZWN0UHJvcHMgPSB7XG4gICAgc3RhdGVSZWR1Y2VyLFxuICAgIGlzT3BlbixcbiAgICBpdGVtVG9TdHJpbmc6IGZpbHRlcmVkSXRlbXMgPT4ge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZmlsdGVyZWRJdGVtcykgJiYgZmlsdGVyZWRJdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1Ub1N0cmluZyhpdGVtKTtcbiAgICAgIH0pLmpvaW4oJywgJykgfHwgJyc7XG4gICAgfSxcbiAgICBzZWxlY3RlZEl0ZW06IGNvbnRyb2xsZWRTZWxlY3RlZEl0ZW1zLFxuICAgIGl0ZW1zOiBmaWx0ZXJlZEl0ZW1zLFxuICAgIGlzSXRlbURpc2FibGVkKGl0ZW0sIF9pbmRleCkge1xuICAgICAgcmV0dXJuIGl0ZW0/LmRpc2FibGVkO1xuICAgIH0sXG4gICAgLi4uZG93bnNoaWZ0UHJvcHNcbiAgfTtcbiAgY29uc3Qge1xuICAgIGdldFRvZ2dsZUJ1dHRvblByb3BzLFxuICAgIGdldExhYmVsUHJvcHMsXG4gICAgZ2V0TWVudVByb3BzLFxuICAgIGdldEl0ZW1Qcm9wcyxcbiAgICBzZWxlY3RlZEl0ZW0sXG4gICAgaGlnaGxpZ2h0ZWRJbmRleCxcbiAgICBzZXRIaWdobGlnaHRlZEluZGV4XG4gIH0gPSB1c2VTZWxlY3Qoc2VsZWN0UHJvcHMpO1xuICBjb25zdCB0b2dnbGVCdXR0b25Qcm9wcyA9IGdldFRvZ2dsZUJ1dHRvblByb3BzKHtcbiAgICBvbkZvY3VzOiAoKSA9PiB7XG4gICAgICBzZXRJbnB1dEZvY3VzZWQodHJ1ZSk7XG4gICAgfSxcbiAgICBvbkJsdXI6ICgpID0+IHtcbiAgICAgIHNldElucHV0Rm9jdXNlZChmYWxzZSk7XG4gICAgfSxcbiAgICBvbktleURvd246IGUgPT4ge1xuICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICBpZiAoKG1hdGNoKGUsIERlbGV0ZSkgfHwgbWF0Y2goZSwgRXNjYXBlKSkgJiYgIWlzT3Blbikge1xuICAgICAgICAgIGNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzT3BlbiAmJiBtYXRjaChlLCBEZWxldGUpICYmIHNlbGVjdGVkSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHNldEl0ZW1zQ2xlYXJlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG1hdGNoKGUsIFNwYWNlKSB8fCBtYXRjaChlLCBBcnJvd0Rvd24pIHx8IG1hdGNoKGUsIEVudGVyKSkgJiYgIWlzT3Blbikge1xuICAgICAgICAgIHNldEhpZ2hsaWdodGVkSW5kZXgoMCk7XG4gICAgICAgICAgc2V0SXRlbXNDbGVhcmVkKGZhbHNlKTtcbiAgICAgICAgICBzZXRJc09wZW5XcmFwcGVyKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaChlLCBBcnJvd0Rvd24pICYmIHNlbGVjdGVkSXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgc2V0SW5wdXRGb2N1c2VkKGZhbHNlKTtcbiAgICAgICAgICBzZXRJc0ZvY3VzZWQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaChlLCBFc2NhcGUpICYmIGlzT3Blbikge1xuICAgICAgICAgIHNldElucHV0Rm9jdXNlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2goZSwgRW50ZXIpICYmIGlzT3Blbikge1xuICAgICAgICAgIHNldElucHV0Rm9jdXNlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG1lcmdlZFJlZiA9IG1lcmdlUmVmcyh0b2dnbGVCdXR0b25Qcm9wcy5yZWYsIHJlZik7XG4gIGNvbnN0IHNlbGVjdGVkSXRlbXMgPSBzZWxlY3RlZEl0ZW07XG5cbiAgLyoqXG4gICAqIHdyYXBwZXIgZnVuY3Rpb24gdG8gZm9yd2FyZCBjaGFuZ2VzIHRvIGNvbnN1bWVyXG4gICAqL1xuICBjb25zdCBzZXRJc09wZW5XcmFwcGVyID0gb3BlbiA9PiB7XG4gICAgc2V0SXNPcGVuKG9wZW4pO1xuICAgIGlmIChvbk1lbnVDaGFuZ2UpIHtcbiAgICAgIG9uTWVudUNoYW5nZShvcGVuKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIHByb2dyYW1tYXRpY2FsbHkgY29udHJvbCB0aGlzIGBvcGVuYCBwcm9wXG4gICAqL1xuICBpZiAocHJldk9wZW5Qcm9wICE9PSBvcGVuKSB7XG4gICAgc2V0SXNPcGVuV3JhcHBlcihvcGVuKTtcbiAgICBzZXRQcmV2T3BlblByb3Aob3Blbik7XG4gIH1cbiAgY29uc3QgaW5saW5lID0gdHlwZSA9PT0gJ2lubGluZSc7XG4gIGNvbnN0IHNob3dXYXJuaW5nID0gIWludmFsaWQgJiYgd2FybjtcbiAgY29uc3Qgd3JhcHBlckNsYXNzZXMgPSBjeChgJHtwcmVmaXh9LS1tdWx0aS1zZWxlY3RfX3dyYXBwZXJgLCBgJHtwcmVmaXh9LS1saXN0LWJveF9fd3JhcHBlcmAsIGNvbnRhaW5lckNsYXNzTmFtZSwge1xuICAgIFtgJHtwcmVmaXh9LS1tdWx0aS1zZWxlY3RfX3dyYXBwZXItLWlubGluZWBdOiBpbmxpbmUsXG4gICAgW2Ake3ByZWZpeH0tLWxpc3QtYm94X193cmFwcGVyLS1pbmxpbmVgXTogaW5saW5lLFxuICAgIFtgJHtwcmVmaXh9LS1tdWx0aS1zZWxlY3RfX3dyYXBwZXItLWlubGluZS0taW52YWxpZGBdOiBpbmxpbmUgJiYgaW52YWxpZCxcbiAgICBbYCR7cHJlZml4fS0tbGlzdC1ib3hfX3dyYXBwZXItLWlubGluZS0taW52YWxpZGBdOiBpbmxpbmUgJiYgaW52YWxpZCxcbiAgICBbYCR7cHJlZml4fS0tbGlzdC1ib3hfX3dyYXBwZXItLWZsdWlkLS1pbnZhbGlkYF06IGlzRmx1aWQgJiYgaW52YWxpZCxcbiAgICBbYCR7cHJlZml4fS0tbGlzdC1ib3hfX3dyYXBwZXItLXNsdWdgXTogc2x1ZyxcbiAgICBbYCR7cHJlZml4fS0tbGlzdC1ib3hfX3dyYXBwZXItLWRlY29yYXRvcmBdOiBkZWNvcmF0b3JcbiAgfSk7XG4gIGNvbnN0IHRpdGxlQ2xhc3NlcyA9IGN4KGAke3ByZWZpeH0tLWxhYmVsYCwge1xuICAgIFtgJHtwcmVmaXh9LS1sYWJlbC0tZGlzYWJsZWRgXTogZGlzYWJsZWQsXG4gICAgW2Ake3ByZWZpeH0tLXZpc3VhbGx5LWhpZGRlbmBdOiBoaWRlTGFiZWxcbiAgfSk7XG4gIGNvbnN0IGhlbHBlcklkID0gIWhlbHBlclRleHQgPyB1bmRlZmluZWQgOiBgbXVsdGlzZWxlY3QtaGVscGVyLXRleHQtJHttdWx0aVNlbGVjdEluc3RhbmNlSWR9YDtcbiAgY29uc3QgZmllbGRMYWJlbElkID0gYG11bHRpc2VsZWN0LWZpZWxkLWxhYmVsLSR7bXVsdGlTZWxlY3RJbnN0YW5jZUlkfWA7XG4gIGNvbnN0IGhlbHBlckNsYXNzZXMgPSBjeChgJHtwcmVmaXh9LS1mb3JtX19oZWxwZXItdGV4dGAsIHtcbiAgICBbYCR7cHJlZml4fS0tZm9ybV9faGVscGVyLXRleHQtLWRpc2FibGVkYF06IGRpc2FibGVkXG4gIH0pO1xuICBjb25zdCBjbGFzc05hbWUgPSBjeChgJHtwcmVmaXh9LS1tdWx0aS1zZWxlY3RgLCB7XG4gICAgW2Ake3ByZWZpeH0tLW11bHRpLXNlbGVjdC0taW52YWxpZGBdOiBpbnZhbGlkLFxuICAgIFtgJHtwcmVmaXh9LS1tdWx0aS1zZWxlY3QtLWludmFsaWQtLWZvY3VzZWRgXTogaW52YWxpZCAmJiBpbnB1dEZvY3VzZWQsXG4gICAgW2Ake3ByZWZpeH0tLW11bHRpLXNlbGVjdC0td2FybmluZ2BdOiBzaG93V2FybmluZyxcbiAgICBbYCR7cHJlZml4fS0tbXVsdGktc2VsZWN0LS1pbmxpbmVgXTogaW5saW5lLFxuICAgIFtgJHtwcmVmaXh9LS1tdWx0aS1zZWxlY3QtLXNlbGVjdGVkYF06IHNlbGVjdGVkSXRlbXMgJiYgc2VsZWN0ZWRJdGVtcy5sZW5ndGggPiAwLFxuICAgIFtgJHtwcmVmaXh9LS1saXN0LWJveC0tdXBgXTogZGlyZWN0aW9uID09PSAndG9wJyxcbiAgICBbYCR7cHJlZml4fS0tbXVsdGktc2VsZWN0LS1yZWFkb25seWBdOiByZWFkT25seSxcbiAgICBbYCR7cHJlZml4fS0tYXV0b2FsaWduYF06IGVuYWJsZUZsb2F0aW5nU3R5bGVzLFxuICAgIFtgJHtwcmVmaXh9LS1tdWx0aS1zZWxlY3QtLXNlbGVjdGFsbGBdOiBzZWxlY3RBbGxcbiAgfSk7XG5cbiAgLy8gbmVlZHMgdG8gYmUgY2FwaXRhbGl6ZWQgZm9yIHJlYWN0IHRvIHJlbmRlciBpdCBjb3JyZWN0bHlcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgY29uc3QgSXRlbVRvRWxlbWVudCA9IGl0ZW1Ub0VsZW1lbnQ7XG4gIGlmIChzZWxlY3Rpb25GZWVkYmFjayA9PT0gJ2ZpeGVkJykge1xuICAgIHNvcnRPcHRpb25zLnNlbGVjdGVkSXRlbXMgPSBbXTtcbiAgfSBlbHNlIGlmIChzZWxlY3Rpb25GZWVkYmFjayA9PT0gJ3RvcC1hZnRlci1yZW9wZW4nKSB7XG4gICAgc29ydE9wdGlvbnMuc2VsZWN0ZWRJdGVtcyA9IHRvcEl0ZW1zO1xuICB9XG4gIGZ1bmN0aW9uIHN0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uQW5kQ2hhbmdlcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNoYW5nZXMsXG4gICAgICBwcm9wcyxcbiAgICAgIHR5cGVcbiAgICB9ID0gYWN0aW9uQW5kQ2hhbmdlcztcbiAgICBjb25zdCB7XG4gICAgICBoaWdobGlnaHRlZEluZGV4XG4gICAgfSA9IGNoYW5nZXM7XG4gICAgaWYgKGNoYW5nZXMuaXNPcGVuICYmICFpc09wZW4pIHtcbiAgICAgIHNldFRvcEl0ZW1zKGNvbnRyb2xsZWRTZWxlY3RlZEl0ZW1zKTtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFRvZ2dsZUJ1dHRvbktleURvd25TcGFjZUJ1dHRvbjpcbiAgICAgIGNhc2UgVG9nZ2xlQnV0dG9uS2V5RG93bkVudGVyOlxuICAgICAgICBpZiAoY2hhbmdlcy5zZWxlY3RlZEl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoYW5nZXMuc2VsZWN0ZWRJdGVtKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG9uSXRlbUNoYW5nZShjaGFuZ2VzLnNlbGVjdGVkSXRlbSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uY2hhbmdlcyxcbiAgICAgICAgICBoaWdobGlnaHRlZEluZGV4OiBzdGF0ZS5oaWdobGlnaHRlZEluZGV4XG4gICAgICAgIH07XG4gICAgICBjYXNlIFRvZ2dsZUJ1dHRvbkJsdXI6XG4gICAgICBjYXNlIFRvZ2dsZUJ1dHRvbktleURvd25Fc2NhcGU6XG4gICAgICAgIHNldElzT3BlbldyYXBwZXIoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVG9nZ2xlQnV0dG9uQ2xpY2s6XG4gICAgICAgIHNldElzT3BlbldyYXBwZXIoY2hhbmdlcy5pc09wZW4gfHwgZmFsc2UpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmNoYW5nZXMsXG4gICAgICAgICAgaGlnaGxpZ2h0ZWRJbmRleDogY29udHJvbGxlZFNlbGVjdGVkSXRlbXMubGVuZ3RoID4gMCA/IDAgOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgSXRlbUNsaWNrOlxuICAgICAgICBzZXRIaWdobGlnaHRlZEluZGV4KGNoYW5nZXMuc2VsZWN0ZWRJdGVtKTtcbiAgICAgICAgb25JdGVtQ2hhbmdlKGNoYW5nZXMuc2VsZWN0ZWRJdGVtKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5jaGFuZ2VzLFxuICAgICAgICAgIGhpZ2hsaWdodGVkSW5kZXg6IHN0YXRlLmhpZ2hsaWdodGVkSW5kZXhcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgTWVudU1vdXNlTGVhdmU6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uY2hhbmdlcyxcbiAgICAgICAgICBoaWdobGlnaHRlZEluZGV4OiBzdGF0ZS5oaWdobGlnaHRlZEluZGV4XG4gICAgICAgIH07XG4gICAgICBjYXNlIEZ1bmN0aW9uU2V0SGlnaGxpZ2h0ZWRJbmRleDpcbiAgICAgICAgaWYgKCFpc09wZW4pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY2hhbmdlcyxcbiAgICAgICAgICAgIGhpZ2hsaWdodGVkSW5kZXg6IDBcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jaGFuZ2VzLFxuICAgICAgICAgICAgaGlnaGxpZ2h0ZWRJbmRleDogZmlsdGVyZWRJdGVtcy5pbmRleE9mKGhpZ2hsaWdodGVkSW5kZXgpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBUb2dnbGVCdXR0b25LZXlEb3duQXJyb3dEb3duOlxuICAgICAgY2FzZSBUb2dnbGVCdXR0b25LZXlEb3duQXJyb3dVcDpcbiAgICAgIGNhc2UgVG9nZ2xlQnV0dG9uS2V5RG93blBhZ2VEb3duOlxuICAgICAgY2FzZSBUb2dnbGVCdXR0b25LZXlEb3duUGFnZVVwOlxuICAgICAgICBpZiAoaGlnaGxpZ2h0ZWRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgY29uc3QgaXRlbUFycmF5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgbGkuJHtwcmVmaXh9LS1saXN0LWJveF9fbWVudS1pdGVtW3JvbGU9XCJvcHRpb25cIl1gKTtcbiAgICAgICAgICBwcm9wcy5zY3JvbGxJbnRvVmlldyhpdGVtQXJyYXlbaGlnaGxpZ2h0ZWRJbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoaWdobGlnaHRlZEluZGV4ID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jaGFuZ2VzLFxuICAgICAgICAgICAgaGlnaGxpZ2h0ZWRJbmRleDogMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgICBjYXNlIEl0ZW1Nb3VzZU1vdmU6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uY2hhbmdlcyxcbiAgICAgICAgICBoaWdobGlnaHRlZEluZGV4OiBzdGF0ZS5oaWdobGlnaHRlZEluZGV4XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VzO1xuICB9XG4gIGNvbnN0IG11bHRpU2VsZWN0RmllbGRXcmFwcGVyQ2xhc3NlcyA9IGN4KGAke3ByZWZpeH0tLWxpc3QtYm94X19maWVsZC0td3JhcHBlcmAsIHtcbiAgICBbYCR7cHJlZml4fS0tbGlzdC1ib3hfX2ZpZWxkLS13cmFwcGVyLS1pbnB1dC1mb2N1c2VkYF06IGlucHV0Rm9jdXNlZFxuICB9KTtcbiAgY29uc3QgaGFuZGxlRm9jdXMgPSBldnQgPT4ge1xuICAgIGV2dC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGAke3ByZWZpeH0tLXRhZ19fY2xvc2UtaWNvbmApID8gc2V0SXNGb2N1c2VkKGZhbHNlKSA6IHNldElzRm9jdXNlZChldnQudHlwZSA9PT0gJ2ZvY3VzJyA/IHRydWUgOiBmYWxzZSk7XG4gIH07XG4gIGNvbnN0IHJlYWRPbmx5RXZlbnRIYW5kbGVycyA9IHJlYWRPbmx5ID8ge1xuICAgIG9uQ2xpY2s6IGV2dCA9PiB7XG4gICAgICAvLyBOT1RFOiBkb2VzIG5vdCBwcmV2ZW50IGNsaWNrXG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIC8vIGZvY3VzIG9uIHRoZSBlbGVtZW50IGFzIHBlciByZWFkb25seSBpbnB1dCBiZWhhdmlvclxuICAgICAgaWYgKG1lcmdlZFJlZi5jdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWVyZ2VkUmVmLmN1cnJlbnQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uS2V5RG93bjogZXZ0ID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdEFjY2Vzc0tleXMgPSBbJ0Fycm93RG93bicsICdBcnJvd1VwJywgJyAnLCAnRW50ZXInXTtcbiAgICAgIC8vIFRoaXMgcHJldmVudHMgdGhlIHNlbGVjdCBmcm9tIG9wZW5pbmcgZm9yIHRoZSBhYm92ZSBrZXlzXG4gICAgICBpZiAoc2VsZWN0QWNjZXNzS2V5cy5pbmNsdWRlcyhldnQua2V5KSkge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gOiB7fTtcblxuICAvLyBBSUxhYmVsIGFsd2F5cyBzaXplIGBtaW5pYFxuICBsZXQgbm9ybWFsaXplZERlY29yYXRvciA9IC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChzbHVnID8/IGRlY29yYXRvcikgPyBzbHVnID8/IGRlY29yYXRvciA6IG51bGw7XG4gIGlmIChub3JtYWxpemVkRGVjb3JhdG9yICYmIG5vcm1hbGl6ZWREZWNvcmF0b3JbJ3R5cGUnXT8uZGlzcGxheU5hbWUgPT09ICdBSUxhYmVsJykge1xuICAgIG5vcm1hbGl6ZWREZWNvcmF0b3IgPSAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KG5vcm1hbGl6ZWREZWNvcmF0b3IsIHtcbiAgICAgIHNpemU6ICdtaW5pJ1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IGl0ZW1zU2VsZWN0ZWRUZXh0ID0gc2VsZWN0ZWRJdGVtcy5sZW5ndGggPiAwICYmIHNlbGVjdGVkSXRlbXMubWFwKGl0ZW0gPT4gaXRlbT8udGV4dCk7XG4gIGNvbnN0IHNlbGVjdGVkSXRlbXNMZW5ndGggPSBzZWxlY3RBbGwgPyBzZWxlY3RlZEl0ZW1zLmZpbHRlcihpdGVtID0+ICFpdGVtLmlzU2VsZWN0QWxsKS5sZW5ndGggOiBzZWxlY3RlZEl0ZW1zLmxlbmd0aDtcblxuICAvLyBNZW1vaXplIHRoZSB2YWx1ZSBvZiBnZXRNZW51UHJvcHMgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICBjb25zdCBtZW51UHJvcHMgPSB1c2VNZW1vKCgpID0+IGdldE1lbnVQcm9wcyh7XG4gICAgcmVmOiBlbmFibGVGbG9hdGluZ1N0eWxlcyA/IHJlZnMuc2V0RmxvYXRpbmcgOiBudWxsXG4gIH0pLCBbZW5hYmxlRmxvYXRpbmdTdHlsZXMsIGdldE1lbnVQcm9wcywgcmVmcy5zZXRGbG9hdGluZ10pO1xuICBjb25zdCBhbGxMYWJlbFByb3BzID0gZ2V0TGFiZWxQcm9wcygpO1xuICBjb25zdCBsYWJlbFByb3BzID0gLyojX19QVVJFX18qL2lzVmFsaWRFbGVtZW50KHRpdGxlVGV4dCkgPyB7XG4gICAgaWQ6IGFsbExhYmVsUHJvcHMuaWRcbiAgfSA6IGFsbExhYmVsUHJvcHM7XG4gIGNvbnN0IGdldFNlbGVjdGlvblN0YXRzID0gdXNlQ2FsbGJhY2soKHNlbGVjdGVkSXRlbXMsIGZpbHRlcmVkSXRlbXMpID0+IHtcbiAgICBjb25zdCBoYXNJbmRpdmlkdWFsU2VsZWN0aW9ucyA9IHNlbGVjdGVkSXRlbXMuc29tZShzZWxlY3RlZCA9PiAhc2VsZWN0ZWQuaXNTZWxlY3RBbGwpO1xuICAgIGNvbnN0IG5vblNlbGVjdEFsbFNlbGVjdGVkQ291bnQgPSBzZWxlY3RlZEl0ZW1zLmZpbHRlcihzZWxlY3RlZCA9PiAhc2VsZWN0ZWQuaXNTZWxlY3RBbGwpLmxlbmd0aDtcbiAgICBjb25zdCB0b3RhbFNlbGVjdGFibGVDb3VudCA9IGZpbHRlcmVkSXRlbXMuZmlsdGVyKGl0ZW0gPT4gIWl0ZW0uaXNTZWxlY3RBbGwgJiYgIWl0ZW0uZGlzYWJsZWQpLmxlbmd0aDtcbiAgICByZXR1cm4ge1xuICAgICAgaGFzSW5kaXZpZHVhbFNlbGVjdGlvbnMsXG4gICAgICBub25TZWxlY3RBbGxTZWxlY3RlZENvdW50LFxuICAgICAgdG90YWxTZWxlY3RhYmxlQ291bnRcbiAgICB9O1xuICB9LCBbc2VsZWN0ZWRJdGVtcywgZmlsdGVyZWRJdGVtc10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogd3JhcHBlckNsYXNzZXNcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiB0aXRsZUNsYXNzZXNcbiAgfSwgbGFiZWxQcm9wcyksIHRpdGxlVGV4dCAmJiB0aXRsZVRleHQsIHNlbGVjdGVkSXRlbXMubGVuZ3RoID4gMCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tdmlzdWFsbHktaGlkZGVuYFxuICB9LCBjbGVhclNlbGVjdGlvbkRlc2NyaXB0aW9uLCBcIiBcIiwgc2VsZWN0ZWRJdGVtcy5sZW5ndGgsICcgJywgaXRlbXNTZWxlY3RlZFRleHQsIFwiLFwiLCBjbGVhclNlbGVjdGlvblRleHQpKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGlzdEJveCwge1xuICAgIG9uRm9jdXM6IGlzRmx1aWQgPyBoYW5kbGVGb2N1cyA6IHVuZGVmaW5lZCxcbiAgICBvbkJsdXI6IGlzRmx1aWQgPyBoYW5kbGVGb2N1cyA6IHVuZGVmaW5lZCxcbiAgICB0eXBlOiB0eXBlLFxuICAgIHNpemU6IHNpemUkMSxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICBkaXNhYmxlZDogZGlzYWJsZWQsXG4gICAgbGlnaHQ6IGxpZ2h0LFxuICAgIGludmFsaWQ6IGludmFsaWQsXG4gICAgaW52YWxpZFRleHQ6IGludmFsaWRUZXh0LFxuICAgIHdhcm46IHdhcm4sXG4gICAgd2FyblRleHQ6IHdhcm5UZXh0LFxuICAgIGlzT3BlbjogaXNPcGVuLFxuICAgIGlkOiBpZFxuICB9LCBpbnZhbGlkICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFdhcm5pbmdGaWxsZWQsIHtcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeH0tLWxpc3QtYm94X19pbnZhbGlkLWljb25gXG4gIH0pLCBzaG93V2FybmluZyAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChXYXJuaW5nQWx0RmlsbGVkLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS1saXN0LWJveF9faW52YWxpZC1pY29uICR7cHJlZml4fS0tbGlzdC1ib3hfX2ludmFsaWQtaWNvbi0td2FybmluZ2BcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IG11bHRpU2VsZWN0RmllbGRXcmFwcGVyQ2xhc3NlcyxcbiAgICByZWY6IGVuYWJsZUZsb2F0aW5nU3R5bGVzID8gcmVmcy5zZXRSZWZlcmVuY2UgOiBudWxsXG4gIH0sIHNlbGVjdGVkSXRlbXMubGVuZ3RoID4gMCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaXN0Qm94LlNlbGVjdGlvbiwge1xuICAgIHJlYWRPbmx5OiByZWFkT25seSxcbiAgICBjbGVhclNlbGVjdGlvbjogIWRpc2FibGVkICYmICFyZWFkT25seSA/IGNsZWFyU2VsZWN0aW9uIDogbm9vcEZuLFxuICAgIHNlbGVjdGlvbkNvdW50OiBzZWxlY3RlZEl0ZW1zTGVuZ3RoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAsXG4gICAgdHJhbnNsYXRlV2l0aElkOiB0cmFuc2xhdGVXaXRoSWQsXG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBfZXh0ZW5kcyh7XG4gICAgdHlwZTogXCJidXR0b25cIixcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeH0tLWxpc3QtYm94X19maWVsZGAsXG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgIFwiYXJpYS1kaXNhYmxlZFwiOiBkaXNhYmxlZCB8fCByZWFkT25seSxcbiAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogIWlubGluZSAmJiAhaW52YWxpZCAmJiAhd2FybiAmJiBoZWxwZXJUZXh0ID8gaGVscGVySWQgOiB1bmRlZmluZWRcbiAgfSwgdG9nZ2xlQnV0dG9uUHJvcHMsIHtcbiAgICByZWY6IG1lcmdlZFJlZlxuICB9LCByZWFkT25seUV2ZW50SGFuZGxlcnMpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGlkOiBmaWVsZExhYmVsSWQsXG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS1saXN0LWJveF9fbGFiZWxgXG4gIH0sIGxhYmVsKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGlzdEJveC5NZW51SWNvbiwge1xuICAgIGlzT3BlbjogaXNPcGVuLFxuICAgIHRyYW5zbGF0ZVdpdGhJZDogdHJhbnNsYXRlV2l0aElkXG4gIH0pKSwgc2x1ZyA/IG5vcm1hbGl6ZWREZWNvcmF0b3IgOiBkZWNvcmF0b3IgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS1saXN0LWJveF9faW5uZXItd3JhcHBlci0tZGVjb3JhdG9yYFxuICB9LCBub3JtYWxpemVkRGVjb3JhdG9yKSA6ICcnKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGlzdEJveC5NZW51LCBtZW51UHJvcHMsIGlzT3BlbiAmJiBzb3J0SXRlbXMoZmlsdGVyZWRJdGVtcywgc29ydE9wdGlvbnMpLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBpc0NoZWNrZWQgPSBzZWxlY3RlZEl0ZW1zLmZpbHRlcihzZWxlY3RlZCA9PiBpc0VxdWFsKHNlbGVjdGVkLCBpdGVtKSkubGVuZ3RoID4gMDtcbiAgICBjb25zdCB7XG4gICAgICBoYXNJbmRpdmlkdWFsU2VsZWN0aW9ucyxcbiAgICAgIG5vblNlbGVjdEFsbFNlbGVjdGVkQ291bnQsXG4gICAgICB0b3RhbFNlbGVjdGFibGVDb3VudFxuICAgIH0gPSBnZXRTZWxlY3Rpb25TdGF0cyhzZWxlY3RlZEl0ZW1zLCBmaWx0ZXJlZEl0ZW1zKTtcbiAgICBjb25zdCBpc0luZGV0ZXJtaW5hdGUgPSBpdGVtWydpc1NlbGVjdEFsbCddICYmIGhhc0luZGl2aWR1YWxTZWxlY3Rpb25zICYmIG5vblNlbGVjdEFsbFNlbGVjdGVkQ291bnQgPCB0b3RhbFNlbGVjdGFibGVDb3VudDtcbiAgICBjb25zdCBpdGVtUHJvcHMgPSBnZXRJdGVtUHJvcHMoe1xuICAgICAgaXRlbSxcbiAgICAgIC8vIHdlIGRvbid0IHdhbnQgRG93bnNoaWZ0IHRvIHNldCBhcmlhLXNlbGVjdGVkIGZvciB1c1xuICAgICAgLy8gd2UgYWxzbyBkb24ndCB3YW50IHRvIHNldCAnZmFsc2UnIGZvciByZWFkZXIgdmVyYm9zaXR5J3Mgc2FrZVxuICAgICAgWydhcmlhLXNlbGVjdGVkJ106IGlzQ2hlY2tlZFxuICAgIH0pO1xuICAgIGNvbnN0IGl0ZW1UZXh0ID0gaXRlbVRvU3RyaW5nKGl0ZW0pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaXN0Qm94Lk1lbnVJdGVtLCBfZXh0ZW5kcyh7XG4gICAgICBrZXk6IGl0ZW1Qcm9wcy5pZCxcbiAgICAgIGlzQWN0aXZlOiBpc0NoZWNrZWQgJiYgIWl0ZW1bJ2lzU2VsZWN0QWxsJ10sXG4gICAgICBcImFyaWEtbGFiZWxcIjogaXRlbVRleHQsXG4gICAgICBpc0hpZ2hsaWdodGVkOiBoaWdobGlnaHRlZEluZGV4ID09PSBpbmRleCxcbiAgICAgIHRpdGxlOiBpdGVtVGV4dCxcbiAgICAgIGRpc2FibGVkOiBpdGVtUHJvcHNbJ2FyaWEtZGlzYWJsZWQnXVxuICAgIH0sIGl0ZW1Qcm9wcyksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tY2hlY2tib3gtd3JhcHBlcmBcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDaGVja2JveCwge1xuICAgICAgaWQ6IGAke2l0ZW1Qcm9wcy5pZH1fX2NoZWNrYm94YCxcbiAgICAgIGxhYmVsVGV4dDogaXRlbVRvRWxlbWVudCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEl0ZW1Ub0VsZW1lbnQsIF9leHRlbmRzKHtcbiAgICAgICAga2V5OiBpdGVtUHJvcHMuaWRcbiAgICAgIH0sIGl0ZW0pKSA6IGl0ZW1UZXh0LFxuICAgICAgY2hlY2tlZDogaXNDaGVja2VkLFxuICAgICAgdGl0bGU6IHVzZVRpdGxlSW5JdGVtID8gaXRlbVRleHQgOiB1bmRlZmluZWQsXG4gICAgICBpbmRldGVybWluYXRlOiBpc0luZGV0ZXJtaW5hdGUsXG4gICAgICBkaXNhYmxlZDogZGlzYWJsZWRcbiAgICB9KSkpO1xuICB9KSksIGl0ZW1zQ2xlYXJlZCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIFwiYXJpYS1saXZlXCI6IFwiYXNzZXJ0aXZlXCIsXG4gICAgXCJhcmlhLWxhYmVsXCI6IGNsZWFyQW5ub3VuY2VtZW50XG4gIH0pKSwgIWlubGluZSAmJiAhaW52YWxpZCAmJiAhd2FybiAmJiBoZWxwZXJUZXh0ICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBpZDogaGVscGVySWQsXG4gICAgY2xhc3NOYW1lOiBoZWxwZXJDbGFzc2VzXG4gIH0sIGhlbHBlclRleHQpKTtcbn0pO1xuTXVsdGlTZWxlY3QuZGlzcGxheU5hbWUgPSAnTXVsdGlTZWxlY3QnO1xuTXVsdGlTZWxlY3QucHJvcFR5cGVzID0ge1xuICAuLi5zb3J0aW5nUHJvcFR5cGVzLFxuICAvKipcbiAgICogKipFeHBlcmltZW50YWwqKjogV2lsbCBhdHRlbXB0IHRvIGF1dG9tYXRpY2FsbHkgYWxpZ24gdGhlIGZsb2F0aW5nXG4gICAqIGVsZW1lbnQgdG8gYXZvaWQgY29sbGlzaW9ucyB3aXRoIHRoZSB2aWV3cG9ydCBhbmQgYmVpbmcgY2xpcHBlZCBieVxuICAgKiBhbmNlc3RvciBlbGVtZW50cy5cbiAgICovXG4gIGF1dG9BbGlnbjogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYmUgYWRkZWQgdG8gdGhlIG91dGVybW9zdCBub2RlIGluIHRoZVxuICAgKiBjb21wb25lbnRcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIHRleHQgdGhhdCBzaG91bGQgYmUgcmVhZCBmb3Igc2NyZWVuIHJlYWRlcnMgdGhhdCBkZXNjcmliZXMgdG90YWwgaXRlbXMgc2VsZWN0ZWRcbiAgICovXG4gIGNsZWFyU2VsZWN0aW9uRGVzY3JpcHRpb246IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSB0ZXh0IHRoYXQgc2hvdWxkIGJlIHJlYWQgZm9yIHNjcmVlbiByZWFkZXJzIHRvIGNsZWFyIHNlbGVjdGlvbi5cbiAgICovXG4gIGNsZWFyU2VsZWN0aW9uVGV4dDogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBjb21wYXJlIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIG9yZGVyaW5nIG9mXG4gICAqIG9wdGlvbnMuIFNlZSAnc29ydEl0ZW1zJyBmb3IgbW9yZSBjb250cm9sLiBDb25zaWRlclxuICAgKiBkZWNsYXJpbmcgZnVuY3Rpb24gd2l0aCBgdXNlQ2FsbGJhY2tgIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmUtcmVuZGVycy5cbiAgICovXG4gIGNvbXBhcmVJdGVtczogUHJvcFR5cGVzLmZ1bmMsXG4gIC8qKlxuICAgKiAqKkV4cGVyaW1lbnRhbCoqOiBQcm92aWRlIGEgZGVjb3JhdG9yIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGBNdWx0aVNlbGVjdGAgY29tcG9uZW50XG4gICAqL1xuICBkZWNvcmF0b3I6IFByb3BUeXBlcy5ub2RlLFxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBtdWx0aXNlbGVjdCBkcm9wZG93bi4gQ2FuIGJlIGVpdGhlciB0b3Agb3IgYm90dG9tLlxuICAgKi9cbiAgZGlyZWN0aW9uOiBQcm9wVHlwZXMub25lT2YoWyd0b3AnLCAnYm90dG9tJ10pLFxuICAvKipcbiAgICogRGlzYWJsZSB0aGUgY29udHJvbFxuICAgKi9cbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAvKipcbiAgICogQWRkaXRpb25hbCBwcm9wcyBwYXNzZWQgdG8gRG93bnNoaWZ0LlxuICAgKlxuICAgKiAqKlVzZSB3aXRoIGNhdXRpb246KiogYW55dGhpbmcgeW91IGRlZmluZSBoZXJlIG92ZXJyaWRlcyB0aGUgY29tcG9uZW50cydcbiAgICogaW50ZXJuYWwgaGFuZGxpbmcgb2YgdGhhdCBwcm9wLiBEb3duc2hpZnQgQVBJcyBhbmQgaW50ZXJuYWxzIGFyZSBzdWJqZWN0IHRvXG4gICAqIGNoYW5nZSwgYW5kIGluIHNvbWUgY2FzZXMgdGhleSBjYW4gbm90IGJlIHNoaW1tZWQgYnkgQ2FyYm9uIHRvIHNoaWVsZCB5b3VcbiAgICogZnJvbSBwb3RlbnRpYWxseSBicmVha2luZyBjaGFuZ2VzLlxuICAgKi9cbiAgZG93bnNoaWZ0UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG4gIC8qKlxuICAgKiBQcm92aWRlIGhlbHBlciB0ZXh0IHRoYXQgaXMgdXNlZCBhbG9uZ3NpZGUgdGhlIGNvbnRyb2wgbGFiZWwgZm9yXG4gICAqIGFkZGl0aW9uYWwgaGVscFxuICAgKi9cbiAgaGVscGVyVGV4dDogUHJvcFR5cGVzLm5vZGUsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgdGhlIHRpdGxlIHRleHQgc2hvdWxkIGJlIGhpZGRlbiBvciBub3RcbiAgICovXG4gIGhpZGVMYWJlbDogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGEgY3VzdG9tIGBpZGBcbiAgICovXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIC8qKlxuICAgKiBBbGxvdyB1c2VycyB0byBwYXNzIGluIGFyYml0cmFyeSBpdGVtcyBmcm9tIHRoZWlyIGNvbGxlY3Rpb24gdGhhdCBhcmVcbiAgICogcHJlLXNlbGVjdGVkXG4gICAqL1xuICBpbml0aWFsU2VsZWN0ZWRJdGVtczogUHJvcFR5cGVzLmFycmF5LFxuICAvKipcbiAgICogSXMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGludmFsaWQ/XG4gICAqL1xuICBpbnZhbGlkOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIElmIGludmFsaWQsIHdoYXQgaXMgdGhlIGVycm9yP1xuICAgKi9cbiAgaW52YWxpZFRleHQ6IFByb3BUeXBlcy5ub2RlLFxuICAvKipcbiAgICogRnVuY3Rpb24gdG8gcmVuZGVyIGl0ZW1zIGFzIGN1c3RvbSBjb21wb25lbnRzIGluc3RlYWQgb2Ygc3RyaW5ncy5cbiAgICogRGVmYXVsdHMgdG8gbnVsbCBhbmQgaXMgb3ZlcnJpZGRlbiBieSBhIGdldHRlclxuICAgKi9cbiAgaXRlbVRvRWxlbWVudDogUHJvcFR5cGVzLmZ1bmMsXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gcGFzc2VkIHRvIGRvd25zaGlmdCB0aGF0IGFsbG93cyB0aGUgbGlicmFyeSB0byByZW5kZXIgYVxuICAgKiBnaXZlbiBpdGVtIHRvIGEgc3RyaW5nIGxhYmVsLiBCeSBkZWZhdWx0LCBpdCBleHRyYWN0cyB0aGUgYGxhYmVsYCBmaWVsZFxuICAgKiBmcm9tIGEgZ2l2ZW4gaXRlbSB0byBzZXJ2ZSBhcyB0aGUgaXRlbSBsYWJlbCBpbiB0aGUgbGlzdC4gQ29uc2lkZXJcbiAgICogZGVjbGFyaW5nIGZ1bmN0aW9uIHdpdGggYHVzZUNhbGxiYWNrYCB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHJlLXJlbmRlcnMuXG4gICAqL1xuICBpdGVtVG9TdHJpbmc6IFByb3BUeXBlcy5mdW5jLFxuICAvKipcbiAgICogV2UgdHJ5IHRvIHN0YXkgYXMgZ2VuZXJpYyBhcyBwb3NzaWJsZSBoZXJlIHRvIGFsbG93IGluZGl2aWR1YWxzIHRvIHBhc3NcbiAgICogaW4gYSBjb2xsZWN0aW9uIG9mIHdoYXRldmVyIGtpbmQgb2YgZGF0YSBzdHJ1Y3R1cmUgdGhleSBwcmVmZXJcbiAgICovXG4gIGl0ZW1zOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgLyoqXG4gICAqIEdlbmVyaWMgYGxhYmVsYCB0aGF0IHdpbGwgYmUgdXNlZCBhcyB0aGUgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB3aGF0XG4gICAqIHRoaXMgZmllbGQgaXMgZm9yXG4gICAqL1xuICBsYWJlbDogUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcbiAgLyoqXG4gICAqIGB0cnVlYCB0byB1c2UgdGhlIGxpZ2h0IHZlcnNpb24uXG4gICAqL1xuICBsaWdodDogZGVwcmVjYXRlKFByb3BUeXBlcy5ib29sLCAnVGhlIGBsaWdodGAgcHJvcCBmb3IgYE11bHRpU2VsZWN0YCBoYXMgJyArICdiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgdGhlIG5ldyBgTGF5ZXJgIGNvbXBvbmVudC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuJyksXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBsb2NhbGUgb2YgdGhlIGNvbnRyb2wuIFVzZWQgZm9yIHRoZSBkZWZhdWx0IGBjb21wYXJlSXRlbXNgXG4gICAqIHVzZWQgZm9yIHNvcnRpbmcgdGhlIGxpc3Qgb2YgaXRlbXMgaW4gdGhlIGNvbnRyb2wuXG4gICAqL1xuICBsb2NhbGU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8qKlxuICAgKiBgb25DaGFuZ2VgIGlzIGEgdXRpbGl0eSBmb3IgdGhpcyBjb250cm9sbGVkIGNvbXBvbmVudCB0byBjb21tdW5pY2F0ZSB0byBhXG4gICAqIGNvbnN1bWluZyBjb21wb25lbnQgd2hhdCBraW5kIG9mIGludGVybmFsIHN0YXRlIGNoYW5nZXMgYXJlIG9jY3VycmluZy5cbiAgICovXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgLyoqXG4gICAqIGBvbk1lbnVDaGFuZ2VgIGlzIGEgdXRpbGl0eSBmb3IgdGhpcyBjb250cm9sbGVkIGNvbXBvbmVudCB0byBjb21tdW5pY2F0ZSB0byBhXG4gICAqIGNvbnN1bWluZyBjb21wb25lbnQgdGhhdCB0aGUgbWVudSB3YXMgb3BlbihgdHJ1ZWApL2Nsb3NlZChgZmFsc2VgKS5cbiAgICovXG4gIG9uTWVudUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBjb21wb25lbnQgd2l0aCBhbiBvcGVuKGB0cnVlYCkvY2xvc2VkKGBmYWxzZWApIG1lbnUuXG4gICAqL1xuICBvcGVuOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSBEcm9wZG93biBpcyByZWFkb25seVxuICAgKi9cbiAgcmVhZE9ubHk6IFByb3BUeXBlcy5ib29sLFxuICAvKipcbiAgICogRm9yIGZ1bGwgY29udHJvbCBvZiB0aGUgc2VsZWN0ZWQgaXRlbXNcbiAgICovXG4gIHNlbGVjdGVkSXRlbXM6IFByb3BUeXBlcy5hcnJheSxcbiAgLyoqXG4gICAqIFNwZWNpZnkgZmVlZGJhY2sgKG1vZGUpIG9mIHRoZSBzZWxlY3Rpb24uXG4gICAqIGB0b3BgOiBzZWxlY3RlZCBpdGVtIGp1bXBzIHRvIHRvcFxuICAgKiBgZml4ZWRgOiBzZWxlY3RlZCBpdGVtIHN0YXlzIGF0IGl0J3MgcG9zaXRpb25cbiAgICogYHRvcC1hZnRlci1yZW9wZW5gOiBzZWxlY3RlZCBpdGVtIGp1bXAgdG8gdG9wIGFmdGVyIHJlb3BlbiBkcm9wZG93blxuICAgKi9cbiAgc2VsZWN0aW9uRmVlZGJhY2s6IFByb3BUeXBlcy5vbmVPZihbJ3RvcCcsICdmaXhlZCcsICd0b3AtYWZ0ZXItcmVvcGVuJ10pLFxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgc2l6ZSBvZiB0aGUgTGlzdEJveC4gQ3VycmVudGx5IHN1cHBvcnRzIGVpdGhlciBgc21gLCBgbWRgIG9yIGBsZ2AgYXMgYW4gb3B0aW9uLlxuICAgKi9cbiAgc2l6ZTogTGlzdEJveFNpemVQcm9wVHlwZSxcbiAgc2x1ZzogZGVwcmVjYXRlKFByb3BUeXBlcy5ub2RlLCAnVGhlIGBzbHVnYCBwcm9wIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLiBVc2UgdGhlIGRlY29yYXRvciBwcm9wIGluc3RlYWQuJyksXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgbWV0aG9kIHRoYXQgc29ydHMgYWxsIG9wdGlvbnMgaW4gdGhlIGNvbnRyb2wuIE92ZXJyaWRpbmcgdGhpc1xuICAgKiBwcm9wIG1lYW5zIHRoYXQgeW91IGFsc28gaGF2ZSB0byBoYW5kbGUgdGhlIHNvcnQgbG9naWMgZm9yIHNlbGVjdGVkIHZlcnN1c1xuICAgKiB1bi1zZWxlY3RlZCBpdGVtcy4gSWYgeW91IGp1c3Qgd2FudCB0byBjb250cm9sIG9yZGVyaW5nLCBjb25zaWRlciB0aGVcbiAgICogYGNvbXBhcmVJdGVtc2AgcHJvcCBpbnN0ZWFkLlxuICAgKlxuICAgKiBUaGUgcmV0dXJuIHZhbHVlIHNob3VsZCBiZSBhIG51bWJlciB3aG9zZSBzaWduIGluZGljYXRlcyB0aGUgcmVsYXRpdmUgb3JkZXJcbiAgICogb2YgdGhlIHR3byBlbGVtZW50czogbmVnYXRpdmUgaWYgYSBpcyBsZXNzIHRoYW4gYiwgcG9zaXRpdmUgaWYgYSBpcyBncmVhdGVyXG4gICAqIHRoYW4gYiwgYW5kIHplcm8gaWYgdGhleSBhcmUgZXF1YWwuXG4gICAqXG4gICAqIHNvcnRJdGVtcyA6XG4gICAqICAgKGl0ZW1zOiBBcnJheTxJdGVtPiwge1xuICAgKiAgICAgc2VsZWN0ZWRJdGVtczogQXJyYXk8SXRlbT4sXG4gICAqICAgICBpdGVtVG9TdHJpbmc6IEl0ZW0gPT4gc3RyaW5nLFxuICAgKiAgICAgY29tcGFyZUl0ZW1zOiAoaXRlbUE6IHN0cmluZywgaXRlbUI6IHN0cmluZywge1xuICAgKiAgICAgICBsb2NhbGU6IHN0cmluZ1xuICAgKiAgICAgfSkgPT4gbnVtYmVyLFxuICAgKiAgICAgbG9jYWxlOiBzdHJpbmcsXG4gICAqICAgfSkgPT4gQXJyYXk8SXRlbT5cbiAgICovXG4gIHNvcnRJdGVtczogUHJvcFR5cGVzLmZ1bmMsXG4gIC8qKlxuICAgKiBQcm92aWRlIHRleHQgdG8gYmUgdXNlZCBpbiBhIGA8bGFiZWw+YCBlbGVtZW50IHRoYXQgaXMgdGllZCB0byB0aGVcbiAgICogbXVsdGlzZWxlY3QgdmlhIEFSSUEgYXR0cmlidXRlcy5cbiAgICovXG4gIHRpdGxlVGV4dDogUHJvcFR5cGVzLm5vZGUsXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgdHJhbnNsYXRpbmcgTGlzdEJveE1lbnVJY29uIFNWRyB0aXRsZVxuICAgKi9cbiAgdHJhbnNsYXRlV2l0aElkOiBQcm9wVHlwZXMuZnVuYyxcbiAgLyoqXG4gICAqIFNwZWNpZnkgJ2lubGluZScgdG8gY3JlYXRlIGFuIGlubGluZSBtdWx0aS1zZWxlY3QuXG4gICAqL1xuICB0eXBlOiBMaXN0Qm94VHlwZVByb3BUeXBlLFxuICAvKipcbiAgICogU3BlY2lmeSB0aXRsZSB0byBzaG93IHRpdGxlIG9uIGhvdmVyXG4gICAqL1xuICB1c2VUaXRsZUluSXRlbTogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgdGhlIGNvbnRyb2wgaXMgY3VycmVudGx5IGluIHdhcm5pbmcgc3RhdGVcbiAgICovXG4gIHdhcm46IFByb3BUeXBlcy5ib29sLFxuICAvKipcbiAgICogUHJvdmlkZSB0aGUgdGV4dCB0aGF0IGlzIGRpc3BsYXllZCB3aGVuIHRoZSBjb250cm9sIGlzIGluIHdhcm5pbmcgc3RhdGVcbiAgICovXG4gIHdhcm5UZXh0OiBQcm9wVHlwZXMubm9kZVxufTtcblxuZXhwb3J0IHsgTXVsdGlTZWxlY3QgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIzXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCB7IEFycm93UmlnaHQsIEFycm93TGVmdCB9IGZyb20gJy4va2V5cy5qcyc7XG5pbXBvcnQgeyBtYXRjaCB9IGZyb20gJy4vbWF0Y2guanMnO1xuXG4vKipcbiAqIEEgXCJyaW5nIGJ1ZmZlclwiIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gYXJyYXkgYW5kLCBkZXBlbmRpbmcgb24gYW4gQXJyb3dSaWdodFxuICogb3IgQXJyb3dMZWZ0IGtleSBpbnB1dCwgbG9vcHMgZnJvbSBsYXN0IGluZGV4IHRvIGZpcnN0IG9yIGZpcnN0IGluZGV4IHRvIGxhc3QuXG4gKlxuICogQHBhcmFtIGtleSAtIHRoZSBsZWZ0IG9yIHJpZ2h0IGFycm93IGtleSAoS2V5Ym9hcmRFdmVudCwgbnVtYmVyLCBvciBzdHJpbmcpXG4gKiBAcGFyYW0gaW5kZXggLSB0aGUgY3VycmVudCBpbmRleCBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSBhcnJheUxlbmd0aCAtIHRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGFycmF5XG4gKlxuICogQGV4YW1wbGVcbiAqICBnZXROZXh0SW5kZXgoa2V5Q29kZXMuUklHSFQsIDAsIDQpXG4gKi9cbmNvbnN0IGdldE5leHRJbmRleCA9IChrZXksIGluZGV4LCBhcnJheUxlbmd0aCkgPT4ge1xuICBpZiAobWF0Y2goa2V5LCBBcnJvd1JpZ2h0KSkge1xuICAgIHJldHVybiAoaW5kZXggKyAxKSAlIGFycmF5TGVuZ3RoO1xuICB9XG4gIGlmIChtYXRjaChrZXksIEFycm93TGVmdCkpIHtcbiAgICByZXR1cm4gKGluZGV4ICsgYXJyYXlMZW5ndGggLSAxKSAlIGFycmF5TGVuZ3RoO1xuICB9XG4gIHJldHVybjtcbn07XG5cbi8qKlxuICogQ1NTIHNlbGVjdG9yIHRoYXQgc2VsZWN0cyBtYWpvciBub2RlcyB0aGF0IGFyZSBzZXF1ZW50aWFsbHkgZm9jdXNhYmxlLlxuICovXG5jb25zdCBzZWxlY3RvclRhYmJhYmxlID0gYFxuICBhW2hyZWZdLCBhcmVhW2hyZWZdLCBpbnB1dDpub3QoW2Rpc2FibGVkXSk6bm90KFt0YWJpbmRleD0nLTEnXSksXG4gIGJ1dHRvbjpub3QoW2Rpc2FibGVkXSk6bm90KFt0YWJpbmRleD0nLTEnXSksc2VsZWN0Om5vdChbZGlzYWJsZWRdKTpub3QoW3RhYmluZGV4PSctMSddKSxcbiAgdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pOm5vdChbdGFiaW5kZXg9Jy0xJ10pLFxuICBpZnJhbWUsIG9iamVjdCwgZW1iZWQsICpbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXg9Jy0xJ10pOm5vdChbZGlzYWJsZWRdKSwgKltjb250ZW50ZWRpdGFibGU9dHJ1ZV1cbmA7XG5cbi8qKlxuICogQ1NTIHNlbGVjdG9yIHRoYXQgc2VsZWN0cyBtYWpvciBub2RlcyB0aGF0IGFyZSBjbGljayBmb2N1c2FibGUuXG4gKi9cbmNvbnN0IHNlbGVjdG9yRm9jdXNhYmxlID0gYFxuICBhW2hyZWZdLCBhcmVhW2hyZWZdLCBpbnB1dDpub3QoW2Rpc2FibGVkXSksXG4gIGJ1dHRvbjpub3QoW2Rpc2FibGVkXSksc2VsZWN0Om5vdChbZGlzYWJsZWRdKSxcbiAgdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pLFxuICBpZnJhbWUsIG9iamVjdCwgZW1iZWQsICpbdGFiaW5kZXhdOm5vdChbZGlzYWJsZWRdKSwgKltjb250ZW50ZWRpdGFibGU9dHJ1ZV1cbmA7XG5cbmV4cG9ydCB7IGdldE5leHRJbmRleCwgc2VsZWN0b3JGb2N1c2FibGUsIHNlbGVjdG9yVGFiYmFibGUgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIzXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCB7IHRhYmJhYmxlIH0gZnJvbSAndGFiYmFibGUnO1xuaW1wb3J0IHsgc2VsZWN0b3JUYWJiYWJsZSB9IGZyb20gJy4va2V5Ym9hcmQvbmF2aWdhdGlvbi5qcyc7XG5cbi8qKlxuICogQSBmbGFnIGBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRhcmdldClgIHJldHVybnMgdGhhdCBpbmRpY2F0ZXNcbiAqIGB0YXJnZXRgIGlzIGxvY2F0ZWQgZWFybGllciB0aGFuIGBub2RlYCBpbiB0aGUgZG9jdW1lbnQgb3IgYHRhcmdldGAgY29udGFpbnMgYG5vZGVgLlxuICovXG5jb25zdCBET0NVTUVOVF9QT1NJVElPTl9CUk9BRF9QUkVDRURJTkcgPSB0eXBlb2YgTm9kZSAhPT0gJ3VuZGVmaW5lZCcgPyBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyB8IE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTlMgOiAwO1xuXG4vKipcbiAqIEEgZmxhZyBgbm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0YXJnZXQpYCByZXR1cm5zIHRoYXQgaW5kaWNhdGVzXG4gKiBgdGFyZ2V0YCBpcyBsb2NhdGVkIGxhdGVyIHRoYW4gYG5vZGVgIGluIHRoZSBkb2N1bWVudCBvciBgbm9kZWAgY29udGFpbnMgYHRhcmdldGAuXG4gKi9cbmNvbnN0IERPQ1VNRU5UX1BPU0lUSU9OX0JST0FEX0ZPTExPV0lORyA9IHR5cGVvZiBOb2RlICE9PSAndW5kZWZpbmVkJyA/IE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HIHwgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkgOiAwO1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBub2RlIG9yIG9uZSBvZiBpdHMgYW5jZXN0b3JzIG1hdGNoZXMgYW55IG9mIHRoZVxuICogc3BlY2lmaWVkIGZsb2F0aW5nIG1lbnUgc2VsZWN0b3JzLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIEEgRE9NIG5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBzZWxlY3RvcnNGbG9hdGluZ01lbnVzIC0gQWRkaXRpb25hbCBDU1Mgc2VsZWN0b3JzIHRoYXRcbiAqIG1hdGNoIGZsb2F0aW5nIG1lbnVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIG5vZGUgb3Igb25lIG9mIGl0cyBhbmNlc3RvcnMgaXMgaW4gYSBmbG9hdGluZ1xuICogbWVudS5cbiAqL1xuY29uc3QgZWxlbWVudE9yUGFyZW50SXNGbG9hdGluZ01lbnUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBsZXQgc2VsZWN0b3JzRmxvYXRpbmdNZW51cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gIGlmIChub2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiB0eXBlb2Ygbm9kZS5jbG9zZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgYWxsU2VsZWN0b3JzRmxvYXRpbmdNZW51cyA9IFsnLmNkcy0tb3ZlcmZsb3ctbWVudS1vcHRpb25zJywgJy5jZHMtLXRvb2x0aXAnLCAnLmZsYXRwaWNrci1jYWxlbmRhcicsIC4uLnNlbGVjdG9yc0Zsb2F0aW5nTWVudXNdO1xuICAgIHJldHVybiBhbGxTZWxlY3RvcnNGbG9hdGluZ01lbnVzLnNvbWUoc2VsZWN0b3IgPT4gISFub2RlLmNsb3Nlc3Qoc2VsZWN0b3IpKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEVuc3VyZXMgdGhlIGZvY3VzIGlzIGtlcHQgd2l0aGluIHRoZSBnaXZlbiBjb250YWluZXIgYnkgaW1wbGVtZW50aW5nXG4gKiBcImZvY3VzLXdyYXBcIiBiZWhhdmlvci5cbiAqL1xuY29uc3Qgd3JhcEZvY3VzID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgYm9keU5vZGUsXG4gICAgc3RhcnRUcmFwTm9kZSxcbiAgICBlbmRUcmFwTm9kZSxcbiAgICBjdXJyZW50QWN0aXZlTm9kZSxcbiAgICBvbGRBY3RpdmVOb2RlLFxuICAgIHNlbGVjdG9yc0Zsb2F0aW5nTWVudXNcbiAgfSA9IF9yZWY7XG4gIGlmIChib2R5Tm9kZSAmJiBjdXJyZW50QWN0aXZlTm9kZSAmJiBvbGRBY3RpdmVOb2RlICYmICFib2R5Tm9kZS5jb250YWlucyhjdXJyZW50QWN0aXZlTm9kZSkgJiYgIWVsZW1lbnRPclBhcmVudElzRmxvYXRpbmdNZW51KGN1cnJlbnRBY3RpdmVOb2RlLCBzZWxlY3RvcnNGbG9hdGluZ01lbnVzKSkge1xuICAgIGNvbnN0IGNvbXBhcmlzb25SZXN1bHQgPSBvbGRBY3RpdmVOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGN1cnJlbnRBY3RpdmVOb2RlKTtcbiAgICBpZiAoY3VycmVudEFjdGl2ZU5vZGUgPT09IHN0YXJ0VHJhcE5vZGUgfHwgY29tcGFyaXNvblJlc3VsdCAmIERPQ1VNRU5UX1BPU0lUSU9OX0JST0FEX1BSRUNFRElORykge1xuICAgICAgY29uc3QgdGFiYmFibGVFbGVtZW50ID0gQXJyYXkuZnJvbShib2R5Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yVGFiYmFibGUpKS5yZXZlcnNlKCkuZmluZChfcmVmMiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgb2Zmc2V0UGFyZW50XG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ob2Zmc2V0UGFyZW50KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRhYmJhYmxlRWxlbWVudCkge1xuICAgICAgICB0YWJiYWJsZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgIH0gZWxzZSBpZiAoYm9keU5vZGUgIT09IG9sZEFjdGl2ZU5vZGUpIHtcbiAgICAgICAgYm9keU5vZGUuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRBY3RpdmVOb2RlID09PSBlbmRUcmFwTm9kZSB8fCBjb21wYXJpc29uUmVzdWx0ICYgRE9DVU1FTlRfUE9TSVRJT05fQlJPQURfRk9MTE9XSU5HKSB7XG4gICAgICBjb25zdCB0YWJiYWJsZUVsZW1lbnQgPSBBcnJheS5mcm9tKGJvZHlOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3JUYWJiYWJsZSkpLmZpbmQoX3JlZjMgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIG9mZnNldFBhcmVudFxuICAgICAgICB9ID0gX3JlZjM7XG4gICAgICAgIHJldHVybiBCb29sZWFuKG9mZnNldFBhcmVudCk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0YWJiYWJsZUVsZW1lbnQpIHtcbiAgICAgICAgdGFiYmFibGVFbGVtZW50LmZvY3VzKCk7XG4gICAgICB9IGVsc2UgaWYgKGJvZHlOb2RlICE9PSBvbGRBY3RpdmVOb2RlKSB7XG4gICAgICAgIGJvZHlOb2RlLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEVuc3VyZXMgdGhlIGZvY3VzIGlzIGtlcHQgaW4gdGhlIGdpdmVuIGNvbnRhaW5lciwgaW1wbGVtZW50aW5nIFwiZm9jdXMtd3JhcFwiXG4gKiBiZWhhdmlvci5cbiAqXG4gKiBOb3RlOiBUaGlzIG11c3QgYmUgY2FsbGVkICpiZWZvcmUqIGZvY3VzIG1vdmVzIHVzaW5nIGBvbktleURvd25gIG9yIHNpbWlsYXIuXG4gKi9cbmNvbnN0IHdyYXBGb2N1c1dpdGhvdXRTZW50aW5lbHMgPSBfcmVmNCA9PiB7XG4gIGxldCB7XG4gICAgY29udGFpbmVyTm9kZSxcbiAgICBjdXJyZW50QWN0aXZlTm9kZSxcbiAgICBldmVudFxuICB9ID0gX3JlZjQ7XG4gIGlmICghY29udGFpbmVyTm9kZSkgcmV0dXJuO1xuICBpZiAoWydibHVyJywgJ2ZvY3Vzb3V0JywgJ2ZvY3VzaW4nLCAnZm9jdXMnXS5pbmNsdWRlcyhldmVudC50eXBlKSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvcjogd3JhcEZvY3VzV2l0aG91dFNlbnRpbmVscyguLi4pIGNhbGxlZCBpbiB1bnN1cHBvcnRlZCAke2V2ZW50LnR5cGV9IGV2ZW50LlxcblxcbkNhbGwgd3JhcEZvY3VzV2l0aG91dFNlbnRpbmVscyguLi4pIGZyb20gb25LZXlEb3duIGluc3RlYWQuYCk7XG4gIH1cblxuICAvLyBVc2UgYHRhYmJhYmxlYCB0byBnZXQgdGhlIGZvY3VzYWJsZSBlbGVtZW50cyBpbiB0YWIgb3JkZXIuXG4gIC8vIGBzZWxlY3RvclRhYmJhYmxlYCByZXR1cm5zIGVsZW1lbnRzIGluIERPTSBvcmRlciB3aGljaCBpcyB3aHkgaXQncyBub3RcbiAgLy8gdXNlZC5cbiAgY29uc3QgdGFiYmFibGVzID0gdGFiYmFibGUoY29udGFpbmVyTm9kZSk7XG4gIGNvbnN0IGZpcnN0VGFiYmFibGUgPSB0YWJiYWJsZXNbMF07XG4gIGNvbnN0IGxhc3RUYWJiYWJsZSA9IHRhYmJhYmxlc1t0YWJiYWJsZXMubGVuZ3RoIC0gMV07XG5cbiAgLy8gVGhlIHNoaWZ0IGtleSBpbmRpY2F0ZXMgaWYgZm9jdXMgaXMgbW92aW5nIGZvcndhcmRzIG9yIGJhY2t3YXJkcy5cbiAgaWYgKGN1cnJlbnRBY3RpdmVOb2RlID09PSBsYXN0VGFiYmFibGUgJiYgIWV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgLy8gQ2FuY2VsIHRoZSBjdXJyZW50IG1vdmVtZW50IG9mIGZvY3VzIGJlY2F1c2Ugd2UncmUgZ29pbmcgdG8gcGxhY2UgaXQgb3Vyc2VsdmVzXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBmaXJzdFRhYmJhYmxlLmZvY3VzKCk7XG4gIH1cbiAgaWYgKGN1cnJlbnRBY3RpdmVOb2RlID09PSBmaXJzdFRhYmJhYmxlICYmIGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgLy8gQ2FuY2VsIHRoZSBjdXJyZW50IG1vdmVtZW50IG9mIGZvY3VzIGJlY2F1c2Ugd2UncmUgZ29pbmcgdG8gcGxhY2UgaXQgb3Vyc2VsdmVzXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBsYXN0VGFiYmFibGUuZm9jdXMoKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgZWxlbWVudE9yUGFyZW50SXNGbG9hdGluZ01lbnUsIHdyYXBGb2N1cywgd3JhcEZvY3VzV2l0aG91dFNlbnRpbmVscyB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjNcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHsgZXh0ZW5kcyBhcyBfZXh0ZW5kcyB9IGZyb20gJy4uLy4uL192aXJ0dWFsL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuanMnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgZGVwcmVjYXRlIGZyb20gJy4uLy4uL3Byb3AtdHlwZXMvZGVwcmVjYXRlLmpzJztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IENsb3NlLCBFcnJvckZpbGxlZCwgQ2hlY2ttYXJrRmlsbGVkLCBXYXJuaW5nRmlsbGVkLCBXYXJuaW5nQWx0RmlsbGVkLCBJbmZvcm1hdGlvbkZpbGxlZCwgSW5mb3JtYXRpb25TcXVhcmVGaWxsZWQgfSBmcm9tICdAY2FyYm9uL2ljb25zLXJlYWN0JztcbmltcG9ydCAnLi4vVGV4dC9pbmRleC5qcyc7XG5pbXBvcnQgQnV0dG9uIGZyb20gJy4uL0J1dHRvbi9CdXR0b24uanMnO1xuaW1wb3J0ICcuLi9CdXR0b24vQnV0dG9uLlNrZWxldG9uLmpzJztcbmltcG9ydCB1c2VJc29tb3JwaGljRWZmZWN0IGZyb20gJy4uLy4uL2ludGVybmFsL3VzZUlzb21vcnBoaWNFZmZlY3QuanMnO1xuaW1wb3J0IHsgdXNlTm9JbnRlcmFjdGl2ZUNoaWxkcmVuLCB1c2VJbnRlcmFjdGl2ZUNoaWxkcmVuTmVlZERlc2NyaXB0aW9uIH0gZnJvbSAnLi4vLi4vaW50ZXJuYWwvdXNlTm9JbnRlcmFjdGl2ZUNoaWxkcmVuLmpzJztcbmltcG9ydCB7IFRhYiwgRXNjYXBlIH0gZnJvbSAnLi4vLi4vaW50ZXJuYWwva2V5Ym9hcmQva2V5cy5qcyc7XG5pbXBvcnQgeyBtYXRjaCwgbWF0Y2hlcyB9IGZyb20gJy4uLy4uL2ludGVybmFsL2tleWJvYXJkL21hdGNoLmpzJztcbmltcG9ydCB7IHVzZVByZWZpeCB9IGZyb20gJy4uLy4uL2ludGVybmFsL3VzZVByZWZpeC5qcyc7XG5pbXBvcnQgeyB1c2VJZCB9IGZyb20gJy4uLy4uL2ludGVybmFsL3VzZUlkLmpzJztcbmltcG9ydCB7IG5vb3BGbiB9IGZyb20gJy4uLy4uL2ludGVybmFsL25vb3BGbi5qcyc7XG5pbXBvcnQgeyB3cmFwRm9jdXMsIHdyYXBGb2N1c1dpdGhvdXRTZW50aW5lbHMgfSBmcm9tICcuLi8uLi9pbnRlcm5hbC93cmFwRm9jdXMuanMnO1xuaW1wb3J0IHsgdXNlRmVhdHVyZUZsYWcgfSBmcm9tICcuLi9GZWF0dXJlRmxhZ3MvaW5kZXguanMnO1xuaW1wb3J0IHsgd2FybmluZyB9IGZyb20gJy4uLy4uL2ludGVybmFsL3dhcm5pbmcuanMnO1xuaW1wb3J0IGRlcHJlY2F0ZVZhbHVlc1dpdGhpbiBmcm9tICcuLi8uLi9wcm9wLXR5cGVzL2RlcHJlY2F0ZVZhbHVlc1dpdGhpbi5qcyc7XG5pbXBvcnQgeyBUZXh0IH0gZnJvbSAnLi4vVGV4dC9UZXh0LmpzJztcblxuLyoqXG4gKiBDb25kaXRpb25hbGx5IGNhbGwgYSBjYWxsYmFjayB3aGVuIHRoZSBlc2NhcGUga2V5IGlzIHByZXNzZWRcbiAqIEBwYXJhbSB7bm9kZX0gcmVmIC0gcmVmIG9mIHRoZSBjb250YWluZXIgZWxlbWVudCB0byBzY29wZSB0aGUgZnVuY3Rpb25hbGl0eSB0b1xuICogQHBhcmFtIHtmdW5jfSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICogQHBhcmFtIHtib29sfSBvdmVycmlkZSAtIGVzY2FwZSBoYXRjaCB0byBjb25kaXRpb25hbGx5IGNhbGwgdGhlIGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIHVzZUVzY2FwZVRvQ2xvc2UocmVmLCBjYWxsYmFjaykge1xuICBsZXQgb3ZlcnJpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gIGNvbnN0IGhhbmRsZUtleURvd24gPSBldmVudCA9PiB7XG4gICAgLy8gVGhlIGNhbGxiYWNrIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuIGZvY3VzIGlzIG9uIG9yIHdpdGhpbiB0aGUgY29udGFpbmVyXG4gICAgY29uc3QgZWxlbWVudENvbnRhaW5zRm9jdXMgPSByZWYuY3VycmVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSByZWYuY3VycmVudCB8fCByZWYuY3VycmVudD8uY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG4gICAgaWYgKG1hdGNoZXMoZXZlbnQsIFtFc2NhcGVdKSAmJiBvdmVycmlkZSAmJiBlbGVtZW50Q29udGFpbnNGb2N1cykge1xuICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgIH1cbiAgfTtcbiAgdXNlSXNvbW9ycGhpY0VmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93biwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24sIGZhbHNlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBOb3RpZmljYXRpb25BY3Rpb25CdXR0b24oX3JlZikge1xuICBsZXQge1xuICAgIGNoaWxkcmVuLFxuICAgIGNsYXNzTmFtZTogY3VzdG9tQ2xhc3NOYW1lLFxuICAgIG9uQ2xpY2ssXG4gICAgaW5saW5lLFxuICAgIC4uLnJlc3RcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHByZWZpeCA9IHVzZVByZWZpeCgpO1xuICBjb25zdCBjbGFzc05hbWUgPSBjeChjdXN0b21DbGFzc05hbWUsIHtcbiAgICBbYCR7cHJlZml4fS0tYWN0aW9uYWJsZS1ub3RpZmljYXRpb25fX2FjdGlvbi1idXR0b25gXTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEJ1dHRvbiwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIGtpbmQ6IGlubGluZSA/ICdnaG9zdCcgOiAndGVydGlhcnknLFxuICAgIG9uQ2xpY2s6IG9uQ2xpY2ssXG4gICAgc2l6ZTogXCJzbVwiXG4gIH0sIHJlc3QpLCBjaGlsZHJlbik7XG59XG5Ob3RpZmljYXRpb25BY3Rpb25CdXR0b24ucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgY29udGVudCBvZiB0aGUgbm90aWZpY2F0aW9uIGFjdGlvbiBidXR0b24uXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGFuIG9wdGlvbmFsIGNsYXNzTmFtZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBub3RpZmljYXRpb24gYWN0aW9uIGJ1dHRvblxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvKipcbiAgICogU3BlY2lmeSBpZiB0aGUgdmlzdWFsIHRyZWF0bWVudCBvZiB0aGUgYnV0dG9uIHNob3VsZCBiZSBmb3IgYW4gaW5saW5lIG5vdGlmaWNhdGlvblxuICAgKi9cbiAgaW5saW5lOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgc3BlY2lmeSBhIGNsaWNrIGhhbmRsZXIgZm9yIHRoZSBub3RpZmljYXRpb24gYWN0aW9uIGJ1dHRvbi5cbiAgICovXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jXG59O1xuXG4vKipcbiAqIE5vdGlmaWNhdGlvbkJ1dHRvblxuICogPT09PT09PT09PT09PT09PT09XG4gKi9cblxuZnVuY3Rpb24gTm90aWZpY2F0aW9uQnV0dG9uKF9yZWYyKSB7XG4gIGxldCB7XG4gICAgJ2FyaWEtbGFiZWwnOiBhcmlhTGFiZWwgPSAnY2xvc2Ugbm90aWZpY2F0aW9uJyxcbiAgICBhcmlhTGFiZWw6IGRlcHJlY2F0ZWRBcmlhTGFiZWwsXG4gICAgY2xhc3NOYW1lLFxuICAgIHR5cGUgPSAnYnV0dG9uJyxcbiAgICByZW5kZXJJY29uOiBJY29uVGFnID0gQ2xvc2UsXG4gICAgbmFtZSxcbiAgICBub3RpZmljYXRpb25UeXBlID0gJ3RvYXN0JyxcbiAgICAuLi5yZXN0XG4gIH0gPSBfcmVmMjtcbiAgY29uc3QgcHJlZml4ID0gdXNlUHJlZml4KCk7XG4gIGNvbnN0IGJ1dHRvbkNsYXNzTmFtZSA9IGN4KGNsYXNzTmFtZSwge1xuICAgIFtgJHtwcmVmaXh9LS0ke25vdGlmaWNhdGlvblR5cGV9LW5vdGlmaWNhdGlvbl9fY2xvc2UtYnV0dG9uYF06IG5vdGlmaWNhdGlvblR5cGVcbiAgfSk7XG4gIGNvbnN0IGljb25DbGFzc05hbWUgPSBjeCh7XG4gICAgW2Ake3ByZWZpeH0tLSR7bm90aWZpY2F0aW9uVHlwZX0tbm90aWZpY2F0aW9uX19jbG9zZS1pY29uYF06IG5vdGlmaWNhdGlvblR5cGVcbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9idXR0b24taGFzLXR5cGVcbiAgICB0eXBlOiB0eXBlLFxuICAgIFwiYXJpYS1sYWJlbFwiOiBkZXByZWNhdGVkQXJpYUxhYmVsIHx8IGFyaWFMYWJlbCxcbiAgICB0aXRsZTogZGVwcmVjYXRlZEFyaWFMYWJlbCB8fCBhcmlhTGFiZWwsXG4gICAgY2xhc3NOYW1lOiBidXR0b25DbGFzc05hbWVcbiAgfSksIEljb25UYWcgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvblRhZywge1xuICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTmFtZSxcbiAgICBuYW1lOiBuYW1lXG4gIH0pKTtcbn1cbk5vdGlmaWNhdGlvbkJ1dHRvbi5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IGEgbGFiZWwgdG8gYmUgcmVhZCBieSBzY3JlZW4gcmVhZGVycyBvbiB0aGUgY29udGFpbmVyIG5vZGVcbiAgICovXG4gIFsnYXJpYS1sYWJlbCddOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvKipcbiAgICogRGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBgYXJpYS1sYWJlbGAgaW5zdGVhZC5cbiAgICogU3BlY2lmeSBhIGxhYmVsIHRvIGJlIHJlYWQgYnkgc2NyZWVuIHJlYWRlcnMgb24gdGhlIGNvbnRhaW5lciBub3RlLlxuICAgKi9cbiAgYXJpYUxhYmVsOiBkZXByZWNhdGUoUHJvcFR5cGVzLnN0cmluZywgJ1RoaXMgcHJvcCBzeW50YXggaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgbmV3IGBhcmlhLWxhYmVsYC4nKSxcbiAgLyoqXG4gICAqIFNwZWNpZnkgYW4gb3B0aW9uYWwgY2xhc3NOYW1lIHRvIGJlIGFwcGxpZWQgdG8gdGhlIG5vdGlmaWNhdGlvbiBidXR0b25cbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAqIFNwZWNpZnkgYW4gb3B0aW9uYWwgaWNvbiBmb3IgdGhlIEJ1dHRvbiB0aHJvdWdoIGEgc3RyaW5nLFxuICAgKiBpZiBzb21ldGhpbmcgYnV0IHJlZ3VsYXIgXCJjbG9zZVwiIGljb24gaXMgZGVzaXJhYmxlXG4gICAqL1xuICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgbm90aWZpY2F0aW9uIHR5cGVcbiAgICovXG4gIG5vdGlmaWNhdGlvblR5cGU6IFByb3BUeXBlcy5vbmVPZihbJ3RvYXN0JywgJ2lubGluZScsICdhY3Rpb25hYmxlJ10pLFxuICAvKipcbiAgICogQSBjb21wb25lbnQgdXNlZCB0byByZW5kZXIgYW4gaWNvbi5cbiAgICovXG4gIHJlbmRlckljb246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMub2JqZWN0XSksXG4gIC8qKlxuICAgKiBPcHRpb25hbCBwcm9wIHRvIHNwZWNpZnkgdGhlIHR5cGUgb2YgdGhlIEJ1dHRvblxuICAgKi9cbiAgdHlwZTogUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuLyoqXG4gKiBOb3RpZmljYXRpb25JY29uXG4gKiA9PT09PT09PT09PT09PT09XG4gKi9cblxuY29uc3QgaWNvblR5cGVzID0ge1xuICBlcnJvcjogRXJyb3JGaWxsZWQsXG4gIHN1Y2Nlc3M6IENoZWNrbWFya0ZpbGxlZCxcbiAgd2FybmluZzogV2FybmluZ0ZpbGxlZCxcbiAgWyd3YXJuaW5nLWFsdCddOiBXYXJuaW5nQWx0RmlsbGVkLFxuICBpbmZvOiBJbmZvcm1hdGlvbkZpbGxlZCxcbiAgWydpbmZvLXNxdWFyZSddOiBJbmZvcm1hdGlvblNxdWFyZUZpbGxlZFxufTtcbmZ1bmN0aW9uIE5vdGlmaWNhdGlvbkljb24oX3JlZjMpIHtcbiAgbGV0IHtcbiAgICBpY29uRGVzY3JpcHRpb24sXG4gICAga2luZCxcbiAgICBub3RpZmljYXRpb25UeXBlXG4gIH0gPSBfcmVmMztcbiAgY29uc3QgcHJlZml4ID0gdXNlUHJlZml4KCk7XG4gIGNvbnN0IEljb25Gb3JLaW5kID0gaWNvblR5cGVzW2tpbmRdO1xuICBpZiAoIUljb25Gb3JLaW5kKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEljb25Gb3JLaW5kLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS0ke25vdGlmaWNhdGlvblR5cGV9LW5vdGlmaWNhdGlvbl9faWNvbmAsXG4gICAgc2l6ZTogMjBcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCBudWxsLCBpY29uRGVzY3JpcHRpb24pKTtcbn1cbk5vdGlmaWNhdGlvbkljb24ucHJvcFR5cGVzID0ge1xuICBpY29uRGVzY3JpcHRpb246IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAga2luZDogUHJvcFR5cGVzLm9uZU9mKFsnZXJyb3InLCAnc3VjY2VzcycsICd3YXJuaW5nJywgJ3dhcm5pbmctYWx0JywgJ2luZm8nLCAnaW5mby1zcXVhcmUnXSkuaXNSZXF1aXJlZCxcbiAgbm90aWZpY2F0aW9uVHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnaW5saW5lJywgJ3RvYXN0J10pLmlzUmVxdWlyZWRcbn07XG5cbi8qKlxuICogVG9hc3ROb3RpZmljYXRpb25cbiAqID09PT09PT09PT09PT09PT09XG4gKi9cblxuZnVuY3Rpb24gVG9hc3ROb3RpZmljYXRpb24oX3JlZjQpIHtcbiAgbGV0IHtcbiAgICBbJ2FyaWEtbGFiZWwnXTogYXJpYUxhYmVsLFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGRlcHJlY2F0ZWQgcHJvcFxuICAgIGFyaWFMYWJlbDogZGVwcmVjYXRlZEFyaWFMYWJlbCxcbiAgICByb2xlID0gJ3N0YXR1cycsXG4gICAgb25DbG9zZSxcbiAgICBvbkNsb3NlQnV0dG9uQ2xpY2sgPSBub29wRm4sXG4gICAgc3RhdHVzSWNvbkRlc2NyaXB0aW9uLFxuICAgIGNsYXNzTmFtZSxcbiAgICBjaGlsZHJlbixcbiAgICBraW5kID0gJ2Vycm9yJyxcbiAgICBsb3dDb250cmFzdCxcbiAgICBoaWRlQ2xvc2VCdXR0b24gPSBmYWxzZSxcbiAgICB0aW1lb3V0ID0gMCxcbiAgICB0aXRsZSxcbiAgICBjYXB0aW9uLFxuICAgIHN1YnRpdGxlLFxuICAgIC4uLnJlc3RcbiAgfSA9IF9yZWY0O1xuICBjb25zdCBbaXNPcGVuLCBzZXRJc09wZW5dID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IHByZWZpeCA9IHVzZVByZWZpeCgpO1xuICBjb25zdCBjb250YWluZXJDbGFzc05hbWUgPSBjeChjbGFzc05hbWUsIHtcbiAgICBbYCR7cHJlZml4fS0tdG9hc3Qtbm90aWZpY2F0aW9uYF06IHRydWUsXG4gICAgW2Ake3ByZWZpeH0tLXRvYXN0LW5vdGlmaWNhdGlvbi0tbG93LWNvbnRyYXN0YF06IGxvd0NvbnRyYXN0LFxuICAgIFtgJHtwcmVmaXh9LS10b2FzdC1ub3RpZmljYXRpb24tLSR7a2luZH1gXToga2luZFxuICB9KTtcbiAgY29uc3QgY29udGVudFJlZiA9IHVzZVJlZihudWxsKTtcbiAgdXNlTm9JbnRlcmFjdGl2ZUNoaWxkcmVuKGNvbnRlbnRSZWYpO1xuICBjb25zdCBoYW5kbGVDbG9zZSA9IGV2dCA9PiB7XG4gICAgaWYgKCFvbkNsb3NlIHx8IG9uQ2xvc2UoZXZ0KSAhPT0gZmFsc2UpIHtcbiAgICAgIHNldElzT3BlbihmYWxzZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZWYgPSB1c2VSZWYobnVsbCk7XG4gIGZ1bmN0aW9uIGhhbmRsZUNsb3NlQnV0dG9uQ2xpY2soZXZlbnQpIHtcbiAgICBvbkNsb3NlQnV0dG9uQ2xpY2soZXZlbnQpO1xuICAgIGhhbmRsZUNsb3NlKGV2ZW50KTtcbiAgfVxuICBjb25zdCBzYXZlZE9uQ2xvc2UgPSB1c2VSZWYob25DbG9zZSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2F2ZWRPbkNsb3NlLmN1cnJlbnQgPSBvbkNsb3NlO1xuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQoZXZlbnQgPT4ge1xuICAgICAgc2V0SXNPcGVuKGZhbHNlKTtcbiAgICAgIGlmIChzYXZlZE9uQ2xvc2UuY3VycmVudCkge1xuICAgICAgICBzYXZlZE9uQ2xvc2UuY3VycmVudChldmVudCk7XG4gICAgICB9XG4gICAgfSwgdGltZW91dCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB9O1xuICB9LCBbdGltZW91dF0pO1xuICBpZiAoIWlzT3Blbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiByZWZcbiAgfSwgcmVzdCwge1xuICAgIHJvbGU6IHJvbGUsXG4gICAgY2xhc3NOYW1lOiBjb250YWluZXJDbGFzc05hbWVcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE5vdGlmaWNhdGlvbkljb24sIHtcbiAgICBub3RpZmljYXRpb25UeXBlOiBcInRvYXN0XCIsXG4gICAga2luZDoga2luZCxcbiAgICBpY29uRGVzY3JpcHRpb246IHN0YXR1c0ljb25EZXNjcmlwdGlvbiB8fCBgJHtraW5kfSBpY29uYFxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogY29udGVudFJlZixcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeH0tLXRvYXN0LW5vdGlmaWNhdGlvbl9fZGV0YWlsc2BcbiAgfSwgdGl0bGUgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dCwge1xuICAgIGFzOiBcImRpdlwiLFxuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tdG9hc3Qtbm90aWZpY2F0aW9uX190aXRsZWBcbiAgfSwgdGl0bGUpLCBzdWJ0aXRsZSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0LCB7XG4gICAgYXM6IFwiZGl2XCIsXG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS10b2FzdC1ub3RpZmljYXRpb25fX3N1YnRpdGxlYFxuICB9LCBzdWJ0aXRsZSksIGNhcHRpb24gJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dCwge1xuICAgIGFzOiBcImRpdlwiLFxuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tdG9hc3Qtbm90aWZpY2F0aW9uX19jYXB0aW9uYFxuICB9LCBjYXB0aW9uKSwgY2hpbGRyZW4pLCAhaGlkZUNsb3NlQnV0dG9uICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE5vdGlmaWNhdGlvbkJ1dHRvbiwge1xuICAgIG5vdGlmaWNhdGlvblR5cGU6IFwidG9hc3RcIixcbiAgICBvbkNsaWNrOiBoYW5kbGVDbG9zZUJ1dHRvbkNsaWNrLFxuICAgIFwiYXJpYS1sYWJlbFwiOiBkZXByZWNhdGVkQXJpYUxhYmVsIHx8IGFyaWFMYWJlbFxuICB9KSk7XG59XG5Ub2FzdE5vdGlmaWNhdGlvbi5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBQcm92aWRlIGEgZGVzY3JpcHRpb24gZm9yIFwiY2xvc2VcIiBpY29uIGJ1dHRvbiB0aGF0IGNhbiBiZSByZWFkIGJ5IHNjcmVlbiByZWFkZXJzXG4gICAqL1xuICBbJ2FyaWEtbGFiZWwnXTogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYGFyaWEtbGFiZWxgIGluc3RlYWQuXG4gICAqIFByb3ZpZGUgYSBkZXNjcmlwdGlvbiBmb3IgXCJjbG9zZVwiIGljb24gYnV0dG9uIHRoYXQgY2FuIGJlIHJlYWQgYnkgc2NyZWVuIHJlYWRlcnNcbiAgICovXG4gIGFyaWFMYWJlbDogZGVwcmVjYXRlKFByb3BUeXBlcy5zdHJpbmcsICdUaGlzIHByb3Agc3ludGF4IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdGhlIG5ldyBgYXJpYS1sYWJlbGAuJyksXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBjYXB0aW9uXG4gICAqL1xuICBjYXB0aW9uOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgY29udGVudFxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAvKipcbiAgICogU3BlY2lmeSBhbiBvcHRpb25hbCBjbGFzc05hbWUgdG8gYmUgYXBwbGllZCB0byB0aGUgbm90aWZpY2F0aW9uIGJveFxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgY2xvc2UgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZCwgb3Igbm90XG4gICAqL1xuICBoaWRlQ2xvc2VCdXR0b246IFByb3BUeXBlcy5ib29sLFxuICAvKipcbiAgICogU3BlY2lmeSB3aGF0IHN0YXRlIHRoZSBub3RpZmljYXRpb24gcmVwcmVzZW50c1xuICAgKi9cbiAga2luZDogUHJvcFR5cGVzLm9uZU9mKFsnZXJyb3InLCAnaW5mbycsICdpbmZvLXNxdWFyZScsICdzdWNjZXNzJywgJ3dhcm5pbmcnLCAnd2FybmluZy1hbHQnXSksXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgeW91IGFyZSB1c2luZyB0aGUgbG93IGNvbnRyYXN0IHZhcmlhbnQgb2YgdGhlIFRvYXN0Tm90aWZpY2F0aW9uLlxuICAgKi9cbiAgbG93Q29udHJhc3Q6IFByb3BUeXBlcy5ib29sLFxuICAvKipcbiAgICogUHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gbWVudSBpcyBjbG9zZWRcbiAgICovXG4gIG9uQ2xvc2U6IFByb3BUeXBlcy5mdW5jLFxuICAvKipcbiAgICogUHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGNsb3NlIGJ1dHRvbiBpcyBjbGlja2VkXG4gICAqL1xuICBvbkNsb3NlQnV0dG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAvKipcbiAgICogQnkgZGVmYXVsdCwgdGhpcyB2YWx1ZSBpcyBcInN0YXR1c1wiLiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhbiBhbHRlcm5hdGVcbiAgICogcm9sZSBpZiBpdCBtYWtlcyBzZW5zZSBmcm9tIHRoZSBhY2Nlc3NpYmlsaXR5LXNpZGVcbiAgICovXG4gIHJvbGU6IFByb3BUeXBlcy5vbmVPZihbJ2FsZXJ0JywgJ2xvZycsICdzdGF0dXMnXSksXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgZGVzY3JpcHRpb24gZm9yIFwic3RhdHVzXCIgaWNvbiB0aGF0IGNhbiBiZSByZWFkIGJ5IHNjcmVlbiByZWFkZXJzXG4gICAqL1xuICBzdGF0dXNJY29uRGVzY3JpcHRpb246IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBzdWJ0aXRsZVxuICAgKi9cbiAgc3VidGl0bGU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGFuIG9wdGlvbmFsIGR1cmF0aW9uIHRoZSBub3RpZmljYXRpb24gc2hvdWxkIGJlIGNsb3NlZCBpblxuICAgKi9cbiAgdGltZW91dDogUHJvcFR5cGVzLm51bWJlcixcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIHRpdGxlXG4gICAqL1xuICB0aXRsZTogUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuLyoqXG4gKiBJbmxpbmVOb3RpZmljYXRpb25cbiAqID09PT09PT09PT09PT09PT09PVxuICovXG5cbmZ1bmN0aW9uIElubGluZU5vdGlmaWNhdGlvbihfcmVmNSkge1xuICBsZXQge1xuICAgIFsnYXJpYS1sYWJlbCddOiBhcmlhTGFiZWwsXG4gICAgY2hpbGRyZW4sXG4gICAgdGl0bGUsXG4gICAgc3VidGl0bGUsXG4gICAgcm9sZSA9ICdzdGF0dXMnLFxuICAgIG9uQ2xvc2UsXG4gICAgb25DbG9zZUJ1dHRvbkNsaWNrID0gbm9vcEZuLFxuICAgIHN0YXR1c0ljb25EZXNjcmlwdGlvbixcbiAgICBjbGFzc05hbWUsXG4gICAga2luZCA9ICdlcnJvcicsXG4gICAgbG93Q29udHJhc3QsXG4gICAgaGlkZUNsb3NlQnV0dG9uID0gZmFsc2UsXG4gICAgLi4ucmVzdFxuICB9ID0gX3JlZjU7XG4gIGNvbnN0IFtpc09wZW4sIHNldElzT3Blbl0gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgcHJlZml4ID0gdXNlUHJlZml4KCk7XG4gIGNvbnN0IGNvbnRhaW5lckNsYXNzTmFtZSA9IGN4KGNsYXNzTmFtZSwge1xuICAgIFtgJHtwcmVmaXh9LS1pbmxpbmUtbm90aWZpY2F0aW9uYF06IHRydWUsXG4gICAgW2Ake3ByZWZpeH0tLWlubGluZS1ub3RpZmljYXRpb24tLWxvdy1jb250cmFzdGBdOiBsb3dDb250cmFzdCxcbiAgICBbYCR7cHJlZml4fS0taW5saW5lLW5vdGlmaWNhdGlvbi0tJHtraW5kfWBdOiBraW5kLFxuICAgIFtgJHtwcmVmaXh9LS1pbmxpbmUtbm90aWZpY2F0aW9uLS1oaWRlLWNsb3NlLWJ1dHRvbmBdOiBoaWRlQ2xvc2VCdXR0b25cbiAgfSk7XG4gIGNvbnN0IGNvbnRlbnRSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHVzZU5vSW50ZXJhY3RpdmVDaGlsZHJlbihjb250ZW50UmVmKTtcbiAgY29uc3QgaGFuZGxlQ2xvc2UgPSBldnQgPT4ge1xuICAgIGlmICghb25DbG9zZSB8fCBvbkNsb3NlKGV2dCkgIT09IGZhbHNlKSB7XG4gICAgICBzZXRJc09wZW4oZmFsc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuICBmdW5jdGlvbiBoYW5kbGVDbG9zZUJ1dHRvbkNsaWNrKGV2ZW50KSB7XG4gICAgb25DbG9zZUJ1dHRvbkNsaWNrKGV2ZW50KTtcbiAgICBoYW5kbGVDbG9zZShldmVudCk7XG4gIH1cbiAgaWYgKCFpc09wZW4pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmVmXG4gIH0sIHJlc3QsIHtcbiAgICByb2xlOiByb2xlLFxuICAgIGNsYXNzTmFtZTogY29udGFpbmVyQ2xhc3NOYW1lXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS1pbmxpbmUtbm90aWZpY2F0aW9uX19kZXRhaWxzYFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChOb3RpZmljYXRpb25JY29uLCB7XG4gICAgbm90aWZpY2F0aW9uVHlwZTogXCJpbmxpbmVcIixcbiAgICBraW5kOiBraW5kLFxuICAgIGljb25EZXNjcmlwdGlvbjogc3RhdHVzSWNvbkRlc2NyaXB0aW9uIHx8IGAke2tpbmR9IGljb25gXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBjb250ZW50UmVmLFxuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0taW5saW5lLW5vdGlmaWNhdGlvbl9fdGV4dC13cmFwcGVyYFxuICB9LCB0aXRsZSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0LCB7XG4gICAgYXM6IFwiZGl2XCIsXG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS1pbmxpbmUtbm90aWZpY2F0aW9uX190aXRsZWBcbiAgfSwgdGl0bGUpLCBzdWJ0aXRsZSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0LCB7XG4gICAgYXM6IFwiZGl2XCIsXG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS1pbmxpbmUtbm90aWZpY2F0aW9uX19zdWJ0aXRsZWBcbiAgfSwgc3VidGl0bGUpLCBjaGlsZHJlbikpLCAhaGlkZUNsb3NlQnV0dG9uICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE5vdGlmaWNhdGlvbkJ1dHRvbiwge1xuICAgIG5vdGlmaWNhdGlvblR5cGU6IFwiaW5saW5lXCIsXG4gICAgb25DbGljazogaGFuZGxlQ2xvc2VCdXR0b25DbGljayxcbiAgICBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsXG4gIH0pKTtcbn1cbklubGluZU5vdGlmaWNhdGlvbi5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBQcm92aWRlIGEgZGVzY3JpcHRpb24gZm9yIFwiY2xvc2VcIiBpY29uIGJ1dHRvbiB0aGF0IGNhbiBiZSByZWFkIGJ5IHNjcmVlbiByZWFkZXJzXG4gICAqL1xuICBbJ2FyaWEtbGFiZWwnXTogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGNvbnRlbnRcbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgLyoqXG4gICAqIFNwZWNpZnkgYW4gb3B0aW9uYWwgY2xhc3NOYW1lIHRvIGJlIGFwcGxpZWQgdG8gdGhlIG5vdGlmaWNhdGlvbiBib3hcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGNsb3NlIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQsIG9yIG5vdFxuICAgKi9cbiAgaGlkZUNsb3NlQnV0dG9uOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIFNwZWNpZnkgd2hhdCBzdGF0ZSB0aGUgbm90aWZpY2F0aW9uIHJlcHJlc2VudHNcbiAgICovXG4gIGtpbmQ6IFByb3BUeXBlcy5vbmVPZihbJ2Vycm9yJywgJ2luZm8nLCAnaW5mby1zcXVhcmUnLCAnc3VjY2VzcycsICd3YXJuaW5nJywgJ3dhcm5pbmctYWx0J10pLFxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIHlvdSBhcmUgdXNpbmcgdGhlIGxvdyBjb250cmFzdCB2YXJpYW50IG9mIHRoZSBJbmxpbmVOb3RpZmljYXRpb24uXG4gICAqL1xuICBsb3dDb250cmFzdDogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBtZW51IGlzIGNsb3NlZFxuICAgKi9cbiAgb25DbG9zZTogUHJvcFR5cGVzLmZ1bmMsXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgY2xvc2UgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICovXG4gIG9uQ2xvc2VCdXR0b25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIHZhbHVlIGlzIFwic3RhdHVzXCIuIFlvdSBjYW4gYWxzbyBwcm92aWRlIGFuIGFsdGVybmF0ZVxuICAgKiByb2xlIGlmIGl0IG1ha2VzIHNlbnNlIGZyb20gdGhlIGFjY2Vzc2liaWxpdHktc2lkZS5cbiAgICovXG4gIHJvbGU6IFByb3BUeXBlcy5vbmVPZihbJ2FsZXJ0JywgJ2xvZycsICdzdGF0dXMnXSksXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgZGVzY3JpcHRpb24gZm9yIFwic3RhdHVzXCIgaWNvbiB0aGF0IGNhbiBiZSByZWFkIGJ5IHNjcmVlbiByZWFkZXJzXG4gICAqL1xuICBzdGF0dXNJY29uRGVzY3JpcHRpb246IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBzdWJ0aXRsZVxuICAgKi9cbiAgc3VidGl0bGU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSB0aXRsZVxuICAgKi9cbiAgdGl0bGU6IFByb3BUeXBlcy5zdHJpbmdcbn07XG5cbi8qKlxuICogQWN0aW9uYWJsZU5vdGlmaWNhdGlvblxuICogPT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmZ1bmN0aW9uIEFjdGlvbmFibGVOb3RpZmljYXRpb24oX3JlZjYpIHtcbiAgbGV0IHtcbiAgICBhY3Rpb25CdXR0b25MYWJlbCxcbiAgICBbJ2FyaWEtbGFiZWwnXTogYXJpYUxhYmVsLFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGRlcHJlY2F0ZWQgcHJvcFxuICAgIGFyaWFMYWJlbDogZGVwcmVjYXRlZEFyaWFMYWJlbCxcbiAgICBjaGlsZHJlbixcbiAgICByb2xlID0gJ2FsZXJ0ZGlhbG9nJyxcbiAgICBvbkFjdGlvbkJ1dHRvbkNsaWNrLFxuICAgIG9uQ2xvc2UsXG4gICAgb25DbG9zZUJ1dHRvbkNsaWNrID0gbm9vcEZuLFxuICAgIHN0YXR1c0ljb25EZXNjcmlwdGlvbixcbiAgICBjbGFzc05hbWUsXG4gICAgaW5saW5lID0gZmFsc2UsXG4gICAga2luZCA9ICdlcnJvcicsXG4gICAgbG93Q29udHJhc3QsXG4gICAgaGlkZUNsb3NlQnV0dG9uID0gZmFsc2UsXG4gICAgaGFzRm9jdXMgPSB0cnVlLFxuICAgIGNsb3NlT25Fc2NhcGUgPSB0cnVlLFxuICAgIHRpdGxlLFxuICAgIHN1YnRpdGxlLFxuICAgIC4uLnJlc3RcbiAgfSA9IF9yZWY2O1xuICBjb25zdCBbaXNPcGVuLCBzZXRJc09wZW5dID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IHByZWZpeCA9IHVzZVByZWZpeCgpO1xuICBjb25zdCBpZCA9IHVzZUlkKCdhY3Rpb25hYmxlLW5vdGlmaWNhdGlvbicpO1xuICBjb25zdCBzdWJ0aXRsZUlkID0gdXNlSWQoJ2FjdGlvbmFibGUtbm90aWZpY2F0aW9uLXN1YnRpdGxlJyk7XG4gIGNvbnN0IGNvbnRhaW5lckNsYXNzTmFtZSA9IGN4KGNsYXNzTmFtZSwge1xuICAgIFtgJHtwcmVmaXh9LS1hY3Rpb25hYmxlLW5vdGlmaWNhdGlvbmBdOiB0cnVlLFxuICAgIFtgJHtwcmVmaXh9LS1hY3Rpb25hYmxlLW5vdGlmaWNhdGlvbi0tdG9hc3RgXTogIWlubGluZSxcbiAgICBbYCR7cHJlZml4fS0tYWN0aW9uYWJsZS1ub3RpZmljYXRpb24tLWxvdy1jb250cmFzdGBdOiBsb3dDb250cmFzdCxcbiAgICBbYCR7cHJlZml4fS0tYWN0aW9uYWJsZS1ub3RpZmljYXRpb24tLSR7a2luZH1gXToga2luZCxcbiAgICBbYCR7cHJlZml4fS0tYWN0aW9uYWJsZS1ub3RpZmljYXRpb24tLWhpZGUtY2xvc2UtYnV0dG9uYF06IGhpZGVDbG9zZUJ1dHRvblxuICB9KTtcbiAgY29uc3QgaW5uZXJNb2RhbCA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qgc3RhcnRUcmFwID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBlbmRUcmFwID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCByZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGZvY3VzVHJhcFdpdGhvdXRTZW50aW5lbHMgPSB1c2VGZWF0dXJlRmxhZygnZW5hYmxlLWV4cGVyaW1lbnRhbC1mb2N1cy13cmFwLXdpdGhvdXQtc2VudGluZWxzJyk7XG4gIHVzZUlzb21vcnBoaWNFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChoYXNGb2N1cyAmJiByb2xlID09PSAnYWxlcnRkaWFsb2cnKSB7XG4gICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdidXR0b24uY2RzLS1hY3Rpb25hYmxlLW5vdGlmaWNhdGlvbl9fYWN0aW9uLWJ1dHRvbicpO1xuICAgICAgYnV0dG9uPy5mb2N1cygpO1xuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIGhhbmRsZUJsdXIoX3JlZjcpIHtcbiAgICBsZXQge1xuICAgICAgdGFyZ2V0OiBvbGRBY3RpdmVOb2RlLFxuICAgICAgcmVsYXRlZFRhcmdldDogY3VycmVudEFjdGl2ZU5vZGVcbiAgICB9ID0gX3JlZjc7XG4gICAgaWYgKGlzT3BlbiAmJiBjdXJyZW50QWN0aXZlTm9kZSAmJiBvbGRBY3RpdmVOb2RlICYmIHJvbGUgPT09ICdhbGVydGRpYWxvZycpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY3VycmVudDogYm9keU5vZGVcbiAgICAgIH0gPSBpbm5lck1vZGFsO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjdXJyZW50OiBzdGFydFRyYXBOb2RlXG4gICAgICB9ID0gc3RhcnRUcmFwO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjdXJyZW50OiBlbmRUcmFwTm9kZVxuICAgICAgfSA9IGVuZFRyYXA7XG4gICAgICB3cmFwRm9jdXMoe1xuICAgICAgICBib2R5Tm9kZSxcbiAgICAgICAgc3RhcnRUcmFwTm9kZSxcbiAgICAgICAgZW5kVHJhcE5vZGUsXG4gICAgICAgIGN1cnJlbnRBY3RpdmVOb2RlLFxuICAgICAgICBvbGRBY3RpdmVOb2RlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgIGlmIChpc09wZW4gJiYgbWF0Y2goZXZlbnQsIFRhYikgJiYgcmVmLmN1cnJlbnQgJiYgcm9sZSA9PT0gJ2FsZXJ0ZGlhbG9nJykge1xuICAgICAgd3JhcEZvY3VzV2l0aG91dFNlbnRpbmVscyh7XG4gICAgICAgIGNvbnRhaW5lck5vZGU6IHJlZi5jdXJyZW50LFxuICAgICAgICBjdXJyZW50QWN0aXZlTm9kZTogZXZlbnQudGFyZ2V0LFxuICAgICAgICBldmVudFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGhhbmRsZUNsb3NlID0gZXZ0ID0+IHtcbiAgICBpZiAoIW9uQ2xvc2UgfHwgb25DbG9zZShldnQpICE9PSBmYWxzZSkge1xuICAgICAgc2V0SXNPcGVuKGZhbHNlKTtcbiAgICB9XG4gIH07XG4gIHVzZUVzY2FwZVRvQ2xvc2UocmVmLCBoYW5kbGVDbG9zZUJ1dHRvbkNsaWNrLCBjbG9zZU9uRXNjYXBlKTtcbiAgZnVuY3Rpb24gaGFuZGxlQ2xvc2VCdXR0b25DbGljayhldmVudCkge1xuICAgIG9uQ2xvc2VCdXR0b25DbGljayhldmVudCk7XG4gICAgaGFuZGxlQ2xvc2UoZXZlbnQpO1xuICB9XG4gIGlmICghaXNPcGVuKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgcmVmOiByZWYsXG4gICAgcm9sZTogcm9sZSxcbiAgICBjbGFzc05hbWU6IGNvbnRhaW5lckNsYXNzTmFtZSxcbiAgICBcImFyaWEtbGFiZWxsZWRieVwiOiB0aXRsZSA/IGlkIDogc3VidGl0bGVJZCxcbiAgICBvbkJsdXI6ICFmb2N1c1RyYXBXaXRob3V0U2VudGluZWxzID8gaGFuZGxlQmx1ciA6ICgpID0+IHt9LFxuICAgIG9uS2V5RG93bjogZm9jdXNUcmFwV2l0aG91dFNlbnRpbmVscyA/IGhhbmRsZUtleURvd24gOiAoKSA9PiB7fVxuICB9KSwgIWZvY3VzVHJhcFdpdGhvdXRTZW50aW5lbHMgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICByZWY6IHN0YXJ0VHJhcCxcbiAgICB0YWJJbmRleDogMCxcbiAgICByb2xlOiBcImxpbmtcIixcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeH0tLXZpc3VhbGx5LWhpZGRlbmBcbiAgfSwgXCJGb2N1cyBzZW50aW5lbFwiKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tYWN0aW9uYWJsZS1ub3RpZmljYXRpb25fX2RldGFpbHNgXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE5vdGlmaWNhdGlvbkljb24sIHtcbiAgICBub3RpZmljYXRpb25UeXBlOiBpbmxpbmUgPyAnaW5saW5lJyA6ICd0b2FzdCcsXG4gICAga2luZDoga2luZCxcbiAgICBpY29uRGVzY3JpcHRpb246IHN0YXR1c0ljb25EZXNjcmlwdGlvbiB8fCBgJHtraW5kfSBpY29uYFxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tYWN0aW9uYWJsZS1ub3RpZmljYXRpb25fX3RleHQtd3JhcHBlcmBcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tYWN0aW9uYWJsZS1ub3RpZmljYXRpb25fX2NvbnRlbnRgXG4gIH0sIHRpdGxlICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRleHQsIHtcbiAgICBhczogXCJkaXZcIixcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeH0tLWFjdGlvbmFibGUtbm90aWZpY2F0aW9uX190aXRsZWAsXG4gICAgaWQ6IGlkXG4gIH0sIHRpdGxlKSwgc3VidGl0bGUgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dCwge1xuICAgIGFzOiBcImRpdlwiLFxuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tYWN0aW9uYWJsZS1ub3RpZmljYXRpb25fX3N1YnRpdGxlYCxcbiAgICBpZDogc3VidGl0bGVJZFxuICB9LCBzdWJ0aXRsZSksIGNoaWxkcmVuKSkpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS1hY3Rpb25hYmxlLW5vdGlmaWNhdGlvbl9fYnV0dG9uLXdyYXBwZXJgLFxuICAgIHJlZjogaW5uZXJNb2RhbFxuICB9LCBhY3Rpb25CdXR0b25MYWJlbCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChOb3RpZmljYXRpb25BY3Rpb25CdXR0b24sIHtcbiAgICBvbkNsaWNrOiBvbkFjdGlvbkJ1dHRvbkNsaWNrLFxuICAgIGlubGluZTogaW5saW5lXG4gIH0sIGFjdGlvbkJ1dHRvbkxhYmVsKSwgIWhpZGVDbG9zZUJ1dHRvbiAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChOb3RpZmljYXRpb25CdXR0b24sIHtcbiAgICBcImFyaWEtbGFiZWxcIjogZGVwcmVjYXRlZEFyaWFMYWJlbCB8fCBhcmlhTGFiZWwsXG4gICAgbm90aWZpY2F0aW9uVHlwZTogXCJhY3Rpb25hYmxlXCIsXG4gICAgb25DbGljazogaGFuZGxlQ2xvc2VCdXR0b25DbGlja1xuICB9KSksICFmb2N1c1RyYXBXaXRob3V0U2VudGluZWxzICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgcmVmOiBlbmRUcmFwLFxuICAgIHRhYkluZGV4OiAwLFxuICAgIHJvbGU6IFwibGlua1wiLFxuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tdmlzdWFsbHktaGlkZGVuYFxuICB9LCBcIkZvY3VzIHNlbnRpbmVsXCIpKTtcbn1cbkFjdGlvbmFibGVOb3RpZmljYXRpb24ucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogUGFzcyBpbiB0aGUgYWN0aW9uIGJ1dHRvbiBsYWJlbCB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgd2l0aGluIHRoZSBBY3Rpb25hYmxlTm90aWZpY2F0aW9uLlxuICAgKi9cbiAgYWN0aW9uQnV0dG9uTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgZGVzY3JpcHRpb24gZm9yIFwiY2xvc2VcIiBpY29uIGJ1dHRvbiB0aGF0IGNhbiBiZSByZWFkIGJ5IHNjcmVlbiByZWFkZXJzXG4gICAqL1xuICBbJ2FyaWEtbGFiZWwnXTogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYGFyaWEtbGFiZWxgIGluc3RlYWQuXG4gICAqIFByb3ZpZGUgYSBkZXNjcmlwdGlvbiBmb3IgXCJjbG9zZVwiIGljb24gYnV0dG9uIHRoYXQgY2FuIGJlIHJlYWQgYnkgc2NyZWVuIHJlYWRlcnNcbiAgICovXG4gIGFyaWFMYWJlbDogZGVwcmVjYXRlKFByb3BUeXBlcy5zdHJpbmcsICdUaGlzIHByb3Agc3ludGF4IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdGhlIG5ldyBgYXJpYS1sYWJlbGAuJyksXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBjb250ZW50XG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGFuIG9wdGlvbmFsIGNsYXNzTmFtZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBub3RpZmljYXRpb24gYm94XG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGlmIHByZXNzaW5nIHRoZSBlc2NhcGUga2V5IHNob3VsZCBjbG9zZSBub3RpZmljYXRpb25zXG4gICAqL1xuICBjbG9zZU9uRXNjYXBlOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIFNwZWNpZnkgaWYgZm9jdXMgc2hvdWxkIGJlIG1vdmVkIHRvIHRoZSBjb21wb25lbnQgd2hlbiB0aGUgbm90aWZpY2F0aW9uIGNvbnRhaW5zIGFjdGlvbnNcbiAgICovXG4gIGhhc0ZvY3VzOiBkZXByZWNhdGUoUHJvcFR5cGVzLmJvb2wsICdoYXNGb2N1cyBpcyBkZXByZWNhdGVkLiBUbyBjb25mb3JtIHRvIGFjY2Vzc2liaWxpdHkgcmVxdWlyZW1lbnRzIGhhc0ZvY3VzICcgKyAnc2hvdWxkIGFsd2F5cyBiZSBgdHJ1ZWAgZm9yIEFjdGlvbmFibGVOb3RpZmljYXRpb24uIElmIHlvdSB3ZXJlICcgKyAnc2V0dGluZyB0aGlzIHByb3AgdG8gYGZhbHNlYCwgY29uc2lkZXIgdXNpbmcgdGhlIENhbGxvdXQgY29tcG9uZW50IGluc3RlYWQuJyksXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBjbG9zZSBidXR0b24gc2hvdWxkIGJlIGRpc2FibGVkLCBvciBub3RcbiAgICovXG4gIGhpZGVDbG9zZUJ1dHRvbjogUHJvcFR5cGVzLmJvb2wsXG4gIC8qXG4gICAqIFNwZWNpZnkgaWYgdGhlIG5vdGlmaWNhdGlvbiBzaG91bGQgaGF2ZSBpbmxpbmUgc3R5bGluZyBhcHBsaWVkIGluc3RlYWQgb2YgdG9hc3RcbiAgICovXG4gIGlubGluZTogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoYXQgc3RhdGUgdGhlIG5vdGlmaWNhdGlvbiByZXByZXNlbnRzXG4gICAqL1xuICBraW5kOiBQcm9wVHlwZXMub25lT2YoWydlcnJvcicsICdpbmZvJywgJ2luZm8tc3F1YXJlJywgJ3N1Y2Nlc3MnLCAnd2FybmluZycsICd3YXJuaW5nLWFsdCddKSxcbiAgLyoqXG4gICAqIFNwZWNpZnkgd2hldGhlciB5b3UgYXJlIHVzaW5nIHRoZSBsb3cgY29udHJhc3QgdmFyaWFudCBvZiB0aGUgQWN0aW9uYWJsZU5vdGlmaWNhdGlvbi5cbiAgICovXG4gIGxvd0NvbnRyYXN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBhY3Rpb24gaXMgY2xpY2tlZFxuICAgKi9cbiAgb25BY3Rpb25CdXR0b25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBtZW51IGlzIGNsb3NlZFxuICAgKi9cbiAgb25DbG9zZTogUHJvcFR5cGVzLmZ1bmMsXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgY2xvc2UgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICovXG4gIG9uQ2xvc2VCdXR0b25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gIC8qKlxuICAgKiBQcm92aWRlIGFuIGFjY2Vzc2libGUgcm9sZSB0byBiZSB1c2VkLiBEZWZhdWx0cyB0byBgYWxlcnRkaWFsb2dgLiBBbnkgb3RoZXJcbiAgICogdmFsdWUgd2lsbCBkaXNhYmxlIHRoZSB3cmFwcGluZyBvZiBmb2N1cy4gVG8gcmVtYWluIGFjY2Vzc2libGUsIGFkZGl0aW9uYWxcbiAgICogd29yayBpcyByZXF1aXJlZC4gU2VlIHRoZSBzdG9yeWJvb2sgZG9jcyBmb3IgbW9yZSBpbmZvOlxuICAgKiBodHRwczovL3JlYWN0LmNhcmJvbmRlc2lnbnN5c3RlbS5jb20vP3BhdGg9L2RvY3MvY29tcG9uZW50cy1ub3RpZmljYXRpb25zLWFjdGlvbmFibGUtLW92ZXJ2aWV3I3VzaW5nLXRoZS1yb2xlLXByb3BcbiAgICovXG4gIHJvbGU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgZGVzY3JpcHRpb24gZm9yIFwic3RhdHVzXCIgaWNvbiB0aGF0IGNhbiBiZSByZWFkIGJ5IHNjcmVlbiByZWFkZXJzXG4gICAqL1xuICBzdGF0dXNJY29uRGVzY3JpcHRpb246IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBzdWJ0aXRsZVxuICAgKi9cbiAgc3VidGl0bGU6IFByb3BUeXBlcy5ub2RlLFxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgdGl0bGVcbiAgICovXG4gIHRpdGxlOiBQcm9wVHlwZXMuc3RyaW5nXG59O1xuXG4vKipcbiAqIENhbGxvdXRcbiAqID09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qKlxuICogRGVwcmVjYXRlZCBjYWxsb3V0IGtpbmQgdmFsdWVzLlxuICogQGRlcHJlY2F0ZWQgVXNlIE5ld0tpbmRQcm9wcyBpbnN0ZWFkLlxuICovXG5cbmNvbnN0IHByb3BNYXBwaW5nRnVuY3Rpb24gPSBkZXByZWNhdGVkVmFsdWUgPT4ge1xuICBjb25zdCBtYXBwaW5nID0ge1xuICAgIGVycm9yOiAnd2FybmluZycsXG4gICAgLy8gb25seSByZWRpcmVjdCBlcnJvciAtPiB3YXJuaW5nXG4gICAgc3VjY2VzczogJ2luZm8nIC8vIG9ubHkgcmVkaXJlY3Qgc3VjY2VzcyAtPiBpbmZvXG4gIH07XG4gIHJldHVybiBtYXBwaW5nW2RlcHJlY2F0ZWRWYWx1ZV07XG59O1xuZnVuY3Rpb24gQ2FsbG91dChfcmVmOCkge1xuICBsZXQge1xuICAgIGFjdGlvbkJ1dHRvbkxhYmVsLFxuICAgIGNoaWxkcmVuLFxuICAgIG9uQWN0aW9uQnV0dG9uQ2xpY2ssXG4gICAgdGl0bGUsXG4gICAgdGl0bGVJZCxcbiAgICBzdWJ0aXRsZSxcbiAgICBzdGF0dXNJY29uRGVzY3JpcHRpb24sXG4gICAgY2xhc3NOYW1lLFxuICAgIGtpbmQgPSAnaW5mbycsXG4gICAgbG93Q29udHJhc3QsXG4gICAgLi4ucmVzdFxuICB9ID0gX3JlZjg7XG4gIGNvbnN0IHByZWZpeCA9IHVzZVByZWZpeCgpO1xuICBjb25zdCBjb250YWluZXJDbGFzc05hbWUgPSBjeChjbGFzc05hbWUsIHtcbiAgICBbYCR7cHJlZml4fS0tYWN0aW9uYWJsZS1ub3RpZmljYXRpb25gXTogdHJ1ZSxcbiAgICBbYCR7cHJlZml4fS0tYWN0aW9uYWJsZS1ub3RpZmljYXRpb24tLWxvdy1jb250cmFzdGBdOiBsb3dDb250cmFzdCxcbiAgICBbYCR7cHJlZml4fS0tYWN0aW9uYWJsZS1ub3RpZmljYXRpb24tLSR7a2luZH1gXToga2luZCxcbiAgICBbYCR7cHJlZml4fS0tYWN0aW9uYWJsZS1ub3RpZmljYXRpb24tLWhpZGUtY2xvc2UtYnV0dG9uYF06IHRydWVcbiAgfSk7XG4gIGNvbnN0IGNoaWxkcmVuQ29udGFpbmVyID0gdXNlUmVmKG51bGwpO1xuICB1c2VJbnRlcmFjdGl2ZUNoaWxkcmVuTmVlZERlc2NyaXB0aW9uKGNoaWxkcmVuQ29udGFpbmVyLCBgaW50ZXJhY3RpdmUgY2hpbGQgbm9kZShzKSBzaG91bGQgaGF2ZSBhbiBcXGBhcmlhLWRlc2NyaWJlZGJ5XFxgIHByb3BlcnR5IHdpdGggYSB2YWx1ZSBtYXRjaGluZyB0aGUgdmFsdWUgb2YgXFxgdGl0bGVJZFxcYGApO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBjbGFzc05hbWU6IGNvbnRhaW5lckNsYXNzTmFtZVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tYWN0aW9uYWJsZS1ub3RpZmljYXRpb25fX2RldGFpbHNgXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE5vdGlmaWNhdGlvbkljb24sIHtcbiAgICBub3RpZmljYXRpb25UeXBlOiBcImlubGluZVwiLFxuICAgIGtpbmQ6IGtpbmQsXG4gICAgaWNvbkRlc2NyaXB0aW9uOiBzdGF0dXNJY29uRGVzY3JpcHRpb24gfHwgYCR7a2luZH0gaWNvbmBcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICByZWY6IGNoaWxkcmVuQ29udGFpbmVyLFxuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tYWN0aW9uYWJsZS1ub3RpZmljYXRpb25fX3RleHQtd3JhcHBlcmBcbiAgfSwgdGl0bGUgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dCwge1xuICAgIGFzOiBcImRpdlwiLFxuICAgIGlkOiB0aXRsZUlkLFxuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fS0tYWN0aW9uYWJsZS1ub3RpZmljYXRpb25fX3RpdGxlYFxuICB9LCB0aXRsZSksIHN1YnRpdGxlICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRleHQsIHtcbiAgICBhczogXCJkaXZcIixcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeH0tLWFjdGlvbmFibGUtbm90aWZpY2F0aW9uX19zdWJ0aXRsZWBcbiAgfSwgc3VidGl0bGUpLCBjaGlsZHJlbikpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9LS1hY3Rpb25hYmxlLW5vdGlmaWNhdGlvbl9fYnV0dG9uLXdyYXBwZXJgXG4gIH0sIGFjdGlvbkJ1dHRvbkxhYmVsICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE5vdGlmaWNhdGlvbkFjdGlvbkJ1dHRvbiwge1xuICAgIG9uQ2xpY2s6IG9uQWN0aW9uQnV0dG9uQ2xpY2ssXG4gICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IHRpdGxlSWQsXG4gICAgaW5saW5lOiB0cnVlXG4gIH0sIGFjdGlvbkJ1dHRvbkxhYmVsKSkpO1xufVxuQ2FsbG91dC5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBQYXNzIGluIHRoZSBhY3Rpb24gYnV0dG9uIGxhYmVsIHRoYXQgd2lsbCBiZSByZW5kZXJlZCB3aXRoaW4gdGhlIEFjdGlvbmFibGVOb3RpZmljYXRpb24uXG4gICAqL1xuICBhY3Rpb25CdXR0b25MYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGNvbnRlbnRcbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgLyoqXG4gICAqIFNwZWNpZnkgYW4gb3B0aW9uYWwgY2xhc3NOYW1lIHRvIGJlIGFwcGxpZWQgdG8gdGhlIG5vdGlmaWNhdGlvbiBib3hcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAqIFNwZWNpZnkgd2hhdCBzdGF0ZSB0aGUgbm90aWZpY2F0aW9uIHJlcHJlc2VudHNcbiAgICovXG4gIGtpbmQ6IGRlcHJlY2F0ZVZhbHVlc1dpdGhpbihQcm9wVHlwZXMub25lT2YoWydlcnJvcicsICdpbmZvJywgJ2luZm8tc3F1YXJlJywgJ3N1Y2Nlc3MnLCAnd2FybmluZycsICd3YXJuaW5nLWFsdCddKSwgWyd3YXJuaW5nJywgJ2luZm8nXSwgcHJvcE1hcHBpbmdGdW5jdGlvbiksXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgeW91IGFyZSB1c2luZyB0aGUgbG93IGNvbnRyYXN0IHZhcmlhbnQgb2YgdGhlIENhbGxvdXQuXG4gICAqL1xuICBsb3dDb250cmFzdDogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgYWN0aW9uIGlzIGNsaWNrZWRcbiAgICovXG4gIG9uQWN0aW9uQnV0dG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAvKipcbiAgICogUHJvdmlkZSBhIGRlc2NyaXB0aW9uIGZvciBcInN0YXR1c1wiIGljb24gdGhhdCBjYW4gYmUgcmVhZCBieSBzY3JlZW4gcmVhZGVyc1xuICAgKi9cbiAgc3RhdHVzSWNvbkRlc2NyaXB0aW9uOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgc3VidGl0bGVcbiAgICovXG4gIHN1YnRpdGxlOiBQcm9wVHlwZXMubm9kZSxcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIHRpdGxlXG4gICAqL1xuICB0aXRsZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGlkIGZvciB0aGUgZWxlbWVudCBjb250YWluaW5nIHRoZSB0aXRsZVxuICAgKi9cbiAgdGl0bGVJZDogUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuLy8gSW4gcmVuYW1pbmcgU3RhdGljTm90aWZpY2F0aW9uIHRvIENhbGxvdXQsIHRoZSBsZWdhY3kgU3RhdGljTm90aWZpY2F0aW9uXG4vLyBleHBvcnQgYW5kIGl0J3MgdHlwZXMgc2hvdWxkIHJlbWFpbiB1c2FibGUgdW50aWwgQ2FsbG91dCBpcyBtb3ZlZCB0byBzdGFibGUuXG4vLyBUaGUgU3RhdGljTm90aWZpY2F0aW9uIGNvbXBvbmVudCBiZWxvdyBmb3J3YXJkcyBwcm9wcyB0byBDYWxsb3V0IGFuZCBpbmhlcml0c1xuLy8gQ2FsbG91dFByb3BzIHRvIGVuc3VyZSBjb25zdW1lciB1c2FnZSBpcyBub3QgaW1wYWN0ZWQsIHdoaWxlIHByb3ZpZGluZyB0aGVtXG4vLyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcuXG4vLyBUT0RPOiByZW1vdmUgdGhpcyB3aGVuIENhbGxvdXQgbW92ZXMgdG8gc3RhYmxlIE9SIGluIHYxMiwgd2hpY2hldmVyIGlzIGZpcnN0XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBgQ2FsbG91dFByb3BzYCBpbnN0ZWFkLlxuICovXG5cbmxldCBkaWRXYXJuQWJvdXREZXByZWNhdGlvbiA9IGZhbHNlO1xuY29uc3QgU3RhdGljTm90aWZpY2F0aW9uID0gcHJvcHMgPT4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZGlkV2FybkFib3V0RGVwcmVjYXRpb24sICdgU3RhdGljTm90aWZpY2F0aW9uYCBoYXMgYmVlbiByZW5hbWVkIHRvIGBDYWxsb3V0YC4nICsgJ1J1biB0aGUgZm9sbG93aW5nIGNvZGVtb2QgdG8gYXV0b21hdGljYWxseSB1cGRhdGUgdXNhZ2VzIGluIHlvdXInICsgJ3Byb2plY3Q6IGBucHggQGNhcmJvbi91cGdyYWRlIG1pZ3JhdGUgcmVmYWN0b3ItdG8tY2FsbG91dCAtLXdyaXRlYCcpIDogdm9pZCAwO1xuICAgIGRpZFdhcm5BYm91dERlcHJlY2F0aW9uID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsbG91dCwgcHJvcHMpO1xufTtcblxuZXhwb3J0IHsgQWN0aW9uYWJsZU5vdGlmaWNhdGlvbiwgQ2FsbG91dCwgSW5saW5lTm90aWZpY2F0aW9uLCBOb3RpZmljYXRpb25BY3Rpb25CdXR0b24sIE5vdGlmaWNhdGlvbkJ1dHRvbiwgU3RhdGljTm90aWZpY2F0aW9uLCBUb2FzdE5vdGlmaWNhdGlvbiB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjNcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0ICcuL2ZlYXR1cmUtZmxhZ3MuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBY2NvcmRpb24gfSBmcm9tICcuL2NvbXBvbmVudHMvQWNjb3JkaW9uL0FjY29yZGlvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEFjY29yZGlvbkl0ZW0gfSBmcm9tICcuL2NvbXBvbmVudHMvQWNjb3JkaW9uL0FjY29yZGlvbkl0ZW0uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBY2NvcmRpb25Ta2VsZXRvbiB9IGZyb20gJy4vY29tcG9uZW50cy9BY2NvcmRpb24vQWNjb3JkaW9uLlNrZWxldG9uLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQXNwZWN0UmF0aW8gfSBmcm9tICcuL2NvbXBvbmVudHMvQXNwZWN0UmF0aW8vQXNwZWN0UmF0aW8uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCcmVhZGNydW1iIH0gZnJvbSAnLi9jb21wb25lbnRzL0JyZWFkY3J1bWIvQnJlYWRjcnVtYi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJyZWFkY3J1bWJJdGVtIH0gZnJvbSAnLi9jb21wb25lbnRzL0JyZWFkY3J1bWIvQnJlYWRjcnVtYkl0ZW0uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCcmVhZGNydW1iU2tlbGV0b24gfSBmcm9tICcuL2NvbXBvbmVudHMvQnJlYWRjcnVtYi9CcmVhZGNydW1iLlNrZWxldG9uLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQnV0dG9uLCBCdXR0b25LaW5kcywgQnV0dG9uU2l6ZXMsIEJ1dHRvblRvb2x0aXBBbGlnbm1lbnRzLCBCdXR0b25Ub29sdGlwUG9zaXRpb25zIH0gZnJvbSAnLi9jb21wb25lbnRzL0J1dHRvbi9CdXR0b24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCdXR0b25Ta2VsZXRvbiB9IGZyb20gJy4vY29tcG9uZW50cy9CdXR0b24vQnV0dG9uLlNrZWxldG9uLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQnV0dG9uU2V0IH0gZnJvbSAnLi9jb21wb25lbnRzL0J1dHRvblNldC9CdXR0b25TZXQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDaGVja2JveCB9IGZyb20gJy4vY29tcG9uZW50cy9DaGVja2JveC9DaGVja2JveC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENoZWNrYm94U2tlbGV0b24gfSBmcm9tICcuL2NvbXBvbmVudHMvQ2hlY2tib3gvQ2hlY2tib3guU2tlbGV0b24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDaGVja2JveEdyb3VwIH0gZnJvbSAnLi9jb21wb25lbnRzL0NoZWNrYm94R3JvdXAvQ2hlY2tib3hHcm91cC5qcyc7XG5leHBvcnQgeyBDbGFzc1ByZWZpeCB9IGZyb20gJy4vY29tcG9uZW50cy9DbGFzc1ByZWZpeC9pbmRleC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENvZGVTbmlwcGV0IH0gZnJvbSAnLi9jb21wb25lbnRzL0NvZGVTbmlwcGV0L0NvZGVTbmlwcGV0LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29kZVNuaXBwZXRTa2VsZXRvbiB9IGZyb20gJy4vY29tcG9uZW50cy9Db2RlU25pcHBldC9Db2RlU25pcHBldC5Ta2VsZXRvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENvbWJvQm94IH0gZnJvbSAnLi9jb21wb25lbnRzL0NvbWJvQm94L0NvbWJvQm94LmpzJztcbmV4cG9ydCB7IENvbWJvQnV0dG9uIH0gZnJvbSAnLi9jb21wb25lbnRzL0NvbWJvQnV0dG9uL2luZGV4LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29tcG9zZWRNb2RhbCwgTW9kYWxCb2R5IH0gZnJvbSAnLi9jb21wb25lbnRzL0NvbXBvc2VkTW9kYWwvQ29tcG9zZWRNb2RhbC5qcyc7XG5leHBvcnQgeyBNb2RhbEhlYWRlciB9IGZyb20gJy4vY29tcG9uZW50cy9Db21wb3NlZE1vZGFsL01vZGFsSGVhZGVyLmpzJztcbmV4cG9ydCB7IE1vZGFsRm9vdGVyIH0gZnJvbSAnLi9jb21wb25lbnRzL0NvbXBvc2VkTW9kYWwvTW9kYWxGb290ZXIuanMnO1xuaW1wb3J0ICcuL2NvbXBvbmVudHMvQ29udGFpbmVkTGlzdC9pbmRleC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENvbnRlbnRTd2l0Y2hlciB9IGZyb20gJy4vY29tcG9uZW50cy9Db250ZW50U3dpdGNoZXIvaW5kZXguanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VDb250ZXh0TWVudSB9IGZyb20gJy4vY29tcG9uZW50cy9Db250ZXh0TWVudS91c2VDb250ZXh0TWVudS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENvcHkgfSBmcm9tICcuL2NvbXBvbmVudHMvQ29weS9Db3B5LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29weUJ1dHRvbiB9IGZyb20gJy4vY29tcG9uZW50cy9Db3B5QnV0dG9uL0NvcHlCdXR0b24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEYW5nZXJCdXR0b24gfSBmcm9tICcuL2NvbXBvbmVudHMvRGFuZ2VyQnV0dG9uL0RhbmdlckJ1dHRvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERhdGFUYWJsZSB9IGZyb20gJy4vY29tcG9uZW50cy9EYXRhVGFibGUvRGF0YVRhYmxlLmpzJztcbmV4cG9ydCB7IFRhYmxlIH0gZnJvbSAnLi9jb21wb25lbnRzL0RhdGFUYWJsZS9UYWJsZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRhYmxlQWN0aW9uTGlzdCB9IGZyb20gJy4vY29tcG9uZW50cy9EYXRhVGFibGUvVGFibGVBY3Rpb25MaXN0LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGFibGVCYXRjaEFjdGlvbiB9IGZyb20gJy4vY29tcG9uZW50cy9EYXRhVGFibGUvVGFibGVCYXRjaEFjdGlvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRhYmxlQmF0Y2hBY3Rpb25zIH0gZnJvbSAnLi9jb21wb25lbnRzL0RhdGFUYWJsZS9UYWJsZUJhdGNoQWN0aW9ucy5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRhYmxlQm9keSB9IGZyb20gJy4vY29tcG9uZW50cy9EYXRhVGFibGUvVGFibGVCb2R5LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGFibGVDZWxsIH0gZnJvbSAnLi9jb21wb25lbnRzL0RhdGFUYWJsZS9UYWJsZUNlbGwuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJsZUNvbnRhaW5lciB9IGZyb20gJy4vY29tcG9uZW50cy9EYXRhVGFibGUvVGFibGVDb250YWluZXIuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJsZUV4cGFuZEhlYWRlciB9IGZyb20gJy4vY29tcG9uZW50cy9EYXRhVGFibGUvVGFibGVFeHBhbmRIZWFkZXIuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJsZURlY29yYXRvclJvdyB9IGZyb20gJy4vY29tcG9uZW50cy9EYXRhVGFibGUvVGFibGVEZWNvcmF0b3JSb3cuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJsZUV4cGFuZFJvdyB9IGZyb20gJy4vY29tcG9uZW50cy9EYXRhVGFibGUvVGFibGVFeHBhbmRSb3cuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJsZUV4cGFuZGVkUm93IH0gZnJvbSAnLi9jb21wb25lbnRzL0RhdGFUYWJsZS9UYWJsZUV4cGFuZGVkUm93LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGFibGVIZWFkIH0gZnJvbSAnLi9jb21wb25lbnRzL0RhdGFUYWJsZS9UYWJsZUhlYWQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJsZUhlYWRlciB9IGZyb20gJy4vY29tcG9uZW50cy9EYXRhVGFibGUvVGFibGVIZWFkZXIuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJsZVJvdyB9IGZyb20gJy4vY29tcG9uZW50cy9EYXRhVGFibGUvVGFibGVSb3cuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJsZVNlbGVjdEFsbCB9IGZyb20gJy4vY29tcG9uZW50cy9EYXRhVGFibGUvVGFibGVTZWxlY3RBbGwuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJsZVNlbGVjdFJvdyB9IGZyb20gJy4vY29tcG9uZW50cy9EYXRhVGFibGUvVGFibGVTZWxlY3RSb3cuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJsZVNsdWdSb3cgfSBmcm9tICcuL2NvbXBvbmVudHMvRGF0YVRhYmxlL1RhYmxlU2x1Z1Jvdy5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRhYmxlVG9vbGJhciB9IGZyb20gJy4vY29tcG9uZW50cy9EYXRhVGFibGUvVGFibGVUb29sYmFyLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGFibGVUb29sYmFyQWN0aW9uIH0gZnJvbSAnLi9jb21wb25lbnRzL0RhdGFUYWJsZS9UYWJsZVRvb2xiYXJBY3Rpb24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJsZVRvb2xiYXJDb250ZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL0RhdGFUYWJsZS9UYWJsZVRvb2xiYXJDb250ZW50LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGFibGVUb29sYmFyU2VhcmNoIH0gZnJvbSAnLi9jb21wb25lbnRzL0RhdGFUYWJsZS9UYWJsZVRvb2xiYXJTZWFyY2guanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJsZVRvb2xiYXJNZW51IH0gZnJvbSAnLi9jb21wb25lbnRzL0RhdGFUYWJsZS9UYWJsZVRvb2xiYXJNZW51LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGF0YVRhYmxlU2tlbGV0b24gfSBmcm9tICcuL2NvbXBvbmVudHMvRGF0YVRhYmxlU2tlbGV0b24vRGF0YVRhYmxlU2tlbGV0b24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEYXRlUGlja2VyIH0gZnJvbSAnLi9jb21wb25lbnRzL0RhdGVQaWNrZXIvRGF0ZVBpY2tlci5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERhdGVQaWNrZXJTa2VsZXRvbiB9IGZyb20gJy4vY29tcG9uZW50cy9EYXRlUGlja2VyL0RhdGVQaWNrZXIuU2tlbGV0b24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEYXRlUGlja2VySW5wdXQgfSBmcm9tICcuL2NvbXBvbmVudHMvRGF0ZVBpY2tlcklucHV0L0RhdGVQaWNrZXJJbnB1dC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERyb3Bkb3duIH0gZnJvbSAnLi9jb21wb25lbnRzL0Ryb3Bkb3duL0Ryb3Bkb3duLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRHJvcGRvd25Ta2VsZXRvbiB9IGZyb20gJy4vY29tcG9uZW50cy9Ecm9wZG93bi9Ecm9wZG93bi5Ta2VsZXRvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVycm9yQm91bmRhcnkgfSBmcm9tICcuL2NvbXBvbmVudHMvRXJyb3JCb3VuZGFyeS9FcnJvckJvdW5kYXJ5LmpzJztcbmV4cG9ydCB7IEVycm9yQm91bmRhcnlDb250ZXh0IH0gZnJvbSAnLi9jb21wb25lbnRzL0Vycm9yQm91bmRhcnkvRXJyb3JCb3VuZGFyeUNvbnRleHQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFeHBhbmRhYmxlU2VhcmNoIH0gZnJvbSAnLi9jb21wb25lbnRzL0V4cGFuZGFibGVTZWFyY2gvRXhwYW5kYWJsZVNlYXJjaC5qcyc7XG5leHBvcnQgeyBGZWF0dXJlRmxhZ3MsIEZlYXR1cmVGbGFncyBhcyB1bnN0YWJsZV9GZWF0dXJlRmxhZ3MsIHVzZUZlYXR1cmVGbGFnIGFzIHVuc3RhYmxlX3VzZUZlYXR1cmVGbGFnLCB1c2VGZWF0dXJlRmxhZ3MgYXMgdW5zdGFibGVfdXNlRmVhdHVyZUZsYWdzLCB1c2VGZWF0dXJlRmxhZywgdXNlRmVhdHVyZUZsYWdzIH0gZnJvbSAnLi9jb21wb25lbnRzL0ZlYXR1cmVGbGFncy9pbmRleC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEZpbGVVcGxvYWRlciB9IGZyb20gJy4vY29tcG9uZW50cy9GaWxlVXBsb2FkZXIvRmlsZVVwbG9hZGVyLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRmlsZW5hbWUgfSBmcm9tICcuL2NvbXBvbmVudHMvRmlsZVVwbG9hZGVyL0ZpbGVuYW1lLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRmlsZVVwbG9hZGVyU2tlbGV0b24gfSBmcm9tICcuL2NvbXBvbmVudHMvRmlsZVVwbG9hZGVyL0ZpbGVVcGxvYWRlci5Ta2VsZXRvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEZpbGVVcGxvYWRlckJ1dHRvbiB9IGZyb20gJy4vY29tcG9uZW50cy9GaWxlVXBsb2FkZXIvRmlsZVVwbG9hZGVyQnV0dG9uLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRmlsZVVwbG9hZGVyRHJvcENvbnRhaW5lciB9IGZyb20gJy4vY29tcG9uZW50cy9GaWxlVXBsb2FkZXIvRmlsZVVwbG9hZGVyRHJvcENvbnRhaW5lci5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEZpbGVVcGxvYWRlckl0ZW0gfSBmcm9tICcuL2NvbXBvbmVudHMvRmlsZVVwbG9hZGVyL0ZpbGVVcGxvYWRlckl0ZW0uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGbHVpZEZvcm0gfSBmcm9tICcuL2NvbXBvbmVudHMvRmx1aWRGb3JtL0ZsdWlkRm9ybS5qcyc7XG5leHBvcnQgeyBGb3JtQ29udGV4dCB9IGZyb20gJy4vY29tcG9uZW50cy9GbHVpZEZvcm0vRm9ybUNvbnRleHQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGb3JtIH0gZnJvbSAnLi9jb21wb25lbnRzL0Zvcm0vRm9ybS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEZvcm1Hcm91cCB9IGZyb20gJy4vY29tcG9uZW50cy9Gb3JtR3JvdXAvRm9ybUdyb3VwLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRm9ybUl0ZW0gfSBmcm9tICcuL2NvbXBvbmVudHMvRm9ybUl0ZW0vRm9ybUl0ZW0uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGb3JtTGFiZWwgfSBmcm9tICcuL2NvbXBvbmVudHMvRm9ybUxhYmVsL0Zvcm1MYWJlbC5qcyc7XG5leHBvcnQgeyBGbGV4R3JpZCB9IGZyb20gJy4vY29tcG9uZW50cy9HcmlkL0ZsZXhHcmlkLmpzJztcbmV4cG9ydCB7IEdyaWQgfSBmcm9tICcuL2NvbXBvbmVudHMvR3JpZC9HcmlkLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUm93IH0gZnJvbSAnLi9jb21wb25lbnRzL0dyaWQvUm93LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29sdW1uIH0gZnJvbSAnLi9jb21wb25lbnRzL0dyaWQvQ29sdW1uLmpzJztcbmV4cG9ydCB7IENvbHVtbkhhbmcgfSBmcm9tICcuL2NvbXBvbmVudHMvR3JpZC9Db2x1bW5IYW5nLmpzJztcbmV4cG9ydCB7IEdyaWRTZXR0aW5ncyB9IGZyb20gJy4vY29tcG9uZW50cy9HcmlkL0dyaWRDb250ZXh0LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSWNvblNrZWxldG9uIH0gZnJvbSAnLi9jb21wb25lbnRzL0ljb24vSWNvbi5Ta2VsZXRvbi5qcyc7XG5leHBvcnQgeyBJZFByZWZpeCB9IGZyb20gJy4vY29tcG9uZW50cy9JZFByZWZpeC9pbmRleC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIElubGluZUxvYWRpbmcgfSBmcm9tICcuL2NvbXBvbmVudHMvSW5saW5lTG9hZGluZy9JbmxpbmVMb2FkaW5nLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGluayB9IGZyb20gJy4vY29tcG9uZW50cy9MaW5rL0xpbmsuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaXN0SXRlbSB9IGZyb20gJy4vY29tcG9uZW50cy9MaXN0SXRlbS9MaXN0SXRlbS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIExvYWRpbmcgfSBmcm9tICcuL2NvbXBvbmVudHMvTG9hZGluZy9Mb2FkaW5nLmpzJztcbmV4cG9ydCB7IE1lbnUgfSBmcm9tICcuL2NvbXBvbmVudHMvTWVudS9NZW51LmpzJztcbmV4cG9ydCB7IE1lbnVJdGVtLCBNZW51SXRlbURpdmlkZXIsIE1lbnVJdGVtR3JvdXAsIE1lbnVJdGVtUmFkaW9Hcm91cCwgTWVudUl0ZW1TZWxlY3RhYmxlIH0gZnJvbSAnLi9jb21wb25lbnRzL01lbnUvTWVudUl0ZW0uanMnO1xuZXhwb3J0IHsgTWVudUJ1dHRvbiB9IGZyb20gJy4vY29tcG9uZW50cy9NZW51QnV0dG9uL2luZGV4LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTW9kYWwgfSBmcm9tICcuL2NvbXBvbmVudHMvTW9kYWwvTW9kYWwuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNb2RhbFdyYXBwZXIgfSBmcm9tICcuL2NvbXBvbmVudHMvTW9kYWxXcmFwcGVyL01vZGFsV3JhcHBlci5qcyc7XG5leHBvcnQgeyBGaWx0ZXJhYmxlTXVsdGlTZWxlY3QgfSBmcm9tICcuL2NvbXBvbmVudHMvTXVsdGlTZWxlY3QvRmlsdGVyYWJsZU11bHRpU2VsZWN0LmpzJztcbmV4cG9ydCB7IE11bHRpU2VsZWN0IH0gZnJvbSAnLi9jb21wb25lbnRzL011bHRpU2VsZWN0L011bHRpU2VsZWN0LmpzJztcbmV4cG9ydCB7IEFjdGlvbmFibGVOb3RpZmljYXRpb24sIENhbGxvdXQsIElubGluZU5vdGlmaWNhdGlvbiwgTm90aWZpY2F0aW9uQWN0aW9uQnV0dG9uLCBOb3RpZmljYXRpb25CdXR0b24sIFN0YXRpY05vdGlmaWNhdGlvbiwgVG9hc3ROb3RpZmljYXRpb24gfSBmcm9tICcuL2NvbXBvbmVudHMvTm90aWZpY2F0aW9uL05vdGlmaWNhdGlvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE51bWJlcklucHV0U2tlbGV0b24gfSBmcm9tICcuL2NvbXBvbmVudHMvTnVtYmVySW5wdXQvTnVtYmVySW5wdXQuU2tlbGV0b24uanMnO1xuZXhwb3J0IHsgTnVtYmVySW5wdXQgfSBmcm9tICcuL2NvbXBvbmVudHMvTnVtYmVySW5wdXQvTnVtYmVySW5wdXQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBPcmRlcmVkTGlzdCB9IGZyb20gJy4vY29tcG9uZW50cy9PcmRlcmVkTGlzdC9PcmRlcmVkTGlzdC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE92ZXJmbG93TWVudSB9IGZyb20gJy4vY29tcG9uZW50cy9PdmVyZmxvd01lbnUvaW5kZXguanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBPdmVyZmxvd01lbnVJdGVtIH0gZnJvbSAnLi9jb21wb25lbnRzL092ZXJmbG93TWVudUl0ZW0vT3ZlcmZsb3dNZW51SXRlbS5qcyc7XG5pbXBvcnQgKiBhcyBpbmRleCBmcm9tICcuL2NvbXBvbmVudHMvUGFnZUhlYWRlci9pbmRleC5qcyc7XG5leHBvcnQgeyBpbmRleCBhcyB1bnN0YWJsZV9fUGFnZUhlYWRlciB9O1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQYWdpbmF0aW9uIH0gZnJvbSAnLi9jb21wb25lbnRzL1BhZ2luYXRpb24vUGFnaW5hdGlvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBhZ2luYXRpb25Ta2VsZXRvbiB9IGZyb20gJy4vY29tcG9uZW50cy9QYWdpbmF0aW9uL1BhZ2luYXRpb24uU2tlbGV0b24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQYWdpbmF0aW9uTmF2IH0gZnJvbSAnLi9jb21wb25lbnRzL1BhZ2luYXRpb25OYXYvUGFnaW5hdGlvbk5hdi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENvbnRyb2xsZWRQYXNzd29yZElucHV0IH0gZnJvbSAnLi9jb21wb25lbnRzL1RleHRJbnB1dC9Db250cm9sbGVkUGFzc3dvcmRJbnB1dC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBhc3N3b3JkSW5wdXQgfSBmcm9tICcuL2NvbXBvbmVudHMvVGV4dElucHV0L1Bhc3N3b3JkSW5wdXQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQcmltYXJ5QnV0dG9uIH0gZnJvbSAnLi9jb21wb25lbnRzL1ByaW1hcnlCdXR0b24vUHJpbWFyeUJ1dHRvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFByb2dyZXNzSW5kaWNhdG9yU2tlbGV0b24gfSBmcm9tICcuL2NvbXBvbmVudHMvUHJvZ3Jlc3NJbmRpY2F0b3IvUHJvZ3Jlc3NJbmRpY2F0b3IuU2tlbGV0b24uanMnO1xuZXhwb3J0IHsgUHJvZ3Jlc3NJbmRpY2F0b3IsIFByb2dyZXNzU3RlcCB9IGZyb20gJy4vY29tcG9uZW50cy9Qcm9ncmVzc0luZGljYXRvci9Qcm9ncmVzc0luZGljYXRvci5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFJhZGlvQnV0dG9uIH0gZnJvbSAnLi9jb21wb25lbnRzL1JhZGlvQnV0dG9uL1JhZGlvQnV0dG9uLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUmFkaW9CdXR0b25Ta2VsZXRvbiB9IGZyb20gJy4vY29tcG9uZW50cy9SYWRpb0J1dHRvbi9SYWRpb0J1dHRvbi5Ta2VsZXRvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFJhZGlvQnV0dG9uR3JvdXAgfSBmcm9tICcuL2NvbXBvbmVudHMvUmFkaW9CdXR0b25Hcm91cC9SYWRpb0J1dHRvbkdyb3VwLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUmFkaW9UaWxlIH0gZnJvbSAnLi9jb21wb25lbnRzL1JhZGlvVGlsZS9SYWRpb1RpbGUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZWFyY2ggfSBmcm9tICcuL2NvbXBvbmVudHMvU2VhcmNoL1NlYXJjaC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNlYXJjaFNrZWxldG9uIH0gZnJvbSAnLi9jb21wb25lbnRzL1NlYXJjaC9TZWFyY2guU2tlbGV0b24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZWNvbmRhcnlCdXR0b24gfSBmcm9tICcuL2NvbXBvbmVudHMvU2Vjb25kYXJ5QnV0dG9uL1NlY29uZGFyeUJ1dHRvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNlbGVjdCB9IGZyb20gJy4vY29tcG9uZW50cy9TZWxlY3QvU2VsZWN0LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2VsZWN0U2tlbGV0b24gfSBmcm9tICcuL2NvbXBvbmVudHMvU2VsZWN0L1NlbGVjdC5Ta2VsZXRvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNlbGVjdEl0ZW0gfSBmcm9tICcuL2NvbXBvbmVudHMvU2VsZWN0SXRlbS9TZWxlY3RJdGVtLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2VsZWN0SXRlbUdyb3VwIH0gZnJvbSAnLi9jb21wb25lbnRzL1NlbGVjdEl0ZW1Hcm91cC9TZWxlY3RJdGVtR3JvdXAuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTa2VsZXRvbkljb24gfSBmcm9tICcuL2NvbXBvbmVudHMvU2tlbGV0b25JY29uL1NrZWxldG9uSWNvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNrZWxldG9uUGxhY2Vob2xkZXIgfSBmcm9tICcuL2NvbXBvbmVudHMvU2tlbGV0b25QbGFjZWhvbGRlci9Ta2VsZXRvblBsYWNlaG9sZGVyLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2tlbGV0b25UZXh0IH0gZnJvbSAnLi9jb21wb25lbnRzL1NrZWxldG9uVGV4dC9Ta2VsZXRvblRleHQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTbGlkZXIgfSBmcm9tICcuL2NvbXBvbmVudHMvU2xpZGVyL2luZGV4LmpzJztcbmV4cG9ydCB7IEhTdGFjayB9IGZyb20gJy4vY29tcG9uZW50cy9TdGFjay9IU3RhY2suanMnO1xuZXhwb3J0IHsgU3RhY2sgfSBmcm9tICcuL2NvbXBvbmVudHMvU3RhY2svU3RhY2suanMnO1xuZXhwb3J0IHsgVlN0YWNrIH0gZnJvbSAnLi9jb21wb25lbnRzL1N0YWNrL1ZTdGFjay5qcyc7XG5leHBvcnQgeyBTdHJ1Y3R1cmVkTGlzdEJvZHksIFN0cnVjdHVyZWRMaXN0Q2VsbCwgU3RydWN0dXJlZExpc3RIZWFkLCBTdHJ1Y3R1cmVkTGlzdElucHV0LCBTdHJ1Y3R1cmVkTGlzdFJvdywgU3RydWN0dXJlZExpc3RXcmFwcGVyIH0gZnJvbSAnLi9jb21wb25lbnRzL1N0cnVjdHVyZWRMaXN0L1N0cnVjdHVyZWRMaXN0LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3RydWN0dXJlZExpc3RTa2VsZXRvbiB9IGZyb20gJy4vY29tcG9uZW50cy9TdHJ1Y3R1cmVkTGlzdC9TdHJ1Y3R1cmVkTGlzdC5Ta2VsZXRvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFN3aXRjaCB9IGZyb20gJy4vY29tcG9uZW50cy9Td2l0Y2gvU3dpdGNoLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSWNvblN3aXRjaCB9IGZyb20gJy4vY29tcG9uZW50cy9Td2l0Y2gvSWNvblN3aXRjaC5qcyc7XG5leHBvcnQgeyBJY29uVGFiLCBUYWIsIFRhYkxpc3QsIFRhYkxpc3RWZXJ0aWNhbCwgVGFiUGFuZWwsIFRhYlBhbmVscywgVGFicywgVGFic1ZlcnRpY2FsIH0gZnJvbSAnLi9jb21wb25lbnRzL1RhYnMvVGFicy5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRhYkNvbnRlbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvVGFiQ29udGVudC9UYWJDb250ZW50LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGFic1NrZWxldG9uIH0gZnJvbSAnLi9jb21wb25lbnRzL1RhYnMvVGFicy5Ta2VsZXRvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRhZyB9IGZyb20gJy4vY29tcG9uZW50cy9UYWcvVGFnLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGlzbWlzc2libGVUYWcgfSBmcm9tICcuL2NvbXBvbmVudHMvVGFnL0Rpc21pc3NpYmxlVGFnLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgT3BlcmF0aW9uYWxUYWcgfSBmcm9tICcuL2NvbXBvbmVudHMvVGFnL09wZXJhdGlvbmFsVGFnLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2VsZWN0YWJsZVRhZyB9IGZyb20gJy4vY29tcG9uZW50cy9UYWcvU2VsZWN0YWJsZVRhZy5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRhZ1NrZWxldG9uIH0gZnJvbSAnLi9jb21wb25lbnRzL1RhZy9UYWcuU2tlbGV0b24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUZXh0QXJlYSB9IGZyb20gJy4vY29tcG9uZW50cy9UZXh0QXJlYS9UZXh0QXJlYS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRleHRBcmVhU2tlbGV0b24gfSBmcm9tICcuL2NvbXBvbmVudHMvVGV4dEFyZWEvVGV4dEFyZWEuU2tlbGV0b24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUZXh0SW5wdXQgfSBmcm9tICcuL2NvbXBvbmVudHMvVGV4dElucHV0L1RleHRJbnB1dC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRleHRJbnB1dFNrZWxldG9uIH0gZnJvbSAnLi9jb21wb25lbnRzL1RleHRJbnB1dC9UZXh0SW5wdXQuU2tlbGV0b24uanMnO1xuZXhwb3J0IHsgQ2xpY2thYmxlVGlsZSwgRXhwYW5kYWJsZVRpbGUsIFNlbGVjdGFibGVUaWxlLCBUaWxlLCBUaWxlQWJvdmVUaGVGb2xkQ29udGVudCwgVGlsZUJlbG93VGhlRm9sZENvbnRlbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvVGlsZS9UaWxlLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGlsZUdyb3VwIH0gZnJvbSAnLi9jb21wb25lbnRzL1RpbGVHcm91cC9UaWxlR3JvdXAuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUaW1lUGlja2VyIH0gZnJvbSAnLi9jb21wb25lbnRzL1RpbWVQaWNrZXIvVGltZVBpY2tlci5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRpbWVQaWNrZXJTZWxlY3QgfSBmcm9tICcuL2NvbXBvbmVudHMvVGltZVBpY2tlclNlbGVjdC9UaW1lUGlja2VyU2VsZWN0LmpzJztcbmV4cG9ydCB7IFRvZ2dsZSB9IGZyb20gJy4vY29tcG9uZW50cy9Ub2dnbGUvVG9nZ2xlLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVG9nZ2xlU2tlbGV0b24gfSBmcm9tICcuL2NvbXBvbmVudHMvVG9nZ2xlL1RvZ2dsZS5Ta2VsZXRvbi5qcyc7XG5leHBvcnQgeyBUb2dnbGVTbWFsbFNrZWxldG9uIH0gZnJvbSAnLi9jb21wb25lbnRzL1RvZ2dsZVNtYWxsL1RvZ2dsZVNtYWxsLlNrZWxldG9uLmpzJztcbmV4cG9ydCB7IFRvZ2dsZXRpcCwgVG9nZ2xldGlwQWN0aW9ucywgVG9nZ2xldGlwQnV0dG9uLCBUb2dnbGV0aXBDb250ZW50LCBUb2dnbGV0aXBMYWJlbCB9IGZyb20gJy4vY29tcG9uZW50cy9Ub2dnbGV0aXAvaW5kZXguanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUcmVlTm9kZSB9IGZyb20gJy4vY29tcG9uZW50cy9UcmVlVmlldy9UcmVlTm9kZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRyZWVWaWV3IH0gZnJvbSAnLi9jb21wb25lbnRzL1RyZWVWaWV3L1RyZWVWaWV3LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29udGVudCB9IGZyb20gJy4vY29tcG9uZW50cy9VSVNoZWxsL0NvbnRlbnQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBIZWFkZXIgfSBmcm9tICcuL2NvbXBvbmVudHMvVUlTaGVsbC9IZWFkZXIuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBIZWFkZXJDb250YWluZXIgfSBmcm9tICcuL2NvbXBvbmVudHMvVUlTaGVsbC9IZWFkZXJDb250YWluZXIuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBIZWFkZXJHbG9iYWxBY3Rpb24gfSBmcm9tICcuL2NvbXBvbmVudHMvVUlTaGVsbC9IZWFkZXJHbG9iYWxBY3Rpb24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBIZWFkZXJHbG9iYWxCYXIgfSBmcm9tICcuL2NvbXBvbmVudHMvVUlTaGVsbC9IZWFkZXJHbG9iYWxCYXIuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBIZWFkZXJNZW51IH0gZnJvbSAnLi9jb21wb25lbnRzL1VJU2hlbGwvSGVhZGVyTWVudS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEhlYWRlck1lbnVCdXR0b24gfSBmcm9tICcuL2NvbXBvbmVudHMvVUlTaGVsbC9IZWFkZXJNZW51QnV0dG9uLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSGVhZGVyTWVudUl0ZW0gfSBmcm9tICcuL2NvbXBvbmVudHMvVUlTaGVsbC9IZWFkZXJNZW51SXRlbS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEhlYWRlck5hbWUgfSBmcm9tICcuL2NvbXBvbmVudHMvVUlTaGVsbC9IZWFkZXJOYW1lLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSGVhZGVyTmF2aWdhdGlvbiB9IGZyb20gJy4vY29tcG9uZW50cy9VSVNoZWxsL0hlYWRlck5hdmlnYXRpb24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBIZWFkZXJQYW5lbCB9IGZyb20gJy4vY29tcG9uZW50cy9VSVNoZWxsL0hlYWRlclBhbmVsLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSGVhZGVyU2lkZU5hdkl0ZW1zIH0gZnJvbSAnLi9jb21wb25lbnRzL1VJU2hlbGwvSGVhZGVyU2lkZU5hdkl0ZW1zLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3dpdGNoZXIgfSBmcm9tICcuL2NvbXBvbmVudHMvVUlTaGVsbC9Td2l0Y2hlci5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFN3aXRjaGVySXRlbSB9IGZyb20gJy4vY29tcG9uZW50cy9VSVNoZWxsL1N3aXRjaGVySXRlbS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFN3aXRjaGVyRGl2aWRlciB9IGZyb20gJy4vY29tcG9uZW50cy9VSVNoZWxsL1N3aXRjaGVyRGl2aWRlci5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNraXBUb0NvbnRlbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvVUlTaGVsbC9Ta2lwVG9Db250ZW50LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2lkZU5hdiB9IGZyb20gJy4vY29tcG9uZW50cy9VSVNoZWxsL1NpZGVOYXYuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTaWRlTmF2RGV0YWlscyB9IGZyb20gJy4vY29tcG9uZW50cy9VSVNoZWxsL1NpZGVOYXZEZXRhaWxzLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2lkZU5hdkRpdmlkZXIgfSBmcm9tICcuL2NvbXBvbmVudHMvVUlTaGVsbC9TaWRlTmF2RGl2aWRlci5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNpZGVOYXZGb290ZXIgfSBmcm9tICcuL2NvbXBvbmVudHMvVUlTaGVsbC9TaWRlTmF2Rm9vdGVyLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2lkZU5hdkhlYWRlciB9IGZyb20gJy4vY29tcG9uZW50cy9VSVNoZWxsL1NpZGVOYXZIZWFkZXIuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTaWRlTmF2SWNvbiB9IGZyb20gJy4vY29tcG9uZW50cy9VSVNoZWxsL1NpZGVOYXZJY29uLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2lkZU5hdkl0ZW0gfSBmcm9tICcuL2NvbXBvbmVudHMvVUlTaGVsbC9TaWRlTmF2SXRlbS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNpZGVOYXZJdGVtcyB9IGZyb20gJy4vY29tcG9uZW50cy9VSVNoZWxsL1NpZGVOYXZJdGVtcy5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNpZGVOYXZMaW5rIH0gZnJvbSAnLi9jb21wb25lbnRzL1VJU2hlbGwvU2lkZU5hdkxpbmsuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTaWRlTmF2TGlua1RleHQgfSBmcm9tICcuL2NvbXBvbmVudHMvVUlTaGVsbC9TaWRlTmF2TGlua1RleHQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTaWRlTmF2TWVudSB9IGZyb20gJy4vY29tcG9uZW50cy9VSVNoZWxsL1NpZGVOYXZNZW51LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2lkZU5hdk1lbnVJdGVtIH0gZnJvbSAnLi9jb21wb25lbnRzL1VJU2hlbGwvU2lkZU5hdk1lbnVJdGVtLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2lkZU5hdlN3aXRjaGVyIH0gZnJvbSAnLi9jb21wb25lbnRzL1VJU2hlbGwvU2lkZU5hdlN3aXRjaGVyLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVW5vcmRlcmVkTGlzdCB9IGZyb20gJy4vY29tcG9uZW50cy9Vbm9yZGVyZWRMaXN0L1Vub3JkZXJlZExpc3QuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bnN0YWJsZV9fRmx1aWRDb21ib0JveCB9IGZyb20gJy4vY29tcG9uZW50cy9GbHVpZENvbWJvQm94L0ZsdWlkQ29tYm9Cb3guanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bnN0YWJsZV9fRmx1aWRDb21ib0JveFNrZWxldG9uIH0gZnJvbSAnLi9jb21wb25lbnRzL0ZsdWlkQ29tYm9Cb3gvRmx1aWRDb21ib0JveC5Ta2VsZXRvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVuc3RhYmxlX19GbHVpZERhdGVQaWNrZXIgfSBmcm9tICcuL2NvbXBvbmVudHMvRmx1aWREYXRlUGlja2VyL0ZsdWlkRGF0ZVBpY2tlci5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVuc3RhYmxlX19GbHVpZERhdGVQaWNrZXJTa2VsZXRvbiB9IGZyb20gJy4vY29tcG9uZW50cy9GbHVpZERhdGVQaWNrZXIvRmx1aWREYXRlUGlja2VyLlNrZWxldG9uLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdW5zdGFibGVfX0ZsdWlkRGF0ZVBpY2tlcklucHV0IH0gZnJvbSAnLi9jb21wb25lbnRzL0ZsdWlkRGF0ZVBpY2tlcklucHV0L0ZsdWlkRGF0ZVBpY2tlcklucHV0LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdW5zdGFibGVfX0ZsdWlkRHJvcGRvd24gfSBmcm9tICcuL2NvbXBvbmVudHMvRmx1aWREcm9wZG93bi9GbHVpZERyb3Bkb3duLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdW5zdGFibGVfX0ZsdWlkRHJvcGRvd25Ta2VsZXRvbiB9IGZyb20gJy4vY29tcG9uZW50cy9GbHVpZERyb3Bkb3duL0ZsdWlkRHJvcGRvd24uU2tlbGV0b24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bnN0YWJsZV9fRmx1aWRNdWx0aVNlbGVjdCB9IGZyb20gJy4vY29tcG9uZW50cy9GbHVpZE11bHRpU2VsZWN0L0ZsdWlkTXVsdGlTZWxlY3QuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bnN0YWJsZV9fRmx1aWRNdWx0aVNlbGVjdFNrZWxldG9uIH0gZnJvbSAnLi9jb21wb25lbnRzL0ZsdWlkTXVsdGlTZWxlY3QvRmx1aWRNdWx0aVNlbGVjdC5Ta2VsZXRvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVuc3RhYmxlX19GbHVpZFNlbGVjdCB9IGZyb20gJy4vY29tcG9uZW50cy9GbHVpZFNlbGVjdC9GbHVpZFNlbGVjdC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVuc3RhYmxlX19GbHVpZFNlbGVjdFNrZWxldG9uIH0gZnJvbSAnLi9jb21wb25lbnRzL0ZsdWlkU2VsZWN0L0ZsdWlkU2VsZWN0LlNrZWxldG9uLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdW5zdGFibGVfX0ZsdWlkU2VhcmNoIH0gZnJvbSAnLi9jb21wb25lbnRzL0ZsdWlkU2VhcmNoL0ZsdWlkU2VhcmNoLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdW5zdGFibGVfX0ZsdWlkU2VhcmNoU2tlbGV0b24gfSBmcm9tICcuL2NvbXBvbmVudHMvRmx1aWRTZWFyY2gvRmx1aWRTZWFyY2guU2tlbGV0b24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bnN0YWJsZV9fRmx1aWRUZXh0QXJlYSB9IGZyb20gJy4vY29tcG9uZW50cy9GbHVpZFRleHRBcmVhL0ZsdWlkVGV4dEFyZWEuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bnN0YWJsZV9fRmx1aWRUZXh0QXJlYVNrZWxldG9uIH0gZnJvbSAnLi9jb21wb25lbnRzL0ZsdWlkVGV4dEFyZWEvRmx1aWRUZXh0QXJlYS5Ta2VsZXRvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVuc3RhYmxlX19GbHVpZFRleHRJbnB1dCB9IGZyb20gJy4vY29tcG9uZW50cy9GbHVpZFRleHRJbnB1dC9GbHVpZFRleHRJbnB1dC5qcyc7XG5pbXBvcnQgJy4vY29tcG9uZW50cy9GbHVpZFRleHRJbnB1dC9GbHVpZFBhc3N3b3JkSW5wdXQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bnN0YWJsZV9fRmx1aWRUZXh0SW5wdXRTa2VsZXRvbiB9IGZyb20gJy4vY29tcG9uZW50cy9GbHVpZFRleHRJbnB1dC9GbHVpZFRleHRJbnB1dC5Ta2VsZXRvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVuc3RhYmxlX19GbHVpZE51bWJlcklucHV0IH0gZnJvbSAnLi9jb21wb25lbnRzL0ZsdWlkTnVtYmVySW5wdXQvRmx1aWROdW1iZXJJbnB1dC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVuc3RhYmxlX19GbHVpZE51bWJlcklucHV0U2tlbGV0b24gfSBmcm9tICcuL2NvbXBvbmVudHMvRmx1aWROdW1iZXJJbnB1dC9GbHVpZE51bWJlcklucHV0LlNrZWxldG9uLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdW5zdGFibGVfX0ZsdWlkVGltZVBpY2tlciB9IGZyb20gJy4vY29tcG9uZW50cy9GbHVpZFRpbWVQaWNrZXIvRmx1aWRUaW1lUGlja2VyLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdW5zdGFibGVfX0ZsdWlkVGltZVBpY2tlclNrZWxldG9uIH0gZnJvbSAnLi9jb21wb25lbnRzL0ZsdWlkVGltZVBpY2tlci9GbHVpZFRpbWVQaWNrZXIuU2tlbGV0b24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bnN0YWJsZV9fRmx1aWRUaW1lUGlja2VyU2VsZWN0IH0gZnJvbSAnLi9jb21wb25lbnRzL0ZsdWlkVGltZVBpY2tlclNlbGVjdC9GbHVpZFRpbWVQaWNrZXJTZWxlY3QuanMnO1xuZXhwb3J0IHsgSGVhZGluZywgU2VjdGlvbiB9IGZyb20gJy4vY29tcG9uZW50cy9IZWFkaW5nL2luZGV4LmpzJztcbmV4cG9ydCB7IEljb25CdXR0b24sIEljb25CdXR0b25LaW5kcyB9IGZyb20gJy4vY29tcG9uZW50cy9JY29uQnV0dG9uL2luZGV4LmpzJztcbmV4cG9ydCB7IExheWVyLCB1c2VMYXllciB9IGZyb20gJy4vY29tcG9uZW50cy9MYXllci9pbmRleC5qcyc7XG5leHBvcnQgeyBMYXlvdXQgYXMgdW5zdGFibGVfTGF5b3V0IH0gZnJvbSAnLi9jb21wb25lbnRzL0xheW91dC9pbmRleC5qcyc7XG5leHBvcnQgeyBMYXlvdXREaXJlY3Rpb24gYXMgdW5zdGFibGVfTGF5b3V0RGlyZWN0aW9uIH0gZnJvbSAnLi9jb21wb25lbnRzL0xheW91dERpcmVjdGlvbi9MYXlvdXREaXJlY3Rpb24uanMnO1xuZXhwb3J0IHsgdXNlTGF5b3V0RGlyZWN0aW9uIGFzIHVuc3RhYmxlX3VzZUxheW91dERpcmVjdGlvbiB9IGZyb20gJy4vY29tcG9uZW50cy9MYXlvdXREaXJlY3Rpb24vdXNlTGF5b3V0RGlyZWN0aW9uLmpzJztcbmV4cG9ydCB7IE92ZXJmbG93TWVudVYyIGFzIHVuc3RhYmxlX092ZXJmbG93TWVudVYyIH0gZnJvbSAnLi9jb21wb25lbnRzL092ZXJmbG93TWVudVYyL2luZGV4LmpzJztcbmV4cG9ydCB7IFBvcG92ZXIsIFBvcG92ZXJDb250ZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL1BvcG92ZXIvaW5kZXguanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQcm9ncmVzc0JhciB9IGZyb20gJy4vY29tcG9uZW50cy9Qcm9ncmVzc0Jhci9Qcm9ncmVzc0Jhci5qcyc7XG5leHBvcnQgeyBBSUxhYmVsLCBBSUxhYmVsQWN0aW9ucywgQUlMYWJlbENvbnRlbnQsIEFJTGFiZWwgYXMgdW5zdGFibGVfX1NsdWcsIEFJTGFiZWxBY3Rpb25zIGFzIHVuc3RhYmxlX19TbHVnQWN0aW9ucywgQUlMYWJlbENvbnRlbnQgYXMgdW5zdGFibGVfX1NsdWdDb250ZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL0FJTGFiZWwvaW5kZXguanMnO1xuZXhwb3J0IHsgSWNvbkluZGljYXRvciBhcyB1bnN0YWJsZV9fSWNvbkluZGljYXRvciB9IGZyb20gJy4vY29tcG9uZW50cy9JY29uSW5kaWNhdG9yL2luZGV4LmpzJztcbmV4cG9ydCB7IFNoYXBlSW5kaWNhdG9yIGFzIHVuc3RhYmxlX19TaGFwZUluZGljYXRvciB9IGZyb20gJy4vY29tcG9uZW50cy9TaGFwZUluZGljYXRvci9pbmRleC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVuc3RhYmxlX19DaGF0QnV0dG9uIH0gZnJvbSAnLi9jb21wb25lbnRzL0NoYXRCdXR0b24vQ2hhdEJ1dHRvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVuc3RhYmxlX19DaGF0QnV0dG9uU2tlbGV0b24gfSBmcm9tICcuL2NvbXBvbmVudHMvQ2hhdEJ1dHRvbi9DaGF0QnV0dG9uLlNrZWxldG9uLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQUlTa2VsZXRvblBsYWNlaG9sZGVyLCBkZWZhdWx0IGFzIHVuc3RhYmxlX19BaVNrZWxldG9uUGxhY2Vob2xkZXIgfSBmcm9tICcuL2NvbXBvbmVudHMvQUlTa2VsZXRvbi9BSVNrZWxldG9uUGxhY2Vob2xkZXIuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBSVNrZWxldG9uSWNvbiwgZGVmYXVsdCBhcyB1bnN0YWJsZV9fQWlTa2VsZXRvbkljb24gfSBmcm9tICcuL2NvbXBvbmVudHMvQUlTa2VsZXRvbi9BSVNrZWxldG9uSWNvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEFJU2tlbGV0b25UZXh0LCBkZWZhdWx0IGFzIHVuc3RhYmxlX19BaVNrZWxldG9uVGV4dCB9IGZyb20gJy4vY29tcG9uZW50cy9BSVNrZWxldG9uL0FJU2tlbGV0b25UZXh0LmpzJztcbmV4cG9ydCB7IERlZmluaXRpb25Ub29sdGlwIH0gZnJvbSAnLi9jb21wb25lbnRzL1Rvb2x0aXAvRGVmaW5pdGlvblRvb2x0aXAuanMnO1xuZXhwb3J0IHsgVG9vbHRpcCB9IGZyb20gJy4vY29tcG9uZW50cy9Ub29sdGlwL1Rvb2x0aXAuanMnO1xuaW1wb3J0ICcuL2NvbXBvbmVudHMvVGV4dC9pbmRleC5qcyc7XG5leHBvcnQgeyBHbG9iYWxUaGVtZSwgVGhlbWUsIFRoZW1lQ29udGV4dCwgdXNlUHJlZmVyc0RhcmtTY2hlbWUsIHVzZVRoZW1lIH0gZnJvbSAnLi9jb21wb25lbnRzL1RoZW1lL2luZGV4LmpzJztcbmV4cG9ydCB7IFByZWZpeENvbnRleHQsIHVzZVByZWZpeCB9IGZyb20gJy4vaW50ZXJuYWwvdXNlUHJlZml4LmpzJztcbmV4cG9ydCB7IHVzZUlkUHJlZml4IH0gZnJvbSAnLi9pbnRlcm5hbC91c2VJZFByZWZpeC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVuc3RhYmxlX1BhZ2VTZWxlY3RvciB9IGZyb20gJy4vY29tcG9uZW50cy9QYWdpbmF0aW9uL2V4cGVyaW1lbnRhbC9QYWdlU2VsZWN0b3IuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bnN0YWJsZV9QYWdpbmF0aW9uIH0gZnJvbSAnLi9jb21wb25lbnRzL1BhZ2luYXRpb24vZXhwZXJpbWVudGFsL1BhZ2luYXRpb24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb250YWluZWRMaXN0SXRlbSB9IGZyb20gJy4vY29tcG9uZW50cy9Db250YWluZWRMaXN0L0NvbnRhaW5lZExpc3RJdGVtL0NvbnRhaW5lZExpc3RJdGVtLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29udGFpbmVkTGlzdCB9IGZyb20gJy4vY29tcG9uZW50cy9Db250YWluZWRMaXN0L0NvbnRhaW5lZExpc3QuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTbGlkZXJTa2VsZXRvbiB9IGZyb20gJy4vY29tcG9uZW50cy9TbGlkZXIvU2xpZGVyLlNrZWxldG9uLmpzJztcbmV4cG9ydCB7IFRleHQgYXMgdW5zdGFibGVfVGV4dCB9IGZyb20gJy4vY29tcG9uZW50cy9UZXh0L1RleHQuanMnO1xuZXhwb3J0IHsgVGV4dERpcmVjdGlvbiBhcyB1bnN0YWJsZV9UZXh0RGlyZWN0aW9uIH0gZnJvbSAnLi9jb21wb25lbnRzL1RleHQvVGV4dERpcmVjdGlvbi5qcyc7XG4iXSwibmFtZXMiOlsiRmVhdHVyZUZsYWdzIiwibWVyZ2UiLCJfZGVmaW5lUHJvcGVydHkiLCJlIiwiciIsInQiLCJfdG9Qcm9wZXJ0eUtleSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfdG9QcmltaXRpdmUiLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsImkiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJleHRlbmRzIiwidG9Qcm9wZXJ0eUtleSIsIlJlYWN0IiwiUHJlZml4Q29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VQcmVmaXgiLCJ1c2VDb250ZXh0IiwiQWNjb3JkaW9uQ29udGV4dCIsImRpc2FibGVkIiwiQWNjb3JkaW9uUHJvdmlkZXIiLCJfcmVmIiwiY2hpbGRyZW4iLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJjeCIsIlByb3BUeXBlcyIsIkFjY29yZGlvbiIsImFsaWduIiwiY2xhc3NOYW1lIiwiY3VzdG9tQ2xhc3NOYW1lIiwiaXNGbHVzaCIsIm9yZGVyZWQiLCJzaXplIiwicmVzdCIsInByZWZpeCIsIkxpc3RUYWciLCJwcm9wVHlwZXMiLCJvbmVPZiIsIm5vZGUiLCJzdHJpbmciLCJib29sIiwiZGVmYXVsdCIsIlRhYiIsImtleSIsIndoaWNoIiwia2V5Q29kZSIsImNvZGUiLCJFbnRlciIsIkVzY2FwZSIsIlNwYWNlIiwiRW5kIiwiSG9tZSIsIkFycm93TGVmdCIsIkFycm93VXAiLCJBcnJvd1JpZ2h0IiwiQXJyb3dEb3duIiwiRGVsZXRlIiwibWF0Y2hlcyIsImV2ZW50Iiwia2V5c1RvTWF0Y2giLCJtYXRjaCIsImV2ZW50T3JDb2RlIiwiQXJyYXkiLCJpc0FycmF5IiwiaW5jbHVkZXMiLCJzZXR1cEdldEluc3RhbmNlSWQiLCJpbnN0YW5jZUlkIiwiY2FuVXNlRE9NIiwid2luZG93IiwiZG9jdW1lbnQiLCJJZFByZWZpeENvbnRleHQiLCJ1c2VJZFByZWZpeCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwiX1JlYWN0IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsInNlcnZlckhhbmRvZmZDb21wbGV0ZWQiLCJkZWZhdWx0SWQiLCJ1c2VDb21wYXRpYmxlSWQiLCJ1bmRlZmluZWQiLCJjb250ZXh0UHJlZml4IiwiaWQiLCJzZXRJZCIsInVzZVJlYWN0SWQiLCJ1c2VJZCIsInVzZUZhbGxiYWNrSWQiLCJmYWxsYmFjayIsIndhcm5pbmciLCJkaWRXYXJuQWJvdXREZXByZWNhdGlvbiIsImRlcHJlY2F0ZSIsInByb3BUeXBlIiwibWVzc2FnZSIsImNoZWNrZXIiLCJwcm9wcyIsInByb3BOYW1lIiwiY29tcG9uZW50TmFtZSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIl9sZW4iLCJfa2V5IiwiVGV4dERpcmVjdGlvbkNvbnRleHQiLCJkaXJlY3Rpb24iLCJnZXRUZXh0RGlyZWN0aW9uIiwiY3VycmVudCIsIkNoaWxkcmVuIiwiVGV4dEJhc2UiLCJmb3J3YXJkUmVmIiwicmVmIiwiYXMiLCJkaXIiLCJjb250ZXh0IiwidGV4dFByb3BzIiwiQmFzZUNvbXBvbmVudCIsInBhcmVudERpcmVjdGlvbiIsInRleHQiLCJnZXRUZXh0RnJvbUNoaWxkcmVuIiwib3ZlcnJpZGUiLCJUZXh0Iiwib25lT2ZUeXBlIiwiZnVuYyIsImVsZW1lbnRUeXBlIiwiaXNSZXF1aXJlZCIsIm1hcCIsImNoaWxkIiwiZmlsdGVyIiwiQ2hldnJvblJpZ2h0IiwiZGVmYXVsdFJlbmRlclRvZ2dsZSIsInR5cGUiLCJBY2NvcmRpb25JdGVtIiwib3BlbiIsIm9uSGVhZGluZ0NsaWNrIiwicmVuZGVyRXhwYW5kbyIsInJlbmRlclRvZ2dsZSIsInRpdGxlIiwiY29udHJvbGxlZERpc2FibGVkIiwiaGFuZGxlQW5pbWF0aW9uRW5kIiwiaXNPcGVuIiwic2V0SXNPcGVuIiwicHJldklzT3BlbiIsInNldFByZXZJc09wZW4iLCJhY2NvcmRpb25TdGF0ZSIsImRpc2FibGVkSXNDb250cm9sbGVkIiwiVG9nZ2xlIiwiY29udGVudCIsInVzZUNhbGxiYWNrIiwic3R5bGUiLCJtYXhCbG9ja1NpemUiLCJvbkNsaWNrIiwibmV4dFZhbHVlIiwib25LZXlEb3duIiwib25BbmltYXRpb25FbmQiLCJvblRyYW5zaXRpb25FbmQiLCJ1c2VJc29tb3JwaGljRWZmZWN0IiwidXNlUmVmIiwicmFuZG9tcyIsImdldFJhbmRvbUludCIsIm1pbiIsIm1heCIsIk1hdGgiLCJmbG9vciIsIlNrZWxldG9uVGV4dCIsInBhcmFncmFwaCIsImxpbmVDb3VudCIsIndpZHRoIiwiaGVhZGluZyIsInNrZWxldG9uVGV4dENsYXNzZXMiLCJ3aWR0aE51bSIsInBhcnNlSW50Iiwid2lkdGhQeCIsIndpZHRoUGVyY2VudCIsImxpbmVDb3VudE51bWJlciIsInJlZnMiLCJpdGVtIiwiaiIsInJhbmRvbVBlcmNlbnRXaWR0aCIsInJhbmRvbVB4V2lkdGgiLCJsaW5lcyIsInB1c2giLCJlbCIsIkZyYWdtZW50IiwibnVtYmVyIiwiX1NrZWxldG9uVGV4dCIsIl9Ta2VsZXRvblRleHQyIiwiX1NrZWxldG9uVGV4dDMiLCJBY2NvcmRpb25Ta2VsZXRvbiIsImNvdW50IiwiY2xhc3NlcyIsIm51bVNrZWxldG9uSXRlbXMiLCJmcm9tIiwiXyIsIkFjY29yZGlvblNrZWxldG9uSXRlbSIsImRlcHJlY2F0ZVZhbHVlc1dpdGhpbiIsImFsbG93ZWRWYWx1ZXMiLCJwcm9wTWFwcGluZ0Z1bmN0aW9uIiwiZGVwcmVjYXRlZFZhbHVlIiwibmV3VmFsdWUiLCJqb2luIiwidXNlTWVyZ2VkUmVmcyIsImZvckVhY2giLCJ1c2VFdmVudCIsImVsZW1lbnRPclJlZiIsImV2ZW50TmFtZSIsImNhbGxiYWNrIiwic2F2ZWRDYWxsYmFjayIsImhhbmRsZXIiLCJlbGVtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1c2VXaW5kb3dFdmVudCIsInBvcG92ZXJBbGlnbk1hcHBpbmciLCJtYXBQb3BvdmVyQWxpZ24iLCJjcmVhdGVTY29wZSIsIkZlYXR1cmVGbGFncyQxIiwiRmVhdHVyZUZsYWdDb250ZXh0IiwiZmxhZ3MiLCJlbmFibGVWMTJUaWxlRGVmYXVsdEljb25zIiwiZW5hYmxlVjEyVGlsZVJhZGlvSWNvbnMiLCJlbmFibGVWMTJPdmVyZmxvd21lbnUiLCJlbmFibGVUcmVldmlld0NvbnRyb2xsYWJsZSIsImVuYWJsZUV4cGVyaW1lbnRhbEZvY3VzV3JhcFdpdGhvdXRTZW50aW5lbHMiLCJlbmFibGVEaWFsb2dFbGVtZW50IiwiZW5hYmxlVjEyRHluYW1pY0Zsb2F0aW5nU3R5bGVzIiwicGFyZW50U2NvcGUiLCJwcmV2UGFyZW50U2NvcGUiLCJzZXRQcmV2UGFyZW50U2NvcGUiLCJjb21iaW5lZEZsYWdzIiwic2NvcGUiLCJ1cGRhdGVTY29wZSIsIm1lcmdlV2l0aFNjb3BlIiwidXNlQ2hhbmdlZFZhbHVlIiwiaXNFcXVhbCIsImNoYW5nZWRGbGFncyIsIm9iamVjdE9mIiwiY29tcGFyZSIsImluaXRpYWxSZW5kZXIiLCJwcmV2VmFsdWUiLCJzZXRQcmV2VmFsdWUiLCJ1c2VGZWF0dXJlRmxhZyIsImZsYWciLCJlbmFibGVkIiwidXNlRmVhdHVyZUZsYWdzIiwiYSIsImIiLCJrZXlzIiwidXNlTWVtbyIsInVzZUZsb2F0aW5nIiwib2Zmc2V0IiwiZmxpcCIsImFycm93IiwiaGlkZSIsImF1dG9VcGRhdGUiLCJQb3BvdmVyQ29udGV4dCIsInNldEZsb2F0aW5nIiwiY2FyZXRSZWYiLCJhdXRvQWxpZ24iLCJQb3BvdmVyIiwiUG9wb3ZlclJlbmRlckZ1bmN0aW9uIiwiaXNUYWJUaXAiLCJpbml0aWFsQWxpZ24iLCJhdXRvQWxpZ25Cb3VuZGFyeSIsImNhcmV0IiwiZHJvcFNoYWRvdyIsImhpZ2hDb250cmFzdCIsIm9uUmVxdWVzdENsb3NlIiwiYWxpZ25tZW50QXhpc09mZnNldCIsImZsb2F0aW5nIiwicG9wb3ZlciIsImVuYWJsZUZsb2F0aW5nU3R5bGVzIiwiX3JlZjIiLCJ0YXJnZXQiLCJOb2RlIiwiY29udGFpbnMiLCJpbml0aWFsQ2FyZXRIZWlnaHQiLCJ0b0FycmF5Iiwic29tZSIsIngiLCJwb3BvdmVyRGltZW5zaW9ucyIsImNhcmV0SGVpZ2h0IiwiZ2V0U3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwib2Zmc2V0UHJvcGVydHkiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiY2FyZXRQcm9wZXJ0eSIsInNwbGl0IiwiZmxvYXRpbmdTdHlsZXMiLCJwbGFjZW1lbnQiLCJtaWRkbGV3YXJlRGF0YSIsInN0cmF0ZWd5IiwibWlkZGxld2FyZSIsImFsaWdubWVudEF4aXMiLCJtYWluQXhpcyIsImZhbGxiYWNrUGxhY2VtZW50cyIsImZhbGxiYWNrU3RyYXRlZ3kiLCJmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uIiwiYm91bmRhcnkiLCJ3aGlsZUVsZW1lbnRzTW91bnRlZCIsInRhYlRpcEFsaWdubWVudHMiLCJ1cGRhdGVkRmxvYXRpbmdTdHlsZXMiLCJ2aXNpYmlsaXR5IiwicmVmZXJlbmNlSGlkZGVuIiwieSIsInN0YXRpY1NpZGUiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJjdXJyZW50QWxpZ25tZW50IiwibWFwcGVkQ2hpbGRyZW4iLCJkaXNwbGF5TmFtZSIsImlzVHJpZ2dlckVsZW1lbnQiLCJpc1RyaWdnZXJDb21wb25lbnQiLCJpc0FsbG93ZWRUcmlnZ2VyQ29tcG9uZW50IiwiaXNWYWxpZEVsZW1lbnQiLCJ0YWJUaXBDbGFzc2VzIiwiY2xvbmVFbGVtZW50Iiwic2V0UmVmZXJlbmNlIiwiQmFzZUNvbXBvbmVudEFzQW55IiwiYXJyYXlPZiIsImV4YWN0IiwiaGVpZ2h0IiwiUG9wb3ZlckNvbnRlbnRSZW5kZXJGdW5jdGlvbiIsIl9yZWYzIiwiUG9wb3ZlckNvbnRlbnQiLCJ1c2VEZWxheWVkU3RhdGUiLCJpbml0aWFsU3RhdGUiLCJzdGF0ZSIsInNldFN0YXRlIiwidGltZW91dElkIiwic2V0U3RhdGVXaXRoRGVsYXkiLCJzdGF0ZVRvU2V0IiwiZGVsYXlNcyIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJ1c2VOb0ludGVyYWN0aXZlQ2hpbGRyZW4iLCJnZXRJbnRlcmFjdGl2ZUNvbnRlbnQiLCJlcnJvck1lc3NhZ2UiLCJvdXRlckhUTUwiLCJjb25zb2xlIiwiZXJyb3IiLCJFcnJvciIsInVzZUludGVyYWN0aXZlQ2hpbGRyZW5OZWVkRGVzY3JpcHRpb24iLCJoYXNBdHRyaWJ1dGUiLCJjaGlsZE5vZGVzIiwiaXNGb2N1c2FibGUiLCJjaGlsZE5vZGUiLCJpbnRlcmFjdGl2ZU5vZGUiLCJnZXRSb2xlQ29udGVudCIsImdldEF0dHJpYnV0ZSIsInJvbGVOb2RlIiwidGFiSW5kZXgiLCJub2RlTmFtZSIsImhyZWYiLCJyZWwiLCJEUkFHX1NUT1BfRVZFTlRfVFlQRVMiLCJTZXQiLCJUb29sdGlwIiwibGFiZWwiLCJkZXNjcmlwdGlvbiIsImVudGVyRGVsYXlNcyIsImxlYXZlRGVsYXlNcyIsImRlZmF1bHRPcGVuIiwiY2xvc2VPbkFjdGl2YXRpb24iLCJ0b29sdGlwUmVmIiwic2V0T3BlbiIsImlzRHJhZ2dpbmciLCJzZXRJc0RyYWdnaW5nIiwiZm9jdXNCeU1vdXNlIiwic2V0Rm9jdXNCeU1vdXNlIiwiaXNQb2ludGVySW50ZXJzZWN0aW5nIiwic2V0SXNQb2ludGVySW50ZXJzZWN0aW5nIiwib25seSIsImFyaWFMYWJlbCIsImFyaWFMYWJlbGxlZEJ5IiwiYXJpYURlc2NyaWJlZEJ5IiwiaGFzTGFiZWwiLCJoYXNBcmlhTGFiZWwiLCJ0cmltIiwibGFiZWxsZWRCeSIsImRlc2NyaWJlZEJ5IiwidHJpZ2dlclByb3BzIiwib25Gb2N1cyIsIm9uQmx1ciIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VMZWF2ZSIsIm9uTW91c2VEb3duIiwib25Nb3VzZU1vdmUiLCJvblRvdWNoU3RhcnQiLCJvbkRyYWdTdGFydCIsImdldENoaWxkRXZlbnRIYW5kbGVycyIsImNoaWxkUHJvcHMiLCJldmVudEhhbmRsZXJGdW5jdGlvbnMiLCJwcm9wIiwic3RhcnRzV2l0aCIsImV2ZW50SGFuZGxlcnMiLCJmdW5jdGlvbk5hbWUiLCJldnQiLCJzdG9wUHJvcGFnYXRpb24iLCJoYW5kbGVLZXlEb3duIiwiYnV0dG9ucyIsIm9uRHJhZ1N0b3AiLCJldmVudFR5cGUiLCJyb2xlIiwiQnV0dG9uQmFzZSIsImRhbmdlckRlc2NyaXB0aW9uIiwiaGFzSWNvbk9ubHkiLCJpY29uRGVzY3JpcHRpb24iLCJpc0V4cHJlc3NpdmUiLCJpc1NlbGVjdGVkIiwia2luZCIsInJlbmRlckljb24iLCJCdXR0b25JbWFnZUVsZW1lbnQiLCJidXR0b25DbGFzc2VzIiwiY29tbW9uUHJvcHMiLCJidXR0b25JbWFnZSIsImRhbmdlckJ1dHRvblZhcmlhbnRzIiwiY29tcG9uZW50IiwiYXNzaXN0aXZlSWQiLCJhcmlhUHJlc3NlZCIsIm90aGVyUHJvcHMiLCJhbmNob3JQcm9wcyIsImFzc2lzdGl2ZVRleHQiLCJCYWRnZUluZGljYXRvciIsIkJhZGdlSW5kaWNhdG9yQ29udGVudCIsImNsYXNzTmFtZXMiLCJkaXNwbGF5Q291bnQiLCJJY29uQnV0dG9uS2luZHMiLCJJY29uQnV0dG9uIiwiYmFkZ2VDb3VudCIsIndyYXBwZXJDbGFzc2VzIiwidG9vbHRpcENsYXNzZXMiLCJ3YXJuIiwiYmFkZ2VJZCIsIkJ1dHRvbktpbmRzIiwiQnV0dG9uU2l6ZXMiLCJCdXR0b25Ub29sdGlwQWxpZ25tZW50cyIsIkJ1dHRvblRvb2x0aXBQb3NpdGlvbnMiLCJpc0ljb25Pbmx5QnV0dG9uIiwiX2tpbmQiLCJCdXR0b24iLCJ0b29sdGlwSGlnaENvbnRyYXN0IiwidG9vbHRpcERyb3BTaGFkb3ciLCJ0b29sdGlwQWxpZ25tZW50IiwidG9vbHRpcFBvc2l0aW9uIiwiaWNvbk9ubHlJbWFnZSIsInByb3BzV2l0aG91dFRvb2x0aXBBbGlnbm1lbnQiLCJ2YWxpZEtpbmRzIiwib2JqZWN0Iiwibm9vcEZuIiwiV2FybmluZ0ZpbGxlZCIsIldhcm5pbmdBbHRGaWxsZWQiLCJDaGVja2JveCIsImRlY29yYXRvciIsImhlbHBlclRleHQiLCJsYWJlbFRleHQiLCJvbkNoYW5nZSIsImluZGV0ZXJtaW5hdGUiLCJpbnZhbGlkIiwiaW52YWxpZFRleHQiLCJoaWRlTGFiZWwiLCJyZWFkT25seSIsIndhcm5UZXh0Iiwic2x1ZyIsIm90aGVyIiwic2hvd1dhcm5pbmciLCJzaG93SGVscGVyIiwiY2hlY2tib3hHcm91cEluc3RhbmNlSWQiLCJoZWxwZXJJZCIsImhlbHBlciIsImlubmVyTGFiZWxDbGFzc2VzIiwibm9ybWFsaXplZERlY29yYXRvciIsImNoZWNrZWQiLCJwcmV2ZW50RGVmYXVsdCIsImh0bWxGb3IiLCJkZWZhdWx0Q2hlY2tlZCIsIkZvcm1Db250ZXh0IiwiaXNGbHVpZCIsImxpc3RCb3hUeXBlcyIsImxpc3RCb3hTaXplcyIsIkxpc3RCb3hUeXBlUHJvcFR5cGUiLCJMaXN0Qm94U2l6ZVByb3BUeXBlIiwiaGFuZGxlT25LZXlEb3duIiwiaGFuZGxlQ2xpY2siLCJMaXN0Qm94IiwiY29udGFpbmVyQ2xhc3NOYW1lIiwiaW52YWxpZFRleHRJZCIsIndhcm5UZXh0SWQiLCJsaWdodCIsIkxpc3RCb3hGaWVsZCIsInVzZUlzVHJ1bmNhdGVkIiwiZm9yd2FyZGVkUmVmIiwiZGVwcyIsImxvY2FsUmVmIiwibWVyZ2VkUmVmIiwiaXNUcnVuY2F0ZWQiLCJzZXRJc1RydW5jYXRlZCIsIm9mZnNldFdpZHRoIiwic2Nyb2xsV2lkdGgiLCJMaXN0Qm94TWVudUl0ZW0iLCJpc0FjdGl2ZSIsImlzSGlnaGxpZ2h0ZWQiLCJtZW51SXRlbU9wdGlvblJlZlByb3AiLCJtZW51SXRlbU9wdGlvblJlZiIsImZyRm4iLCJMaXN0Qm94TWVudSIsInNoYXBlIiwiQ2hldnJvbkRvd24iLCJkZWZhdWx0VHJhbnNsYXRpb25zIiwiZGVmYXVsdFRyYW5zbGF0ZVdpdGhJZCIsIkxpc3RCb3hNZW51SWNvbiIsInRyYW5zbGF0ZVdpdGhJZCIsIm5hbWUiLCJDbG9zZSIsIl9DbG9zZSIsIl9DbG9zZTIiLCJ0cmFuc2xhdGlvbklkcyIsIkxpc3RCb3hTZWxlY3Rpb24iLCJjbGVhclNlbGVjdGlvbiIsInNlbGVjdGlvbkNvdW50Iiwib25DbGVhclNlbGVjdGlvbiIsImhhbmRsZU9uQ2xpY2siLCJ0YWdDbGFzc2VzIiwiTGlzdEJveCQxIiwiRmllbGQiLCJNZW51IiwiTWVudUljb24iLCJNZW51SXRlbSIsIlNlbGVjdGlvbiIsIm1lcmdlUmVmcyIsIm1lcmdlUmVmcyQxIiwidXNlU2VsZWN0IiwiQ2hlY2ttYXJrIiwiSXRlbU1vdXNlTW92ZSIsIk1lbnVNb3VzZUxlYXZlIiwic3RhdGVDaGFuZ2VUeXBlcyIsImRlZmF1bHRJdGVtVG9TdHJpbmciLCJzdGF0ZVJlZHVjZXIiLCJhY3Rpb25BbmRDaGFuZ2VzIiwiY2hhbmdlcyIsImhpZ2hsaWdodGVkSW5kZXgiLCJEcm9wZG93biIsIml0ZW1zIiwiaXRlbXNQcm9wIiwiZGVwcmVjYXRlZEFyaWFMYWJlbCIsIml0ZW1Ub1N0cmluZyIsIml0ZW1Ub0VsZW1lbnQiLCJyZW5kZXJTZWxlY3RlZEl0ZW0iLCJzaXplJDEiLCJ0aXRsZVRleHQiLCJpbml0aWFsU2VsZWN0ZWRJdGVtIiwic2VsZWN0ZWRJdGVtIiwiY29udHJvbGxlZFNlbGVjdGVkSXRlbSIsImRvd25zaGlmdFByb3BzIiwicmVjdHMiLCJlbGVtZW50cyIsInJlZmVyZW5jZSIsIm9uU2VsZWN0ZWRJdGVtQ2hhbmdlIiwiaXNJdGVtRGlzYWJsZWQiLCJfaW5kZXgiLCJpc09iamVjdCIsIm9uSGlnaGxpZ2h0ZWRJbmRleENoYW5nZSIsIml0ZW1BcnJheSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJoaWdobGlnaHRlZEl0ZW0iLCJzY3JvbGxJbnRvVmlldyIsImJlaGF2aW9yIiwiYmxvY2siLCJzZWxlY3RQcm9wcyIsImRyb3Bkb3duSW5zdGFuY2VJZCIsImdldFRvZ2dsZUJ1dHRvblByb3BzIiwiZ2V0TGFiZWxQcm9wcyIsImdldE1lbnVQcm9wcyIsImdldEl0ZW1Qcm9wcyIsImlubGluZSIsImlzRm9jdXNlZCIsInNldElzRm9jdXNlZCIsInRpdGxlQ2xhc3NlcyIsImhlbHBlckNsYXNzZXMiLCJJdGVtVG9FbGVtZW50IiwidG9nZ2xlQnV0dG9uUHJvcHMiLCJoYW5kbGVGb2N1cyIsImN1cnJUaW1lciIsInNldEN1cnJUaW1lciIsImlzVHlwaW5nIiwic2V0SXNUeXBpbmciLCJvbktleURvd25IYW5kbGVyIiwicmVhZE9ubHlFdmVudEhhbmRsZXJzIiwiZm9jdXMiLCJzZWxlY3RBY2Nlc3NLZXlzIiwibWVudVByb3BzIiwiYWxsTGFiZWxQcm9wcyIsImxhYmVsUHJvcHMiLCJpbmRleCIsIml0ZW1Qcm9wcyIsImFycmF5IiwiTG9hZGluZyIsImFjdGl2ZSIsIndpdGhPdmVybGF5Iiwic21hbGwiLCJsb2FkaW5nQ2xhc3NOYW1lIiwib3ZlcmxheUNsYXNzTmFtZSIsImxvYWRpbmciLCJ2aWV3Qm94IiwiY3kiLCJzb3J0aW5nUHJvcFR5cGVzIiwiY29tcGFyZUl0ZW1zIiwic29ydEl0ZW1zIiwiZGVmYXVsdENvbXBhcmVJdGVtcyIsIml0ZW1BIiwiaXRlbUIiLCJsb2NhbGUiLCJsb2NhbGVDb21wYXJlIiwibnVtZXJpYyIsImRlZmF1bHRTb3J0SXRlbXMiLCJzZWxlY3RlZEl0ZW1zIiwic29ydCIsImlzU2VsZWN0QWxsIiwiaGFzSXRlbUEiLCJoYXNJdGVtQiIsImNhbGxPbkNoYW5nZUhhbmRsZXIiLCJpc0NvbnRyb2xsZWQiLCJpc01vdW50ZWQiLCJvbkNoYW5nZUhhbmRsZXJDb250cm9sbGVkIiwib25DaGFuZ2VIYW5kbGVyVW5jb250cm9sbGVkIiwidXNlU2VsZWN0aW9uIiwiaW5pdGlhbFNlbGVjdGVkSXRlbXMiLCJjb250cm9sbGVkSXRlbXMiLCJzZWxlY3RBbGwiLCJmaWx0ZXJlZEl0ZW1zIiwic2F2ZWRPbkNoYW5nZSIsInVuY29udHJvbGxlZEl0ZW1zIiwic2V0VW5jb250cm9sbGVkSXRlbXMiLCJvbkl0ZW1DaGFuZ2UiLCJhbGxTZWxlY3RhYmxlSXRlbXMiLCJkaXNhYmxlZEl0ZW1Db3VudCIsIm5ld1NlbGVjdGVkSXRlbXMiLCJzZWxlY3RlZEluZGV4IiwiZmluZExhc3RJbmRleCIsImNvbmNhdCIsInJlbW92ZUF0SW5kZXgiLCJyZXN1bHQiLCJzbGljZSIsInNwbGljZSIsIkl0ZW1DbGljayIsIlRvZ2dsZUJ1dHRvbkJsdXIiLCJUb2dnbGVCdXR0b25LZXlEb3duQXJyb3dEb3duIiwiVG9nZ2xlQnV0dG9uS2V5RG93bkFycm93VXAiLCJUb2dnbGVCdXR0b25LZXlEb3duRW50ZXIiLCJUb2dnbGVCdXR0b25LZXlEb3duRXNjYXBlIiwiVG9nZ2xlQnV0dG9uS2V5RG93blNwYWNlQnV0dG9uIiwiVG9nZ2xlQnV0dG9uQ2xpY2siLCJUb2dnbGVCdXR0b25LZXlEb3duUGFnZURvd24iLCJUb2dnbGVCdXR0b25LZXlEb3duUGFnZVVwIiwiRnVuY3Rpb25TZXRIaWdobGlnaHRlZEluZGV4IiwiTXVsdGlTZWxlY3QiLCJjbGVhclNlbGVjdGlvblRleHQiLCJjbGVhckFubm91bmNlbWVudCIsImNsZWFyU2VsZWN0aW9uRGVzY3JpcHRpb24iLCJ1c2VUaXRsZUluSXRlbSIsInNlbGVjdGlvbkZlZWRiYWNrIiwib25NZW51Q2hhbmdlIiwic2VsZWN0ZWQiLCJoYXNPd24iLCJtdWx0aVNlbGVjdEluc3RhbmNlSWQiLCJpbnB1dEZvY3VzZWQiLCJzZXRJbnB1dEZvY3VzZWQiLCJwcmV2T3BlblByb3AiLCJzZXRQcmV2T3BlblByb3AiLCJ0b3BJdGVtcyIsInNldFRvcEl0ZW1zIiwiaXRlbXNDbGVhcmVkIiwic2V0SXRlbXNDbGVhcmVkIiwiY3Jvc3NBeGlzIiwiY29udHJvbGxlZFNlbGVjdGVkSXRlbXMiLCJzb3J0T3B0aW9ucyIsInNldEhpZ2hsaWdodGVkSW5kZXgiLCJzZXRJc09wZW5XcmFwcGVyIiwiZmllbGRMYWJlbElkIiwiaW5kZXhPZiIsIm11bHRpU2VsZWN0RmllbGRXcmFwcGVyQ2xhc3NlcyIsImNsYXNzTGlzdCIsIml0ZW1zU2VsZWN0ZWRUZXh0Iiwic2VsZWN0ZWRJdGVtc0xlbmd0aCIsImdldFNlbGVjdGlvblN0YXRzIiwiaGFzSW5kaXZpZHVhbFNlbGVjdGlvbnMiLCJub25TZWxlY3RBbGxTZWxlY3RlZENvdW50IiwidG90YWxTZWxlY3RhYmxlQ291bnQiLCJpc0NoZWNrZWQiLCJpc0luZGV0ZXJtaW5hdGUiLCJpdGVtVGV4dCIsImdldE5leHRJbmRleCIsImFycmF5TGVuZ3RoIiwic2VsZWN0b3JUYWJiYWJsZSIsInNlbGVjdG9yRm9jdXNhYmxlIiwidGFiYmFibGUiLCJET0NVTUVOVF9QT1NJVElPTl9CUk9BRF9QUkVDRURJTkciLCJET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkciLCJET0NVTUVOVF9QT1NJVElPTl9DT05UQUlOUyIsIkRPQ1VNRU5UX1BPU0lUSU9OX0JST0FEX0ZPTExPV0lORyIsIkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyIsIkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSIsImVsZW1lbnRPclBhcmVudElzRmxvYXRpbmdNZW51Iiwic2VsZWN0b3JzRmxvYXRpbmdNZW51cyIsIkVsZW1lbnQiLCJjbG9zZXN0IiwiYWxsU2VsZWN0b3JzRmxvYXRpbmdNZW51cyIsInNlbGVjdG9yIiwid3JhcEZvY3VzIiwiYm9keU5vZGUiLCJzdGFydFRyYXBOb2RlIiwiZW5kVHJhcE5vZGUiLCJjdXJyZW50QWN0aXZlTm9kZSIsIm9sZEFjdGl2ZU5vZGUiLCJjb21wYXJpc29uUmVzdWx0IiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJ0YWJiYWJsZUVsZW1lbnQiLCJyZXZlcnNlIiwiZmluZCIsIm9mZnNldFBhcmVudCIsIkJvb2xlYW4iLCJ3cmFwRm9jdXNXaXRob3V0U2VudGluZWxzIiwiX3JlZjQiLCJjb250YWluZXJOb2RlIiwidGFiYmFibGVzIiwiZmlyc3RUYWJiYWJsZSIsImxhc3RUYWJiYWJsZSIsInNoaWZ0S2V5IiwiRXJyb3JGaWxsZWQiLCJDaGVja21hcmtGaWxsZWQiLCJJbmZvcm1hdGlvbkZpbGxlZCIsIkluZm9ybWF0aW9uU3F1YXJlRmlsbGVkIiwidXNlRXNjYXBlVG9DbG9zZSIsImVsZW1lbnRDb250YWluc0ZvY3VzIiwiYWN0aXZlRWxlbWVudCIsIk5vdGlmaWNhdGlvbkFjdGlvbkJ1dHRvbiIsIk5vdGlmaWNhdGlvbkJ1dHRvbiIsIkljb25UYWciLCJub3RpZmljYXRpb25UeXBlIiwiYnV0dG9uQ2xhc3NOYW1lIiwiaWNvbkNsYXNzTmFtZSIsImljb25UeXBlcyIsInN1Y2Nlc3MiLCJpbmZvIiwiTm90aWZpY2F0aW9uSWNvbiIsIkljb25Gb3JLaW5kIiwiVG9hc3ROb3RpZmljYXRpb24iLCJvbkNsb3NlIiwib25DbG9zZUJ1dHRvbkNsaWNrIiwic3RhdHVzSWNvbkRlc2NyaXB0aW9uIiwibG93Q29udHJhc3QiLCJoaWRlQ2xvc2VCdXR0b24iLCJ0aW1lb3V0IiwiY2FwdGlvbiIsInN1YnRpdGxlIiwiY29udGVudFJlZiIsImhhbmRsZUNsb3NlIiwiaGFuZGxlQ2xvc2VCdXR0b25DbGljayIsInNhdmVkT25DbG9zZSIsIklubGluZU5vdGlmaWNhdGlvbiIsIl9yZWY1IiwiQWN0aW9uYWJsZU5vdGlmaWNhdGlvbiIsIl9yZWY2IiwiYWN0aW9uQnV0dG9uTGFiZWwiLCJvbkFjdGlvbkJ1dHRvbkNsaWNrIiwiaGFzRm9jdXMiLCJjbG9zZU9uRXNjYXBlIiwic3VidGl0bGVJZCIsImlubmVyTW9kYWwiLCJzdGFydFRyYXAiLCJlbmRUcmFwIiwiZm9jdXNUcmFwV2l0aG91dFNlbnRpbmVscyIsImJ1dHRvbiIsInF1ZXJ5U2VsZWN0b3IiLCJoYW5kbGVCbHVyIiwiX3JlZjciLCJyZWxhdGVkVGFyZ2V0IiwibWFwcGluZyIsIkNhbGxvdXQiLCJfcmVmOCIsInRpdGxlSWQiLCJjaGlsZHJlbkNvbnRhaW5lciIsIlN0YXRpY05vdGlmaWNhdGlvbiIsIkFzcGVjdFJhdGlvIiwiQnJlYWRjcnVtYiIsIkJyZWFkY3J1bWJJdGVtIiwiQnJlYWRjcnVtYlNrZWxldG9uIiwiQnV0dG9uU2tlbGV0b24iLCJCdXR0b25TZXQiLCJDaGVja2JveFNrZWxldG9uIiwiQ2hlY2tib3hHcm91cCIsIkNsYXNzUHJlZml4IiwiQ29kZVNuaXBwZXQiLCJDb2RlU25pcHBldFNrZWxldG9uIiwiQ29tYm9Cb3giLCJDb21ib0J1dHRvbiIsIkNvbXBvc2VkTW9kYWwiLCJNb2RhbEJvZHkiLCJNb2RhbEhlYWRlciIsIk1vZGFsRm9vdGVyIiwiQ29udGVudFN3aXRjaGVyIiwidXNlQ29udGV4dE1lbnUiLCJDb3B5IiwiQ29weUJ1dHRvbiIsIkRhbmdlckJ1dHRvbiIsIkRhdGFUYWJsZSIsIlRhYmxlIiwiVGFibGVBY3Rpb25MaXN0IiwiVGFibGVCYXRjaEFjdGlvbiIsIlRhYmxlQmF0Y2hBY3Rpb25zIiwiVGFibGVCb2R5IiwiVGFibGVDZWxsIiwiVGFibGVDb250YWluZXIiLCJUYWJsZUV4cGFuZEhlYWRlciIsIlRhYmxlRGVjb3JhdG9yUm93IiwiVGFibGVFeHBhbmRSb3ciLCJUYWJsZUV4cGFuZGVkUm93IiwiVGFibGVIZWFkIiwiVGFibGVIZWFkZXIiLCJUYWJsZVJvdyIsIlRhYmxlU2VsZWN0QWxsIiwiVGFibGVTZWxlY3RSb3ciLCJUYWJsZVNsdWdSb3ciLCJUYWJsZVRvb2xiYXIiLCJUYWJsZVRvb2xiYXJBY3Rpb24iLCJUYWJsZVRvb2xiYXJDb250ZW50IiwiVGFibGVUb29sYmFyU2VhcmNoIiwiVGFibGVUb29sYmFyTWVudSIsIkRhdGFUYWJsZVNrZWxldG9uIiwiRGF0ZVBpY2tlciIsIkRhdGVQaWNrZXJTa2VsZXRvbiIsIkRhdGVQaWNrZXJJbnB1dCIsIkRyb3Bkb3duU2tlbGV0b24iLCJFcnJvckJvdW5kYXJ5IiwiRXJyb3JCb3VuZGFyeUNvbnRleHQiLCJFeHBhbmRhYmxlU2VhcmNoIiwidW5zdGFibGVfRmVhdHVyZUZsYWdzIiwidW5zdGFibGVfdXNlRmVhdHVyZUZsYWciLCJ1bnN0YWJsZV91c2VGZWF0dXJlRmxhZ3MiLCJGaWxlVXBsb2FkZXIiLCJGaWxlbmFtZSIsIkZpbGVVcGxvYWRlclNrZWxldG9uIiwiRmlsZVVwbG9hZGVyQnV0dG9uIiwiRmlsZVVwbG9hZGVyRHJvcENvbnRhaW5lciIsIkZpbGVVcGxvYWRlckl0ZW0iLCJGbHVpZEZvcm0iLCJGb3JtIiwiRm9ybUdyb3VwIiwiRm9ybUl0ZW0iLCJGb3JtTGFiZWwiLCJGbGV4R3JpZCIsIkdyaWQiLCJSb3ciLCJDb2x1bW4iLCJDb2x1bW5IYW5nIiwiR3JpZFNldHRpbmdzIiwiSWNvblNrZWxldG9uIiwiSWRQcmVmaXgiLCJJbmxpbmVMb2FkaW5nIiwiTGluayIsIkxpc3RJdGVtIiwiTWVudUl0ZW1EaXZpZGVyIiwiTWVudUl0ZW1Hcm91cCIsIk1lbnVJdGVtUmFkaW9Hcm91cCIsIk1lbnVJdGVtU2VsZWN0YWJsZSIsIk1lbnVCdXR0b24iLCJNb2RhbCIsIk1vZGFsV3JhcHBlciIsIkZpbHRlcmFibGVNdWx0aVNlbGVjdCIsIk51bWJlcklucHV0U2tlbGV0b24iLCJOdW1iZXJJbnB1dCIsIk9yZGVyZWRMaXN0IiwiT3ZlcmZsb3dNZW51IiwiT3ZlcmZsb3dNZW51SXRlbSIsInVuc3RhYmxlX19QYWdlSGVhZGVyIiwiUGFnaW5hdGlvbiIsIlBhZ2luYXRpb25Ta2VsZXRvbiIsIlBhZ2luYXRpb25OYXYiLCJDb250cm9sbGVkUGFzc3dvcmRJbnB1dCIsIlBhc3N3b3JkSW5wdXQiLCJQcmltYXJ5QnV0dG9uIiwiUHJvZ3Jlc3NJbmRpY2F0b3JTa2VsZXRvbiIsIlByb2dyZXNzSW5kaWNhdG9yIiwiUHJvZ3Jlc3NTdGVwIiwiUmFkaW9CdXR0b24iLCJSYWRpb0J1dHRvblNrZWxldG9uIiwiUmFkaW9CdXR0b25Hcm91cCIsIlJhZGlvVGlsZSIsIlNlYXJjaCIsIlNlYXJjaFNrZWxldG9uIiwiU2Vjb25kYXJ5QnV0dG9uIiwiU2VsZWN0IiwiU2VsZWN0U2tlbGV0b24iLCJTZWxlY3RJdGVtIiwiU2VsZWN0SXRlbUdyb3VwIiwiU2tlbGV0b25JY29uIiwiU2tlbGV0b25QbGFjZWhvbGRlciIsIlNsaWRlciIsIkhTdGFjayIsIlN0YWNrIiwiVlN0YWNrIiwiU3RydWN0dXJlZExpc3RCb2R5IiwiU3RydWN0dXJlZExpc3RDZWxsIiwiU3RydWN0dXJlZExpc3RIZWFkIiwiU3RydWN0dXJlZExpc3RJbnB1dCIsIlN0cnVjdHVyZWRMaXN0Um93IiwiU3RydWN0dXJlZExpc3RXcmFwcGVyIiwiU3RydWN0dXJlZExpc3RTa2VsZXRvbiIsIlN3aXRjaCIsIkljb25Td2l0Y2giLCJJY29uVGFiIiwiVGFiTGlzdCIsIlRhYkxpc3RWZXJ0aWNhbCIsIlRhYlBhbmVsIiwiVGFiUGFuZWxzIiwiVGFicyIsIlRhYnNWZXJ0aWNhbCIsIlRhYkNvbnRlbnQiLCJUYWJzU2tlbGV0b24iLCJUYWciLCJEaXNtaXNzaWJsZVRhZyIsIk9wZXJhdGlvbmFsVGFnIiwiU2VsZWN0YWJsZVRhZyIsIlRhZ1NrZWxldG9uIiwiVGV4dEFyZWEiLCJUZXh0QXJlYVNrZWxldG9uIiwiVGV4dElucHV0IiwiVGV4dElucHV0U2tlbGV0b24iLCJDbGlja2FibGVUaWxlIiwiRXhwYW5kYWJsZVRpbGUiLCJTZWxlY3RhYmxlVGlsZSIsIlRpbGUiLCJUaWxlQWJvdmVUaGVGb2xkQ29udGVudCIsIlRpbGVCZWxvd1RoZUZvbGRDb250ZW50IiwiVGlsZUdyb3VwIiwiVGltZVBpY2tlciIsIlRpbWVQaWNrZXJTZWxlY3QiLCJUb2dnbGVTa2VsZXRvbiIsIlRvZ2dsZVNtYWxsU2tlbGV0b24iLCJUb2dnbGV0aXAiLCJUb2dnbGV0aXBBY3Rpb25zIiwiVG9nZ2xldGlwQnV0dG9uIiwiVG9nZ2xldGlwQ29udGVudCIsIlRvZ2dsZXRpcExhYmVsIiwiVHJlZU5vZGUiLCJUcmVlVmlldyIsIkNvbnRlbnQiLCJIZWFkZXIiLCJIZWFkZXJDb250YWluZXIiLCJIZWFkZXJHbG9iYWxBY3Rpb24iLCJIZWFkZXJHbG9iYWxCYXIiLCJIZWFkZXJNZW51IiwiSGVhZGVyTWVudUJ1dHRvbiIsIkhlYWRlck1lbnVJdGVtIiwiSGVhZGVyTmFtZSIsIkhlYWRlck5hdmlnYXRpb24iLCJIZWFkZXJQYW5lbCIsIkhlYWRlclNpZGVOYXZJdGVtcyIsIlN3aXRjaGVyIiwiU3dpdGNoZXJJdGVtIiwiU3dpdGNoZXJEaXZpZGVyIiwiU2tpcFRvQ29udGVudCIsIlNpZGVOYXYiLCJTaWRlTmF2RGV0YWlscyIsIlNpZGVOYXZEaXZpZGVyIiwiU2lkZU5hdkZvb3RlciIsIlNpZGVOYXZIZWFkZXIiLCJTaWRlTmF2SWNvbiIsIlNpZGVOYXZJdGVtIiwiU2lkZU5hdkl0ZW1zIiwiU2lkZU5hdkxpbmsiLCJTaWRlTmF2TGlua1RleHQiLCJTaWRlTmF2TWVudSIsIlNpZGVOYXZNZW51SXRlbSIsIlNpZGVOYXZTd2l0Y2hlciIsIlVub3JkZXJlZExpc3QiLCJ1bnN0YWJsZV9fRmx1aWRDb21ib0JveCIsInVuc3RhYmxlX19GbHVpZENvbWJvQm94U2tlbGV0b24iLCJ1bnN0YWJsZV9fRmx1aWREYXRlUGlja2VyIiwidW5zdGFibGVfX0ZsdWlkRGF0ZVBpY2tlclNrZWxldG9uIiwidW5zdGFibGVfX0ZsdWlkRGF0ZVBpY2tlcklucHV0IiwidW5zdGFibGVfX0ZsdWlkRHJvcGRvd24iLCJ1bnN0YWJsZV9fRmx1aWREcm9wZG93blNrZWxldG9uIiwidW5zdGFibGVfX0ZsdWlkTXVsdGlTZWxlY3QiLCJ1bnN0YWJsZV9fRmx1aWRNdWx0aVNlbGVjdFNrZWxldG9uIiwidW5zdGFibGVfX0ZsdWlkU2VsZWN0IiwidW5zdGFibGVfX0ZsdWlkU2VsZWN0U2tlbGV0b24iLCJ1bnN0YWJsZV9fRmx1aWRTZWFyY2giLCJ1bnN0YWJsZV9fRmx1aWRTZWFyY2hTa2VsZXRvbiIsInVuc3RhYmxlX19GbHVpZFRleHRBcmVhIiwidW5zdGFibGVfX0ZsdWlkVGV4dEFyZWFTa2VsZXRvbiIsInVuc3RhYmxlX19GbHVpZFRleHRJbnB1dCIsInVuc3RhYmxlX19GbHVpZFRleHRJbnB1dFNrZWxldG9uIiwidW5zdGFibGVfX0ZsdWlkTnVtYmVySW5wdXQiLCJ1bnN0YWJsZV9fRmx1aWROdW1iZXJJbnB1dFNrZWxldG9uIiwidW5zdGFibGVfX0ZsdWlkVGltZVBpY2tlciIsInVuc3RhYmxlX19GbHVpZFRpbWVQaWNrZXJTa2VsZXRvbiIsInVuc3RhYmxlX19GbHVpZFRpbWVQaWNrZXJTZWxlY3QiLCJIZWFkaW5nIiwiU2VjdGlvbiIsIkxheWVyIiwidXNlTGF5ZXIiLCJMYXlvdXQiLCJ1bnN0YWJsZV9MYXlvdXQiLCJMYXlvdXREaXJlY3Rpb24iLCJ1bnN0YWJsZV9MYXlvdXREaXJlY3Rpb24iLCJ1c2VMYXlvdXREaXJlY3Rpb24iLCJ1bnN0YWJsZV91c2VMYXlvdXREaXJlY3Rpb24iLCJPdmVyZmxvd01lbnVWMiIsInVuc3RhYmxlX092ZXJmbG93TWVudVYyIiwiUHJvZ3Jlc3NCYXIiLCJBSUxhYmVsIiwiQUlMYWJlbEFjdGlvbnMiLCJBSUxhYmVsQ29udGVudCIsInVuc3RhYmxlX19TbHVnIiwidW5zdGFibGVfX1NsdWdBY3Rpb25zIiwidW5zdGFibGVfX1NsdWdDb250ZW50IiwiSWNvbkluZGljYXRvciIsInVuc3RhYmxlX19JY29uSW5kaWNhdG9yIiwiU2hhcGVJbmRpY2F0b3IiLCJ1bnN0YWJsZV9fU2hhcGVJbmRpY2F0b3IiLCJ1bnN0YWJsZV9fQ2hhdEJ1dHRvbiIsInVuc3RhYmxlX19DaGF0QnV0dG9uU2tlbGV0b24iLCJBSVNrZWxldG9uUGxhY2Vob2xkZXIiLCJ1bnN0YWJsZV9fQWlTa2VsZXRvblBsYWNlaG9sZGVyIiwiQUlTa2VsZXRvbkljb24iLCJ1bnN0YWJsZV9fQWlTa2VsZXRvbkljb24iLCJBSVNrZWxldG9uVGV4dCIsInVuc3RhYmxlX19BaVNrZWxldG9uVGV4dCIsIkRlZmluaXRpb25Ub29sdGlwIiwiR2xvYmFsVGhlbWUiLCJUaGVtZSIsIlRoZW1lQ29udGV4dCIsInVzZVByZWZlcnNEYXJrU2NoZW1lIiwidXNlVGhlbWUiLCJ1bnN0YWJsZV9QYWdlU2VsZWN0b3IiLCJ1bnN0YWJsZV9QYWdpbmF0aW9uIiwiQ29udGFpbmVkTGlzdEl0ZW0iLCJDb250YWluZWRMaXN0IiwiU2xpZGVyU2tlbGV0b24iLCJ1bnN0YWJsZV9UZXh0IiwiVGV4dERpcmVjdGlvbiIsInVuc3RhYmxlX1RleHREaXJlY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6732\n")}}]);