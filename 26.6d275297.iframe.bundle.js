"use strict";(self.webpackChunk_ibm_aiops_ui_extension_template=self.webpackChunk_ibm_aiops_ui_extension_template||[]).push([[26],{8645:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Wh: function() { return /* binding */ et; },\n/* harmony export */   bl: function() { return /* binding */ cU; },\n/* harmony export */   dM: function() { return /* binding */ oU; },\n/* harmony export */   kf: function() { return /* binding */ mU; },\n/* harmony export */   rW: function() { return /* binding */ dU; }\n/* harmony export */ });\n/* unused harmony exports Alignments, AlluvialChart, AreaChart, AreaEvent, ArrowDirections, ArrowLeftMarker, ArrowRightMarker, AxisEvent, AxisFlavor, AxisPositions, AxisTitleOrientations, BarEvent, BoxplotChart, BoxplotEvent, BubbleChart, BulletChart, CalloutDirections, CanvasZoomEvent, CardNode, CardNodeColumn, CardNodeLabel, CardNodeSubtitle, CardNodeTitle, CartesianOrientations, ChartEvent, ChartTheme, ChartTypes, ChoroplethChart, CircleMarker, CirclePackChart, ColorClassNameTypes, ColorLegendType, ComboChart, DiamondMarker, DividerStatus, DominantBaseline, DonutChart, Edge, ExperimentalChoroplethChart, GaugeChart, GaugeEvent, GaugeTypes, GroupedBarChart, HistogramChart, LayoutAlignItems, LayoutDirection, LayoutGrowth, LegendItemType, LegendOrientations, LegendPositions, LineEvent, LollipopChart, Marker, MeterChart, ModalEvent, ModelEvent, PieEvent, Projection, RadarChart, RadarEvent, RenderTypes, ScatterChart, ScatterEvent, ShapeNode, Skeletons, SquareMarker, StackedAreaChart, StackedBarChart, Statuses, TeeMarker, TextAnchor, ThresholdEvent, TickRotations, ToolbarControlTypes, TooltipEvent, TreeChart, TreeEvent, TreeTypes, TreemapChart, TreemapEvent, TruncationTypes, WordCloudChart, WordCloudEvent, ZoomBarTypes, ZoomDomainEvent, ZoombarEvent */\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4674);\nvar u0 = Object.defineProperty;\nvar h0 = (e, t, n) => t in e ? u0(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;\nvar So = (e, t, n) => h0(e, typeof t != "symbol" ? t + "" : t, n);\n\nvar Ip = /* @__PURE__ */ ((e) => (e.RENDER_FINISHED = "render-finished", e.RESIZE = "chart-resize", e.MOUSEOVER = "chart-mouseover", e.MOUSEOUT = "chart-mouseout", e))(Ip || {}), Np = /* @__PURE__ */ ((e) => (e.SHOW = "show-modal", e.HIDE = "hide-modal", e))(Np || {}), Pp = /* @__PURE__ */ ((e) => (e.UPDATE = "model-update", e))(Pp || {}), Up = /* @__PURE__ */ ((e) => (e.SHOW_OVERFLOW_MENU = "show-toolbar-overflow-menu", e.HIDE_OVERFLOW_MENU = "hide-toolbar-overflow-menu", e.BUTTON_CLICK = "toolbar-button-click", e.SHOW_TOOLTIP = "toolbar-show-tooltip", e.HIDE_TOOLTIP = "toolbar-hide-tooltip", e))(Up || {}), Bp = /* @__PURE__ */ ((e) => (e.UPDATE = "zoom-bar-update", e.SELECTION_START = "zoom-bar-selection-start", e.SELECTION_IN_PROGRESS = "zoom-bar-selection-in-progress", e.SELECTION_END = "zoom-bar-selection-end", e))(Bp || {}), Hp = /* @__PURE__ */ ((e) => (e.CHANGE = "zoom-domain-change", e))(Hp || {}), Vp = /* @__PURE__ */ ((e) => (e.CANVAS_ZOOM_IN = "canvas-zoom-in", e.CANVAS_ZOOM_OUT = "canvas-zoom-out", e))(Vp || {}), Gp = /* @__PURE__ */ ((e) => (e.LABEL_MOUSEOVER = "axis-label-mouseover", e.LABEL_MOUSEMOVE = "axis-label-mousemove", e.LABEL_CLICK = "axis-label-click", e.LABEL_MOUSEOUT = "axis-label-mouseout", e.LABEL_FOCUS = "axis-label-focus", e.LABEL_BLUR = "axis-label-blur", e.RENDER_COMPLETE = "axis-render-complete", e))(Gp || {}), zp = /* @__PURE__ */ ((e) => (e.POINT_MOUSEOVER = "scatter-mouseover", e.POINT_MOUSEMOVE = "scatter-mousemove", e.POINT_CLICK = "scatter-click", e.POINT_MOUSEOUT = "scatter-mouseout", e))(zp || {}), Fp = /* @__PURE__ */ ((e) => (e.WORD_MOUSEOVER = "wordcloud-word-mouseover", e.WORD_MOUSEMOVE = "wordcloud-word-mousemove", e.WORD_CLICK = "wordcloud-word-click", e.WORD_MOUSEOUT = "wordcloud-word-mouseout", e))(Fp || {}), jp = /* @__PURE__ */ ((e) => (e.SLICE_MOUSEOVER = "pie-slice-mouseover", e.SLICE_MOUSEMOVE = "pie-slice-mousemove", e.SLICE_CLICK = "pie-slice-click", e.SLICE_MOUSEOUT = "pie-slice-mouseout", e))(jp || {}), Wp = /* @__PURE__ */ ((e) => (e.ARC_MOUSEOVER = "gauge-arc-mouseover", e.ARC_MOUSEMOVE = "gauge-arc-mousemove", e.ARC_CLICK = "gauge-arc-click", e.ARC_MOUSEOUT = "gauge-arc-mouseout", e))(Wp || {}), qp = /* @__PURE__ */ ((e) => (e.BAR_MOUSEOVER = "bar-mouseover", e.BAR_MOUSEMOVE = "bar-mousemove", e.BAR_CLICK = "bar-click", e.BAR_MOUSEOUT = "bar-mouseout", e))(qp || {}), Yp = /* @__PURE__ */ ((e) => (e.BOX_MOUSEOVER = "box-mouseover", e.BOX_MOUSEMOVE = "box-mousemove", e.BOX_CLICK = "box-click", e.BOX_MOUSEOUT = "box-mouseout", e.OUTLIER_MOUSEOVER = "outlier-mouseover", e.OUTLIER_MOUSEMOVE = "outlier-mousemove", e.OUTLIER_CLICK = "outlier-click", e.OUTLIER_MOUSEOUT = "outlier-mouseout", e))(Yp || {}), Xp = /* @__PURE__ */ ((e) => (e.SCATTER_MOUSEOVER = "scatter-mouseover", e.SCATTER_MOUSEMOVE = "scatter-mousemove", e.SCATTER_CLICK = "scatter-click", e.SCATTER_MOUSEOUT = "scatter-mouseout", e))(Xp || {}), Zp = /* @__PURE__ */ ((e) => (e.POINT_MOUSEOVER = "scatter-mouseover", e.POINT_MOUSEMOVE = "scatter-mousemove", e.POINT_CLICK = "scatter-click", e.POINT_MOUSEOUT = "scatter-mouseout", e))(Zp || {}), Kp = /* @__PURE__ */ ((e) => (e.X_AXIS_MOUSEOVER = "radar-x-axis-mouseover", e.X_AXIS_MOUSEMOVE = "radar-x-axis-mousemove", e.X_AXIS_CLICK = "radar-x-axis-click", e.X_AXIS_MOUSEOUT = "radar-x-axis-mouseout", e))(Kp || {}), Qp = /* @__PURE__ */ ((e) => (e.NODE_MOUSEOVER = "tree-node-mouseover", e.NODE_CLICK = "tree-node-click", e.NODE_MOUSEOUT = "tree-node-mouseout", e))(Qp || {}), Jp = /* @__PURE__ */ ((e) => (e.LEAF_MOUSEOVER = "leaf-mouseover", e.LEAF_MOUSEMOVE = "leaf-mousemove", e.LEAF_CLICK = "leaf-click", e.LEAF_MOUSEOUT = "leaf-mouseout", e))(Jp || {}), Ii = /* @__PURE__ */ ((e) => (e.SHOW = "show-tooltip", e.MOVE = "move-tooltip", e.HIDE = "hide-tooltip", e))(Ii || {}), tf = /* @__PURE__ */ ((e) => (e.SHOW = "show-threshold", e.HIDE = "hide-threshold", e))(tf || {}), ef = /* @__PURE__ */ ((e) => (e.ITEM_HOVER = "legend-item-onhover", e.ITEM_CLICK = "legend-item-onclick", e.ITEM_MOUSEOUT = "legend-item-onmouseout", e.ITEMS_UPDATE = "legend-items-update", e))(ef || {}), nf = /* @__PURE__ */ ((e) => (e.CIRCLE_MOUSEOVER = "circle-leaf-mouseover", e.CIRCLE_CLICK = "circle-leaf-click", e.CIRCLE_MOUSEOUT = "circle-leaf-mouseout", e.CIRCLE_MOUSEMOVE = "circle-leaf-mousemove", e))(nf || {}), rf = /* @__PURE__ */ ((e) => (e.NODE_MOUSEOVER = "alluvial-node-mouseover", e.NODE_CLICK = "alluvial-node-click", e.NODE_MOUSEOUT = "alluvial-node-mouseout", e.NODE_MOUSEMOVE = "alluvial-node-mousemove", e.LINE_MOUSEOVER = "alluvial-line-mouseover", e.LINE_CLICK = "alluvial-line-click", e.LINE_MOUSEOUT = "alluvial-line-mouseout", e.LINE_MOUSEMOVE = "alluvial-line-mousemove", e))(rf || {}), sf = /* @__PURE__ */ ((e) => (e.METER_MOUSEOVER = "meter-mouseover", e.METER_CLICK = "meter-click", e.METER_MOUSEOUT = "meter-mouseout", e.METER_MOUSEMOVE = "meter-mousemove", e))(sf || {}), af = /* @__PURE__ */ ((e) => (e.HEATMAP_MOUSEOVER = "heatmap-mouseover", e.HEATMAP_CLICK = "heatmap-click", e.HEATMAP_MOUSEOUT = "heatmap-mouseout", e.HEATMAP_MOUSEMOVE = "hetmap-mousemove", e))(af || {}), Dr = /* @__PURE__ */ ((e) => (e.CHOROPLETH_MOUSEOVER = "choropleth-mouseover", e.CHOROPLETH_CLICK = "choropleth-click", e.CHOROPLETH_MOUSEOUT = "choropleth-mouseout", e.CHOROPLETH_MOUSEMOVE = "choropleth-mousemove", e))(Dr || {});\nconst d0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  Alluvial: rf,\n  Area: zp,\n  Axis: Gp,\n  Bar: qp,\n  Boxplot: Yp,\n  CanvasZoom: Vp,\n  Chart: Ip,\n  Choropleth: Dr,\n  CirclePack: nf,\n  Gauge: Wp,\n  Heatmap: af,\n  Legend: ef,\n  Line: Zp,\n  Meter: sf,\n  Modal: Np,\n  Model: Pp,\n  Pie: jp,\n  Radar: Kp,\n  Scatter: Xp,\n  Threshold: tf,\n  Toolbar: Up,\n  Tooltip: Ii,\n  Tree: Qp,\n  Treemap: Jp,\n  WordCloud: Fp,\n  ZoomBar: Bp,\n  ZoomDomain: Hp\n}, Symbol.toStringTag, { value: "Module" })), T = d0;\nvar rt = /* @__PURE__ */ ((e) => (e.HTML = "html", e.SVG = "svg", e))(rt || {}), of = /* @__PURE__ */ ((e) => (e.WHITE = "white", e.G100 = "g100", e.G90 = "g90", e.G10 = "g10", e))(of || {}), it = /* @__PURE__ */ ((e) => (e.BACKGROUND = "background", e.FILL = "fill", e.STROKE = "stroke", e.TOOLTIP = "tooltip", e))(it || {}), G = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.RIGHT = "right", e.TOP = "top", e.BOTTOM = "bottom", e))(G || {}), Ke = /* @__PURE__ */ ((e) => (e.GRAPH_VIEW = "graph_view", e.SLIDER_VIEW = "slider_view", e))(Ke || {}), Ve = /* @__PURE__ */ ((e) => (e.END_LINE = "end_line", e.MID_LINE = "mid_line", e.FRONT_LINE = "front_line", e.NONE = "none", e))(Ve || {}), Ft = /* @__PURE__ */ ((e) => (e.VERTICAL = "vertical", e.HORIZONTAL = "horizontal", e))(Ft || {}), et = /* @__PURE__ */ ((e) => (e.TIME = "time", e.LINEAR = "linear", e.LOG = "log", e.LABELS = "labels", e.LABELS_RATIO = "labels-ratio", e))(et || {}), Ni = /* @__PURE__ */ ((e) => (e.RIGHT = "right", e.LEFT = "left", e.TOP = "top", e.BOTTOM = "bottom", e))(Ni || {}), jt = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.CENTER = "center", e.RIGHT = "right", e))(jt || {}), ji = /* @__PURE__ */ ((e) => (e.HORIZONTAL = "horizontal", e.VERTICAL = "vertical", e))(ji || {}), pc = /* @__PURE__ */ ((e) => (e.TREE = "tree", e.DENDROGRAM = "dendrogram", e))(pc || {}), At = /* @__PURE__ */ ((e) => (e.ROW = "row", e.COLUMN = "column", e.ROW_REVERSE = "row-reverse", e.COLUMN_REVERSE = "column-reverse", e))(At || {}), ct = /* @__PURE__ */ ((e) => (e.FIXED = "fixed", e.PREFERRED = "preferred", e.STRETCH = "stretch", e))(ct || {}), ni = /* @__PURE__ */ ((e) => (e.CENTER = "center", e))(ni || {}), Fs = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.RIGHT = "right", e))(Fs || {}), zt = /* @__PURE__ */ ((e) => (e.GRID = "grid", e.VERT_OR_HORIZ = "vertOrHoriz", e.PIE = "pie", e.DONUT = "donut", e))(zt || {}), dn = /* @__PURE__ */ ((e) => (e.START = "start", e.MIDDLE = "middle", e.END = "end", e))(dn || {}), pn = /* @__PURE__ */ ((e) => (e.BASELINE = "baseline", e.MIDDLE = "middle", e.HANGING = "hanging", e))(pn || {}), Rr = /* @__PURE__ */ ((e) => (e.SEMI = "semi", e.FULL = "full", e))(Rr || {}), pl = /* @__PURE__ */ ((e) => (e.UP = "up", e.DOWN = "down", e))(pl || {}), js = /* @__PURE__ */ ((e) => (e.SUCCESS = "success", e.WARNING = "warning", e.DANGER = "danger", e))(js || {}), Ws = /* @__PURE__ */ ((e) => (e.ALWAYS = "always", e.AUTO = "auto", e.NEVER = "never", e))(Ws || {}), we = /* @__PURE__ */ ((e) => (e.SCATTER = "scatter", e.LINE = "line", e.SIMPLE_BAR = "simple-bar", e.STACKED_BAR = "stacked-bar", e.GROUPED_BAR = "grouped-bar", e.AREA = "area", e.STACKED_AREA = "stacked-area", e))(we || {}), _t = /* @__PURE__ */ ((e) => (e.EXPORT_CSV = "Export as CSV", e.EXPORT_PNG = "Export as PNG", e.EXPORT_JPG = "Export as JPG", e.ZOOM_IN = "Zoom in", e.ZOOM_OUT = "Zoom out", e.RESET_ZOOM = "Reset zoom", e.MAKE_FULLSCREEN = "Make fullscreen", e.EXIT_FULLSCREEN = "Exit fullscreen", e.SHOW_AS_DATATABLE = "Show as data-table", e.CUSTOM = "Custom", e))(_t || {}), fl = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.RIGHT = "right", e))(fl || {}), Gt = /* @__PURE__ */ ((e) => (e.CHECKBOX = "checkbox", e.RADIUS = "radius", e.AREA = "area", e.SIZE = "size", e.LINE = "line", e.QUARTILE = "quartile", e.ZOOM = "zoom", e))(Gt || {}), qs = /* @__PURE__ */ ((e) => (e.LINEAR = "linear", e.QUANTIZE = "quantize", e))(qs || {}), Pi = /* @__PURE__ */ ((e) => (e.ON = "on", e.AUTO = "auto", e.OFF = "off", e))(Pi || {}), Ga = /* @__PURE__ */ ((e) => (e.DEFAULT = "default", e.HOVERABLE = "hoverable", e))(Ga || {}), gn = /* @__PURE__ */ ((e) => (e.geoEqualEarth = "geoEqualEarth", e.geoAlbers = "geoAlbers", e.geoConicEqualArea = "geoConicEqualArea", e.geoConicEquidistant = "geoConicEquidistant", e.geoEquirectangular = "geoEquirectangular", e.geoMercator = "geoMercator", e.geoNaturalEarth1 = "geoNaturalEarth1", e))(gn || {}), lf = /* @__PURE__ */ ((e) => (e["15seconds"] = "15seconds", e.minute = "minute", e["30minutes"] = "30minutes", e.hourly = "hourly", e.daily = "daily", e.weekly = "weekly", e.monthly = "monthly", e.quarterly = "quarterly", e.yearly = "yearly", e))(lf || {});\nfunction To(e) {\n  return (t = {}) => {\n    const n = t.width ? String(t.width) : e.defaultWidth;\n    return e.formats[n] || e.formats[e.defaultWidth];\n  };\n}\nfunction ui(e) {\n  return (t, n) => {\n    const r = n != null && n.context ? String(n.context) : "standalone";\n    let i;\n    if (r === "formatting" && e.formattingValues) {\n      const a = e.defaultFormattingWidth || e.defaultWidth, o = n != null && n.width ? String(n.width) : a;\n      i = e.formattingValues[o] || e.formattingValues[a];\n    } else {\n      const a = e.defaultWidth, o = n != null && n.width ? String(n.width) : e.defaultWidth;\n      i = e.values[o] || e.values[a];\n    }\n    const s = e.argumentCallback ? e.argumentCallback(t) : t;\n    return i[s];\n  };\n}\nfunction hi(e) {\n  return (t, n = {}) => {\n    const r = n.width, i = r && e.matchPatterns[r] || e.matchPatterns[e.defaultMatchWidth], s = t.match(i);\n    if (!s)\n      return null;\n    const a = s[0], o = r && e.parsePatterns[r] || e.parsePatterns[e.defaultParseWidth], l = Array.isArray(o) ? f0(o, (d) => d.test(a)) : (\n      // [TODO] -- I challenge you to fix the type\n      p0(o, (d) => d.test(a))\n    );\n    let c;\n    c = e.valueCallback ? e.valueCallback(l) : l, c = n.valueCallback ? (\n      // [TODO] -- I challenge you to fix the type\n      n.valueCallback(c)\n    ) : c;\n    const u = t.slice(a.length);\n    return { value: c, rest: u };\n  };\n}\nfunction p0(e, t) {\n  for (const n in e)\n    if (Object.prototype.hasOwnProperty.call(e, n) && t(e[n]))\n      return n;\n}\nfunction f0(e, t) {\n  for (let n = 0; n < e.length; n++)\n    if (t(e[n]))\n      return n;\n}\nfunction m0(e) {\n  return (t, n = {}) => {\n    const r = t.match(e.matchPattern);\n    if (!r) return null;\n    const i = r[0], s = t.match(e.parsePattern);\n    if (!s) return null;\n    let a = e.valueCallback ? e.valueCallback(s[0]) : s[0];\n    a = n.valueCallback ? n.valueCallback(a) : a;\n    const o = t.slice(i.length);\n    return { value: a, rest: o };\n  };\n}\nconst cf = 6048e5, g0 = 864e5, uf = 6e4, hf = 36e5, Ru = Symbol.for("constructDateFrom");\nfunction Le(e, t) {\n  return typeof e == "function" ? e(t) : e && typeof e == "object" && Ru in e ? e[Ru](t) : e instanceof Date ? new e.constructor(t) : new Date(t);\n}\nfunction ur(e, ...t) {\n  const n = Le.bind(\n    null,\n    t.find((r) => typeof r == "object")\n  );\n  return t.map(n);\n}\nlet v0 = {};\nfunction za() {\n  return v0;\n}\nfunction Ht(e, t) {\n  return Le(t || e, e);\n}\nfunction Wi(e, t) {\n  var n, r, i, s;\n  const a = za(), o = (t == null ? void 0 : t.weekStartsOn) ?? ((r = (n = t == null ? void 0 : t.locale) == null ? void 0 : n.options) == null ? void 0 : r.weekStartsOn) ?? a.weekStartsOn ?? ((s = (i = a.locale) == null ? void 0 : i.options) == null ? void 0 : s.weekStartsOn) ?? 0, l = Ht(e, t == null ? void 0 : t.in), c = l.getDay(), u = (c < o ? 7 : 0) + c - o;\n  return l.setDate(l.getDate() - u), l.setHours(0, 0, 0, 0), l;\n}\nconst y0 = {\n  lessThanXSeconds: {\n    one: "less than a second",\n    other: "less than {{count}} seconds"\n  },\n  xSeconds: {\n    one: "1 second",\n    other: "{{count}} seconds"\n  },\n  halfAMinute: "half a minute",\n  lessThanXMinutes: {\n    one: "less than a minute",\n    other: "less than {{count}} minutes"\n  },\n  xMinutes: {\n    one: "1 minute",\n    other: "{{count}} minutes"\n  },\n  aboutXHours: {\n    one: "about 1 hour",\n    other: "about {{count}} hours"\n  },\n  xHours: {\n    one: "1 hour",\n    other: "{{count}} hours"\n  },\n  xDays: {\n    one: "1 day",\n    other: "{{count}} days"\n  },\n  aboutXWeeks: {\n    one: "about 1 week",\n    other: "about {{count}} weeks"\n  },\n  xWeeks: {\n    one: "1 week",\n    other: "{{count}} weeks"\n  },\n  aboutXMonths: {\n    one: "about 1 month",\n    other: "about {{count}} months"\n  },\n  xMonths: {\n    one: "1 month",\n    other: "{{count}} months"\n  },\n  aboutXYears: {\n    one: "about 1 year",\n    other: "about {{count}} years"\n  },\n  xYears: {\n    one: "1 year",\n    other: "{{count}} years"\n  },\n  overXYears: {\n    one: "over 1 year",\n    other: "over {{count}} years"\n  },\n  almostXYears: {\n    one: "almost 1 year",\n    other: "almost {{count}} years"\n  }\n}, x0 = (e, t, n) => {\n  let r;\n  const i = y0[e];\n  return typeof i == "string" ? r = i : t === 1 ? r = i.one : r = i.other.replace("{{count}}", t.toString()), n != null && n.addSuffix ? n.comparison && n.comparison > 0 ? "in " + r : r + " ago" : r;\n}, b0 = {\n  lastWeek: "\'last\' eeee \'at\' p",\n  yesterday: "\'yesterday at\' p",\n  today: "\'today at\' p",\n  tomorrow: "\'tomorrow at\' p",\n  nextWeek: "eeee \'at\' p",\n  other: "P"\n}, _0 = (e, t, n, r) => b0[e], E0 = {\n  narrow: ["B", "A"],\n  abbreviated: ["BC", "AD"],\n  wide: ["Before Christ", "Anno Domini"]\n}, O0 = {\n  narrow: ["1", "2", "3", "4"],\n  abbreviated: ["Q1", "Q2", "Q3", "Q4"],\n  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]\n}, S0 = {\n  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],\n  abbreviated: [\n    "Jan",\n    "Feb",\n    "Mar",\n    "Apr",\n    "May",\n    "Jun",\n    "Jul",\n    "Aug",\n    "Sep",\n    "Oct",\n    "Nov",\n    "Dec"\n  ],\n  wide: [\n    "January",\n    "February",\n    "March",\n    "April",\n    "May",\n    "June",\n    "July",\n    "August",\n    "September",\n    "October",\n    "November",\n    "December"\n  ]\n}, T0 = {\n  narrow: ["S", "M", "T", "W", "T", "F", "S"],\n  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],\n  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],\n  wide: [\n    "Sunday",\n    "Monday",\n    "Tuesday",\n    "Wednesday",\n    "Thursday",\n    "Friday",\n    "Saturday"\n  ]\n}, w0 = {\n  narrow: {\n    am: "a",\n    pm: "p",\n    midnight: "mi",\n    noon: "n",\n    morning: "morning",\n    afternoon: "afternoon",\n    evening: "evening",\n    night: "night"\n  },\n  abbreviated: {\n    am: "AM",\n    pm: "PM",\n    midnight: "midnight",\n    noon: "noon",\n    morning: "morning",\n    afternoon: "afternoon",\n    evening: "evening",\n    night: "night"\n  },\n  wide: {\n    am: "a.m.",\n    pm: "p.m.",\n    midnight: "midnight",\n    noon: "noon",\n    morning: "morning",\n    afternoon: "afternoon",\n    evening: "evening",\n    night: "night"\n  }\n}, $0 = {\n  narrow: {\n    am: "a",\n    pm: "p",\n    midnight: "mi",\n    noon: "n",\n    morning: "in the morning",\n    afternoon: "in the afternoon",\n    evening: "in the evening",\n    night: "at night"\n  },\n  abbreviated: {\n    am: "AM",\n    pm: "PM",\n    midnight: "midnight",\n    noon: "noon",\n    morning: "in the morning",\n    afternoon: "in the afternoon",\n    evening: "in the evening",\n    night: "at night"\n  },\n  wide: {\n    am: "a.m.",\n    pm: "p.m.",\n    midnight: "midnight",\n    noon: "noon",\n    morning: "in the morning",\n    afternoon: "in the afternoon",\n    evening: "in the evening",\n    night: "at night"\n  }\n}, M0 = (e, t) => {\n  const n = Number(e), r = n % 100;\n  if (r > 20 || r < 10)\n    switch (r % 10) {\n      case 1:\n        return n + "st";\n      case 2:\n        return n + "nd";\n      case 3:\n        return n + "rd";\n    }\n  return n + "th";\n}, C0 = {\n  ordinalNumber: M0,\n  era: ui({\n    values: E0,\n    defaultWidth: "wide"\n  }),\n  quarter: ui({\n    values: O0,\n    defaultWidth: "wide",\n    argumentCallback: (e) => e - 1\n  }),\n  month: ui({\n    values: S0,\n    defaultWidth: "wide"\n  }),\n  day: ui({\n    values: T0,\n    defaultWidth: "wide"\n  }),\n  dayPeriod: ui({\n    values: w0,\n    defaultWidth: "wide",\n    formattingValues: $0,\n    defaultFormattingWidth: "wide"\n  })\n}, A0 = /^(\\d+)(th|st|nd|rd)?/i, L0 = /\\d+/i, k0 = {\n  narrow: /^(b|a)/i,\n  abbreviated: /^(b\\.?\\s?c\\.?|b\\.?\\s?c\\.?\\s?e\\.?|a\\.?\\s?d\\.?|c\\.?\\s?e\\.?)/i,\n  wide: /^(before christ|before common era|anno domini|common era)/i\n}, D0 = {\n  any: [/^b/i, /^(a|c)/i]\n}, R0 = {\n  narrow: /^[1234]/i,\n  abbreviated: /^q[1234]/i,\n  wide: /^[1234](th|st|nd|rd)? quarter/i\n}, I0 = {\n  any: [/1/i, /2/i, /3/i, /4/i]\n}, N0 = {\n  narrow: /^[jfmasond]/i,\n  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,\n  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i\n}, P0 = {\n  narrow: [\n    /^j/i,\n    /^f/i,\n    /^m/i,\n    /^a/i,\n    /^m/i,\n    /^j/i,\n    /^j/i,\n    /^a/i,\n    /^s/i,\n    /^o/i,\n    /^n/i,\n    /^d/i\n  ],\n  any: [\n    /^ja/i,\n    /^f/i,\n    /^mar/i,\n    /^ap/i,\n    /^may/i,\n    /^jun/i,\n    /^jul/i,\n    /^au/i,\n    /^s/i,\n    /^o/i,\n    /^n/i,\n    /^d/i\n  ]\n}, U0 = {\n  narrow: /^[smtwf]/i,\n  short: /^(su|mo|tu|we|th|fr|sa)/i,\n  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,\n  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i\n}, B0 = {\n  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],\n  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]\n}, H0 = {\n  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,\n  any: /^([ap]\\.?\\s?m\\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i\n}, V0 = {\n  any: {\n    am: /^a/i,\n    pm: /^p/i,\n    midnight: /^mi/i,\n    noon: /^no/i,\n    morning: /morning/i,\n    afternoon: /afternoon/i,\n    evening: /evening/i,\n    night: /night/i\n  }\n}, G0 = {\n  ordinalNumber: m0({\n    matchPattern: A0,\n    parsePattern: L0,\n    valueCallback: (e) => parseInt(e, 10)\n  }),\n  era: hi({\n    matchPatterns: k0,\n    defaultMatchWidth: "wide",\n    parsePatterns: D0,\n    defaultParseWidth: "any"\n  }),\n  quarter: hi({\n    matchPatterns: R0,\n    defaultMatchWidth: "wide",\n    parsePatterns: I0,\n    defaultParseWidth: "any",\n    valueCallback: (e) => e + 1\n  }),\n  month: hi({\n    matchPatterns: N0,\n    defaultMatchWidth: "wide",\n    parsePatterns: P0,\n    defaultParseWidth: "any"\n  }),\n  day: hi({\n    matchPatterns: U0,\n    defaultMatchWidth: "wide",\n    parsePatterns: B0,\n    defaultParseWidth: "any"\n  }),\n  dayPeriod: hi({\n    matchPatterns: H0,\n    defaultMatchWidth: "any",\n    parsePatterns: V0,\n    defaultParseWidth: "any"\n  })\n}, z0 = {\n  full: "EEEE, MMMM do, y",\n  long: "MMMM do, y",\n  medium: "MMM d, y",\n  short: "MM/dd/yyyy"\n}, F0 = {\n  full: "h:mm:ss a zzzz",\n  long: "h:mm:ss a z",\n  medium: "h:mm:ss a",\n  short: "h:mm a"\n}, j0 = {\n  full: "{{date}} \'at\' {{time}}",\n  long: "{{date}} \'at\' {{time}}",\n  medium: "{{date}}, {{time}}",\n  short: "{{date}}, {{time}}"\n}, W0 = {\n  date: To({\n    formats: z0,\n    defaultWidth: "full"\n  }),\n  time: To({\n    formats: F0,\n    defaultWidth: "full"\n  }),\n  dateTime: To({\n    formats: j0,\n    defaultWidth: "full"\n  })\n}, df = {\n  code: "en-US",\n  formatDistance: x0,\n  formatLong: W0,\n  formatRelative: _0,\n  localize: C0,\n  match: G0,\n  options: {\n    weekStartsOn: 0,\n    firstWeekContainsDate: 1\n  }\n};\nvar pf = typeof global == "object" && global && global.Object === Object && global, q0 = typeof self == "object" && self && self.Object === Object && self, We = pf || q0 || Function("return this")(), ke = We.Symbol, ff = Object.prototype, Y0 = ff.hasOwnProperty, X0 = ff.toString, di = ke ? ke.toStringTag : void 0;\nfunction Z0(e) {\n  var t = Y0.call(e, di), n = e[di];\n  try {\n    e[di] = void 0;\n    var r = !0;\n  } catch {\n  }\n  var i = X0.call(e);\n  return r && (t ? e[di] = n : delete e[di]), i;\n}\nvar K0 = Object.prototype, Q0 = K0.toString;\nfunction J0(e) {\n  return Q0.call(e);\n}\nvar t1 = "[object Null]", e1 = "[object Undefined]", Iu = ke ? ke.toStringTag : void 0;\nfunction hr(e) {\n  return e == null ? e === void 0 ? e1 : t1 : Iu && Iu in Object(e) ? Z0(e) : J0(e);\n}\nfunction rn(e) {\n  return e != null && typeof e == "object";\n}\nvar n1 = "[object Symbol]";\nfunction Fa(e) {\n  return typeof e == "symbol" || rn(e) && hr(e) == n1;\n}\nfunction fc(e, t) {\n  for (var n = -1, r = e == null ? 0 : e.length, i = Array(r); ++n < r; )\n    i[n] = t(e[n], n, e);\n  return i;\n}\nvar Kt = Array.isArray, Nu = ke ? ke.prototype : void 0, Pu = Nu ? Nu.toString : void 0;\nfunction mf(e) {\n  if (typeof e == "string")\n    return e;\n  if (Kt(e))\n    return fc(e, mf) + "";\n  if (Fa(e))\n    return Pu ? Pu.call(e) : "";\n  var t = e + "";\n  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;\n}\nfunction De(e) {\n  var t = typeof e;\n  return e != null && (t == "object" || t == "function");\n}\nfunction mc(e) {\n  return e;\n}\nvar r1 = "[object AsyncFunction]", i1 = "[object Function]", s1 = "[object GeneratorFunction]", a1 = "[object Proxy]";\nfunction gc(e) {\n  if (!De(e))\n    return !1;\n  var t = hr(e);\n  return t == i1 || t == s1 || t == r1 || t == a1;\n}\nvar wo = We["__core-js_shared__"], Uu = function() {\n  var e = /[^.]+$/.exec(wo && wo.keys && wo.keys.IE_PROTO || "");\n  return e ? "Symbol(src)_1." + e : "";\n}();\nfunction o1(e) {\n  return !!Uu && Uu in e;\n}\nvar l1 = Function.prototype, c1 = l1.toString;\nfunction dr(e) {\n  if (e != null) {\n    try {\n      return c1.call(e);\n    } catch {\n    }\n    try {\n      return e + "";\n    } catch {\n    }\n  }\n  return "";\n}\nvar u1 = /[\\\\^$.*+?()[\\]{}|]/g, h1 = /^\\[object .+?Constructor\\]$/, d1 = Function.prototype, p1 = Object.prototype, f1 = d1.toString, m1 = p1.hasOwnProperty, g1 = RegExp(\n  "^" + f1.call(m1).replace(u1, "\\\\$&").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, "$1.*?") + "$"\n);\nfunction v1(e) {\n  if (!De(e) || o1(e))\n    return !1;\n  var t = gc(e) ? g1 : h1;\n  return t.test(dr(e));\n}\nfunction y1(e, t) {\n  return e == null ? void 0 : e[t];\n}\nfunction pr(e, t) {\n  var n = y1(e, t);\n  return v1(n) ? n : void 0;\n}\nvar ml = pr(We, "WeakMap"), Bu = Object.create, x1 = /* @__PURE__ */ function() {\n  function e() {\n  }\n  return function(t) {\n    if (!De(t))\n      return {};\n    if (Bu)\n      return Bu(t);\n    e.prototype = t;\n    var n = new e();\n    return e.prototype = void 0, n;\n  };\n}();\nfunction b1(e, t, n) {\n  switch (n.length) {\n    case 0:\n      return e.call(t);\n    case 1:\n      return e.call(t, n[0]);\n    case 2:\n      return e.call(t, n[0], n[1]);\n    case 3:\n      return e.call(t, n[0], n[1], n[2]);\n  }\n  return e.apply(t, n);\n}\nfunction _1() {\n}\nfunction gf(e, t) {\n  var n = -1, r = e.length;\n  for (t || (t = Array(r)); ++n < r; )\n    t[n] = e[n];\n  return t;\n}\nvar E1 = 800, O1 = 16, S1 = Date.now;\nfunction T1(e) {\n  var t = 0, n = 0;\n  return function() {\n    var r = S1(), i = O1 - (r - n);\n    if (n = r, i > 0) {\n      if (++t >= E1)\n        return arguments[0];\n    } else\n      t = 0;\n    return e.apply(void 0, arguments);\n  };\n}\nfunction w1(e) {\n  return function() {\n    return e;\n  };\n}\nvar aa = function() {\n  try {\n    var e = pr(Object, "defineProperty");\n    return e({}, "", {}), e;\n  } catch {\n  }\n}(), $1 = aa ? function(e, t) {\n  return aa(e, "toString", {\n    configurable: !0,\n    enumerable: !1,\n    value: w1(t),\n    writable: !0\n  });\n} : mc, vf = T1($1);\nfunction M1(e, t) {\n  for (var n = -1, r = e == null ? 0 : e.length; ++n < r && t(e[n], n, e) !== !1; )\n    ;\n  return e;\n}\nfunction C1(e, t, n, r) {\n  for (var i = e.length, s = n + -1; ++s < i; )\n    if (t(e[s], s, e))\n      return s;\n  return -1;\n}\nfunction A1(e) {\n  return e !== e;\n}\nfunction L1(e, t, n) {\n  for (var r = n - 1, i = e.length; ++r < i; )\n    if (e[r] === t)\n      return r;\n  return -1;\n}\nfunction k1(e, t, n) {\n  return t === t ? L1(e, t, n) : C1(e, A1, n);\n}\nfunction D1(e, t) {\n  var n = e == null ? 0 : e.length;\n  return !!n && k1(e, t, 0) > -1;\n}\nvar R1 = 9007199254740991, I1 = /^(?:0|[1-9]\\d*)$/;\nfunction vc(e, t) {\n  var n = typeof e;\n  return t = t ?? R1, !!t && (n == "number" || n != "symbol" && I1.test(e)) && e > -1 && e % 1 == 0 && e < t;\n}\nfunction ja(e, t, n) {\n  t == "__proto__" && aa ? aa(e, t, {\n    configurable: !0,\n    enumerable: !0,\n    value: n,\n    writable: !0\n  }) : e[t] = n;\n}\nfunction os(e, t) {\n  return e === t || e !== e && t !== t;\n}\nvar N1 = Object.prototype, P1 = N1.hasOwnProperty;\nfunction yf(e, t, n) {\n  var r = e[t];\n  (!(P1.call(e, t) && os(r, n)) || n === void 0 && !(t in e)) && ja(e, t, n);\n}\nfunction ri(e, t, n, r) {\n  var i = !n;\n  n || (n = {});\n  for (var s = -1, a = t.length; ++s < a; ) {\n    var o = t[s], l = void 0;\n    l === void 0 && (l = e[o]), i ? ja(n, o, l) : yf(n, o, l);\n  }\n  return n;\n}\nvar Hu = Math.max;\nfunction xf(e, t, n) {\n  return t = Hu(t === void 0 ? e.length - 1 : t, 0), function() {\n    for (var r = arguments, i = -1, s = Hu(r.length - t, 0), a = Array(s); ++i < s; )\n      a[i] = r[t + i];\n    i = -1;\n    for (var o = Array(t + 1); ++i < t; )\n      o[i] = r[i];\n    return o[t] = n(a), b1(e, this, o);\n  };\n}\nfunction yc(e, t) {\n  return vf(xf(e, t, mc), e + "");\n}\nvar U1 = 9007199254740991;\nfunction xc(e) {\n  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= U1;\n}\nfunction fr(e) {\n  return e != null && xc(e.length) && !gc(e);\n}\nfunction B1(e, t, n) {\n  if (!De(n))\n    return !1;\n  var r = typeof t;\n  return (r == "number" ? fr(n) && vc(t, n.length) : r == "string" && t in n) ? os(n[t], e) : !1;\n}\nfunction H1(e) {\n  return yc(function(t, n) {\n    var r = -1, i = n.length, s = i > 1 ? n[i - 1] : void 0, a = i > 2 ? n[2] : void 0;\n    for (s = e.length > 3 && typeof s == "function" ? (i--, s) : void 0, a && B1(n[0], n[1], a) && (s = i < 3 ? void 0 : s, i = 1), t = Object(t); ++r < i; ) {\n      var o = n[r];\n      o && e(t, o, r, s);\n    }\n    return t;\n  });\n}\nvar V1 = Object.prototype;\nfunction Wa(e) {\n  var t = e && e.constructor, n = typeof t == "function" && t.prototype || V1;\n  return e === n;\n}\nfunction G1(e, t) {\n  for (var n = -1, r = Array(e); ++n < e; )\n    r[n] = t(n);\n  return r;\n}\nvar z1 = "[object Arguments]";\nfunction Vu(e) {\n  return rn(e) && hr(e) == z1;\n}\nvar bf = Object.prototype, F1 = bf.hasOwnProperty, j1 = bf.propertyIsEnumerable, jr = Vu(/* @__PURE__ */ function() {\n  return arguments;\n}()) ? Vu : function(e) {\n  return rn(e) && F1.call(e, "callee") && !j1.call(e, "callee");\n};\nfunction W1() {\n  return !1;\n}\nvar _f = typeof exports == "object" && exports && !exports.nodeType && exports, Gu = _f && typeof module == "object" && module && !module.nodeType && module, q1 = Gu && Gu.exports === _f, zu = q1 ? We.Buffer : void 0, Y1 = zu ? zu.isBuffer : void 0, Wr = Y1 || W1, X1 = "[object Arguments]", Z1 = "[object Array]", K1 = "[object Boolean]", Q1 = "[object Date]", J1 = "[object Error]", ty = "[object Function]", ey = "[object Map]", ny = "[object Number]", ry = "[object Object]", iy = "[object RegExp]", sy = "[object Set]", ay = "[object String]", oy = "[object WeakMap]", ly = "[object ArrayBuffer]", cy = "[object DataView]", uy = "[object Float32Array]", hy = "[object Float64Array]", dy = "[object Int8Array]", py = "[object Int16Array]", fy = "[object Int32Array]", my = "[object Uint8Array]", gy = "[object Uint8ClampedArray]", vy = "[object Uint16Array]", yy = "[object Uint32Array]", Lt = {};\nLt[uy] = Lt[hy] = Lt[dy] = Lt[py] = Lt[fy] = Lt[my] = Lt[gy] = Lt[vy] = Lt[yy] = !0;\nLt[X1] = Lt[Z1] = Lt[ly] = Lt[K1] = Lt[cy] = Lt[Q1] = Lt[J1] = Lt[ty] = Lt[ey] = Lt[ny] = Lt[ry] = Lt[iy] = Lt[sy] = Lt[ay] = Lt[oy] = !1;\nfunction xy(e) {\n  return rn(e) && xc(e.length) && !!Lt[hr(e)];\n}\nfunction bc(e) {\n  return function(t) {\n    return e(t);\n  };\n}\nvar Ef = typeof exports == "object" && exports && !exports.nodeType && exports, Ui = Ef && typeof module == "object" && module && !module.nodeType && module, by = Ui && Ui.exports === Ef, $o = by && pf.process, qr = function() {\n  try {\n    var e = Ui && Ui.require && Ui.require("util").types;\n    return e || $o && $o.binding && $o.binding("util");\n  } catch {\n  }\n}(), Fu = qr && qr.isTypedArray, qa = Fu ? bc(Fu) : xy, _y = Object.prototype, Ey = _y.hasOwnProperty;\nfunction Of(e, t) {\n  var n = Kt(e), r = !n && jr(e), i = !n && !r && Wr(e), s = !n && !r && !i && qa(e), a = n || r || i || s, o = a ? G1(e.length, String) : [], l = o.length;\n  for (var c in e)\n    (t || Ey.call(e, c)) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.\n    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.\n    i && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n    s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.\n    vc(c, l))) && o.push(c);\n  return o;\n}\nfunction Sf(e, t) {\n  return function(n) {\n    return e(t(n));\n  };\n}\nvar Oy = Sf(Object.keys, Object), Sy = Object.prototype, Ty = Sy.hasOwnProperty;\nfunction Tf(e) {\n  if (!Wa(e))\n    return Oy(e);\n  var t = [];\n  for (var n in Object(e))\n    Ty.call(e, n) && n != "constructor" && t.push(n);\n  return t;\n}\nfunction ls(e) {\n  return fr(e) ? Of(e) : Tf(e);\n}\nfunction wy(e) {\n  var t = [];\n  if (e != null)\n    for (var n in Object(e))\n      t.push(n);\n  return t;\n}\nvar $y = Object.prototype, My = $y.hasOwnProperty;\nfunction Cy(e) {\n  if (!De(e))\n    return wy(e);\n  var t = Wa(e), n = [];\n  for (var r in e)\n    r == "constructor" && (t || !My.call(e, r)) || n.push(r);\n  return n;\n}\nfunction cs(e) {\n  return fr(e) ? Of(e, !0) : Cy(e);\n}\nvar Ay = /\\.|\\[(?:[^[\\]]*|(["\'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/, Ly = /^\\w*$/;\nfunction _c(e, t) {\n  if (Kt(e))\n    return !1;\n  var n = typeof e;\n  return n == "number" || n == "symbol" || n == "boolean" || e == null || Fa(e) ? !0 : Ly.test(e) || !Ay.test(e) || t != null && e in Object(t);\n}\nvar qi = pr(Object, "create");\nfunction ky() {\n  this.__data__ = qi ? qi(null) : {}, this.size = 0;\n}\nfunction Dy(e) {\n  var t = this.has(e) && delete this.__data__[e];\n  return this.size -= t ? 1 : 0, t;\n}\nvar Ry = "__lodash_hash_undefined__", Iy = Object.prototype, Ny = Iy.hasOwnProperty;\nfunction Py(e) {\n  var t = this.__data__;\n  if (qi) {\n    var n = t[e];\n    return n === Ry ? void 0 : n;\n  }\n  return Ny.call(t, e) ? t[e] : void 0;\n}\nvar Uy = Object.prototype, By = Uy.hasOwnProperty;\nfunction Hy(e) {\n  var t = this.__data__;\n  return qi ? t[e] !== void 0 : By.call(t, e);\n}\nvar Vy = "__lodash_hash_undefined__";\nfunction Gy(e, t) {\n  var n = this.__data__;\n  return this.size += this.has(e) ? 0 : 1, n[e] = qi && t === void 0 ? Vy : t, this;\n}\nfunction er(e) {\n  var t = -1, n = e == null ? 0 : e.length;\n  for (this.clear(); ++t < n; ) {\n    var r = e[t];\n    this.set(r[0], r[1]);\n  }\n}\ner.prototype.clear = ky;\ner.prototype.delete = Dy;\ner.prototype.get = Py;\ner.prototype.has = Hy;\ner.prototype.set = Gy;\nfunction zy() {\n  this.__data__ = [], this.size = 0;\n}\nfunction Ya(e, t) {\n  for (var n = e.length; n--; )\n    if (os(e[n][0], t))\n      return n;\n  return -1;\n}\nvar Fy = Array.prototype, jy = Fy.splice;\nfunction Wy(e) {\n  var t = this.__data__, n = Ya(t, e);\n  if (n < 0)\n    return !1;\n  var r = t.length - 1;\n  return n == r ? t.pop() : jy.call(t, n, 1), --this.size, !0;\n}\nfunction qy(e) {\n  var t = this.__data__, n = Ya(t, e);\n  return n < 0 ? void 0 : t[n][1];\n}\nfunction Yy(e) {\n  return Ya(this.__data__, e) > -1;\n}\nfunction Xy(e, t) {\n  var n = this.__data__, r = Ya(n, e);\n  return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;\n}\nfunction Ln(e) {\n  var t = -1, n = e == null ? 0 : e.length;\n  for (this.clear(); ++t < n; ) {\n    var r = e[t];\n    this.set(r[0], r[1]);\n  }\n}\nLn.prototype.clear = zy;\nLn.prototype.delete = Wy;\nLn.prototype.get = qy;\nLn.prototype.has = Yy;\nLn.prototype.set = Xy;\nvar Yi = pr(We, "Map");\nfunction Zy() {\n  this.size = 0, this.__data__ = {\n    hash: new er(),\n    map: new (Yi || Ln)(),\n    string: new er()\n  };\n}\nfunction Ky(e) {\n  var t = typeof e;\n  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;\n}\nfunction Xa(e, t) {\n  var n = e.__data__;\n  return Ky(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;\n}\nfunction Qy(e) {\n  var t = Xa(this, e).delete(e);\n  return this.size -= t ? 1 : 0, t;\n}\nfunction Jy(e) {\n  return Xa(this, e).get(e);\n}\nfunction tx(e) {\n  return Xa(this, e).has(e);\n}\nfunction ex(e, t) {\n  var n = Xa(this, e), r = n.size;\n  return n.set(e, t), this.size += n.size == r ? 0 : 1, this;\n}\nfunction kn(e) {\n  var t = -1, n = e == null ? 0 : e.length;\n  for (this.clear(); ++t < n; ) {\n    var r = e[t];\n    this.set(r[0], r[1]);\n  }\n}\nkn.prototype.clear = Zy;\nkn.prototype.delete = Qy;\nkn.prototype.get = Jy;\nkn.prototype.has = tx;\nkn.prototype.set = ex;\nvar nx = "Expected a function";\nfunction Ec(e, t) {\n  if (typeof e != "function" || t != null && typeof t != "function")\n    throw new TypeError(nx);\n  var n = function() {\n    var r = arguments, i = t ? t.apply(this, r) : r[0], s = n.cache;\n    if (s.has(i))\n      return s.get(i);\n    var a = e.apply(this, r);\n    return n.cache = s.set(i, a) || s, a;\n  };\n  return n.cache = new (Ec.Cache || kn)(), n;\n}\nEc.Cache = kn;\nvar rx = 500;\nfunction ix(e) {\n  var t = Ec(e, function(r) {\n    return n.size === rx && n.clear(), r;\n  }), n = t.cache;\n  return t;\n}\nvar sx = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|(["\'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g, ax = /\\\\(\\\\)?/g, ox = ix(function(e) {\n  var t = [];\n  return e.charCodeAt(0) === 46 && t.push(""), e.replace(sx, function(n, r, i, s) {\n    t.push(i ? s.replace(ax, "$1") : r || n);\n  }), t;\n});\nfunction us(e) {\n  return e == null ? "" : mf(e);\n}\nfunction Za(e, t) {\n  return Kt(e) ? e : _c(e, t) ? [e] : ox(us(e));\n}\nfunction hs(e) {\n  if (typeof e == "string" || Fa(e))\n    return e;\n  var t = e + "";\n  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;\n}\nfunction Oc(e, t) {\n  t = Za(t, e);\n  for (var n = 0, r = t.length; e != null && n < r; )\n    e = e[hs(t[n++])];\n  return n && n == r ? e : void 0;\n}\nfunction gt(e, t, n) {\n  var r = e == null ? void 0 : Oc(e, t);\n  return r === void 0 ? n : r;\n}\nfunction Sc(e, t) {\n  for (var n = -1, r = t.length, i = e.length; ++n < r; )\n    e[i + n] = t[n];\n  return e;\n}\nvar ju = ke ? ke.isConcatSpreadable : void 0;\nfunction lx(e) {\n  return Kt(e) || jr(e) || !!(ju && e && e[ju]);\n}\nfunction Ka(e, t, n, r, i) {\n  var s = -1, a = e.length;\n  for (n || (n = lx), i || (i = []); ++s < a; ) {\n    var o = e[s];\n    t > 0 && n(o) ? t > 1 ? Ka(o, t - 1, n, r, i) : Sc(i, o) : r || (i[i.length] = o);\n  }\n  return i;\n}\nvar Tc = Sf(Object.getPrototypeOf, Object), cx = "[object Object]", ux = Function.prototype, hx = Object.prototype, wf = ux.toString, dx = hx.hasOwnProperty, px = wf.call(Object);\nfunction $f(e) {\n  if (!rn(e) || hr(e) != cx)\n    return !1;\n  var t = Tc(e);\n  if (t === null)\n    return !0;\n  var n = dx.call(t, "constructor") && t.constructor;\n  return typeof n == "function" && n instanceof n && wf.call(n) == px;\n}\nfunction fx() {\n  this.__data__ = new Ln(), this.size = 0;\n}\nfunction mx(e) {\n  var t = this.__data__, n = t.delete(e);\n  return this.size = t.size, n;\n}\nfunction gx(e) {\n  return this.__data__.get(e);\n}\nfunction vx(e) {\n  return this.__data__.has(e);\n}\nvar yx = 200;\nfunction xx(e, t) {\n  var n = this.__data__;\n  if (n instanceof Ln) {\n    var r = n.__data__;\n    if (!Yi || r.length < yx - 1)\n      return r.push([e, t]), this.size = ++n.size, this;\n    n = this.__data__ = new kn(r);\n  }\n  return n.set(e, t), this.size = n.size, this;\n}\nfunction Ge(e) {\n  var t = this.__data__ = new Ln(e);\n  this.size = t.size;\n}\nGe.prototype.clear = fx;\nGe.prototype.delete = mx;\nGe.prototype.get = gx;\nGe.prototype.has = vx;\nGe.prototype.set = xx;\nfunction bx(e, t) {\n  return e && ri(t, ls(t), e);\n}\nfunction _x(e, t) {\n  return e && ri(t, cs(t), e);\n}\nvar Mf = typeof exports == "object" && exports && !exports.nodeType && exports, Wu = Mf && typeof module == "object" && module && !module.nodeType && module, Ex = Wu && Wu.exports === Mf, qu = Ex ? We.Buffer : void 0, Yu = qu ? qu.allocUnsafe : void 0;\nfunction Cf(e, t) {\n  if (t)\n    return e.slice();\n  var n = e.length, r = Yu ? Yu(n) : new e.constructor(n);\n  return e.copy(r), r;\n}\nfunction Ox(e, t) {\n  for (var n = -1, r = e == null ? 0 : e.length, i = 0, s = []; ++n < r; ) {\n    var a = e[n];\n    t(a, n, e) && (s[i++] = a);\n  }\n  return s;\n}\nfunction Af() {\n  return [];\n}\nvar Sx = Object.prototype, Tx = Sx.propertyIsEnumerable, Xu = Object.getOwnPropertySymbols, wc = Xu ? function(e) {\n  return e == null ? [] : (e = Object(e), Ox(Xu(e), function(t) {\n    return Tx.call(e, t);\n  }));\n} : Af;\nfunction wx(e, t) {\n  return ri(e, wc(e), t);\n}\nvar $x = Object.getOwnPropertySymbols, Lf = $x ? function(e) {\n  for (var t = []; e; )\n    Sc(t, wc(e)), e = Tc(e);\n  return t;\n} : Af;\nfunction Mx(e, t) {\n  return ri(e, Lf(e), t);\n}\nfunction kf(e, t, n) {\n  var r = t(e);\n  return Kt(e) ? r : Sc(r, n(e));\n}\nfunction gl(e) {\n  return kf(e, ls, wc);\n}\nfunction Df(e) {\n  return kf(e, cs, Lf);\n}\nvar vl = pr(We, "DataView"), yl = pr(We, "Promise"), Vr = pr(We, "Set"), Zu = "[object Map]", Cx = "[object Object]", Ku = "[object Promise]", Qu = "[object Set]", Ju = "[object WeakMap]", th = "[object DataView]", Ax = dr(vl), Lx = dr(Yi), kx = dr(yl), Dx = dr(Vr), Rx = dr(ml), $e = hr;\n(vl && $e(new vl(new ArrayBuffer(1))) != th || Yi && $e(new Yi()) != Zu || yl && $e(yl.resolve()) != Ku || Vr && $e(new Vr()) != Qu || ml && $e(new ml()) != Ju) && ($e = function(e) {\n  var t = hr(e), n = t == Cx ? e.constructor : void 0, r = n ? dr(n) : "";\n  if (r)\n    switch (r) {\n      case Ax:\n        return th;\n      case Lx:\n        return Zu;\n      case kx:\n        return Ku;\n      case Dx:\n        return Qu;\n      case Rx:\n        return Ju;\n    }\n  return t;\n});\nvar Ix = Object.prototype, Nx = Ix.hasOwnProperty;\nfunction Px(e) {\n  var t = e.length, n = new e.constructor(t);\n  return t && typeof e[0] == "string" && Nx.call(e, "index") && (n.index = e.index, n.input = e.input), n;\n}\nvar oa = We.Uint8Array;\nfunction $c(e) {\n  var t = new e.constructor(e.byteLength);\n  return new oa(t).set(new oa(e)), t;\n}\nfunction Ux(e, t) {\n  var n = t ? $c(e.buffer) : e.buffer;\n  return new e.constructor(n, e.byteOffset, e.byteLength);\n}\nvar Bx = /\\w*$/;\nfunction Hx(e) {\n  var t = new e.constructor(e.source, Bx.exec(e));\n  return t.lastIndex = e.lastIndex, t;\n}\nvar eh = ke ? ke.prototype : void 0, nh = eh ? eh.valueOf : void 0;\nfunction Vx(e) {\n  return nh ? Object(nh.call(e)) : {};\n}\nfunction Rf(e, t) {\n  var n = t ? $c(e.buffer) : e.buffer;\n  return new e.constructor(n, e.byteOffset, e.length);\n}\nvar Gx = "[object Boolean]", zx = "[object Date]", Fx = "[object Map]", jx = "[object Number]", Wx = "[object RegExp]", qx = "[object Set]", Yx = "[object String]", Xx = "[object Symbol]", Zx = "[object ArrayBuffer]", Kx = "[object DataView]", Qx = "[object Float32Array]", Jx = "[object Float64Array]", tb = "[object Int8Array]", eb = "[object Int16Array]", nb = "[object Int32Array]", rb = "[object Uint8Array]", ib = "[object Uint8ClampedArray]", sb = "[object Uint16Array]", ab = "[object Uint32Array]";\nfunction ob(e, t, n) {\n  var r = e.constructor;\n  switch (t) {\n    case Zx:\n      return $c(e);\n    case Gx:\n    case zx:\n      return new r(+e);\n    case Kx:\n      return Ux(e, n);\n    case Qx:\n    case Jx:\n    case tb:\n    case eb:\n    case nb:\n    case rb:\n    case ib:\n    case sb:\n    case ab:\n      return Rf(e, n);\n    case Fx:\n      return new r();\n    case jx:\n    case Yx:\n      return new r(e);\n    case Wx:\n      return Hx(e);\n    case qx:\n      return new r();\n    case Xx:\n      return Vx(e);\n  }\n}\nfunction If(e) {\n  return typeof e.constructor == "function" && !Wa(e) ? x1(Tc(e)) : {};\n}\nvar lb = "[object Map]";\nfunction cb(e) {\n  return rn(e) && $e(e) == lb;\n}\nvar rh = qr && qr.isMap, ub = rh ? bc(rh) : cb, hb = "[object Set]";\nfunction db(e) {\n  return rn(e) && $e(e) == hb;\n}\nvar ih = qr && qr.isSet, pb = ih ? bc(ih) : db, fb = 1, mb = 2, gb = 4, Nf = "[object Arguments]", vb = "[object Array]", yb = "[object Boolean]", xb = "[object Date]", bb = "[object Error]", Pf = "[object Function]", _b = "[object GeneratorFunction]", Eb = "[object Map]", Ob = "[object Number]", Uf = "[object Object]", Sb = "[object RegExp]", Tb = "[object Set]", wb = "[object String]", $b = "[object Symbol]", Mb = "[object WeakMap]", Cb = "[object ArrayBuffer]", Ab = "[object DataView]", Lb = "[object Float32Array]", kb = "[object Float64Array]", Db = "[object Int8Array]", Rb = "[object Int16Array]", Ib = "[object Int32Array]", Nb = "[object Uint8Array]", Pb = "[object Uint8ClampedArray]", Ub = "[object Uint16Array]", Bb = "[object Uint32Array]", $t = {};\n$t[Nf] = $t[vb] = $t[Cb] = $t[Ab] = $t[yb] = $t[xb] = $t[Lb] = $t[kb] = $t[Db] = $t[Rb] = $t[Ib] = $t[Eb] = $t[Ob] = $t[Uf] = $t[Sb] = $t[Tb] = $t[wb] = $t[$b] = $t[Nb] = $t[Pb] = $t[Ub] = $t[Bb] = !0;\n$t[bb] = $t[Pf] = $t[Mb] = !1;\nfunction Bi(e, t, n, r, i, s) {\n  var a, o = t & fb, l = t & mb, c = t & gb;\n  if (n && (a = i ? n(e, r, i, s) : n(e)), a !== void 0)\n    return a;\n  if (!De(e))\n    return e;\n  var u = Kt(e);\n  if (u) {\n    if (a = Px(e), !o)\n      return gf(e, a);\n  } else {\n    var d = $e(e), h = d == Pf || d == _b;\n    if (Wr(e))\n      return Cf(e, o);\n    if (d == Uf || d == Nf || h && !i) {\n      if (a = l || h ? {} : If(e), !o)\n        return l ? Mx(e, _x(a, e)) : wx(e, bx(a, e));\n    } else {\n      if (!$t[d])\n        return i ? e : {};\n      a = ob(e, d, o);\n    }\n  }\n  s || (s = new Ge());\n  var p = s.get(e);\n  if (p)\n    return p;\n  s.set(e, a), pb(e) ? e.forEach(function(m) {\n    a.add(Bi(m, t, n, m, e, s));\n  }) : ub(e) && e.forEach(function(m, v) {\n    a.set(v, Bi(m, t, n, v, e, s));\n  });\n  var f = c ? l ? Df : gl : l ? cs : ls, g = u ? void 0 : f(e);\n  return M1(g || e, function(m, v) {\n    g && (v = m, m = e[v]), yf(a, v, Bi(m, t, n, v, e, s));\n  }), a;\n}\nvar Hb = 1, Vb = 4;\nfunction Sn(e) {\n  return Bi(e, Hb | Vb);\n}\nvar Gb = "__lodash_hash_undefined__";\nfunction zb(e) {\n  return this.__data__.set(e, Gb), this;\n}\nfunction Fb(e) {\n  return this.__data__.has(e);\n}\nfunction Xi(e) {\n  var t = -1, n = e == null ? 0 : e.length;\n  for (this.__data__ = new kn(); ++t < n; )\n    this.add(e[t]);\n}\nXi.prototype.add = Xi.prototype.push = zb;\nXi.prototype.has = Fb;\nfunction Bf(e, t) {\n  for (var n = -1, r = e == null ? 0 : e.length; ++n < r; )\n    if (t(e[n], n, e))\n      return !0;\n  return !1;\n}\nfunction Hf(e, t) {\n  return e.has(t);\n}\nvar jb = 1, Wb = 2;\nfunction Vf(e, t, n, r, i, s) {\n  var a = n & jb, o = e.length, l = t.length;\n  if (o != l && !(a && l > o))\n    return !1;\n  var c = s.get(e), u = s.get(t);\n  if (c && u)\n    return c == t && u == e;\n  var d = -1, h = !0, p = n & Wb ? new Xi() : void 0;\n  for (s.set(e, t), s.set(t, e); ++d < o; ) {\n    var f = e[d], g = t[d];\n    if (r)\n      var m = a ? r(g, f, d, t, e, s) : r(f, g, d, e, t, s);\n    if (m !== void 0) {\n      if (m)\n        continue;\n      h = !1;\n      break;\n    }\n    if (p) {\n      if (!Bf(t, function(v, x) {\n        if (!Hf(p, x) && (f === v || i(f, v, n, r, s)))\n          return p.push(x);\n      })) {\n        h = !1;\n        break;\n      }\n    } else if (!(f === g || i(f, g, n, r, s))) {\n      h = !1;\n      break;\n    }\n  }\n  return s.delete(e), s.delete(t), h;\n}\nfunction qb(e) {\n  var t = -1, n = Array(e.size);\n  return e.forEach(function(r, i) {\n    n[++t] = [i, r];\n  }), n;\n}\nfunction Mc(e) {\n  var t = -1, n = Array(e.size);\n  return e.forEach(function(r) {\n    n[++t] = r;\n  }), n;\n}\nvar Yb = 1, Xb = 2, Zb = "[object Boolean]", Kb = "[object Date]", Qb = "[object Error]", Jb = "[object Map]", t_ = "[object Number]", e_ = "[object RegExp]", n_ = "[object Set]", r_ = "[object String]", i_ = "[object Symbol]", s_ = "[object ArrayBuffer]", a_ = "[object DataView]", sh = ke ? ke.prototype : void 0, Mo = sh ? sh.valueOf : void 0;\nfunction o_(e, t, n, r, i, s, a) {\n  switch (n) {\n    case a_:\n      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)\n        return !1;\n      e = e.buffer, t = t.buffer;\n    case s_:\n      return !(e.byteLength != t.byteLength || !s(new oa(e), new oa(t)));\n    case Zb:\n    case Kb:\n    case t_:\n      return os(+e, +t);\n    case Qb:\n      return e.name == t.name && e.message == t.message;\n    case e_:\n    case r_:\n      return e == t + "";\n    case Jb:\n      var o = qb;\n    case n_:\n      var l = r & Yb;\n      if (o || (o = Mc), e.size != t.size && !l)\n        return !1;\n      var c = a.get(e);\n      if (c)\n        return c == t;\n      r |= Xb, a.set(e, t);\n      var u = Vf(o(e), o(t), r, i, s, a);\n      return a.delete(e), u;\n    case i_:\n      if (Mo)\n        return Mo.call(e) == Mo.call(t);\n  }\n  return !1;\n}\nvar l_ = 1, c_ = Object.prototype, u_ = c_.hasOwnProperty;\nfunction h_(e, t, n, r, i, s) {\n  var a = n & l_, o = gl(e), l = o.length, c = gl(t), u = c.length;\n  if (l != u && !a)\n    return !1;\n  for (var d = l; d--; ) {\n    var h = o[d];\n    if (!(a ? h in t : u_.call(t, h)))\n      return !1;\n  }\n  var p = s.get(e), f = s.get(t);\n  if (p && f)\n    return p == t && f == e;\n  var g = !0;\n  s.set(e, t), s.set(t, e);\n  for (var m = a; ++d < l; ) {\n    h = o[d];\n    var v = e[h], x = t[h];\n    if (r)\n      var _ = a ? r(x, v, h, t, e, s) : r(v, x, h, e, t, s);\n    if (!(_ === void 0 ? v === x || i(v, x, n, r, s) : _)) {\n      g = !1;\n      break;\n    }\n    m || (m = h == "constructor");\n  }\n  if (g && !m) {\n    var E = e.constructor, b = t.constructor;\n    E != b && "constructor" in e && "constructor" in t && !(typeof E == "function" && E instanceof E && typeof b == "function" && b instanceof b) && (g = !1);\n  }\n  return s.delete(e), s.delete(t), g;\n}\nvar d_ = 1, ah = "[object Arguments]", oh = "[object Array]", Ts = "[object Object]", p_ = Object.prototype, lh = p_.hasOwnProperty;\nfunction f_(e, t, n, r, i, s) {\n  var a = Kt(e), o = Kt(t), l = a ? oh : $e(e), c = o ? oh : $e(t);\n  l = l == ah ? Ts : l, c = c == ah ? Ts : c;\n  var u = l == Ts, d = c == Ts, h = l == c;\n  if (h && Wr(e)) {\n    if (!Wr(t))\n      return !1;\n    a = !0, u = !1;\n  }\n  if (h && !u)\n    return s || (s = new Ge()), a || qa(e) ? Vf(e, t, n, r, i, s) : o_(e, t, l, n, r, i, s);\n  if (!(n & d_)) {\n    var p = u && lh.call(e, "__wrapped__"), f = d && lh.call(t, "__wrapped__");\n    if (p || f) {\n      var g = p ? e.value() : e, m = f ? t.value() : t;\n      return s || (s = new Ge()), i(g, m, n, r, s);\n    }\n  }\n  return h ? (s || (s = new Ge()), h_(e, t, n, r, i, s)) : !1;\n}\nfunction Qa(e, t, n, r, i) {\n  return e === t ? !0 : e == null || t == null || !rn(e) && !rn(t) ? e !== e && t !== t : f_(e, t, n, r, Qa, i);\n}\nvar m_ = 1, g_ = 2;\nfunction v_(e, t, n, r) {\n  var i = n.length, s = i;\n  if (e == null)\n    return !s;\n  for (e = Object(e); i--; ) {\n    var a = n[i];\n    if (a[2] ? a[1] !== e[a[0]] : !(a[0] in e))\n      return !1;\n  }\n  for (; ++i < s; ) {\n    a = n[i];\n    var o = a[0], l = e[o], c = a[1];\n    if (a[2]) {\n      if (l === void 0 && !(o in e))\n        return !1;\n    } else {\n      var u = new Ge(), d;\n      if (!(d === void 0 ? Qa(c, l, m_ | g_, r, u) : d))\n        return !1;\n    }\n  }\n  return !0;\n}\nfunction Gf(e) {\n  return e === e && !De(e);\n}\nfunction y_(e) {\n  for (var t = ls(e), n = t.length; n--; ) {\n    var r = t[n], i = e[r];\n    t[n] = [r, i, Gf(i)];\n  }\n  return t;\n}\nfunction zf(e, t) {\n  return function(n) {\n    return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));\n  };\n}\nfunction x_(e) {\n  var t = y_(e);\n  return t.length == 1 && t[0][2] ? zf(t[0][0], t[0][1]) : function(n) {\n    return n === e || v_(n, e, t);\n  };\n}\nfunction b_(e, t) {\n  return e != null && t in Object(e);\n}\nfunction __(e, t, n) {\n  t = Za(t, e);\n  for (var r = -1, i = t.length, s = !1; ++r < i; ) {\n    var a = hs(t[r]);\n    if (!(s = e != null && n(e, a)))\n      break;\n    e = e[a];\n  }\n  return s || ++r != i ? s : (i = e == null ? 0 : e.length, !!i && xc(i) && vc(a, i) && (Kt(e) || jr(e)));\n}\nfunction E_(e, t) {\n  return e != null && __(e, t, b_);\n}\nvar O_ = 1, S_ = 2;\nfunction T_(e, t) {\n  return _c(e) && Gf(t) ? zf(hs(e), t) : function(n) {\n    var r = gt(n, e);\n    return r === void 0 && r === t ? E_(n, e) : Qa(t, r, O_ | S_);\n  };\n}\nfunction w_(e) {\n  return function(t) {\n    return t == null ? void 0 : t[e];\n  };\n}\nfunction $_(e) {\n  return function(t) {\n    return Oc(t, e);\n  };\n}\nfunction M_(e) {\n  return _c(e) ? w_(hs(e)) : $_(e);\n}\nfunction Ja(e) {\n  return typeof e == "function" ? e : e == null ? mc : typeof e == "object" ? Kt(e) ? T_(e[0], e[1]) : x_(e) : M_(e);\n}\nfunction C_(e) {\n  return function(t, n, r) {\n    for (var i = -1, s = Object(t), a = r(t), o = a.length; o--; ) {\n      var l = a[++i];\n      if (n(s[l], l, s) === !1)\n        break;\n    }\n    return t;\n  };\n}\nvar Ff = C_();\nfunction xl(e, t, n) {\n  (n !== void 0 && !os(e[t], n) || n === void 0 && !(t in e)) && ja(e, t, n);\n}\nfunction bl(e) {\n  return rn(e) && fr(e);\n}\nfunction _l(e, t) {\n  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")\n    return e[t];\n}\nfunction A_(e) {\n  return ri(e, cs(e));\n}\nfunction L_(e, t, n, r, i, s, a) {\n  var o = _l(e, n), l = _l(t, n), c = a.get(l);\n  if (c) {\n    xl(e, n, c);\n    return;\n  }\n  var u = s ? s(o, l, n + "", e, t, a) : void 0, d = u === void 0;\n  if (d) {\n    var h = Kt(l), p = !h && Wr(l), f = !h && !p && qa(l);\n    u = l, h || p || f ? Kt(o) ? u = o : bl(o) ? u = gf(o) : p ? (d = !1, u = Cf(l, !0)) : f ? (d = !1, u = Rf(l, !0)) : u = [] : $f(l) || jr(l) ? (u = o, jr(o) ? u = A_(o) : (!De(o) || gc(o)) && (u = If(l))) : d = !1;\n  }\n  d && (a.set(l, u), i(u, l, r, s, a), a.delete(l)), xl(e, n, u);\n}\nfunction jf(e, t, n, r, i) {\n  e !== t && Ff(t, function(s, a) {\n    if (i || (i = new Ge()), De(s))\n      L_(e, t, a, n, jf, r, i);\n    else {\n      var o = r ? r(_l(e, a), s, a + "", e, t, i) : void 0;\n      o === void 0 && (o = s), xl(e, a, o);\n    }\n  }, cs);\n}\nfunction Wf(e) {\n  var t = e == null ? 0 : e.length;\n  return t ? e[t - 1] : void 0;\n}\nvar k_ = "[object Map]", D_ = "[object Set]", R_ = Object.prototype, I_ = R_.hasOwnProperty;\nfunction Be(e) {\n  if (e == null)\n    return !0;\n  if (fr(e) && (Kt(e) || typeof e == "string" || typeof e.splice == "function" || Wr(e) || qa(e) || jr(e)))\n    return !e.length;\n  var t = $e(e);\n  if (t == k_ || t == D_)\n    return !e.size;\n  if (Wa(e))\n    return !Tf(e).length;\n  for (var n in e)\n    if (I_.call(e, n))\n      return !1;\n  return !0;\n}\nvar at = H1(function(e, t, n) {\n  jf(e, t, n);\n}), N_ = 1 / 0, P_ = Vr && 1 / Mc(new Vr([, -0]))[1] == N_ ? function(e) {\n  return new Vr(e);\n} : _1, U_ = 200;\nfunction qf(e, t, n) {\n  var r = -1, i = D1, s = e.length, a = !0, o = [], l = o;\n  if (s >= U_) {\n    var c = t ? null : P_(e);\n    if (c)\n      return Mc(c);\n    a = !1, i = Hf, l = new Xi();\n  } else\n    l = t ? [] : o;\n  t:\n    for (; ++r < s; ) {\n      var u = e[r], d = t ? t(u) : u;\n      if (u = u !== 0 ? u : 0, a && d === d) {\n        for (var h = l.length; h--; )\n          if (l[h] === d)\n            continue t;\n        t && l.push(d), o.push(u);\n      } else i(l, d, n) || (l !== o && l.push(d), o.push(u));\n    }\n  return o;\n}\nvar B_ = yc(function(e) {\n  var t = Wf(e);\n  return bl(t) && (t = void 0), qf(Ka(e, 1, bl, !0), Ja(t));\n});\nfunction Zi(e) {\n  return e && e.length ? qf(e) : [];\n}\nfunction Jn(e, t) {\n  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;\n}\nfunction H_(e, t) {\n  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;\n}\nfunction Cc(e) {\n  let t, n, r;\n  e.length !== 2 ? (t = Jn, n = (o, l) => Jn(e(o), l), r = (o, l) => e(o) - l) : (t = e === Jn || e === H_ ? e : V_, n = e, r = e);\n  function i(o, l, c = 0, u = o.length) {\n    if (c < u) {\n      if (t(l, l) !== 0) return u;\n      do {\n        const d = c + u >>> 1;\n        n(o[d], l) < 0 ? c = d + 1 : u = d;\n      } while (c < u);\n    }\n    return c;\n  }\n  function s(o, l, c = 0, u = o.length) {\n    if (c < u) {\n      if (t(l, l) !== 0) return u;\n      do {\n        const d = c + u >>> 1;\n        n(o[d], l) <= 0 ? c = d + 1 : u = d;\n      } while (c < u);\n    }\n    return c;\n  }\n  function a(o, l, c = 0, u = o.length) {\n    const d = i(o, l, c, u - 1);\n    return d > c && r(o[d - 1], l) > -r(o[d], l) ? d - 1 : d;\n  }\n  return { left: i, center: a, right: s };\n}\nfunction V_() {\n  return 0;\n}\nfunction G_(e) {\n  return e === null ? NaN : +e;\n}\nfunction* z_(e, t) {\n  for (let n of e)\n    n != null && (n = +n) >= n && (yield n);\n}\nconst F_ = Cc(Jn), Ac = F_.right;\nCc(G_).center;\nfunction ze(e, t) {\n  let n, r;\n  if (t === void 0)\n    for (const i of e)\n      i != null && (n === void 0 ? i >= i && (n = r = i) : (n > i && (n = i), r < i && (r = i)));\n  else {\n    let i = -1;\n    for (let s of e)\n      (s = t(s, ++i, e)) != null && (n === void 0 ? s >= s && (n = r = s) : (n > s && (n = s), r < s && (r = s)));\n  }\n  return [n, r];\n}\nlet ch = class extends Map {\n  constructor(t, n = q_) {\n    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null) for (const [r, i] of t) this.set(r, i);\n  }\n  get(t) {\n    return super.get(uh(this, t));\n  }\n  has(t) {\n    return super.has(uh(this, t));\n  }\n  set(t, n) {\n    return super.set(j_(this, t), n);\n  }\n  delete(t) {\n    return super.delete(W_(this, t));\n  }\n};\nfunction uh({ _intern: e, _key: t }, n) {\n  const r = t(n);\n  return e.has(r) ? e.get(r) : n;\n}\nfunction j_({ _intern: e, _key: t }, n) {\n  const r = t(n);\n  return e.has(r) ? e.get(r) : (e.set(r, n), n);\n}\nfunction W_({ _intern: e, _key: t }, n) {\n  const r = t(n);\n  return e.has(r) && (n = e.get(r), e.delete(r)), n;\n}\nfunction q_(e) {\n  return e !== null && typeof e == "object" ? e.valueOf() : e;\n}\nconst Y_ = Math.sqrt(50), X_ = Math.sqrt(10), Z_ = Math.sqrt(2);\nfunction la(e, t, n) {\n  const r = (t - e) / Math.max(0, n), i = Math.floor(Math.log10(r)), s = r / Math.pow(10, i), a = s >= Y_ ? 10 : s >= X_ ? 5 : s >= Z_ ? 2 : 1;\n  let o, l, c;\n  return i < 0 ? (c = Math.pow(10, -i) / a, o = Math.round(e * c), l = Math.round(t * c), o / c < e && ++o, l / c > t && --l, c = -c) : (c = Math.pow(10, i) * a, o = Math.round(e / c), l = Math.round(t / c), o * c < e && ++o, l * c > t && --l), l < o && 0.5 <= n && n < 2 ? la(e, t, n * 2) : [o, l, c];\n}\nfunction ca(e, t, n) {\n  if (t = +t, e = +e, n = +n, !(n > 0)) return [];\n  if (e === t) return [e];\n  const r = t < e, [i, s, a] = r ? la(t, e, n) : la(e, t, n);\n  if (!(s >= i)) return [];\n  const o = s - i + 1, l = new Array(o);\n  if (r)\n    if (a < 0) for (let c = 0; c < o; ++c) l[c] = (s - c) / -a;\n    else for (let c = 0; c < o; ++c) l[c] = (s - c) * a;\n  else if (a < 0) for (let c = 0; c < o; ++c) l[c] = (i + c) / -a;\n  else for (let c = 0; c < o; ++c) l[c] = (i + c) * a;\n  return l;\n}\nfunction Yr(e, t, n) {\n  return t = +t, e = +e, n = +n, la(e, t, n)[2];\n}\nfunction El(e, t, n) {\n  t = +t, e = +e, n = +n;\n  const r = t < e, i = r ? Yr(t, e, n) : Yr(e, t, n);\n  return (r ? -1 : 1) * (i < 0 ? 1 / -i : i);\n}\nfunction nr(e, t) {\n  let n;\n  if (t === void 0)\n    for (const r of e)\n      r != null && (n < r || n === void 0 && r >= r) && (n = r);\n  else {\n    let r = -1;\n    for (let i of e)\n      (i = t(i, ++r, e)) != null && (n < i || n === void 0 && i >= i) && (n = i);\n  }\n  return n;\n}\nfunction Bn(e, t) {\n  let n;\n  for (const r of e)\n    r != null && (n > r || n === void 0 && r >= r) && (n = r);\n  return n;\n}\nvar K_ = { value: () => {\n} };\nfunction Lc() {\n  for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {\n    if (!(r = arguments[e] + "") || r in n || /[\\s.]/.test(r)) throw new Error("illegal type: " + r);\n    n[r] = [];\n  }\n  return new Ys(n);\n}\nfunction Ys(e) {\n  this._ = e;\n}\nfunction Q_(e, t) {\n  return e.trim().split(/^|\\s+/).map(function(n) {\n    var r = "", i = n.indexOf(".");\n    if (i >= 0 && (r = n.slice(i + 1), n = n.slice(0, i)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);\n    return { type: n, name: r };\n  });\n}\nYs.prototype = Lc.prototype = {\n  constructor: Ys,\n  on: function(e, t) {\n    var n = this._, r = Q_(e + "", n), i, s = -1, a = r.length;\n    if (arguments.length < 2) {\n      for (; ++s < a; ) if ((i = (e = r[s]).type) && (i = J_(n[i], e.name))) return i;\n      return;\n    }\n    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);\n    for (; ++s < a; )\n      if (i = (e = r[s]).type) n[i] = hh(n[i], e.name, t);\n      else if (t == null) for (i in n) n[i] = hh(n[i], e.name, null);\n    return this;\n  },\n  copy: function() {\n    var e = {}, t = this._;\n    for (var n in t) e[n] = t[n].slice();\n    return new Ys(e);\n  },\n  call: function(e, t) {\n    if ((i = arguments.length - 2) > 0) for (var n = new Array(i), r = 0, i, s; r < i; ++r) n[r] = arguments[r + 2];\n    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);\n    for (s = this._[e], r = 0, i = s.length; r < i; ++r) s[r].value.apply(t, n);\n  },\n  apply: function(e, t, n) {\n    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);\n    for (var r = this._[e], i = 0, s = r.length; i < s; ++i) r[i].value.apply(t, n);\n  }\n};\nfunction J_(e, t) {\n  for (var n = 0, r = e.length, i; n < r; ++n)\n    if ((i = e[n]).name === t)\n      return i.value;\n}\nfunction hh(e, t, n) {\n  for (var r = 0, i = e.length; r < i; ++r)\n    if (e[r].name === t) {\n      e[r] = K_, e = e.slice(0, r).concat(e.slice(r + 1));\n      break;\n    }\n  return n != null && e.push({ name: t, value: n }), e;\n}\nvar Ol = "http://www.w3.org/1999/xhtml";\nconst dh = {\n  svg: "http://www.w3.org/2000/svg",\n  xhtml: Ol,\n  xlink: "http://www.w3.org/1999/xlink",\n  xml: "http://www.w3.org/XML/1998/namespace",\n  xmlns: "http://www.w3.org/2000/xmlns/"\n};\nfunction to(e) {\n  var t = e += "", n = t.indexOf(":");\n  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), dh.hasOwnProperty(t) ? { space: dh[t], local: e } : e;\n}\nfunction tE(e) {\n  return function() {\n    var t = this.ownerDocument, n = this.namespaceURI;\n    return n === Ol && t.documentElement.namespaceURI === Ol ? t.createElement(e) : t.createElementNS(n, e);\n  };\n}\nfunction eE(e) {\n  return function() {\n    return this.ownerDocument.createElementNS(e.space, e.local);\n  };\n}\nfunction Yf(e) {\n  var t = to(e);\n  return (t.local ? eE : tE)(t);\n}\nfunction nE() {\n}\nfunction kc(e) {\n  return e == null ? nE : function() {\n    return this.querySelector(e);\n  };\n}\nfunction rE(e) {\n  typeof e != "function" && (e = kc(e));\n  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)\n    for (var s = t[i], a = s.length, o = r[i] = new Array(a), l, c, u = 0; u < a; ++u)\n      (l = s[u]) && (c = e.call(l, l.__data__, u, s)) && ("__data__" in l && (c.__data__ = l.__data__), o[u] = c);\n  return new _e(r, this._parents);\n}\nfunction iE(e) {\n  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);\n}\nfunction sE() {\n  return [];\n}\nfunction Xf(e) {\n  return e == null ? sE : function() {\n    return this.querySelectorAll(e);\n  };\n}\nfunction aE(e) {\n  return function() {\n    return iE(e.apply(this, arguments));\n  };\n}\nfunction oE(e) {\n  typeof e == "function" ? e = aE(e) : e = Xf(e);\n  for (var t = this._groups, n = t.length, r = [], i = [], s = 0; s < n; ++s)\n    for (var a = t[s], o = a.length, l, c = 0; c < o; ++c)\n      (l = a[c]) && (r.push(e.call(l, l.__data__, c, a)), i.push(l));\n  return new _e(r, i);\n}\nfunction Zf(e) {\n  return function() {\n    return this.matches(e);\n  };\n}\nfunction Kf(e) {\n  return function(t) {\n    return t.matches(e);\n  };\n}\nvar lE = Array.prototype.find;\nfunction cE(e) {\n  return function() {\n    return lE.call(this.children, e);\n  };\n}\nfunction uE() {\n  return this.firstElementChild;\n}\nfunction hE(e) {\n  return this.select(e == null ? uE : cE(typeof e == "function" ? e : Kf(e)));\n}\nvar dE = Array.prototype.filter;\nfunction pE() {\n  return Array.from(this.children);\n}\nfunction fE(e) {\n  return function() {\n    return dE.call(this.children, e);\n  };\n}\nfunction mE(e) {\n  return this.selectAll(e == null ? pE : fE(typeof e == "function" ? e : Kf(e)));\n}\nfunction gE(e) {\n  typeof e != "function" && (e = Zf(e));\n  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)\n    for (var s = t[i], a = s.length, o = r[i] = [], l, c = 0; c < a; ++c)\n      (l = s[c]) && e.call(l, l.__data__, c, s) && o.push(l);\n  return new _e(r, this._parents);\n}\nfunction Qf(e) {\n  return new Array(e.length);\n}\nfunction vE() {\n  return new _e(this._enter || this._groups.map(Qf), this._parents);\n}\nfunction ua(e, t) {\n  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;\n}\nua.prototype = {\n  constructor: ua,\n  appendChild: function(e) {\n    return this._parent.insertBefore(e, this._next);\n  },\n  insertBefore: function(e, t) {\n    return this._parent.insertBefore(e, t);\n  },\n  querySelector: function(e) {\n    return this._parent.querySelector(e);\n  },\n  querySelectorAll: function(e) {\n    return this._parent.querySelectorAll(e);\n  }\n};\nfunction yE(e) {\n  return function() {\n    return e;\n  };\n}\nfunction xE(e, t, n, r, i, s) {\n  for (var a = 0, o, l = t.length, c = s.length; a < c; ++a)\n    (o = t[a]) ? (o.__data__ = s[a], r[a] = o) : n[a] = new ua(e, s[a]);\n  for (; a < l; ++a)\n    (o = t[a]) && (i[a] = o);\n}\nfunction bE(e, t, n, r, i, s, a) {\n  var o, l, c = /* @__PURE__ */ new Map(), u = t.length, d = s.length, h = new Array(u), p;\n  for (o = 0; o < u; ++o)\n    (l = t[o]) && (h[o] = p = a.call(l, l.__data__, o, t) + "", c.has(p) ? i[o] = l : c.set(p, l));\n  for (o = 0; o < d; ++o)\n    p = a.call(e, s[o], o, s) + "", (l = c.get(p)) ? (r[o] = l, l.__data__ = s[o], c.delete(p)) : n[o] = new ua(e, s[o]);\n  for (o = 0; o < u; ++o)\n    (l = t[o]) && c.get(h[o]) === l && (i[o] = l);\n}\nfunction _E(e) {\n  return e.__data__;\n}\nfunction EE(e, t) {\n  if (!arguments.length) return Array.from(this, _E);\n  var n = t ? bE : xE, r = this._parents, i = this._groups;\n  typeof e != "function" && (e = yE(e));\n  for (var s = i.length, a = new Array(s), o = new Array(s), l = new Array(s), c = 0; c < s; ++c) {\n    var u = r[c], d = i[c], h = d.length, p = OE(e.call(u, u && u.__data__, c, r)), f = p.length, g = o[c] = new Array(f), m = a[c] = new Array(f), v = l[c] = new Array(h);\n    n(u, d, g, m, v, p, t);\n    for (var x = 0, _ = 0, E, b; x < f; ++x)\n      if (E = g[x]) {\n        for (x >= _ && (_ = x + 1); !(b = m[_]) && ++_ < f; ) ;\n        E._next = b || null;\n      }\n  }\n  return a = new _e(a, r), a._enter = o, a._exit = l, a;\n}\nfunction OE(e) {\n  return typeof e == "object" && "length" in e ? e : Array.from(e);\n}\nfunction SE() {\n  return new _e(this._exit || this._groups.map(Qf), this._parents);\n}\nfunction TE(e, t, n) {\n  var r = this.enter(), i = this, s = this.exit();\n  return typeof e == "function" ? (r = e(r), r && (r = r.selection())) : r = r.append(e + ""), t != null && (i = t(i), i && (i = i.selection())), n == null ? s.remove() : n(s), r && i ? r.merge(i).order() : i;\n}\nfunction wE(e) {\n  for (var t = e.selection ? e.selection() : e, n = this._groups, r = t._groups, i = n.length, s = r.length, a = Math.min(i, s), o = new Array(i), l = 0; l < a; ++l)\n    for (var c = n[l], u = r[l], d = c.length, h = o[l] = new Array(d), p, f = 0; f < d; ++f)\n      (p = c[f] || u[f]) && (h[f] = p);\n  for (; l < i; ++l)\n    o[l] = n[l];\n  return new _e(o, this._parents);\n}\nfunction $E() {\n  for (var e = this._groups, t = -1, n = e.length; ++t < n; )\n    for (var r = e[t], i = r.length - 1, s = r[i], a; --i >= 0; )\n      (a = r[i]) && (s && a.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(a, s), s = a);\n  return this;\n}\nfunction ME(e) {\n  e || (e = CE);\n  function t(d, h) {\n    return d && h ? e(d.__data__, h.__data__) : !d - !h;\n  }\n  for (var n = this._groups, r = n.length, i = new Array(r), s = 0; s < r; ++s) {\n    for (var a = n[s], o = a.length, l = i[s] = new Array(o), c, u = 0; u < o; ++u)\n      (c = a[u]) && (l[u] = c);\n    l.sort(t);\n  }\n  return new _e(i, this._parents).order();\n}\nfunction CE(e, t) {\n  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;\n}\nfunction AE() {\n  var e = arguments[0];\n  return arguments[0] = this, e.apply(null, arguments), this;\n}\nfunction LE() {\n  return Array.from(this);\n}\nfunction kE() {\n  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)\n    for (var r = e[t], i = 0, s = r.length; i < s; ++i) {\n      var a = r[i];\n      if (a) return a;\n    }\n  return null;\n}\nfunction DE() {\n  let e = 0;\n  for (const t of this) ++e;\n  return e;\n}\nfunction RE() {\n  return !this.node();\n}\nfunction IE(e) {\n  for (var t = this._groups, n = 0, r = t.length; n < r; ++n)\n    for (var i = t[n], s = 0, a = i.length, o; s < a; ++s)\n      (o = i[s]) && e.call(o, o.__data__, s, i);\n  return this;\n}\nfunction NE(e) {\n  return function() {\n    this.removeAttribute(e);\n  };\n}\nfunction PE(e) {\n  return function() {\n    this.removeAttributeNS(e.space, e.local);\n  };\n}\nfunction UE(e, t) {\n  return function() {\n    this.setAttribute(e, t);\n  };\n}\nfunction BE(e, t) {\n  return function() {\n    this.setAttributeNS(e.space, e.local, t);\n  };\n}\nfunction HE(e, t) {\n  return function() {\n    var n = t.apply(this, arguments);\n    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);\n  };\n}\nfunction VE(e, t) {\n  return function() {\n    var n = t.apply(this, arguments);\n    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);\n  };\n}\nfunction GE(e, t) {\n  var n = to(e);\n  if (arguments.length < 2) {\n    var r = this.node();\n    return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);\n  }\n  return this.each((t == null ? n.local ? PE : NE : typeof t == "function" ? n.local ? VE : HE : n.local ? BE : UE)(n, t));\n}\nfunction Jf(e) {\n  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;\n}\nfunction zE(e) {\n  return function() {\n    this.style.removeProperty(e);\n  };\n}\nfunction FE(e, t, n) {\n  return function() {\n    this.style.setProperty(e, t, n);\n  };\n}\nfunction jE(e, t, n) {\n  return function() {\n    var r = t.apply(this, arguments);\n    r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, n);\n  };\n}\nfunction WE(e, t, n) {\n  return arguments.length > 1 ? this.each((t == null ? zE : typeof t == "function" ? jE : FE)(e, t, n ?? "")) : Xr(this.node(), e);\n}\nfunction Xr(e, t) {\n  return e.style.getPropertyValue(t) || Jf(e).getComputedStyle(e, null).getPropertyValue(t);\n}\nfunction qE(e) {\n  return function() {\n    delete this[e];\n  };\n}\nfunction YE(e, t) {\n  return function() {\n    this[e] = t;\n  };\n}\nfunction XE(e, t) {\n  return function() {\n    var n = t.apply(this, arguments);\n    n == null ? delete this[e] : this[e] = n;\n  };\n}\nfunction ZE(e, t) {\n  return arguments.length > 1 ? this.each((t == null ? qE : typeof t == "function" ? XE : YE)(e, t)) : this.node()[e];\n}\nfunction tm(e) {\n  return e.trim().split(/^|\\s+/);\n}\nfunction Dc(e) {\n  return e.classList || new em(e);\n}\nfunction em(e) {\n  this._node = e, this._names = tm(e.getAttribute("class") || "");\n}\nem.prototype = {\n  add: function(e) {\n    var t = this._names.indexOf(e);\n    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));\n  },\n  remove: function(e) {\n    var t = this._names.indexOf(e);\n    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));\n  },\n  contains: function(e) {\n    return this._names.indexOf(e) >= 0;\n  }\n};\nfunction nm(e, t) {\n  for (var n = Dc(e), r = -1, i = t.length; ++r < i; ) n.add(t[r]);\n}\nfunction rm(e, t) {\n  for (var n = Dc(e), r = -1, i = t.length; ++r < i; ) n.remove(t[r]);\n}\nfunction KE(e) {\n  return function() {\n    nm(this, e);\n  };\n}\nfunction QE(e) {\n  return function() {\n    rm(this, e);\n  };\n}\nfunction JE(e, t) {\n  return function() {\n    (t.apply(this, arguments) ? nm : rm)(this, e);\n  };\n}\nfunction tO(e, t) {\n  var n = tm(e + "");\n  if (arguments.length < 2) {\n    for (var r = Dc(this.node()), i = -1, s = n.length; ++i < s; ) if (!r.contains(n[i])) return !1;\n    return !0;\n  }\n  return this.each((typeof t == "function" ? JE : t ? KE : QE)(n, t));\n}\nfunction eO() {\n  this.textContent = "";\n}\nfunction nO(e) {\n  return function() {\n    this.textContent = e;\n  };\n}\nfunction rO(e) {\n  return function() {\n    var t = e.apply(this, arguments);\n    this.textContent = t ?? "";\n  };\n}\nfunction iO(e) {\n  return arguments.length ? this.each(e == null ? eO : (typeof e == "function" ? rO : nO)(e)) : this.node().textContent;\n}\nfunction sO() {\n  this.innerHTML = "";\n}\nfunction aO(e) {\n  return function() {\n    this.innerHTML = e;\n  };\n}\nfunction oO(e) {\n  return function() {\n    var t = e.apply(this, arguments);\n    this.innerHTML = t ?? "";\n  };\n}\nfunction lO(e) {\n  return arguments.length ? this.each(e == null ? sO : (typeof e == "function" ? oO : aO)(e)) : this.node().innerHTML;\n}\nfunction cO() {\n  this.nextSibling && this.parentNode.appendChild(this);\n}\nfunction uO() {\n  return this.each(cO);\n}\nfunction hO() {\n  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);\n}\nfunction dO() {\n  return this.each(hO);\n}\nfunction pO(e) {\n  var t = typeof e == "function" ? e : Yf(e);\n  return this.select(function() {\n    return this.appendChild(t.apply(this, arguments));\n  });\n}\nfunction fO() {\n  return null;\n}\nfunction mO(e, t) {\n  var n = typeof e == "function" ? e : Yf(e), r = t == null ? fO : typeof t == "function" ? t : kc(t);\n  return this.select(function() {\n    return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);\n  });\n}\nfunction gO() {\n  var e = this.parentNode;\n  e && e.removeChild(this);\n}\nfunction vO() {\n  return this.each(gO);\n}\nfunction yO() {\n  var e = this.cloneNode(!1), t = this.parentNode;\n  return t ? t.insertBefore(e, this.nextSibling) : e;\n}\nfunction xO() {\n  var e = this.cloneNode(!0), t = this.parentNode;\n  return t ? t.insertBefore(e, this.nextSibling) : e;\n}\nfunction bO(e) {\n  return this.select(e ? xO : yO);\n}\nfunction _O(e) {\n  return arguments.length ? this.property("__data__", e) : this.node().__data__;\n}\nfunction EO(e) {\n  return function(t) {\n    e.call(this, t, this.__data__);\n  };\n}\nfunction OO(e) {\n  return e.trim().split(/^|\\s+/).map(function(t) {\n    var n = "", r = t.indexOf(".");\n    return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), { type: t, name: n };\n  });\n}\nfunction SO(e) {\n  return function() {\n    var t = this.__on;\n    if (t) {\n      for (var n = 0, r = -1, i = t.length, s; n < i; ++n)\n        s = t[n], (!e.type || s.type === e.type) && s.name === e.name ? this.removeEventListener(s.type, s.listener, s.options) : t[++r] = s;\n      ++r ? t.length = r : delete this.__on;\n    }\n  };\n}\nfunction TO(e, t, n) {\n  return function() {\n    var r = this.__on, i, s = EO(t);\n    if (r) {\n      for (var a = 0, o = r.length; a < o; ++a)\n        if ((i = r[a]).type === e.type && i.name === e.name) {\n          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = s, i.options = n), i.value = t;\n          return;\n        }\n    }\n    this.addEventListener(e.type, s, n), i = { type: e.type, name: e.name, value: t, listener: s, options: n }, r ? r.push(i) : this.__on = [i];\n  };\n}\nfunction wO(e, t, n) {\n  var r = OO(e + ""), i, s = r.length, a;\n  if (arguments.length < 2) {\n    var o = this.node().__on;\n    if (o) {\n      for (var l = 0, c = o.length, u; l < c; ++l)\n        for (i = 0, u = o[l]; i < s; ++i)\n          if ((a = r[i]).type === u.type && a.name === u.name)\n            return u.value;\n    }\n    return;\n  }\n  for (o = t ? TO : SO, i = 0; i < s; ++i) this.each(o(r[i], t, n));\n  return this;\n}\nfunction im(e, t, n) {\n  var r = Jf(e), i = r.CustomEvent;\n  typeof i == "function" ? i = new i(t, n) : (i = r.document.createEvent("Event"), n ? (i.initEvent(t, n.bubbles, n.cancelable), i.detail = n.detail) : i.initEvent(t, !1, !1)), e.dispatchEvent(i);\n}\nfunction $O(e, t) {\n  return function() {\n    return im(this, e, t);\n  };\n}\nfunction MO(e, t) {\n  return function() {\n    return im(this, e, t.apply(this, arguments));\n  };\n}\nfunction CO(e, t) {\n  return this.each((typeof t == "function" ? MO : $O)(e, t));\n}\nfunction* AO() {\n  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)\n    for (var r = e[t], i = 0, s = r.length, a; i < s; ++i)\n      (a = r[i]) && (yield a);\n}\nvar sm = [null];\nfunction _e(e, t) {\n  this._groups = e, this._parents = t;\n}\nfunction ds() {\n  return new _e([[document.documentElement]], sm);\n}\nfunction LO() {\n  return this;\n}\n_e.prototype = ds.prototype = {\n  constructor: _e,\n  select: rE,\n  selectAll: oE,\n  selectChild: hE,\n  selectChildren: mE,\n  filter: gE,\n  data: EE,\n  enter: vE,\n  exit: SE,\n  join: TE,\n  merge: wE,\n  selection: LO,\n  order: $E,\n  sort: ME,\n  call: AE,\n  nodes: LE,\n  node: kE,\n  size: DE,\n  empty: RE,\n  each: IE,\n  attr: GE,\n  style: WE,\n  property: ZE,\n  classed: tO,\n  text: iO,\n  html: lO,\n  raise: uO,\n  lower: dO,\n  append: pO,\n  insert: mO,\n  remove: vO,\n  clone: bO,\n  datum: _O,\n  on: wO,\n  dispatch: CO,\n  [Symbol.iterator]: AO\n};\nfunction kO(e) {\n  let t;\n  for (; t = e.sourceEvent; ) e = t;\n  return e;\n}\nfunction rr(e, t) {\n  if (e = kO(e), t === void 0 && (t = e.currentTarget), t) {\n    var n = t.ownerSVGElement || t;\n    if (n.createSVGPoint) {\n      var r = n.createSVGPoint();\n      return r.x = e.clientX, r.y = e.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y];\n    }\n    if (t.getBoundingClientRect) {\n      var i = t.getBoundingClientRect();\n      return [e.clientX - i.left - t.clientLeft, e.clientY - i.top - t.clientTop];\n    }\n  }\n  return [e.pageX, e.pageY];\n}\nfunction Rc(e, t, n) {\n  e.prototype = t.prototype = n, n.constructor = e;\n}\nfunction am(e, t) {\n  var n = Object.create(e.prototype);\n  for (var r in t) n[r] = t[r];\n  return n;\n}\nfunction ps() {\n}\nvar Ki = 0.7, ha = 1 / Ki, Gr = "\\\\s*([+-]?\\\\d+)\\\\s*", Qi = "\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*", tn = "\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*", DO = /^#([0-9a-f]{3,8})$/, RO = new RegExp(`^rgb\\\\(${Gr},${Gr},${Gr}\\\\)$`), IO = new RegExp(`^rgb\\\\(${tn},${tn},${tn}\\\\)$`), NO = new RegExp(`^rgba\\\\(${Gr},${Gr},${Gr},${Qi}\\\\)$`), PO = new RegExp(`^rgba\\\\(${tn},${tn},${tn},${Qi}\\\\)$`), UO = new RegExp(`^hsl\\\\(${Qi},${tn},${tn}\\\\)$`), BO = new RegExp(`^hsla\\\\(${Qi},${tn},${tn},${Qi}\\\\)$`), ph = {\n  aliceblue: 15792383,\n  antiquewhite: 16444375,\n  aqua: 65535,\n  aquamarine: 8388564,\n  azure: 15794175,\n  beige: 16119260,\n  bisque: 16770244,\n  black: 0,\n  blanchedalmond: 16772045,\n  blue: 255,\n  blueviolet: 9055202,\n  brown: 10824234,\n  burlywood: 14596231,\n  cadetblue: 6266528,\n  chartreuse: 8388352,\n  chocolate: 13789470,\n  coral: 16744272,\n  cornflowerblue: 6591981,\n  cornsilk: 16775388,\n  crimson: 14423100,\n  cyan: 65535,\n  darkblue: 139,\n  darkcyan: 35723,\n  darkgoldenrod: 12092939,\n  darkgray: 11119017,\n  darkgreen: 25600,\n  darkgrey: 11119017,\n  darkkhaki: 12433259,\n  darkmagenta: 9109643,\n  darkolivegreen: 5597999,\n  darkorange: 16747520,\n  darkorchid: 10040012,\n  darkred: 9109504,\n  darksalmon: 15308410,\n  darkseagreen: 9419919,\n  darkslateblue: 4734347,\n  darkslategray: 3100495,\n  darkslategrey: 3100495,\n  darkturquoise: 52945,\n  darkviolet: 9699539,\n  deeppink: 16716947,\n  deepskyblue: 49151,\n  dimgray: 6908265,\n  dimgrey: 6908265,\n  dodgerblue: 2003199,\n  firebrick: 11674146,\n  floralwhite: 16775920,\n  forestgreen: 2263842,\n  fuchsia: 16711935,\n  gainsboro: 14474460,\n  ghostwhite: 16316671,\n  gold: 16766720,\n  goldenrod: 14329120,\n  gray: 8421504,\n  green: 32768,\n  greenyellow: 11403055,\n  grey: 8421504,\n  honeydew: 15794160,\n  hotpink: 16738740,\n  indianred: 13458524,\n  indigo: 4915330,\n  ivory: 16777200,\n  khaki: 15787660,\n  lavender: 15132410,\n  lavenderblush: 16773365,\n  lawngreen: 8190976,\n  lemonchiffon: 16775885,\n  lightblue: 11393254,\n  lightcoral: 15761536,\n  lightcyan: 14745599,\n  lightgoldenrodyellow: 16448210,\n  lightgray: 13882323,\n  lightgreen: 9498256,\n  lightgrey: 13882323,\n  lightpink: 16758465,\n  lightsalmon: 16752762,\n  lightseagreen: 2142890,\n  lightskyblue: 8900346,\n  lightslategray: 7833753,\n  lightslategrey: 7833753,\n  lightsteelblue: 11584734,\n  lightyellow: 16777184,\n  lime: 65280,\n  limegreen: 3329330,\n  linen: 16445670,\n  magenta: 16711935,\n  maroon: 8388608,\n  mediumaquamarine: 6737322,\n  mediumblue: 205,\n  mediumorchid: 12211667,\n  mediumpurple: 9662683,\n  mediumseagreen: 3978097,\n  mediumslateblue: 8087790,\n  mediumspringgreen: 64154,\n  mediumturquoise: 4772300,\n  mediumvioletred: 13047173,\n  midnightblue: 1644912,\n  mintcream: 16121850,\n  mistyrose: 16770273,\n  moccasin: 16770229,\n  navajowhite: 16768685,\n  navy: 128,\n  oldlace: 16643558,\n  olive: 8421376,\n  olivedrab: 7048739,\n  orange: 16753920,\n  orangered: 16729344,\n  orchid: 14315734,\n  palegoldenrod: 15657130,\n  palegreen: 10025880,\n  paleturquoise: 11529966,\n  palevioletred: 14381203,\n  papayawhip: 16773077,\n  peachpuff: 16767673,\n  peru: 13468991,\n  pink: 16761035,\n  plum: 14524637,\n  powderblue: 11591910,\n  purple: 8388736,\n  rebeccapurple: 6697881,\n  red: 16711680,\n  rosybrown: 12357519,\n  royalblue: 4286945,\n  saddlebrown: 9127187,\n  salmon: 16416882,\n  sandybrown: 16032864,\n  seagreen: 3050327,\n  seashell: 16774638,\n  sienna: 10506797,\n  silver: 12632256,\n  skyblue: 8900331,\n  slateblue: 6970061,\n  slategray: 7372944,\n  slategrey: 7372944,\n  snow: 16775930,\n  springgreen: 65407,\n  steelblue: 4620980,\n  tan: 13808780,\n  teal: 32896,\n  thistle: 14204888,\n  tomato: 16737095,\n  turquoise: 4251856,\n  violet: 15631086,\n  wheat: 16113331,\n  white: 16777215,\n  whitesmoke: 16119285,\n  yellow: 16776960,\n  yellowgreen: 10145074\n};\nRc(ps, Tn, {\n  copy(e) {\n    return Object.assign(new this.constructor(), this, e);\n  },\n  displayable() {\n    return this.rgb().displayable();\n  },\n  hex: fh,\n  // Deprecated! Use color.formatHex.\n  formatHex: fh,\n  formatHex8: HO,\n  formatHsl: VO,\n  formatRgb: mh,\n  toString: mh\n});\nfunction fh() {\n  return this.rgb().formatHex();\n}\nfunction HO() {\n  return this.rgb().formatHex8();\n}\nfunction VO() {\n  return om(this).formatHsl();\n}\nfunction mh() {\n  return this.rgb().formatRgb();\n}\nfunction Tn(e) {\n  var t, n;\n  return e = (e + "").trim().toLowerCase(), (t = DO.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? gh(t) : n === 3 ? new he(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? ws(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? ws(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = RO.exec(e)) ? new he(t[1], t[2], t[3], 1) : (t = IO.exec(e)) ? new he(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = NO.exec(e)) ? ws(t[1], t[2], t[3], t[4]) : (t = PO.exec(e)) ? ws(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = UO.exec(e)) ? xh(t[1], t[2] / 100, t[3] / 100, 1) : (t = BO.exec(e)) ? xh(t[1], t[2] / 100, t[3] / 100, t[4]) : ph.hasOwnProperty(e) ? gh(ph[e]) : e === "transparent" ? new he(NaN, NaN, NaN, 0) : null;\n}\nfunction gh(e) {\n  return new he(e >> 16 & 255, e >> 8 & 255, e & 255, 1);\n}\nfunction ws(e, t, n, r) {\n  return r <= 0 && (e = t = n = NaN), new he(e, t, n, r);\n}\nfunction GO(e) {\n  return e instanceof ps || (e = Tn(e)), e ? (e = e.rgb(), new he(e.r, e.g, e.b, e.opacity)) : new he();\n}\nfunction Sl(e, t, n, r) {\n  return arguments.length === 1 ? GO(e) : new he(e, t, n, r ?? 1);\n}\nfunction he(e, t, n, r) {\n  this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;\n}\nRc(he, Sl, am(ps, {\n  brighter(e) {\n    return e = e == null ? ha : Math.pow(ha, e), new he(this.r * e, this.g * e, this.b * e, this.opacity);\n  },\n  darker(e) {\n    return e = e == null ? Ki : Math.pow(Ki, e), new he(this.r * e, this.g * e, this.b * e, this.opacity);\n  },\n  rgb() {\n    return this;\n  },\n  clamp() {\n    return new he(tr(this.r), tr(this.g), tr(this.b), da(this.opacity));\n  },\n  displayable() {\n    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;\n  },\n  hex: vh,\n  // Deprecated! Use color.formatHex.\n  formatHex: vh,\n  formatHex8: zO,\n  formatRgb: yh,\n  toString: yh\n}));\nfunction vh() {\n  return `#${Qn(this.r)}${Qn(this.g)}${Qn(this.b)}`;\n}\nfunction zO() {\n  return `#${Qn(this.r)}${Qn(this.g)}${Qn(this.b)}${Qn((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;\n}\nfunction yh() {\n  const e = da(this.opacity);\n  return `${e === 1 ? "rgb(" : "rgba("}${tr(this.r)}, ${tr(this.g)}, ${tr(this.b)}${e === 1 ? ")" : `, ${e})`}`;\n}\nfunction da(e) {\n  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));\n}\nfunction tr(e) {\n  return Math.max(0, Math.min(255, Math.round(e) || 0));\n}\nfunction Qn(e) {\n  return e = tr(e), (e < 16 ? "0" : "") + e.toString(16);\n}\nfunction xh(e, t, n, r) {\n  return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new He(e, t, n, r);\n}\nfunction om(e) {\n  if (e instanceof He) return new He(e.h, e.s, e.l, e.opacity);\n  if (e instanceof ps || (e = Tn(e)), !e) return new He();\n  if (e instanceof He) return e;\n  e = e.rgb();\n  var t = e.r / 255, n = e.g / 255, r = e.b / 255, i = Math.min(t, n, r), s = Math.max(t, n, r), a = NaN, o = s - i, l = (s + i) / 2;\n  return o ? (t === s ? a = (n - r) / o + (n < r) * 6 : n === s ? a = (r - t) / o + 2 : a = (t - n) / o + 4, o /= l < 0.5 ? s + i : 2 - s - i, a *= 60) : o = l > 0 && l < 1 ? 0 : a, new He(a, o, l, e.opacity);\n}\nfunction lm(e, t, n, r) {\n  return arguments.length === 1 ? om(e) : new He(e, t, n, r ?? 1);\n}\nfunction He(e, t, n, r) {\n  this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;\n}\nRc(He, lm, am(ps, {\n  brighter(e) {\n    return e = e == null ? ha : Math.pow(ha, e), new He(this.h, this.s, this.l * e, this.opacity);\n  },\n  darker(e) {\n    return e = e == null ? Ki : Math.pow(Ki, e), new He(this.h, this.s, this.l * e, this.opacity);\n  },\n  rgb() {\n    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, i = 2 * n - r;\n    return new he(\n      Co(e >= 240 ? e - 240 : e + 120, i, r),\n      Co(e, i, r),\n      Co(e < 120 ? e + 240 : e - 120, i, r),\n      this.opacity\n    );\n  },\n  clamp() {\n    return new He(bh(this.h), $s(this.s), $s(this.l), da(this.opacity));\n  },\n  displayable() {\n    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;\n  },\n  formatHsl() {\n    const e = da(this.opacity);\n    return `${e === 1 ? "hsl(" : "hsla("}${bh(this.h)}, ${$s(this.s) * 100}%, ${$s(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;\n  }\n}));\nfunction bh(e) {\n  return e = (e || 0) % 360, e < 0 ? e + 360 : e;\n}\nfunction $s(e) {\n  return Math.max(0, Math.min(1, e || 0));\n}\nfunction Co(e, t, n) {\n  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;\n}\nconst Ic = (e) => () => e;\nfunction FO(e, t) {\n  return function(n) {\n    return e + n * t;\n  };\n}\nfunction jO(e, t, n) {\n  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(r) {\n    return Math.pow(e + r * t, n);\n  };\n}\nfunction WO(e) {\n  return (e = +e) == 1 ? cm : function(t, n) {\n    return n - t ? jO(t, n, e) : Ic(isNaN(t) ? n : t);\n  };\n}\nfunction cm(e, t) {\n  var n = t - e;\n  return n ? FO(e, n) : Ic(isNaN(e) ? t : e);\n}\nconst pa = function e(t) {\n  var n = WO(t);\n  function r(i, s) {\n    var a = n((i = Sl(i)).r, (s = Sl(s)).r), o = n(i.g, s.g), l = n(i.b, s.b), c = cm(i.opacity, s.opacity);\n    return function(u) {\n      return i.r = a(u), i.g = o(u), i.b = l(u), i.opacity = c(u), i + "";\n    };\n  }\n  return r.gamma = e, r;\n}(1);\nfunction qO(e, t) {\n  t || (t = []);\n  var n = e ? Math.min(t.length, e.length) : 0, r = t.slice(), i;\n  return function(s) {\n    for (i = 0; i < n; ++i) r[i] = e[i] * (1 - s) + t[i] * s;\n    return r;\n  };\n}\nfunction YO(e) {\n  return ArrayBuffer.isView(e) && !(e instanceof DataView);\n}\nfunction XO(e, t) {\n  var n = t ? t.length : 0, r = e ? Math.min(n, e.length) : 0, i = new Array(r), s = new Array(n), a;\n  for (a = 0; a < r; ++a) i[a] = fs(e[a], t[a]);\n  for (; a < n; ++a) s[a] = t[a];\n  return function(o) {\n    for (a = 0; a < r; ++a) s[a] = i[a](o);\n    return s;\n  };\n}\nfunction ZO(e, t) {\n  var n = /* @__PURE__ */ new Date();\n  return e = +e, t = +t, function(r) {\n    return n.setTime(e * (1 - r) + t * r), n;\n  };\n}\nfunction xe(e, t) {\n  return e = +e, t = +t, function(n) {\n    return e * (1 - n) + t * n;\n  };\n}\nfunction KO(e, t) {\n  var n = {}, r = {}, i;\n  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});\n  for (i in t)\n    i in e ? n[i] = fs(e[i], t[i]) : r[i] = t[i];\n  return function(s) {\n    for (i in n) r[i] = n[i](s);\n    return r;\n  };\n}\nvar Tl = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g, Ao = new RegExp(Tl.source, "g");\nfunction QO(e) {\n  return function() {\n    return e;\n  };\n}\nfunction JO(e) {\n  return function(t) {\n    return e(t) + "";\n  };\n}\nfunction um(e, t) {\n  var n = Tl.lastIndex = Ao.lastIndex = 0, r, i, s, a = -1, o = [], l = [];\n  for (e = e + "", t = t + ""; (r = Tl.exec(e)) && (i = Ao.exec(t)); )\n    (s = i.index) > n && (s = t.slice(n, s), o[a] ? o[a] += s : o[++a] = s), (r = r[0]) === (i = i[0]) ? o[a] ? o[a] += i : o[++a] = i : (o[++a] = null, l.push({ i: a, x: xe(r, i) })), n = Ao.lastIndex;\n  return n < t.length && (s = t.slice(n), o[a] ? o[a] += s : o[++a] = s), o.length < 2 ? l[0] ? JO(l[0].x) : QO(t) : (t = l.length, function(c) {\n    for (var u = 0, d; u < t; ++u) o[(d = l[u]).i] = d.x(c);\n    return o.join("");\n  });\n}\nfunction fs(e, t) {\n  var n = typeof t, r;\n  return t == null || n === "boolean" ? Ic(t) : (n === "number" ? xe : n === "string" ? (r = Tn(t)) ? (t = r, pa) : um : t instanceof Tn ? pa : t instanceof Date ? ZO : YO(t) ? qO : Array.isArray(t) ? XO : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? KO : xe)(e, t);\n}\nfunction hm(e, t) {\n  return e = +e, t = +t, function(n) {\n    return Math.round(e * (1 - n) + t * n);\n  };\n}\nvar _h = 180 / Math.PI, dm = {\n  translateX: 0,\n  translateY: 0,\n  rotate: 0,\n  skewX: 0,\n  scaleX: 1,\n  scaleY: 1\n};\nfunction pm(e, t, n, r, i, s) {\n  var a, o, l;\n  return (a = Math.sqrt(e * e + t * t)) && (e /= a, t /= a), (l = e * n + t * r) && (n -= e * l, r -= t * l), (o = Math.sqrt(n * n + r * r)) && (n /= o, r /= o, l /= o), e * r < t * n && (e = -e, t = -t, l = -l, a = -a), {\n    translateX: i,\n    translateY: s,\n    rotate: Math.atan2(t, e) * _h,\n    skewX: Math.atan(l) * _h,\n    scaleX: a,\n    scaleY: o\n  };\n}\nvar Ms;\nfunction tS(e) {\n  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");\n  return t.isIdentity ? dm : pm(t.a, t.b, t.c, t.d, t.e, t.f);\n}\nfunction eS(e) {\n  return e == null || (Ms || (Ms = document.createElementNS("http://www.w3.org/2000/svg", "g")), Ms.setAttribute("transform", e), !(e = Ms.transform.baseVal.consolidate())) ? dm : (e = e.matrix, pm(e.a, e.b, e.c, e.d, e.e, e.f));\n}\nfunction fm(e, t, n, r) {\n  function i(c) {\n    return c.length ? c.pop() + " " : "";\n  }\n  function s(c, u, d, h, p, f) {\n    if (c !== d || u !== h) {\n      var g = p.push("translate(", null, t, null, n);\n      f.push({ i: g - 4, x: xe(c, d) }, { i: g - 2, x: xe(u, h) });\n    } else (d || h) && p.push("translate(" + d + t + h + n);\n  }\n  function a(c, u, d, h) {\n    c !== u ? (c - u > 180 ? u += 360 : u - c > 180 && (c += 360), h.push({ i: d.push(i(d) + "rotate(", null, r) - 2, x: xe(c, u) })) : u && d.push(i(d) + "rotate(" + u + r);\n  }\n  function o(c, u, d, h) {\n    c !== u ? h.push({ i: d.push(i(d) + "skewX(", null, r) - 2, x: xe(c, u) }) : u && d.push(i(d) + "skewX(" + u + r);\n  }\n  function l(c, u, d, h, p, f) {\n    if (c !== d || u !== h) {\n      var g = p.push(i(p) + "scale(", null, ",", null, ")");\n      f.push({ i: g - 4, x: xe(c, d) }, { i: g - 2, x: xe(u, h) });\n    } else (d !== 1 || h !== 1) && p.push(i(p) + "scale(" + d + "," + h + ")");\n  }\n  return function(c, u) {\n    var d = [], h = [];\n    return c = e(c), u = e(u), s(c.translateX, c.translateY, u.translateX, u.translateY, d, h), a(c.rotate, u.rotate, d, h), o(c.skewX, u.skewX, d, h), l(c.scaleX, c.scaleY, u.scaleX, u.scaleY, d, h), c = u = null, function(p) {\n      for (var f = -1, g = h.length, m; ++f < g; ) d[(m = h[f]).i] = m.x(p);\n      return d.join("");\n    };\n  };\n}\nvar nS = fm(tS, "px, ", "px)", "deg)"), rS = fm(eS, ", ", ")", ")"), Zr = 0, Ti = 0, pi = 0, mm = 1e3, fa, wi, ma = 0, ir = 0, eo = 0, Ji = typeof performance == "object" && performance.now ? performance : Date, gm = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {\n  setTimeout(e, 17);\n};\nfunction Nc() {\n  return ir || (gm(iS), ir = Ji.now() + eo);\n}\nfunction iS() {\n  ir = 0;\n}\nfunction ga() {\n  this._call = this._time = this._next = null;\n}\nga.prototype = vm.prototype = {\n  constructor: ga,\n  restart: function(e, t, n) {\n    if (typeof e != "function") throw new TypeError("callback is not a function");\n    n = (n == null ? Nc() : +n) + (t == null ? 0 : +t), !this._next && wi !== this && (wi ? wi._next = this : fa = this, wi = this), this._call = e, this._time = n, wl();\n  },\n  stop: function() {\n    this._call && (this._call = null, this._time = 1 / 0, wl());\n  }\n};\nfunction vm(e, t, n) {\n  var r = new ga();\n  return r.restart(e, t, n), r;\n}\nfunction sS() {\n  Nc(), ++Zr;\n  for (var e = fa, t; e; )\n    (t = ir - e._time) >= 0 && e._call.call(void 0, t), e = e._next;\n  --Zr;\n}\nfunction Eh() {\n  ir = (ma = Ji.now()) + eo, Zr = Ti = 0;\n  try {\n    sS();\n  } finally {\n    Zr = 0, oS(), ir = 0;\n  }\n}\nfunction aS() {\n  var e = Ji.now(), t = e - ma;\n  t > mm && (eo -= t, ma = e);\n}\nfunction oS() {\n  for (var e, t = fa, n, r = 1 / 0; t; )\n    t._call ? (r > t._time && (r = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : fa = n);\n  wi = e, wl(r);\n}\nfunction wl(e) {\n  if (!Zr) {\n    Ti && (Ti = clearTimeout(Ti));\n    var t = e - ir;\n    t > 24 ? (e < 1 / 0 && (Ti = setTimeout(Eh, e - Ji.now() - eo)), pi && (pi = clearInterval(pi))) : (pi || (ma = Ji.now(), pi = setInterval(aS, mm)), Zr = 1, gm(Eh));\n  }\n}\nfunction Oh(e, t, n) {\n  var r = new ga();\n  return t = t == null ? 0 : +t, r.restart((i) => {\n    r.stop(), e(i + t);\n  }, t, n), r;\n}\nvar lS = Lc("start", "end", "cancel", "interrupt"), cS = [], ym = 0, Sh = 1, $l = 2, Xs = 3, Th = 4, Ml = 5, Zs = 6;\nfunction no(e, t, n, r, i, s) {\n  var a = e.__transition;\n  if (!a) e.__transition = {};\n  else if (n in a) return;\n  uS(e, n, {\n    name: t,\n    index: r,\n    // For context during callback.\n    group: i,\n    // For context during callback.\n    on: lS,\n    tween: cS,\n    time: s.time,\n    delay: s.delay,\n    duration: s.duration,\n    ease: s.ease,\n    timer: null,\n    state: ym\n  });\n}\nfunction Pc(e, t) {\n  var n = qe(e, t);\n  if (n.state > ym) throw new Error("too late; already scheduled");\n  return n;\n}\nfunction sn(e, t) {\n  var n = qe(e, t);\n  if (n.state > Xs) throw new Error("too late; already running");\n  return n;\n}\nfunction qe(e, t) {\n  var n = e.__transition;\n  if (!n || !(n = n[t])) throw new Error("transition not found");\n  return n;\n}\nfunction uS(e, t, n) {\n  var r = e.__transition, i;\n  r[t] = n, n.timer = vm(s, 0, n.time);\n  function s(c) {\n    n.state = Sh, n.timer.restart(a, n.delay, n.time), n.delay <= c && a(c - n.delay);\n  }\n  function a(c) {\n    var u, d, h, p;\n    if (n.state !== Sh) return l();\n    for (u in r)\n      if (p = r[u], p.name === n.name) {\n        if (p.state === Xs) return Oh(a);\n        p.state === Th ? (p.state = Zs, p.timer.stop(), p.on.call("interrupt", e, e.__data__, p.index, p.group), delete r[u]) : +u < t && (p.state = Zs, p.timer.stop(), p.on.call("cancel", e, e.__data__, p.index, p.group), delete r[u]);\n      }\n    if (Oh(function() {\n      n.state === Xs && (n.state = Th, n.timer.restart(o, n.delay, n.time), o(c));\n    }), n.state = $l, n.on.call("start", e, e.__data__, n.index, n.group), n.state === $l) {\n      for (n.state = Xs, i = new Array(h = n.tween.length), u = 0, d = -1; u < h; ++u)\n        (p = n.tween[u].value.call(e, e.__data__, n.index, n.group)) && (i[++d] = p);\n      i.length = d + 1;\n    }\n  }\n  function o(c) {\n    for (var u = c < n.duration ? n.ease.call(null, c / n.duration) : (n.timer.restart(l), n.state = Ml, 1), d = -1, h = i.length; ++d < h; )\n      i[d].call(e, u);\n    n.state === Ml && (n.on.call("end", e, e.__data__, n.index, n.group), l());\n  }\n  function l() {\n    n.state = Zs, n.timer.stop(), delete r[t];\n    for (var c in r) return;\n    delete e.__transition;\n  }\n}\nfunction Cl(e, t) {\n  var n = e.__transition, r, i, s = !0, a;\n  if (n) {\n    t = t == null ? null : t + "";\n    for (a in n) {\n      if ((r = n[a]).name !== t) {\n        s = !1;\n        continue;\n      }\n      i = r.state > $l && r.state < Ml, r.state = Zs, r.timer.stop(), r.on.call(i ? "interrupt" : "cancel", e, e.__data__, r.index, r.group), delete n[a];\n    }\n    s && delete e.__transition;\n  }\n}\nfunction hS(e) {\n  return this.each(function() {\n    Cl(this, e);\n  });\n}\nfunction dS(e, t) {\n  var n, r;\n  return function() {\n    var i = sn(this, e), s = i.tween;\n    if (s !== n) {\n      r = n = s;\n      for (var a = 0, o = r.length; a < o; ++a)\n        if (r[a].name === t) {\n          r = r.slice(), r.splice(a, 1);\n          break;\n        }\n    }\n    i.tween = r;\n  };\n}\nfunction pS(e, t, n) {\n  var r, i;\n  if (typeof n != "function") throw new Error();\n  return function() {\n    var s = sn(this, e), a = s.tween;\n    if (a !== r) {\n      i = (r = a).slice();\n      for (var o = { name: t, value: n }, l = 0, c = i.length; l < c; ++l)\n        if (i[l].name === t) {\n          i[l] = o;\n          break;\n        }\n      l === c && i.push(o);\n    }\n    s.tween = i;\n  };\n}\nfunction fS(e, t) {\n  var n = this._id;\n  if (e += "", arguments.length < 2) {\n    for (var r = qe(this.node(), n).tween, i = 0, s = r.length, a; i < s; ++i)\n      if ((a = r[i]).name === e)\n        return a.value;\n    return null;\n  }\n  return this.each((t == null ? dS : pS)(n, e, t));\n}\nfunction Uc(e, t, n) {\n  var r = e._id;\n  return e.each(function() {\n    var i = sn(this, r);\n    (i.value || (i.value = {}))[t] = n.apply(this, arguments);\n  }), function(i) {\n    return qe(i, r).value[t];\n  };\n}\nfunction xm(e, t) {\n  var n;\n  return (typeof t == "number" ? xe : t instanceof Tn ? pa : (n = Tn(t)) ? (t = n, pa) : um)(e, t);\n}\nfunction mS(e) {\n  return function() {\n    this.removeAttribute(e);\n  };\n}\nfunction gS(e) {\n  return function() {\n    this.removeAttributeNS(e.space, e.local);\n  };\n}\nfunction vS(e, t, n) {\n  var r, i = n + "", s;\n  return function() {\n    var a = this.getAttribute(e);\n    return a === i ? null : a === r ? s : s = t(r = a, n);\n  };\n}\nfunction yS(e, t, n) {\n  var r, i = n + "", s;\n  return function() {\n    var a = this.getAttributeNS(e.space, e.local);\n    return a === i ? null : a === r ? s : s = t(r = a, n);\n  };\n}\nfunction xS(e, t, n) {\n  var r, i, s;\n  return function() {\n    var a, o = n(this), l;\n    return o == null ? void this.removeAttribute(e) : (a = this.getAttribute(e), l = o + "", a === l ? null : a === r && l === i ? s : (i = l, s = t(r = a, o)));\n  };\n}\nfunction bS(e, t, n) {\n  var r, i, s;\n  return function() {\n    var a, o = n(this), l;\n    return o == null ? void this.removeAttributeNS(e.space, e.local) : (a = this.getAttributeNS(e.space, e.local), l = o + "", a === l ? null : a === r && l === i ? s : (i = l, s = t(r = a, o)));\n  };\n}\nfunction _S(e, t) {\n  var n = to(e), r = n === "transform" ? rS : xm;\n  return this.attrTween(e, typeof t == "function" ? (n.local ? bS : xS)(n, r, Uc(this, "attr." + e, t)) : t == null ? (n.local ? gS : mS)(n) : (n.local ? yS : vS)(n, r, t));\n}\nfunction ES(e, t) {\n  return function(n) {\n    this.setAttribute(e, t.call(this, n));\n  };\n}\nfunction OS(e, t) {\n  return function(n) {\n    this.setAttributeNS(e.space, e.local, t.call(this, n));\n  };\n}\nfunction SS(e, t) {\n  var n, r;\n  function i() {\n    var s = t.apply(this, arguments);\n    return s !== r && (n = (r = s) && OS(e, s)), n;\n  }\n  return i._value = t, i;\n}\nfunction TS(e, t) {\n  var n, r;\n  function i() {\n    var s = t.apply(this, arguments);\n    return s !== r && (n = (r = s) && ES(e, s)), n;\n  }\n  return i._value = t, i;\n}\nfunction wS(e, t) {\n  var n = "attr." + e;\n  if (arguments.length < 2) return (n = this.tween(n)) && n._value;\n  if (t == null) return this.tween(n, null);\n  if (typeof t != "function") throw new Error();\n  var r = to(e);\n  return this.tween(n, (r.local ? SS : TS)(r, t));\n}\nfunction $S(e, t) {\n  return function() {\n    Pc(this, e).delay = +t.apply(this, arguments);\n  };\n}\nfunction MS(e, t) {\n  return t = +t, function() {\n    Pc(this, e).delay = t;\n  };\n}\nfunction CS(e) {\n  var t = this._id;\n  return arguments.length ? this.each((typeof e == "function" ? $S : MS)(t, e)) : qe(this.node(), t).delay;\n}\nfunction AS(e, t) {\n  return function() {\n    sn(this, e).duration = +t.apply(this, arguments);\n  };\n}\nfunction LS(e, t) {\n  return t = +t, function() {\n    sn(this, e).duration = t;\n  };\n}\nfunction kS(e) {\n  var t = this._id;\n  return arguments.length ? this.each((typeof e == "function" ? AS : LS)(t, e)) : qe(this.node(), t).duration;\n}\nfunction DS(e, t) {\n  if (typeof t != "function") throw new Error();\n  return function() {\n    sn(this, e).ease = t;\n  };\n}\nfunction RS(e) {\n  var t = this._id;\n  return arguments.length ? this.each(DS(t, e)) : qe(this.node(), t).ease;\n}\nfunction IS(e, t) {\n  return function() {\n    var n = t.apply(this, arguments);\n    if (typeof n != "function") throw new Error();\n    sn(this, e).ease = n;\n  };\n}\nfunction NS(e) {\n  if (typeof e != "function") throw new Error();\n  return this.each(IS(this._id, e));\n}\nfunction PS(e) {\n  typeof e != "function" && (e = Zf(e));\n  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)\n    for (var s = t[i], a = s.length, o = r[i] = [], l, c = 0; c < a; ++c)\n      (l = s[c]) && e.call(l, l.__data__, c, s) && o.push(l);\n  return new wn(r, this._parents, this._name, this._id);\n}\nfunction US(e) {\n  if (e._id !== this._id) throw new Error();\n  for (var t = this._groups, n = e._groups, r = t.length, i = n.length, s = Math.min(r, i), a = new Array(r), o = 0; o < s; ++o)\n    for (var l = t[o], c = n[o], u = l.length, d = a[o] = new Array(u), h, p = 0; p < u; ++p)\n      (h = l[p] || c[p]) && (d[p] = h);\n  for (; o < r; ++o)\n    a[o] = t[o];\n  return new wn(a, this._parents, this._name, this._id);\n}\nfunction BS(e) {\n  return (e + "").trim().split(/^|\\s+/).every(function(t) {\n    var n = t.indexOf(".");\n    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";\n  });\n}\nfunction HS(e, t, n) {\n  var r, i, s = BS(t) ? Pc : sn;\n  return function() {\n    var a = s(this, e), o = a.on;\n    o !== r && (i = (r = o).copy()).on(t, n), a.on = i;\n  };\n}\nfunction VS(e, t) {\n  var n = this._id;\n  return arguments.length < 2 ? qe(this.node(), n).on.on(e) : this.each(HS(n, e, t));\n}\nfunction GS(e) {\n  return function() {\n    var t = this.parentNode;\n    for (var n in this.__transition) if (+n !== e) return;\n    t && t.removeChild(this);\n  };\n}\nfunction zS() {\n  return this.on("end.remove", GS(this._id));\n}\nfunction FS(e) {\n  var t = this._name, n = this._id;\n  typeof e != "function" && (e = kc(e));\n  for (var r = this._groups, i = r.length, s = new Array(i), a = 0; a < i; ++a)\n    for (var o = r[a], l = o.length, c = s[a] = new Array(l), u, d, h = 0; h < l; ++h)\n      (u = o[h]) && (d = e.call(u, u.__data__, h, o)) && ("__data__" in u && (d.__data__ = u.__data__), c[h] = d, no(c[h], t, n, h, c, qe(u, n)));\n  return new wn(s, this._parents, t, n);\n}\nfunction jS(e) {\n  var t = this._name, n = this._id;\n  typeof e != "function" && (e = Xf(e));\n  for (var r = this._groups, i = r.length, s = [], a = [], o = 0; o < i; ++o)\n    for (var l = r[o], c = l.length, u, d = 0; d < c; ++d)\n      if (u = l[d]) {\n        for (var h = e.call(u, u.__data__, d, l), p, f = qe(u, n), g = 0, m = h.length; g < m; ++g)\n          (p = h[g]) && no(p, t, n, g, h, f);\n        s.push(h), a.push(u);\n      }\n  return new wn(s, a, t, n);\n}\nvar WS = ds.prototype.constructor;\nfunction qS() {\n  return new WS(this._groups, this._parents);\n}\nfunction YS(e, t) {\n  var n, r, i;\n  return function() {\n    var s = Xr(this, e), a = (this.style.removeProperty(e), Xr(this, e));\n    return s === a ? null : s === n && a === r ? i : i = t(n = s, r = a);\n  };\n}\nfunction bm(e) {\n  return function() {\n    this.style.removeProperty(e);\n  };\n}\nfunction XS(e, t, n) {\n  var r, i = n + "", s;\n  return function() {\n    var a = Xr(this, e);\n    return a === i ? null : a === r ? s : s = t(r = a, n);\n  };\n}\nfunction ZS(e, t, n) {\n  var r, i, s;\n  return function() {\n    var a = Xr(this, e), o = n(this), l = o + "";\n    return o == null && (l = o = (this.style.removeProperty(e), Xr(this, e))), a === l ? null : a === r && l === i ? s : (i = l, s = t(r = a, o));\n  };\n}\nfunction KS(e, t) {\n  var n, r, i, s = "style." + t, a = "end." + s, o;\n  return function() {\n    var l = sn(this, e), c = l.on, u = l.value[s] == null ? o || (o = bm(t)) : void 0;\n    (c !== n || i !== u) && (r = (n = c).copy()).on(a, i = u), l.on = r;\n  };\n}\nfunction QS(e, t, n) {\n  var r = (e += "") == "transform" ? nS : xm;\n  return t == null ? this.styleTween(e, YS(e, r)).on("end.style." + e, bm(e)) : typeof t == "function" ? this.styleTween(e, ZS(e, r, Uc(this, "style." + e, t))).each(KS(this._id, e)) : this.styleTween(e, XS(e, r, t), n).on("end.style." + e, null);\n}\nfunction JS(e, t, n) {\n  return function(r) {\n    this.style.setProperty(e, t.call(this, r), n);\n  };\n}\nfunction tT(e, t, n) {\n  var r, i;\n  function s() {\n    var a = t.apply(this, arguments);\n    return a !== i && (r = (i = a) && JS(e, a, n)), r;\n  }\n  return s._value = t, s;\n}\nfunction eT(e, t, n) {\n  var r = "style." + (e += "");\n  if (arguments.length < 2) return (r = this.tween(r)) && r._value;\n  if (t == null) return this.tween(r, null);\n  if (typeof t != "function") throw new Error();\n  return this.tween(r, tT(e, t, n ?? ""));\n}\nfunction nT(e) {\n  return function() {\n    this.textContent = e;\n  };\n}\nfunction rT(e) {\n  return function() {\n    var t = e(this);\n    this.textContent = t ?? "";\n  };\n}\nfunction iT(e) {\n  return this.tween("text", typeof e == "function" ? rT(Uc(this, "text", e)) : nT(e == null ? "" : e + ""));\n}\nfunction sT(e) {\n  return function(t) {\n    this.textContent = e.call(this, t);\n  };\n}\nfunction aT(e) {\n  var t, n;\n  function r() {\n    var i = e.apply(this, arguments);\n    return i !== n && (t = (n = i) && sT(i)), t;\n  }\n  return r._value = e, r;\n}\nfunction oT(e) {\n  var t = "text";\n  if (arguments.length < 1) return (t = this.tween(t)) && t._value;\n  if (e == null) return this.tween(t, null);\n  if (typeof e != "function") throw new Error();\n  return this.tween(t, aT(e));\n}\nfunction lT() {\n  for (var e = this._name, t = this._id, n = _m(), r = this._groups, i = r.length, s = 0; s < i; ++s)\n    for (var a = r[s], o = a.length, l, c = 0; c < o; ++c)\n      if (l = a[c]) {\n        var u = qe(l, t);\n        no(l, e, n, c, a, {\n          time: u.time + u.delay + u.duration,\n          delay: 0,\n          duration: u.duration,\n          ease: u.ease\n        });\n      }\n  return new wn(r, this._parents, e, n);\n}\nfunction cT() {\n  var e, t, n = this, r = n._id, i = n.size();\n  return new Promise(function(s, a) {\n    var o = { value: a }, l = { value: function() {\n      --i === 0 && s();\n    } };\n    n.each(function() {\n      var c = sn(this, r), u = c.on;\n      u !== e && (t = (e = u).copy(), t._.cancel.push(o), t._.interrupt.push(o), t._.end.push(l)), c.on = t;\n    }), i === 0 && s();\n  });\n}\nvar uT = 0;\nfunction wn(e, t, n, r) {\n  this._groups = e, this._parents = t, this._name = n, this._id = r;\n}\nfunction _m() {\n  return ++uT;\n}\nvar un = ds.prototype;\nwn.prototype = {\n  constructor: wn,\n  select: FS,\n  selectAll: jS,\n  selectChild: un.selectChild,\n  selectChildren: un.selectChildren,\n  filter: PS,\n  merge: US,\n  selection: qS,\n  transition: lT,\n  call: un.call,\n  nodes: un.nodes,\n  node: un.node,\n  size: un.size,\n  empty: un.empty,\n  each: un.each,\n  on: VS,\n  attr: _S,\n  attrTween: wS,\n  style: QS,\n  styleTween: eT,\n  text: iT,\n  textTween: oT,\n  remove: zS,\n  tween: fS,\n  delay: CS,\n  duration: kS,\n  ease: RS,\n  easeVarying: NS,\n  end: cT,\n  [Symbol.iterator]: un[Symbol.iterator]\n};\nfunction Em(e) {\n  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;\n}\nvar hT = {\n  time: null,\n  // Set on use.\n  delay: 0,\n  duration: 250,\n  ease: Em\n};\nfunction dT(e, t) {\n  for (var n; !(n = e.__transition) || !(n = n[t]); )\n    if (!(e = e.parentNode))\n      throw new Error(`transition ${t} not found`);\n  return n;\n}\nfunction pT(e) {\n  var t, n;\n  e instanceof wn ? (t = e._id, e = e._name) : (t = _m(), (n = hT).time = Nc(), e = e == null ? null : e + "");\n  for (var r = this._groups, i = r.length, s = 0; s < i; ++s)\n    for (var a = r[s], o = a.length, l, c = 0; c < o; ++c)\n      (l = a[c]) && no(l, e, t, c, a, n || dT(l, t));\n  return new wn(r, this._parents, e, t);\n}\nds.prototype.interrupt = hS;\nds.prototype.transition = pT;\nfunction fT(e) {\n  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);\n}\nfunction va(e, t) {\n  if ((n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0) return null;\n  var n, r = e.slice(0, n);\n  return [\n    r.length > 1 ? r[0] + r.slice(2) : r,\n    +e.slice(n + 1)\n  ];\n}\nfunction Kr(e) {\n  return e = va(Math.abs(e)), e ? e[1] : NaN;\n}\nfunction mT(e, t) {\n  return function(n, r) {\n    for (var i = n.length, s = [], a = 0, o = e[0], l = 0; i > 0 && o > 0 && (l + o + 1 > r && (o = Math.max(1, r - l)), s.push(n.substring(i -= o, i + o)), !((l += o + 1) > r)); )\n      o = e[a = (a + 1) % e.length];\n    return s.reverse().join(t);\n  };\n}\nfunction gT(e) {\n  return function(t) {\n    return t.replace(/[0-9]/g, function(n) {\n      return e[+n];\n    });\n  };\n}\nvar vT = /^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;\nfunction ts(e) {\n  if (!(t = vT.exec(e))) throw new Error("invalid format: " + e);\n  var t;\n  return new Bc({\n    fill: t[1],\n    align: t[2],\n    sign: t[3],\n    symbol: t[4],\n    zero: t[5],\n    width: t[6],\n    comma: t[7],\n    precision: t[8] && t[8].slice(1),\n    trim: t[9],\n    type: t[10]\n  });\n}\nts.prototype = Bc.prototype;\nfunction Bc(e) {\n  this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";\n}\nBc.prototype.toString = function() {\n  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;\n};\nfunction yT(e) {\n  t: for (var t = e.length, n = 1, r = -1, i; n < t; ++n)\n    switch (e[n]) {\n      case ".":\n        r = i = n;\n        break;\n      case "0":\n        r === 0 && (r = n), i = n;\n        break;\n      default:\n        if (!+e[n]) break t;\n        r > 0 && (r = 0);\n        break;\n    }\n  return r > 0 ? e.slice(0, r) + e.slice(i + 1) : e;\n}\nvar Om;\nfunction xT(e, t) {\n  var n = va(e, t);\n  if (!n) return e + "";\n  var r = n[0], i = n[1], s = i - (Om = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1, a = r.length;\n  return s === a ? r : s > a ? r + new Array(s - a + 1).join("0") : s > 0 ? r.slice(0, s) + "." + r.slice(s) : "0." + new Array(1 - s).join("0") + va(e, Math.max(0, t + s - 1))[0];\n}\nfunction wh(e, t) {\n  var n = va(e, t);\n  if (!n) return e + "";\n  var r = n[0], i = n[1];\n  return i < 0 ? "0." + new Array(-i).join("0") + r : r.length > i + 1 ? r.slice(0, i + 1) + "." + r.slice(i + 1) : r + new Array(i - r.length + 2).join("0");\n}\nconst $h = {\n  "%": (e, t) => (e * 100).toFixed(t),\n  b: (e) => Math.round(e).toString(2),\n  c: (e) => e + "",\n  d: fT,\n  e: (e, t) => e.toExponential(t),\n  f: (e, t) => e.toFixed(t),\n  g: (e, t) => e.toPrecision(t),\n  o: (e) => Math.round(e).toString(8),\n  p: (e, t) => wh(e * 100, t),\n  r: wh,\n  s: xT,\n  X: (e) => Math.round(e).toString(16).toUpperCase(),\n  x: (e) => Math.round(e).toString(16)\n};\nfunction Mh(e) {\n  return e;\n}\nvar Ch = Array.prototype.map, Ah = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];\nfunction bT(e) {\n  var t = e.grouping === void 0 || e.thousands === void 0 ? Mh : mT(Ch.call(e.grouping, Number), e.thousands + ""), n = e.currency === void 0 ? "" : e.currency[0] + "", r = e.currency === void 0 ? "" : e.currency[1] + "", i = e.decimal === void 0 ? "." : e.decimal + "", s = e.numerals === void 0 ? Mh : gT(Ch.call(e.numerals, String)), a = e.percent === void 0 ? "%" : e.percent + "", o = e.minus === void 0 ? "" : e.minus + "", l = e.nan === void 0 ? "NaN" : e.nan + "";\n  function c(d) {\n    d = ts(d);\n    var h = d.fill, p = d.align, f = d.sign, g = d.symbol, m = d.zero, v = d.width, x = d.comma, _ = d.precision, E = d.trim, b = d.type;\n    b === "n" ? (x = !0, b = "g") : $h[b] || (_ === void 0 && (_ = 12), E = !0, b = "g"), (m || h === "0" && p === "=") && (m = !0, h = "0", p = "=");\n    var S = g === "$" ? n : g === "#" && /[boxX]/.test(b) ? "0" + b.toLowerCase() : "", M = g === "$" ? r : /[%p]/.test(b) ? a : "", D = $h[b], A = /[defgprs%]/.test(b);\n    _ = _ === void 0 ? 6 : /[gprs]/.test(b) ? Math.max(1, Math.min(21, _)) : Math.max(0, Math.min(20, _));\n    function R($) {\n      var H = S, P = M, B, O, w;\n      if (b === "c")\n        P = D($) + P, $ = "";\n      else {\n        $ = +$;\n        var L = $ < 0 || 1 / $ < 0;\n        if ($ = isNaN($) ? l : D(Math.abs($), _), E && ($ = yT($)), L && +$ == 0 && f !== "+" && (L = !1), H = (L ? f === "(" ? f : o : f === "-" || f === "(" ? "" : f) + H, P = (b === "s" ? Ah[8 + Om / 3] : "") + P + (L && f === "(" ? ")" : ""), A) {\n          for (B = -1, O = $.length; ++B < O; )\n            if (w = $.charCodeAt(B), 48 > w || w > 57) {\n              P = (w === 46 ? i + $.slice(B + 1) : $.slice(B)) + P, $ = $.slice(0, B);\n              break;\n            }\n        }\n      }\n      x && !m && ($ = t($, 1 / 0));\n      var k = H.length + $.length + P.length, U = k < v ? new Array(v - k + 1).join(h) : "";\n      switch (x && m && ($ = t(U + $, U.length ? v - P.length : 1 / 0), U = ""), p) {\n        case "<":\n          $ = H + $ + P + U;\n          break;\n        case "=":\n          $ = H + U + $ + P;\n          break;\n        case "^":\n          $ = U.slice(0, k = U.length >> 1) + H + $ + P + U.slice(k);\n          break;\n        default:\n          $ = U + H + $ + P;\n          break;\n      }\n      return s($);\n    }\n    return R.toString = function() {\n      return d + "";\n    }, R;\n  }\n  function u(d, h) {\n    var p = c((d = ts(d), d.type = "f", d)), f = Math.max(-8, Math.min(8, Math.floor(Kr(h) / 3))) * 3, g = Math.pow(10, -f), m = Ah[8 + f / 3];\n    return function(v) {\n      return p(g * v) + m;\n    };\n  }\n  return {\n    format: c,\n    formatPrefix: u\n  };\n}\nvar Cs, Hc, Sm;\n_T({\n  thousands: ",",\n  grouping: [3],\n  currency: ["$", ""]\n});\nfunction _T(e) {\n  return Cs = bT(e), Hc = Cs.format, Sm = Cs.formatPrefix, Cs;\n}\nfunction ET(e) {\n  return Math.max(0, -Kr(Math.abs(e)));\n}\nfunction OT(e, t) {\n  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Kr(t) / 3))) * 3 - Kr(Math.abs(e)));\n}\nfunction ST(e, t) {\n  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, Kr(t) - Kr(e)) + 1;\n}\nfunction ii(e, t) {\n  switch (arguments.length) {\n    case 0:\n      break;\n    case 1:\n      this.range(e);\n      break;\n    default:\n      this.range(t).domain(e);\n      break;\n  }\n  return this;\n}\nconst Lh = Symbol("implicit");\nfunction ro() {\n  var e = new ch(), t = [], n = [], r = Lh;\n  function i(s) {\n    let a = e.get(s);\n    if (a === void 0) {\n      if (r !== Lh) return r;\n      e.set(s, a = t.push(s) - 1);\n    }\n    return n[a % n.length];\n  }\n  return i.domain = function(s) {\n    if (!arguments.length) return t.slice();\n    t = [], e = new ch();\n    for (const a of s)\n      e.has(a) || e.set(a, t.push(a) - 1);\n    return i;\n  }, i.range = function(s) {\n    return arguments.length ? (n = Array.from(s), i) : n.slice();\n  }, i.unknown = function(s) {\n    return arguments.length ? (r = s, i) : r;\n  }, i.copy = function() {\n    return ro(t, n).unknown(r);\n  }, ii.apply(i, arguments), i;\n}\nfunction TT(e) {\n  return function() {\n    return e;\n  };\n}\nfunction wT(e) {\n  return +e;\n}\nvar kh = [0, 1];\nfunction Ir(e) {\n  return e;\n}\nfunction Al(e, t) {\n  return (t -= e = +e) ? function(n) {\n    return (n - e) / t;\n  } : TT(isNaN(t) ? NaN : 0.5);\n}\nfunction $T(e, t) {\n  var n;\n  return e > t && (n = e, e = t, t = n), function(r) {\n    return Math.max(e, Math.min(t, r));\n  };\n}\nfunction MT(e, t, n) {\n  var r = e[0], i = e[1], s = t[0], a = t[1];\n  return i < r ? (r = Al(i, r), s = n(a, s)) : (r = Al(r, i), s = n(s, a)), function(o) {\n    return s(r(o));\n  };\n}\nfunction CT(e, t, n) {\n  var r = Math.min(e.length, t.length) - 1, i = new Array(r), s = new Array(r), a = -1;\n  for (e[r] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++a < r; )\n    i[a] = Al(e[a], e[a + 1]), s[a] = n(t[a], t[a + 1]);\n  return function(o) {\n    var l = Ac(e, o, 1, r) - 1;\n    return s[l](i[l](o));\n  };\n}\nfunction Vc(e, t) {\n  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());\n}\nfunction Tm() {\n  var e = kh, t = kh, n = fs, r, i, s, a = Ir, o, l, c;\n  function u() {\n    var h = Math.min(e.length, t.length);\n    return a !== Ir && (a = $T(e[0], e[h - 1])), o = h > 2 ? CT : MT, l = c = null, d;\n  }\n  function d(h) {\n    return h == null || isNaN(h = +h) ? s : (l || (l = o(e.map(r), t, n)))(r(a(h)));\n  }\n  return d.invert = function(h) {\n    return a(i((c || (c = o(t, e.map(r), xe)))(h)));\n  }, d.domain = function(h) {\n    return arguments.length ? (e = Array.from(h, wT), u()) : e.slice();\n  }, d.range = function(h) {\n    return arguments.length ? (t = Array.from(h), u()) : t.slice();\n  }, d.rangeRound = function(h) {\n    return t = Array.from(h), n = hm, u();\n  }, d.clamp = function(h) {\n    return arguments.length ? (a = h ? !0 : Ir, u()) : a !== Ir;\n  }, d.interpolate = function(h) {\n    return arguments.length ? (n = h, u()) : n;\n  }, d.unknown = function(h) {\n    return arguments.length ? (s = h, d) : s;\n  }, function(h, p) {\n    return r = h, i = p, u();\n  };\n}\nfunction wm() {\n  return Tm()(Ir, Ir);\n}\nfunction AT(e, t, n, r) {\n  var i = El(e, t, n), s;\n  switch (r = ts(r ?? ",f"), r.type) {\n    case "s": {\n      var a = Math.max(Math.abs(e), Math.abs(t));\n      return r.precision == null && !isNaN(s = OT(i, a)) && (r.precision = s), Sm(r, a);\n    }\n    case "":\n    case "e":\n    case "g":\n    case "p":\n    case "r": {\n      r.precision == null && !isNaN(s = ST(i, Math.max(Math.abs(e), Math.abs(t)))) && (r.precision = s - (r.type === "e"));\n      break;\n    }\n    case "f":\n    case "%": {\n      r.precision == null && !isNaN(s = ET(i)) && (r.precision = s - (r.type === "%") * 2);\n      break;\n    }\n  }\n  return Hc(r);\n}\nfunction $m(e) {\n  var t = e.domain;\n  return e.ticks = function(n) {\n    var r = t();\n    return ca(r[0], r[r.length - 1], n ?? 10);\n  }, e.tickFormat = function(n, r) {\n    var i = t();\n    return AT(i[0], i[i.length - 1], n ?? 10, r);\n  }, e.nice = function(n) {\n    n == null && (n = 10);\n    var r = t(), i = 0, s = r.length - 1, a = r[i], o = r[s], l, c, u = 10;\n    for (o < a && (c = a, a = o, o = c, c = i, i = s, s = c); u-- > 0; ) {\n      if (c = Yr(a, o, n), c === l)\n        return r[i] = a, r[s] = o, t(r);\n      if (c > 0)\n        a = Math.floor(a / c) * c, o = Math.ceil(o / c) * c;\n      else if (c < 0)\n        a = Math.ceil(a * c) / c, o = Math.floor(o * c) / c;\n      else\n        break;\n      l = c;\n    }\n    return e;\n  }, e;\n}\nfunction Fe() {\n  var e = wm();\n  return e.copy = function() {\n    return Vc(e, Fe());\n  }, ii.apply(e, arguments), $m(e);\n}\nfunction Gc() {\n  var e = 0, t = 1, n = 1, r = [0.5], i = [0, 1], s;\n  function a(l) {\n    return l != null && l <= l ? i[Ac(r, l, 0, n)] : s;\n  }\n  function o() {\n    var l = -1;\n    for (r = new Array(n); ++l < n; ) r[l] = ((l + 1) * t - (l - n) * e) / (n + 1);\n    return a;\n  }\n  return a.domain = function(l) {\n    return arguments.length ? ([e, t] = l, e = +e, t = +t, o()) : [e, t];\n  }, a.range = function(l) {\n    return arguments.length ? (n = (i = Array.from(l)).length - 1, o()) : i.slice();\n  }, a.invertExtent = function(l) {\n    var c = i.indexOf(l);\n    return c < 0 ? [NaN, NaN] : c < 1 ? [e, r[0]] : c >= n ? [r[n - 1], t] : [r[c - 1], r[c]];\n  }, a.unknown = function(l) {\n    return arguments.length && (s = l), a;\n  }, a.thresholds = function() {\n    return r.slice();\n  }, a.copy = function() {\n    return Gc().domain([e, t]).range(i).unknown(s);\n  }, ii.apply($m(a), arguments);\n}\nfunction $i(e, t, n) {\n  this.k = e, this.x = t, this.y = n;\n}\n$i.prototype = {\n  constructor: $i,\n  scale: function(e) {\n    return e === 1 ? this : new $i(this.k * e, this.x, this.y);\n  },\n  translate: function(e, t) {\n    return e === 0 & t === 0 ? this : new $i(this.k, this.x + this.k * e, this.y + this.k * t);\n  },\n  apply: function(e) {\n    return [e[0] * this.k + this.x, e[1] * this.k + this.y];\n  },\n  applyX: function(e) {\n    return e * this.k + this.x;\n  },\n  applyY: function(e) {\n    return e * this.k + this.y;\n  },\n  invert: function(e) {\n    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];\n  },\n  invertX: function(e) {\n    return (e - this.x) / this.k;\n  },\n  invertY: function(e) {\n    return (e - this.y) / this.k;\n  },\n  rescaleX: function(e) {\n    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));\n  },\n  rescaleY: function(e) {\n    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));\n  },\n  toString: function() {\n    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";\n  }\n};\n$i.prototype;\nconst ue = "cds", yn = {\n  opacity: {\n    unselected: 0.05,\n    selected: 0.4\n  }\n}, Pn = {\n  ticks: {\n    number: 7,\n    verticalSpaceRatio: 2.5,\n    horizontalSpaceRatio: 3.5\n  },\n  ratio: {\n    reference: "value",\n    compareTo: "marker"\n  },\n  paddingRatio: 0.1,\n  hover: {\n    rectanglePadding: 4\n  }\n}, Nr = {\n  duration: 1e3,\n  ease: Em,\n  zoomLevel: 3\n}, Cr = {\n  circles: {\n    fillOpacity: 0.3,\n    hover: {\n      stroke: "#FFF"\n    }\n  },\n  padding: {\n    mainGroup: 4,\n    children: 2\n  },\n  depth: 2\n}, Mm = {\n  pairingOptions: {\n    "1-color": 4,\n    "2-color": 5,\n    "3-color": 5,\n    "4-color": 3,\n    "5-color": 2,\n    "14-color": 1\n  }\n}, Te = {\n  circle: {\n    radius: 4,\n    opacity: {\n      hovered: 1,\n      default: 0.3\n    }\n  },\n  box: {\n    opacity: {\n      hovered: 0.5,\n      default: 0.3\n    }\n  },\n  strokeWidth: {\n    default: 1,\n    thicker: 2\n  }\n}, LT = {\n  defaultBins: 10\n}, It = {\n  items: {\n    status: {\n      ACTIVE: 1,\n      DISABLED: 0\n    },\n    horizontalSpace: 12,\n    verticalSpace: 24,\n    textYOffset: 8,\n    spaceAfter: 4\n  },\n  checkbox: {\n    radius: 6.5\n  },\n  radius: {\n    iconData: [\n      { cx: 7, cy: 7, r: 6.5 },\n      { cx: 7, cy: 10, r: 3.5 }\n    ],\n    fill: null,\n    stroke: "#8c8c8c"\n  },\n  line: {\n    yPosition: 6,\n    width: 24,\n    strokeWidth: 1.4,\n    fill: null,\n    stroke: "#999999"\n  },\n  area: {\n    width: 24,\n    height: 14,\n    fill: "#6f6f6f",\n    stroke: null\n  },\n  size: {\n    iconData: [\n      { width: 23, height: 12 },\n      { width: 13, height: 6 }\n    ],\n    fill: null,\n    stroke: "#8D8D8D"\n  },\n  quartile: {\n    iconData: [\n      { x: 0, y: 0, width: 24, height: 13 },\n      { x: 11, y: 4, width: 1, height: 4 }\n    ]\n  },\n  zoom: {\n    iconData: [{ x: 0, y: 0, width: 12, height: 12 }],\n    color: "#8D8D8D"\n  },\n  color: {\n    barWidth: 300,\n    barHeight: 8,\n    axisYTranslation: 10\n  }\n}, vn = {\n  opacity: {\n    unselected: 0.3,\n    selected: 1\n  },\n  weight: {\n    selected: 2,\n    unselected: 1\n  }\n}, Zt = {\n  statusBar: {\n    paddingRight: 5\n  },\n  status: {\n    indicatorSize: 16,\n    paddingLeft: 15\n  },\n  total: {\n    paddingLeft: 36,\n    paddingRight: 24\n  },\n  height: {\n    default: 8,\n    proportional: 16\n  },\n  dividerWidth: 2\n}, Mt = {\n  radiusOffset: -15,\n  innerRadius: 2,\n  padAngle: 7e-3,\n  hoverArc: {\n    outerRadiusOffset: 3\n  },\n  xOffset: 30,\n  yOffset: 20,\n  yOffsetCallout: 10,\n  callout: {\n    minSliceDegree: 5,\n    offsetX: 15,\n    offsetY: 12,\n    horizontalLineLength: 8,\n    textMargin: 2\n  }\n}, Wn = {\n  opacity: {\n    unselected: 0.1,\n    selected: 0.3\n  },\n  xLabelPadding: 10,\n  yLabelPadding: 8,\n  yTicksNumber: 4,\n  minRange: 10,\n  xAxisRectHeight: 50,\n  dotsRadius: 5\n}, Pe = {\n  nodeWidth: 4,\n  minNodePadding: 24,\n  opacity: {\n    unfocus: 0.3,\n    default: 0.8,\n    selected: 1\n  }\n}, Dh = {\n  minCellDividerDimension: 16\n}, Rh = {\n  default: {\n    size: 24\n  }\n}, Ih = {\n  defaultOffset: 4,\n  horizontalOffset: 10\n}, Nh = {\n  default: {\n    duration: 300\n  },\n  pie_slice_mouseover: {\n    duration: 100\n  },\n  pie_slice_mouseout: {\n    duration: 100\n  },\n  pie_chart_titles: {\n    duration: 375\n  },\n  graph_element_mouseover_fill_update: {\n    duration: 100\n  },\n  graph_element_mouseout_fill_update: {\n    duration: 100\n  }\n}, ye = {\n  height: {\n    [Ke.GRAPH_VIEW]: 32,\n    [Ke.SLIDER_VIEW]: 10\n  },\n  spacerHeight: 8,\n  handleWidth: 5,\n  handleBarWidth: 1,\n  handleBarHeight: 12\n}, kT = [\n  {\n    type: Gt.RADIUS,\n    name: "Radius"\n  },\n  {\n    type: Gt.AREA,\n    name: "Poor area"\n  },\n  {\n    type: Gt.AREA,\n    name: "Satisfactory area"\n  },\n  {\n    type: Gt.AREA,\n    name: "Great area"\n  },\n  {\n    type: Gt.QUARTILE,\n    name: "Quartiles"\n  }\n], Pr = {\n  type: Ve.END_LINE,\n  threshold: 16,\n  numCharacter: 14\n}, DT = {\n  code: typeof navigator < "u" && (navigator == null ? void 0 : navigator.language) || "en-US",\n  // read from browser\'s navigator.language\n  number: (e, t = (navigator == null ? void 0 : navigator.language) || "en-US") => {\n    var n;\n    return (n = e == null ? void 0 : e.toLocaleString) == null ? void 0 : n.call(e, t);\n  },\n  // based on code property if specified\n  date: (e, t = (navigator == null ? void 0 : navigator.language) || "en-US", n = {}, r = null) => r || e.toLocaleDateString(t, n),\n  // based on code property if specified\n  time: (e, t = (navigator == null ? void 0 : navigator.language) || "en-US", n = {}, r = null) => r || e.toLocaleTimeString(t, n),\n  // based on code property if specified\n  optionsObject: {\n    "15seconds": {\n      primary: {\n        "MMM d, pp": {\n          month: "short",\n          day: "numeric",\n          hour: "numeric",\n          minute: "2-digit",\n          second: "2-digit",\n          hourCycle: "h12"\n        },\n        "MMM d, h:mm:ss.SSS a": {\n          month: "short",\n          day: "numeric",\n          hour: "numeric",\n          minute: "2-digit",\n          fractionalSecondDigits: 3,\n          hourCycle: "h12"\n        }\n      },\n      secondary: {\n        pp: {\n          hour: "numeric",\n          minute: "2-digit",\n          second: "2-digit",\n          hourCycle: "h12"\n        },\n        "h:mm:ss.SSS a": {\n          hour: "numeric",\n          minute: "2-digit",\n          fractionalSecondDigits: 3,\n          hourCycle: "h12"\n        }\n      },\n      type: "time"\n    },\n    minute: {\n      primary: {\n        "MMM d, p": {\n          month: "short",\n          day: "numeric",\n          hour: "numeric",\n          minute: "2-digit",\n          hourCycle: "h12"\n        }\n      },\n      secondary: {\n        p: {\n          hour: "numeric",\n          minute: "2-digit",\n          hourCycle: "h12"\n        }\n      },\n      type: "time"\n    },\n    "30minutes": {\n      primary: {\n        "MMM d, p": {\n          month: "short",\n          day: "numeric",\n          hour: "numeric",\n          minute: "2-digit",\n          hourCycle: "h12"\n        }\n      },\n      secondary: {\n        p: {\n          hour: "numeric",\n          minute: "2-digit",\n          hourCycle: "h12"\n        }\n      },\n      type: "time"\n    },\n    hourly: {\n      primary: {\n        "MMM d, hh a": {\n          month: "short",\n          day: "numeric",\n          hour: "2-digit",\n          hourCycle: "h12"\n        }\n      },\n      secondary: {\n        "hh a": {\n          hour: "2-digit",\n          hourCycle: "h12"\n        }\n      },\n      type: "time"\n    },\n    daily: {\n      primary: {\n        "MMM d": {\n          month: "short",\n          day: "numeric"\n        }\n      },\n      secondary: {\n        d: {\n          day: "numeric"\n        }\n      },\n      type: "date"\n    },\n    weekly: {\n      primary: {\n        "eee, MMM d": {\n          weekday: "short",\n          month: "short",\n          day: "numeric"\n        }\n      },\n      secondary: {\n        eee: {\n          weekday: "short"\n        }\n      },\n      type: "date"\n    },\n    monthly: {\n      primary: {\n        "MMM yyyy": {\n          month: "short",\n          year: "numeric"\n        }\n      },\n      secondary: {\n        MMM: {\n          month: "short"\n        }\n      },\n      type: "date"\n    },\n    quarterly: {\n      primary: {},\n      secondary: {},\n      type: "date"\n    },\n    yearly: {\n      primary: {\n        yyyy: {\n          year: "numeric"\n        }\n      },\n      secondary: {\n        yyyy: {\n          year: "numeric"\n        }\n      },\n      type: "date"\n    }\n  },\n  translations: {\n    group: "Group",\n    total: "Total",\n    meter: {\n      title: ""\n      //default is emply string as meter title is dataset label\n    },\n    tabularRep: {\n      title: "Tabular representation",\n      downloadAsCSV: "Download as CSV"\n    },\n    toolbar: {\n      exportAsCSV: "Export to CSV",\n      exportAsJPG: "Export to JPG",\n      exportAsPNG: "Export to PNG",\n      zoomIn: "Zoom in",\n      zoomOut: "Zoom out",\n      resetZoom: "Reset zoom",\n      moreOptions: "More options",\n      makeFullScreen: "Make fullscreen",\n      exitFullScreen: "Exit fullscreen",\n      showAsTable: "Show as table"\n    }\n  }\n}, RT = {\n  enabled: !0,\n  position: Ni.BOTTOM,\n  clickable: !0,\n  truncation: Pr,\n  alignment: jt.LEFT,\n  order: null,\n  additionalItems: []\n}, IT = {\n  x: {\n    // set enable to false will not draw grid and stroke of grid backdrop\n    enabled: !0,\n    numberOfTicks: 15,\n    alignWithAxisTicks: !1\n  },\n  y: {\n    // set enable to false will not draw grid and stroke of grid backdrop\n    enabled: !0,\n    numberOfTicks: 5,\n    alignWithAxisTicks: !1\n  }\n}, NT = {\n  // enable or disable ruler\n  enabled: !0\n}, Cm = {\n  enabled: !0,\n  showTotal: !0,\n  truncation: Pr,\n  groupLabel: "Group"\n}, Am = {\n  top: {\n    visible: !0,\n    includeZero: !0,\n    truncation: Pr\n  },\n  bottom: {\n    visible: !0,\n    includeZero: !0,\n    truncation: Pr\n  },\n  left: {\n    visible: !0,\n    includeZero: !0,\n    truncation: Pr\n  },\n  right: {\n    visible: !0,\n    includeZero: !0,\n    truncation: Pr\n  }\n}, io = {\n  addSpaceOnEdges: 1,\n  showDayName: !1,\n  localeObject: df,\n  timeIntervalFormats: {\n    "15seconds": { primary: "MMM d, pp", secondary: "pp" },\n    minute: { primary: "MMM d, p", secondary: "p" },\n    "30minutes": { primary: "MMM d, p", secondary: "p" },\n    hourly: { primary: "MMM d, hh a", secondary: "hh a" },\n    daily: { primary: "MMM d", secondary: "d" },\n    weekly: { primary: "eee, MMM d", secondary: "eee" },\n    monthly: { primary: "MMM yyyy", secondary: "MMM" },\n    quarterly: { primary: "QQQ \'\'yy", secondary: "QQQ" },\n    yearly: { primary: "yyyy", secondary: "yyyy" }\n  }\n};\nlet Lm = !1;\ntry {\n  Lm = typeof document < "u" && (document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled);\n} catch (e) {\n  console.warn("Fullscreen capabilities check failed: ", e.message);\n}\nconst re = {\n  width: null,\n  height: null,\n  resizable: !0,\n  theme: of.WHITE,\n  tooltip: Cm,\n  legend: RT,\n  locale: DT,\n  style: {\n    prefix: "cc"\n  },\n  data: {\n    groupMapsTo: "group",\n    loading: !1,\n    selectedGroups: []\n  },\n  color: {\n    scale: null,\n    pairing: {\n      numberOfVariants: null,\n      option: 1\n    },\n    gradient: {\n      enabled: !1\n    }\n  },\n  toolbar: {\n    enabled: !0,\n    numberOfIcons: 3,\n    controls: [\n      {\n        type: _t.SHOW_AS_DATATABLE\n      },\n      ...Lm ? [\n        {\n          type: _t.MAKE_FULLSCREEN\n        }\n      ] : [],\n      {\n        type: _t.EXPORT_CSV\n      },\n      {\n        type: _t.EXPORT_PNG\n      },\n      {\n        type: _t.EXPORT_JPG\n      }\n    ]\n  }\n}, km = at({}, re, {\n  thematic: {\n    projection: gn.geoNaturalEarth1\n  }\n}), ms = at({}, re, {\n  axes: Am,\n  timeScale: io,\n  grid: IT,\n  ruler: NT,\n  zoomBar: {\n    zoomRatio: 0.4,\n    minZoomRatio: 0.01,\n    top: {\n      enabled: !1,\n      type: Ke.GRAPH_VIEW\n    }\n  }\n}), sr = at({}, ms, {\n  bars: {\n    maxWidth: 16,\n    spacingFactor: 0.25\n  },\n  timeScale: at(io, {\n    addSpaceOnEdges: 1\n  })\n}), PT = at({}, sr, {}), UT = at({}, sr, {}), BT = at({}, sr, {\n  bars: at({}, sr.bars, {\n    dividerSize: 1.5\n  })\n}), HT = at({}, sr, {}), zc = at({}, ms, {\n  points: {\n    // default point radius to 4\n    radius: 4,\n    fillOpacity: 0.3,\n    filled: !0,\n    enabled: !0\n  }\n}), VT = zc, Dm = at({}, zc, {\n  points: {\n    // default point radius to 3\n    radius: 3,\n    filled: !1,\n    enabled: !0\n  }\n}), Rm = at({}, Dm, {\n  timeScale: at(io, {\n    addSpaceOnEdges: 0\n  })\n}), GT = Rm, zT = at({}, ms, {\n  bubble: {\n    radiusMapsTo: "radius",\n    radiusLabel: "Radius",\n    radiusRange: (e) => {\n      const t = Math.min(e.width, e.height);\n      return [t * 3 / 400, t * 25 / 400];\n    },\n    fillOpacity: 0.2,\n    enabled: !0\n  },\n  points: {\n    filled: !0\n  },\n  legend: {\n    additionalItems: [\n      {\n        type: Gt.RADIUS,\n        name: "Radius"\n      }\n    ]\n  }\n}), FT = at({}, ms, {\n  bullet: {\n    performanceAreaTitles: ["Poor", "Satisfactory", "Great"]\n  },\n  grid: {\n    x: {\n      enabled: !1\n    },\n    y: {\n      enabled: !1\n    }\n  },\n  legend: {\n    additionalItems: [\n      {\n        type: Gt.AREA,\n        name: "Poor area"\n      },\n      {\n        type: Gt.AREA,\n        name: "Satisfactory area"\n      },\n      {\n        type: Gt.AREA,\n        name: "Great area"\n      },\n      {\n        type: Gt.QUARTILE,\n        name: "Quartiles"\n      }\n    ]\n  }\n}), jT = at({}, sr, {\n  bars: {\n    dividerSize: 1.5\n  },\n  timeScale: at(io, {\n    addSpaceOnEdges: 0\n  })\n}), WT = at({}, re, {\n  tooltip: at({}, Cm, {\n    wordLabel: "Word",\n    valueLabel: "Value"\n  }),\n  wordCloud: {\n    fontSizeMapsTo: "value",\n    fontSizeRange: (e) => {\n      const t = Math.min(e.width, e.height);\n      return [t * 20 / 400, t * 75 / 400];\n    },\n    wordMapsTo: "word"\n  }\n}), Im = at({}, re, {\n  pie: {\n    labels: {\n      formatter: null,\n      enabled: !0\n    },\n    alignment: jt.LEFT,\n    sortFunction: null,\n    valueMapsTo: "value"\n  }\n}), qT = at({}, re, {\n  legend: {\n    enabled: !1\n  },\n  gauge: {\n    type: Rr.SEMI,\n    arcWidth: 16,\n    deltaArrow: {\n      size: (e) => e / 8,\n      enabled: !0\n    },\n    showPercentageSymbol: !0,\n    status: null,\n    numberSpacing: 10,\n    deltaFontSize: (e) => e / 8,\n    valueFontSize: (e) => e / 2.5,\n    alignment: jt.LEFT\n  }\n}), YT = at({}, Im, {\n  donut: {\n    center: {\n      numberFontSize: (e) => `${Math.min(e / 100 * 24, 24)}px`,\n      titleFontSize: (e) => `${Math.min(e / 100 * 15, 15)}px`,\n      titleYPosition: (e) => Math.min(e / 80 * 20, 20)\n    },\n    alignment: jt.LEFT\n  }\n}), Nm = at({}, re, {\n  legend: {\n    enabled: !1,\n    clickable: !1\n  },\n  meter: {\n    showLabels: !0,\n    proportional: null,\n    statusBar: {\n      percentageIndicator: {\n        enabled: !0\n      }\n    }\n  }\n}), XT = at({}, Nm, {\n  legend: {\n    enabled: !0\n  }\n}), ZT = at({}, re, {\n  radar: {\n    axes: {\n      angle: "key",\n      value: "value"\n    },\n    alignment: jt.LEFT\n  },\n  tooltip: {\n    gridline: {\n      enabled: !0\n    }\n  }\n}), KT = at({}, sr, {\n  comboChartTypes: []\n}), QT = at(\n  {\n    tree: {\n      type: pc.TREE\n    }\n  },\n  re,\n  {}\n), JT = at({}, re, {\n  data: at(re.data, {\n    groupMapsTo: "name"\n  })\n}), tw = at({}, re, Cr, {\n  data: at(re.data, {\n    groupMapsTo: "name"\n  })\n}), ew = at({}, re, {\n  alluvial: {\n    data: at(re.data, {\n      groupMapsTo: "source"\n    }),\n    nodeAlignment: jt.CENTER,\n    nodePadding: 24,\n    monochrome: !1,\n    nodes: []\n  }\n}), nw = at({}, re, {\n  axes: Am,\n  heatmap: {\n    divider: {\n      state: Pi.AUTO\n    },\n    colorLegend: {\n      type: "linear"\n    }\n  }\n}), rw = at({}, km, {\n  choropleth: {\n    colorLegend: {\n      type: "linear"\n    }\n  }\n}), wt = {\n  alluvialChart: ew,\n  areaChart: Rm,\n  axisChart: ms,\n  boxplotChart: HT,\n  bubbleChart: zT,\n  bulletChart: FT,\n  chart: re,\n  circlePackChart: tw,\n  choroplethChart: rw,\n  comboChart: KT,\n  donutChart: YT,\n  gaugeChart: qT,\n  groupedBarChart: UT,\n  heatmapChart: nw,\n  histogramChart: jT,\n  lineChart: Dm,\n  lollipopChart: VT,\n  meterChart: Nm,\n  pieChart: Im,\n  proportionalMeterChart: XT,\n  radarChart: ZT,\n  scatterChart: zc,\n  simpleBarChart: PT,\n  stackedAreaChart: GT,\n  stackedBarChart: BT,\n  thematicChart: km,\n  treeChart: QT,\n  treemapChart: JT,\n  wordCloudChart: WT\n};\nfunction iw(e, t, n) {\n  let r = null;\n  return function(...i) {\n    const s = this;\n    s.mousePosition = rr(i[0], n), clearTimeout(r), r = setTimeout(function() {\n      e.apply(s, i);\n    }, t);\n  };\n}\nfunction Rt(e, t) {\n  var n;\n  const r = Sn(e), i = Object.keys(t.axes || {});\n  (n = t == null ? void 0 : t.toolbar) != null && n.controls && delete r.toolbar.controls, i.length === 0 && delete r.axes;\n  for (const s in r.axes)\n    if (i.includes(s)) {\n      const a = t.axes[s];\n      if ((a.primary || a.secondary) && console.warn(\n        "`primary` & `secondary` are no longer needed for axis configurations. Read more here https://charts.carbondesignsystem.com/"\n      ), a.mapsTo == null) {\n        const l = a.scaleType;\n        l == null ? a.mapsTo = "value" : l === et.TIME ? a.mapsTo = "date" : l === et.LABELS && (a.mapsTo = "key");\n      }\n    } else\n      delete r.axes[s];\n  return Fc(r, t), at(r, t);\n}\nfunction fn(e) {\n  if (!e)\n    return;\n  const t = /translate\\([0-9]+\\.?[0-9]*,[0-9]+\\.?[0-9]*\\)/, n = e.getAttribute("transform").match(t);\n  if (!n)\n    return null;\n  if (n[0]) {\n    const r = n[0].replace(/translate\\(/, "").replace(/\\)/, "").split(",");\n    return {\n      tx: r[0],\n      ty: r[1]\n    };\n  }\n  return null;\n}\nfunction Mi(e) {\n  const t = /\\(([^)]+)\\)/.exec(e);\n  if (t && t.length > 1) {\n    const n = t[1].split(",");\n    if (n.length > 1)\n      return {\n        x: parseFloat(n[0]),\n        y: parseFloat(n[1])\n      };\n  }\n  return { x: 0, y: 0 };\n}\nfunction Lo(e, t, n = "value", r = !1) {\n  const i = e / t.reduce((s, a) => s + a[n], 0) * 100;\n  return r ? i : i % 1 !== 0 ? parseFloat(i.toFixed(1)) : i;\n}\nfunction es(e, t, n) {\n  if (n > e.length)\n    return e;\n  if (t === Ve.MID_LINE)\n    return e.substr(0, n / 2) + "..." + e.substr(-n / 2);\n  if (t === Ve.FRONT_LINE)\n    return "..." + e.substr(-n);\n  if (t === Ve.END_LINE)\n    return e.substr(0, n) + "...";\n}\nfunction Fc(e, t) {\n  const n = y(e, "legend", "additionalItems"), r = y(t, "legend", "additionalItems");\n  if (n && r) {\n    const i = r.map((o) => o.type), s = n.map((o) => o.type), a = kT.filter(\n      (o) => s.includes(o.type) && !i.includes(o.type)\n    );\n    e.legend.additionalItems = a, t.legend.additionalItems = B_(\n      a,\n      r,\n      "name"\n    );\n  }\n}\nconst y = (e, ...t) => {\n  let n = e;\n  if (n) {\n    for (const r of t)\n      if (n[r] !== null && n[r] !== void 0)\n        n = n[r];\n      else\n        return null;\n    return n;\n  }\n  return null;\n}, Pm = (e, t) => t === Ft.HORIZONTAL ? {\n  y0: e.x0,\n  y1: e.x1,\n  x0: e.y0,\n  x1: e.y1\n} : e, ae = (e, t) => {\n  const { x0: n, x1: r, y0: i, y1: s } = Pm(e, t);\n  return `M${n},${i}L${n},${s}L${r},${s}L${r},${i}L${n},${i}`;\n};\nfunction En(e, t, n) {\n  return n === Ft.VERTICAL ? [e, t] : [t, e];\n}\nfunction Ph(e) {\n  const t = Ht(e), n = new Date(\n    Date.UTC(\n      t.getFullYear(),\n      t.getMonth(),\n      t.getDate(),\n      t.getHours(),\n      t.getMinutes(),\n      t.getSeconds(),\n      t.getMilliseconds()\n    )\n  );\n  return n.setUTCFullYear(t.getFullYear()), +e - +n;\n}\nfunction Uh(e, t) {\n  const n = Ht(e, void 0);\n  return n.setHours(0, 0, 0, 0), n;\n}\nfunction Um(e, t, n) {\n  const [r, i] = ur(\n    void 0,\n    e,\n    t\n  ), s = Uh(r), a = Uh(i), o = +s - Ph(s), l = +a - Ph(a);\n  return Math.round((o - l) / g0);\n}\nfunction sw(e, t) {\n  const n = Ht(e, void 0);\n  return n.setFullYear(n.getFullYear(), 0, 1), n.setHours(0, 0, 0, 0), n;\n}\nfunction aw(e, t) {\n  const n = Ht(e, void 0);\n  return Um(n, sw(n)) + 1;\n}\nfunction ya(e, t) {\n  return Wi(e, { ...t, weekStartsOn: 1 });\n}\nfunction Bm(e, t) {\n  const n = Ht(e, void 0), r = n.getFullYear(), i = Le(n, 0);\n  i.setFullYear(r + 1, 0, 4), i.setHours(0, 0, 0, 0);\n  const s = ya(i), a = Le(n, 0);\n  a.setFullYear(r, 0, 4), a.setHours(0, 0, 0, 0);\n  const o = ya(a);\n  return n.getTime() >= s.getTime() ? r + 1 : n.getTime() >= o.getTime() ? r : r - 1;\n}\nfunction ow(e, t) {\n  const n = Bm(e), r = Le(e, 0);\n  return r.setFullYear(n, 0, 4), r.setHours(0, 0, 0, 0), ya(r);\n}\nfunction lw(e, t) {\n  const n = Ht(e, void 0), r = +ya(n) - +ow(n);\n  return Math.round(r / cf) + 1;\n}\nfunction Hm(e, t) {\n  var n, r, i, s;\n  const a = Ht(e, t == null ? void 0 : t.in), o = a.getFullYear(), l = za(), c = (t == null ? void 0 : t.firstWeekContainsDate) ?? ((r = (n = t == null ? void 0 : t.locale) == null ? void 0 : n.options) == null ? void 0 : r.firstWeekContainsDate) ?? l.firstWeekContainsDate ?? ((s = (i = l.locale) == null ? void 0 : i.options) == null ? void 0 : s.firstWeekContainsDate) ?? 1, u = Le((t == null ? void 0 : t.in) || e, 0);\n  u.setFullYear(o + 1, 0, c), u.setHours(0, 0, 0, 0);\n  const d = Wi(u, t), h = Le((t == null ? void 0 : t.in) || e, 0);\n  h.setFullYear(o, 0, c), h.setHours(0, 0, 0, 0);\n  const p = Wi(h, t);\n  return +a >= +d ? o + 1 : +a >= +p ? o : o - 1;\n}\nfunction cw(e, t) {\n  var n, r, i, s;\n  const a = za(), o = (t == null ? void 0 : t.firstWeekContainsDate) ?? ((r = (n = t == null ? void 0 : t.locale) == null ? void 0 : n.options) == null ? void 0 : r.firstWeekContainsDate) ?? a.firstWeekContainsDate ?? ((s = (i = a.locale) == null ? void 0 : i.options) == null ? void 0 : s.firstWeekContainsDate) ?? 1, l = Hm(e, t), c = Le((t == null ? void 0 : t.in) || e, 0);\n  return c.setFullYear(l, 0, o), c.setHours(0, 0, 0, 0), Wi(c, t);\n}\nfunction uw(e, t) {\n  const n = Ht(e, t == null ? void 0 : t.in), r = +Wi(n, t) - +cw(n, t);\n  return Math.round(r / cf) + 1;\n}\nfunction Et(e, t) {\n  const n = e < 0 ? "-" : "", r = Math.abs(e).toString().padStart(t, "0");\n  return n + r;\n}\nconst Rn = {\n  // Year\n  y(e, t) {\n    const n = e.getFullYear(), r = n > 0 ? n : 1 - n;\n    return Et(t === "yy" ? r % 100 : r, t.length);\n  },\n  // Month\n  M(e, t) {\n    const n = e.getMonth();\n    return t === "M" ? String(n + 1) : Et(n + 1, 2);\n  },\n  // Day of the month\n  d(e, t) {\n    return Et(e.getDate(), t.length);\n  },\n  // AM or PM\n  a(e, t) {\n    const n = e.getHours() / 12 >= 1 ? "pm" : "am";\n    switch (t) {\n      case "a":\n      case "aa":\n        return n.toUpperCase();\n      case "aaa":\n        return n;\n      case "aaaaa":\n        return n[0];\n      case "aaaa":\n      default:\n        return n === "am" ? "a.m." : "p.m.";\n    }\n  },\n  // Hour [1-12]\n  h(e, t) {\n    return Et(e.getHours() % 12 || 12, t.length);\n  },\n  // Hour [0-23]\n  H(e, t) {\n    return Et(e.getHours(), t.length);\n  },\n  // Minute\n  m(e, t) {\n    return Et(e.getMinutes(), t.length);\n  },\n  // Second\n  s(e, t) {\n    return Et(e.getSeconds(), t.length);\n  },\n  // Fraction of second\n  S(e, t) {\n    const n = t.length, r = e.getMilliseconds(), i = Math.trunc(\n      r * Math.pow(10, n - 3)\n    );\n    return Et(i, t.length);\n  }\n}, Or = {\n  midnight: "midnight",\n  noon: "noon",\n  morning: "morning",\n  afternoon: "afternoon",\n  evening: "evening",\n  night: "night"\n}, Bh = {\n  // Era\n  G: function(e, t, n) {\n    const r = e.getFullYear() > 0 ? 1 : 0;\n    switch (t) {\n      // AD, BC\n      case "G":\n      case "GG":\n      case "GGG":\n        return n.era(r, { width: "abbreviated" });\n      // A, B\n      case "GGGGG":\n        return n.era(r, { width: "narrow" });\n      // Anno Domini, Before Christ\n      case "GGGG":\n      default:\n        return n.era(r, { width: "wide" });\n    }\n  },\n  // Year\n  y: function(e, t, n) {\n    if (t === "yo") {\n      const r = e.getFullYear(), i = r > 0 ? r : 1 - r;\n      return n.ordinalNumber(i, { unit: "year" });\n    }\n    return Rn.y(e, t);\n  },\n  // Local week-numbering year\n  Y: function(e, t, n, r) {\n    const i = Hm(e, r), s = i > 0 ? i : 1 - i;\n    if (t === "YY") {\n      const a = s % 100;\n      return Et(a, 2);\n    }\n    return t === "Yo" ? n.ordinalNumber(s, { unit: "year" }) : Et(s, t.length);\n  },\n  // ISO week-numbering year\n  R: function(e, t) {\n    const n = Bm(e);\n    return Et(n, t.length);\n  },\n  // Extended year. This is a single number designating the year of this calendar system.\n  // The main difference between `y` and `u` localizers are B.C. years:\n  // | Year | `y` | `u` |\n  // |------|-----|-----|\n  // | AC 1 |   1 |   1 |\n  // | BC 1 |   1 |   0 |\n  // | BC 2 |   2 |  -1 |\n  // Also `yy` always returns the last two digits of a year,\n  // while `uu` pads single digit years to 2 characters and returns other years unchanged.\n  u: function(e, t) {\n    const n = e.getFullYear();\n    return Et(n, t.length);\n  },\n  // Quarter\n  Q: function(e, t, n) {\n    const r = Math.ceil((e.getMonth() + 1) / 3);\n    switch (t) {\n      // 1, 2, 3, 4\n      case "Q":\n        return String(r);\n      // 01, 02, 03, 04\n      case "QQ":\n        return Et(r, 2);\n      // 1st, 2nd, 3rd, 4th\n      case "Qo":\n        return n.ordinalNumber(r, { unit: "quarter" });\n      // Q1, Q2, Q3, Q4\n      case "QQQ":\n        return n.quarter(r, {\n          width: "abbreviated",\n          context: "formatting"\n        });\n      // 1, 2, 3, 4 (narrow quarter; could be not numerical)\n      case "QQQQQ":\n        return n.quarter(r, {\n          width: "narrow",\n          context: "formatting"\n        });\n      // 1st quarter, 2nd quarter, ...\n      case "QQQQ":\n      default:\n        return n.quarter(r, {\n          width: "wide",\n          context: "formatting"\n        });\n    }\n  },\n  // Stand-alone quarter\n  q: function(e, t, n) {\n    const r = Math.ceil((e.getMonth() + 1) / 3);\n    switch (t) {\n      // 1, 2, 3, 4\n      case "q":\n        return String(r);\n      // 01, 02, 03, 04\n      case "qq":\n        return Et(r, 2);\n      // 1st, 2nd, 3rd, 4th\n      case "qo":\n        return n.ordinalNumber(r, { unit: "quarter" });\n      // Q1, Q2, Q3, Q4\n      case "qqq":\n        return n.quarter(r, {\n          width: "abbreviated",\n          context: "standalone"\n        });\n      // 1, 2, 3, 4 (narrow quarter; could be not numerical)\n      case "qqqqq":\n        return n.quarter(r, {\n          width: "narrow",\n          context: "standalone"\n        });\n      // 1st quarter, 2nd quarter, ...\n      case "qqqq":\n      default:\n        return n.quarter(r, {\n          width: "wide",\n          context: "standalone"\n        });\n    }\n  },\n  // Month\n  M: function(e, t, n) {\n    const r = e.getMonth();\n    switch (t) {\n      case "M":\n      case "MM":\n        return Rn.M(e, t);\n      // 1st, 2nd, ..., 12th\n      case "Mo":\n        return n.ordinalNumber(r + 1, { unit: "month" });\n      // Jan, Feb, ..., Dec\n      case "MMM":\n        return n.month(r, {\n          width: "abbreviated",\n          context: "formatting"\n        });\n      // J, F, ..., D\n      case "MMMMM":\n        return n.month(r, {\n          width: "narrow",\n          context: "formatting"\n        });\n      // January, February, ..., December\n      case "MMMM":\n      default:\n        return n.month(r, { width: "wide", context: "formatting" });\n    }\n  },\n  // Stand-alone month\n  L: function(e, t, n) {\n    const r = e.getMonth();\n    switch (t) {\n      // 1, 2, ..., 12\n      case "L":\n        return String(r + 1);\n      // 01, 02, ..., 12\n      case "LL":\n        return Et(r + 1, 2);\n      // 1st, 2nd, ..., 12th\n      case "Lo":\n        return n.ordinalNumber(r + 1, { unit: "month" });\n      // Jan, Feb, ..., Dec\n      case "LLL":\n        return n.month(r, {\n          width: "abbreviated",\n          context: "standalone"\n        });\n      // J, F, ..., D\n      case "LLLLL":\n        return n.month(r, {\n          width: "narrow",\n          context: "standalone"\n        });\n      // January, February, ..., December\n      case "LLLL":\n      default:\n        return n.month(r, { width: "wide", context: "standalone" });\n    }\n  },\n  // Local week of year\n  w: function(e, t, n, r) {\n    const i = uw(e, r);\n    return t === "wo" ? n.ordinalNumber(i, { unit: "week" }) : Et(i, t.length);\n  },\n  // ISO week of year\n  I: function(e, t, n) {\n    const r = lw(e);\n    return t === "Io" ? n.ordinalNumber(r, { unit: "week" }) : Et(r, t.length);\n  },\n  // Day of the month\n  d: function(e, t, n) {\n    return t === "do" ? n.ordinalNumber(e.getDate(), { unit: "date" }) : Rn.d(e, t);\n  },\n  // Day of year\n  D: function(e, t, n) {\n    const r = aw(e);\n    return t === "Do" ? n.ordinalNumber(r, { unit: "dayOfYear" }) : Et(r, t.length);\n  },\n  // Day of week\n  E: function(e, t, n) {\n    const r = e.getDay();\n    switch (t) {\n      // Tue\n      case "E":\n      case "EE":\n      case "EEE":\n        return n.day(r, {\n          width: "abbreviated",\n          context: "formatting"\n        });\n      // T\n      case "EEEEE":\n        return n.day(r, {\n          width: "narrow",\n          context: "formatting"\n        });\n      // Tu\n      case "EEEEEE":\n        return n.day(r, {\n          width: "short",\n          context: "formatting"\n        });\n      // Tuesday\n      case "EEEE":\n      default:\n        return n.day(r, {\n          width: "wide",\n          context: "formatting"\n        });\n    }\n  },\n  // Local day of week\n  e: function(e, t, n, r) {\n    const i = e.getDay(), s = (i - r.weekStartsOn + 8) % 7 || 7;\n    switch (t) {\n      // Numerical value (Nth day of week with current locale or weekStartsOn)\n      case "e":\n        return String(s);\n      // Padded numerical value\n      case "ee":\n        return Et(s, 2);\n      // 1st, 2nd, ..., 7th\n      case "eo":\n        return n.ordinalNumber(s, { unit: "day" });\n      case "eee":\n        return n.day(i, {\n          width: "abbreviated",\n          context: "formatting"\n        });\n      // T\n      case "eeeee":\n        return n.day(i, {\n          width: "narrow",\n          context: "formatting"\n        });\n      // Tu\n      case "eeeeee":\n        return n.day(i, {\n          width: "short",\n          context: "formatting"\n        });\n      // Tuesday\n      case "eeee":\n      default:\n        return n.day(i, {\n          width: "wide",\n          context: "formatting"\n        });\n    }\n  },\n  // Stand-alone local day of week\n  c: function(e, t, n, r) {\n    const i = e.getDay(), s = (i - r.weekStartsOn + 8) % 7 || 7;\n    switch (t) {\n      // Numerical value (same as in `e`)\n      case "c":\n        return String(s);\n      // Padded numerical value\n      case "cc":\n        return Et(s, t.length);\n      // 1st, 2nd, ..., 7th\n      case "co":\n        return n.ordinalNumber(s, { unit: "day" });\n      case "ccc":\n        return n.day(i, {\n          width: "abbreviated",\n          context: "standalone"\n        });\n      // T\n      case "ccccc":\n        return n.day(i, {\n          width: "narrow",\n          context: "standalone"\n        });\n      // Tu\n      case "cccccc":\n        return n.day(i, {\n          width: "short",\n          context: "standalone"\n        });\n      // Tuesday\n      case "cccc":\n      default:\n        return n.day(i, {\n          width: "wide",\n          context: "standalone"\n        });\n    }\n  },\n  // ISO day of week\n  i: function(e, t, n) {\n    const r = e.getDay(), i = r === 0 ? 7 : r;\n    switch (t) {\n      // 2\n      case "i":\n        return String(i);\n      // 02\n      case "ii":\n        return Et(i, t.length);\n      // 2nd\n      case "io":\n        return n.ordinalNumber(i, { unit: "day" });\n      // Tue\n      case "iii":\n        return n.day(r, {\n          width: "abbreviated",\n          context: "formatting"\n        });\n      // T\n      case "iiiii":\n        return n.day(r, {\n          width: "narrow",\n          context: "formatting"\n        });\n      // Tu\n      case "iiiiii":\n        return n.day(r, {\n          width: "short",\n          context: "formatting"\n        });\n      // Tuesday\n      case "iiii":\n      default:\n        return n.day(r, {\n          width: "wide",\n          context: "formatting"\n        });\n    }\n  },\n  // AM or PM\n  a: function(e, t, n) {\n    const r = e.getHours() / 12 >= 1 ? "pm" : "am";\n    switch (t) {\n      case "a":\n      case "aa":\n        return n.dayPeriod(r, {\n          width: "abbreviated",\n          context: "formatting"\n        });\n      case "aaa":\n        return n.dayPeriod(r, {\n          width: "abbreviated",\n          context: "formatting"\n        }).toLowerCase();\n      case "aaaaa":\n        return n.dayPeriod(r, {\n          width: "narrow",\n          context: "formatting"\n        });\n      case "aaaa":\n      default:\n        return n.dayPeriod(r, {\n          width: "wide",\n          context: "formatting"\n        });\n    }\n  },\n  // AM, PM, midnight, noon\n  b: function(e, t, n) {\n    const r = e.getHours();\n    let i;\n    switch (r === 12 ? i = Or.noon : r === 0 ? i = Or.midnight : i = r / 12 >= 1 ? "pm" : "am", t) {\n      case "b":\n      case "bb":\n        return n.dayPeriod(i, {\n          width: "abbreviated",\n          context: "formatting"\n        });\n      case "bbb":\n        return n.dayPeriod(i, {\n          width: "abbreviated",\n          context: "formatting"\n        }).toLowerCase();\n      case "bbbbb":\n        return n.dayPeriod(i, {\n          width: "narrow",\n          context: "formatting"\n        });\n      case "bbbb":\n      default:\n        return n.dayPeriod(i, {\n          width: "wide",\n          context: "formatting"\n        });\n    }\n  },\n  // in the morning, in the afternoon, in the evening, at night\n  B: function(e, t, n) {\n    const r = e.getHours();\n    let i;\n    switch (r >= 17 ? i = Or.evening : r >= 12 ? i = Or.afternoon : r >= 4 ? i = Or.morning : i = Or.night, t) {\n      case "B":\n      case "BB":\n      case "BBB":\n        return n.dayPeriod(i, {\n          width: "abbreviated",\n          context: "formatting"\n        });\n      case "BBBBB":\n        return n.dayPeriod(i, {\n          width: "narrow",\n          context: "formatting"\n        });\n      case "BBBB":\n      default:\n        return n.dayPeriod(i, {\n          width: "wide",\n          context: "formatting"\n        });\n    }\n  },\n  // Hour [1-12]\n  h: function(e, t, n) {\n    if (t === "ho") {\n      let r = e.getHours() % 12;\n      return r === 0 && (r = 12), n.ordinalNumber(r, { unit: "hour" });\n    }\n    return Rn.h(e, t);\n  },\n  // Hour [0-23]\n  H: function(e, t, n) {\n    return t === "Ho" ? n.ordinalNumber(e.getHours(), { unit: "hour" }) : Rn.H(e, t);\n  },\n  // Hour [0-11]\n  K: function(e, t, n) {\n    const r = e.getHours() % 12;\n    return t === "Ko" ? n.ordinalNumber(r, { unit: "hour" }) : Et(r, t.length);\n  },\n  // Hour [1-24]\n  k: function(e, t, n) {\n    let r = e.getHours();\n    return r === 0 && (r = 24), t === "ko" ? n.ordinalNumber(r, { unit: "hour" }) : Et(r, t.length);\n  },\n  // Minute\n  m: function(e, t, n) {\n    return t === "mo" ? n.ordinalNumber(e.getMinutes(), { unit: "minute" }) : Rn.m(e, t);\n  },\n  // Second\n  s: function(e, t, n) {\n    return t === "so" ? n.ordinalNumber(e.getSeconds(), { unit: "second" }) : Rn.s(e, t);\n  },\n  // Fraction of second\n  S: function(e, t) {\n    return Rn.S(e, t);\n  },\n  // Timezone (ISO-8601. If offset is 0, output is always `\'Z\'`)\n  X: function(e, t, n) {\n    const r = e.getTimezoneOffset();\n    if (r === 0)\n      return "Z";\n    switch (t) {\n      // Hours and optional minutes\n      case "X":\n        return Vh(r);\n      // Hours, minutes and optional seconds without `:` delimiter\n      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets\n      // so this token always has the same output as `XX`\n      case "XXXX":\n      case "XX":\n        return Yn(r);\n      // Hours, minutes and optional seconds with `:` delimiter\n      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets\n      // so this token always has the same output as `XXX`\n      case "XXXXX":\n      case "XXX":\n      // Hours and minutes with `:` delimiter\n      default:\n        return Yn(r, ":");\n    }\n  },\n  // Timezone (ISO-8601. If offset is 0, output is `\'+00:00\'` or equivalent)\n  x: function(e, t, n) {\n    const r = e.getTimezoneOffset();\n    switch (t) {\n      // Hours and optional minutes\n      case "x":\n        return Vh(r);\n      // Hours, minutes and optional seconds without `:` delimiter\n      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets\n      // so this token always has the same output as `xx`\n      case "xxxx":\n      case "xx":\n        return Yn(r);\n      // Hours, minutes and optional seconds with `:` delimiter\n      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets\n      // so this token always has the same output as `xxx`\n      case "xxxxx":\n      case "xxx":\n      // Hours and minutes with `:` delimiter\n      default:\n        return Yn(r, ":");\n    }\n  },\n  // Timezone (GMT)\n  O: function(e, t, n) {\n    const r = e.getTimezoneOffset();\n    switch (t) {\n      // Short\n      case "O":\n      case "OO":\n      case "OOO":\n        return "GMT" + Hh(r, ":");\n      // Long\n      case "OOOO":\n      default:\n        return "GMT" + Yn(r, ":");\n    }\n  },\n  // Timezone (specific non-location)\n  z: function(e, t, n) {\n    const r = e.getTimezoneOffset();\n    switch (t) {\n      // Short\n      case "z":\n      case "zz":\n      case "zzz":\n        return "GMT" + Hh(r, ":");\n      // Long\n      case "zzzz":\n      default:\n        return "GMT" + Yn(r, ":");\n    }\n  },\n  // Seconds timestamp\n  t: function(e, t, n) {\n    const r = Math.trunc(+e / 1e3);\n    return Et(r, t.length);\n  },\n  // Milliseconds timestamp\n  T: function(e, t, n) {\n    return Et(+e, t.length);\n  }\n};\nfunction Hh(e, t = "") {\n  const n = e > 0 ? "-" : "+", r = Math.abs(e), i = Math.trunc(r / 60), s = r % 60;\n  return s === 0 ? n + String(i) : n + String(i) + t + Et(s, 2);\n}\nfunction Vh(e, t) {\n  return e % 60 === 0 ? (e > 0 ? "-" : "+") + Et(Math.abs(e) / 60, 2) : Yn(e, t);\n}\nfunction Yn(e, t = "") {\n  const n = e > 0 ? "-" : "+", r = Math.abs(e), i = Et(Math.trunc(r / 60), 2), s = Et(r % 60, 2);\n  return n + i + t + s;\n}\nconst Gh = (e, t) => {\n  switch (e) {\n    case "P":\n      return t.date({ width: "short" });\n    case "PP":\n      return t.date({ width: "medium" });\n    case "PPP":\n      return t.date({ width: "long" });\n    case "PPPP":\n    default:\n      return t.date({ width: "full" });\n  }\n}, Vm = (e, t) => {\n  switch (e) {\n    case "p":\n      return t.time({ width: "short" });\n    case "pp":\n      return t.time({ width: "medium" });\n    case "ppp":\n      return t.time({ width: "long" });\n    case "pppp":\n    default:\n      return t.time({ width: "full" });\n  }\n}, hw = (e, t) => {\n  const n = e.match(/(P+)(p+)?/) || [], r = n[1], i = n[2];\n  if (!i)\n    return Gh(e, t);\n  let s;\n  switch (r) {\n    case "P":\n      s = t.dateTime({ width: "short" });\n      break;\n    case "PP":\n      s = t.dateTime({ width: "medium" });\n      break;\n    case "PPP":\n      s = t.dateTime({ width: "long" });\n      break;\n    case "PPPP":\n    default:\n      s = t.dateTime({ width: "full" });\n      break;\n  }\n  return s.replace("{{date}}", Gh(r, t)).replace("{{time}}", Vm(i, t));\n}, dw = {\n  p: Vm,\n  P: hw\n}, pw = /^D+$/, fw = /^Y+$/, mw = ["D", "DD", "YY", "YYYY"];\nfunction gw(e) {\n  return pw.test(e);\n}\nfunction vw(e) {\n  return fw.test(e);\n}\nfunction yw(e, t, n) {\n  const r = xw(e, t, n);\n  if (console.warn(r), mw.includes(e)) throw new RangeError(r);\n}\nfunction xw(e, t, n) {\n  const r = e[0] === "Y" ? "years" : "days of the month";\n  return `Use \\`${e.toLowerCase()}\\` instead of \\`${e}\\` (in \\`${t}\\`) for formatting ${r} to the input \\`${n}\\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;\n}\nfunction bw(e) {\n  return e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]";\n}\nfunction _w(e) {\n  return !(!bw(e) && typeof e != "number" || isNaN(+Ht(e)));\n}\nconst Ew = /[yYQqMLwIdDecihHKkms]o|(\\w)\\1*|\'\'|\'(\'\'|[^\'])+(\'|$)|./g, Ow = /P+p+|P+|p+|\'\'|\'(\'\'|[^\'])+(\'|$)|./g, Sw = /^\'([^]*?)\'?$/, Tw = /\'\'/g, ww = /[a-zA-Z]/;\nfunction Ll(e, t, n) {\n  var r, i, s, a, o, l, c, u;\n  const d = za(), h = (n == null ? void 0 : n.locale) ?? d.locale ?? df, p = (n == null ? void 0 : n.firstWeekContainsDate) ?? ((i = (r = n == null ? void 0 : n.locale) == null ? void 0 : r.options) == null ? void 0 : i.firstWeekContainsDate) ?? d.firstWeekContainsDate ?? ((a = (s = d.locale) == null ? void 0 : s.options) == null ? void 0 : a.firstWeekContainsDate) ?? 1, f = (n == null ? void 0 : n.weekStartsOn) ?? ((l = (o = n == null ? void 0 : n.locale) == null ? void 0 : o.options) == null ? void 0 : l.weekStartsOn) ?? d.weekStartsOn ?? ((u = (c = d.locale) == null ? void 0 : c.options) == null ? void 0 : u.weekStartsOn) ?? 0, g = Ht(e, n == null ? void 0 : n.in);\n  if (!_w(g))\n    throw new RangeError("Invalid time value");\n  let m = t.match(Ow).map((x) => {\n    const _ = x[0];\n    if (_ === "p" || _ === "P") {\n      const E = dw[_];\n      return E(x, h.formatLong);\n    }\n    return x;\n  }).join("").match(Ew).map((x) => {\n    if (x === "\'\'")\n      return { isToken: !1, value: "\'" };\n    const _ = x[0];\n    if (_ === "\'")\n      return { isToken: !1, value: $w(x) };\n    if (Bh[_])\n      return { isToken: !0, value: x };\n    if (_.match(ww))\n      throw new RangeError(\n        "Format string contains an unescaped latin alphabet character `" + _ + "`"\n      );\n    return { isToken: !1, value: x };\n  });\n  h.localize.preprocessor && (m = h.localize.preprocessor(g, m));\n  const v = {\n    firstWeekContainsDate: p,\n    weekStartsOn: f,\n    locale: h\n  };\n  return m.map((x) => {\n    if (!x.isToken) return x.value;\n    const _ = x.value;\n    (!(n != null && n.useAdditionalWeekYearTokens) && vw(_) || !(n != null && n.useAdditionalDayOfYearTokens) && gw(_)) && yw(_, t, String(e));\n    const E = Bh[_[0]];\n    return E(g, _, h.localize, v);\n  }).join("");\n}\nfunction $w(e) {\n  const t = e.match(Sw);\n  return t ? t[1].replace(Tw, "\'") : e;\n}\nconst ko = [\n  ["15seconds", 15 * 1e3],\n  ["minute", 60 * 1e3],\n  ["30minutes", 30 * 60 * 1e3],\n  ["hourly", 60 * 60 * 1e3],\n  ["daily", 24 * 60 * 60 * 1e3],\n  ["monthly", 30 * 24 * 60 * 60 * 1e3],\n  ["quarterly", 3 * 30 * 24 * 60 * 60 * 1e3],\n  ["yearly", 12 * 30 * 24 * 60 * 60 * 1e3]\n];\nfunction Gm(e, t, n, r, i) {\n  const s = t === 0, a = Number(Ll(new Date(e), "c")) === 2, o = Number(Ll(new Date(e), "q")) === 1, l = t !== 0 ? n[t - 1] : null;\n  switch (r) {\n    case "15seconds":\n      return s || As(e) || fi(e, l) || In(e);\n    case "minute":\n      return s || As(e) || fi(e, l) || In(e);\n    case "30minutes":\n      return s || As(e) || fi(e, l) || In(e);\n    case "hourly":\n      return s || As(e) || fi(e, l) || In(e);\n    case "daily":\n      return i ? s || a || In(e) : s || fi(e, l) || In(e);\n    case "weekly":\n      return s || a || In(e);\n    case "monthly":\n      return s || In(e);\n    case "quarterly":\n      return s || o;\n    case "yearly":\n      return !1;\n    default:\n      throw new Error(`${r} is not a valid time interval.`);\n  }\n}\nfunction kl(e, t, n, r, i, s) {\n  const a = i.showDayName, o = r === "daily" && a ? "weekly" : r, l = new Date(e), c = y(i, "timeIntervalFormats")[o], u = y(c, "primary"), d = y(c, "secondary"), h = Gm(e, t, n, r, a);\n  let p = h ? u : d;\n  r === "15seconds" && l.getMilliseconds() !== 0 && (p = p.replace("pp", "h:mm:ss.SSS a"));\n  const f = i.localeObject, { code: g, optionsObject: m } = s, v = m[r].type, x = m[r][h ? "primary" : "secondary"][p];\n  if (r === "quarterly" || !x) {\n    const _ = Ll(l, p, { locale: f }).split("").map((E) => {\n      var b;\n      const S = Number(E);\n      return E !== " " && !Number.isNaN(S) ? (b = S == null ? void 0 : S.toLocaleString) == null ? void 0 : b.call(S, g) : E;\n    });\n    return s[v](l, g, {}, _.join(""));\n  } else\n    return s[v](l, g, x);\n}\nfunction xa(e) {\n  const t = new Date(e);\n  return {\n    M: t.getMonth() + 1,\n    // month: 1-12\n    d: t.getDate(),\n    // day of the month: 1-31\n    H: t.getHours(),\n    // 24-hour clock: 0-23\n    m: t.getMinutes(),\n    // minute: 0-59\n    s: t.getSeconds()\n    // seconds: 0-59\n  };\n}\nfunction Mw(e) {\n  if (e)\n    return e.slice(1).map((t, n) => t - e[n]);\n}\nfunction Cw(e) {\n  const t = ko.reduce((n, [, r], i) => {\n    const s = ko[n][1], a = Math.abs(s - e), o = Math.abs(r - e);\n    return a < o ? n : i;\n  }, 0);\n  return ko[t][0];\n}\nfunction Dl(e, t) {\n  if (lf[t])\n    return t;\n  if (e.length === 1)\n    return "15seconds";\n  const n = Mw(e), r = Bn(n);\n  return Cw(r);\n}\nfunction As(e) {\n  const { s: t, m: n, H: r } = xa(e);\n  return r === 0 && n === 0 && t === 0;\n}\nfunction fi(e, t) {\n  const n = xa(e).M, r = xa(t).M;\n  return n !== r;\n}\nfunction In(e) {\n  const { M: t, d: n, s: r, m: i, H: s } = xa(e);\n  return t === 1 && n === 1 && s === 0 && i === 0 && r === 0;\n}\nfunction zh(e) {\n  return e === void 0 ? "" : e.toISOString();\n}\nfunction zm(e) {\n  const t = ze(e, (r) => r.value), n = Fe().domain(t).nice().domain();\n  if (n[0] > 0)\n    n[0] = 0;\n  else if (n[0] === 0 && n[1] === 0)\n    return [0, 1];\n  return n[0] < 0 && n[1] > 0 && (Math.abs(n[0]) > n[1] ? n[1] = Math.abs(n[0]) : n[0] = -n[1]), n;\n}\nfunction Fm(e, t) {\n  const n = y(t, "gradient", "colors"), r = !Be(n);\n  let i = y(t, "pairing", "option");\n  const s = zm(e), a = s[0] < 0 && s[1] > 0 ? "diverge" : "mono";\n  (i < 1 && i > 4 && a === "mono" || i < 1 && i > 2 && a === "diverge") && (i = 1);\n  const o = r ? n : [];\n  if (!r) {\n    const l = a === "diverge" ? 17 : 11;\n    for (let c = 1; c < l + 1; c++)\n      o.push(`fill-${a}-${i}-${c}`);\n  }\n  return Gc().domain(s).range(o);\n}\nvar ht = /* @__PURE__ */ ((e) => (e.GRAPHICS_DOCUMENT = "graphics-document", e.GRAPHICS_OBJECT = "graphics-object", e.GRAPHICS_SYMBOL = "graphics-symbol", e.GROUP = "group", e.DOCUMENT = "document", e.CHECKBOX = "checkbox", e.BUTTON = "button", e.MENU = "menu", e.MENU_ITEM = "menuitem", e.IMG = "img", e))(ht || {});\nfunction Aw(e, t) {\n  return e && Ff(e, t, ls);\n}\nfunction Lw(e, t) {\n  return function(n, r) {\n    if (n == null)\n      return n;\n    if (!fr(n))\n      return e(n, r);\n    for (var i = n.length, s = -1, a = Object(n); ++s < i && r(a[s], s, a) !== !1; )\n      ;\n    return n;\n  };\n}\nvar jc = Lw(Aw);\nfunction dt(e) {\n  return function() {\n    return e;\n  };\n}\nvar kw = Array.prototype.slice;\nfunction so(e) {\n  return typeof e == "object" && "length" in e ? e : Array.from(e);\n}\nfunction Dw(e, t, n, r) {\n  for (var i = -1, s = e == null ? 0 : e.length; ++i < s; ) {\n    var a = e[i];\n    t(r, a, n(a), e);\n  }\n  return r;\n}\nfunction Rw(e, t, n, r) {\n  return jc(e, function(i, s, a) {\n    t(r, i, n(i), a);\n  }), r;\n}\nfunction Iw(e, t) {\n  return function(n, r) {\n    var i = Kt(n) ? Dw : Rw, s = {};\n    return i(n, e, Ja(r), s);\n  };\n}\nfunction Nw(e) {\n  for (var t = -1, n = e == null ? 0 : e.length, r = {}; ++t < n; ) {\n    var i = e[t];\n    r[i[0]] = i[1];\n  }\n  return r;\n}\nvar Pw = Object.prototype, Uw = Pw.hasOwnProperty, Bw = Iw(function(e, t, n) {\n  Uw.call(e, n) ? e[n].push(t) : ja(e, n, [t]);\n});\nfunction Hw(e, t) {\n  let n = 0;\n  for (let r of e)\n    r != null && (r = +r) >= r && ++n;\n  return n;\n}\nfunction Vw(e) {\n  return e;\n}\nfunction Gw(e = Jn) {\n  if (e === Jn) return jm;\n  if (typeof e != "function") throw new TypeError("compare is not a function");\n  return (t, n) => {\n    const r = e(t, n);\n    return r || r === 0 ? r : (e(n, n) === 0) - (e(t, t) === 0);\n  };\n}\nfunction jm(e, t) {\n  return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0);\n}\nvar zw = Array.prototype, Fw = zw.slice;\nfunction Do(e) {\n  return () => e;\n}\nfunction jw(e, t, n) {\n  let r;\n  for (; ; ) {\n    const i = Yr(e, t, n);\n    if (i === r || i === 0 || !isFinite(i))\n      return [e, t];\n    i > 0 ? (e = Math.floor(e / i) * i, t = Math.ceil(t / i) * i) : i < 0 && (e = Math.ceil(e * i) / i, t = Math.floor(t * i) / i), r = i;\n  }\n}\nfunction Ww(e) {\n  return Math.max(1, Math.ceil(Math.log(Hw(e)) / Math.LN2) + 1);\n}\nfunction qw() {\n  var e = Vw, t = ze, n = Ww;\n  function r(i) {\n    Array.isArray(i) || (i = Array.from(i));\n    var s, a = i.length, o, l, c = new Array(a);\n    for (s = 0; s < a; ++s)\n      c[s] = e(i[s], s, i);\n    var u = t(c), d = u[0], h = u[1], p = n(c, d, h);\n    if (!Array.isArray(p)) {\n      const _ = h, E = +p;\n      if (t === ze && ([d, h] = jw(d, h, E)), p = ca(d, h, E), p[0] <= d && (l = Yr(d, h, E)), p[p.length - 1] >= h)\n        if (_ >= h && t === ze) {\n          const b = Yr(d, h, E);\n          isFinite(b) && (b > 0 ? h = (Math.floor(h / b) + 1) * b : b < 0 && (h = (Math.ceil(h * -b) + 1) / -b));\n        } else\n          p.pop();\n    }\n    for (var f = p.length, g = 0, m = f; p[g] <= d; ) ++g;\n    for (; p[m - 1] > h; ) --m;\n    (g || m < f) && (p = p.slice(g, m), f = m - g);\n    var v = new Array(f + 1), x;\n    for (s = 0; s <= f; ++s)\n      x = v[s] = [], x.x0 = s > 0 ? p[s - 1] : d, x.x1 = s < f ? p[s] : h;\n    if (isFinite(l)) {\n      if (l > 0)\n        for (s = 0; s < a; ++s)\n          (o = c[s]) != null && d <= o && o <= h && v[Math.min(f, Math.floor((o - d) / l))].push(i[s]);\n      else if (l < 0) {\n        for (s = 0; s < a; ++s)\n          if ((o = c[s]) != null && d <= o && o <= h) {\n            const _ = Math.floor((d - o) * l);\n            v[Math.min(f, _ + (p[_] <= o))].push(i[s]);\n          }\n      }\n    } else\n      for (s = 0; s < a; ++s)\n        (o = c[s]) != null && d <= o && o <= h && v[Ac(p, o, 0, f)].push(i[s]);\n    return v;\n  }\n  return r.value = function(i) {\n    return arguments.length ? (e = typeof i == "function" ? i : Do(i), r) : e;\n  }, r.domain = function(i) {\n    return arguments.length ? (t = typeof i == "function" ? i : Do([i[0], i[1]]), r) : t;\n  }, r.thresholds = function(i) {\n    return arguments.length ? (n = typeof i == "function" ? i : Do(Array.isArray(i) ? Fw.call(i) : i), r) : n;\n  }, r;\n}\nfunction Wm(e, t, n = 0, r = 1 / 0, i) {\n  if (t = Math.floor(t), n = Math.floor(Math.max(0, n)), r = Math.floor(Math.min(e.length - 1, r)), !(n <= t && t <= r)) return e;\n  for (i = i === void 0 ? jm : Gw(i); r > n; ) {\n    if (r - n > 600) {\n      const l = r - n + 1, c = t - n + 1, u = Math.log(l), d = 0.5 * Math.exp(2 * u / 3), h = 0.5 * Math.sqrt(u * d * (l - d) / l) * (c - l / 2 < 0 ? -1 : 1), p = Math.max(n, Math.floor(t - c * d / l + h)), f = Math.min(r, Math.floor(t + (l - c) * d / l + h));\n      Wm(e, t, p, f, i);\n    }\n    const s = e[t];\n    let a = n, o = r;\n    for (mi(e, n, t), i(e[r], s) > 0 && mi(e, n, r); a < o; ) {\n      for (mi(e, a, o), ++a, --o; i(e[a], s) < 0; ) ++a;\n      for (; i(e[o], s) > 0; ) --o;\n    }\n    i(e[n], s) === 0 ? mi(e, n, o) : (++o, mi(e, o, r)), o <= t && (n = o + 1), t <= o && (r = o - 1);\n  }\n  return e;\n}\nfunction mi(e, t, n) {\n  const r = e[t];\n  e[t] = e[n], e[n] = r;\n}\nfunction Ro(e, t, n) {\n  if (e = Float64Array.from(z_(e)), !(!(r = e.length) || isNaN(t = +t))) {\n    if (t <= 0 || r < 2) return Bn(e);\n    if (t >= 1) return nr(e);\n    var r, i = (r - 1) * t, s = Math.floor(i), a = nr(Wm(e, s).subarray(0, s + 1)), o = Bn(e.subarray(s + 1));\n    return a + (o - a) * (i - s);\n  }\n}\nfunction Fh(e, t) {\n  if ((a = e.length) > 1)\n    for (var n = 1, r, i, s = e[t[0]], a, o = s.length; n < a; ++n)\n      for (i = s, s = e[t[n]], r = 0; r < o; ++r)\n        s[r][1] += s[r][0] = isNaN(i[r][1]) ? i[r][0] : i[r][1];\n}\nfunction jh(e) {\n  for (var t = e.length, n = new Array(t); --t >= 0; ) n[t] = t;\n  return n;\n}\nfunction Yw(e, t) {\n  return e[t];\n}\nfunction Xw(e) {\n  const t = [];\n  return t.key = e, t;\n}\nfunction Io() {\n  var e = dt([]), t = jh, n = Fh, r = Yw;\n  function i(s) {\n    var a = Array.from(e.apply(this, arguments), Xw), o, l = a.length, c = -1, u;\n    for (const d of s)\n      for (o = 0, ++c; o < l; ++o)\n        (a[o][c] = [0, +r(d, a[o].key, c, s)]).data = d;\n    for (o = 0, u = so(t(a)); o < l; ++o)\n      a[u[o]].index = o;\n    return n(a, u), a;\n  }\n  return i.keys = function(s) {\n    return arguments.length ? (e = typeof s == "function" ? s : dt(Array.from(s)), i) : e;\n  }, i.value = function(s) {\n    return arguments.length ? (r = typeof s == "function" ? s : dt(+s), i) : r;\n  }, i.order = function(s) {\n    return arguments.length ? (t = s == null ? jh : typeof s == "function" ? s : dt(Array.from(s)), i) : t;\n  }, i.offset = function(s) {\n    return arguments.length ? (n = s ?? Fh, i) : n;\n  }, i;\n}\nfunction Zw(e, t) {\n  if ((l = e.length) > 0)\n    for (var n, r = 0, i, s, a, o, l, c = e[t[0]].length; r < c; ++r)\n      for (a = o = 0, n = 0; n < l; ++n)\n        (s = (i = e[t[n]][r])[1] - i[0]) > 0 ? (i[0] = a, i[1] = a += s) : s < 0 ? (i[1] = o, i[0] = o += s) : (i[0] = 0, i[1] = s);\n}\nfunction Kw(e) {\n  const t = e.trim();\n  return ["=", "+", "-", "@", "\t", "\\r"].includes(t.charAt(0)) ? `${t}` : /[,\\"\\n]/.test(t) ? `"${t}"` : t;\n}\nclass an {\n  constructor(t) {\n    this.state = {\n      options: {}\n    }, this.colorScale = {}, this.colorClassNames = {}, this.services = t;\n  }\n  formatTable({ headers: t, cells: n }) {\n    const r = this.getOptions(), {\n      code: i,\n      date: s,\n      number: a\n    } = y(r, "locale"), o = y(r, "tabularRepModal", "tableHeadingFormatter"), l = y(r, "tabularRepModal", "tableCellFormatter"), { cartesianScales: c } = this.services, u = c == null ? void 0 : c.getDomainAxisScaleType();\n    let d;\n    return u === et.TIME && (d = (h) => s(h, i, { month: "short", day: "numeric", year: "numeric" })), [\n      typeof o == "function" ? o(t) : t,\n      ...typeof l == "function" ? l(n) : n.map((h) => {\n        d && (h[1] = d(h[1]));\n        for (const p in h) {\n          const f = h[p];\n          typeof f == "number" && (h[p] = a(f, i));\n        }\n        return h;\n      })\n    ];\n  }\n  getAllDataFromDomain(t) {\n    if (!this.getData())\n      return null;\n    const n = this.getOptions();\n    let r = this.getData();\n    const i = this.getDataGroups(), { groupMapsTo: s } = y(n, "data"), a = y(n, "axes");\n    return t && (r = r.filter((o) => t.includes(o[s]))), a && Object.keys(a).forEach((o) => {\n      const l = a[o].mapsTo, c = a[o].scaleType;\n      if ((c === et.LINEAR || c === et.LOG) && (r = r.map((u) => ({\n        ...u,\n        [l]: u[l] === null ? u[l] : Number(u[l])\n      }))), l && a[o].domain)\n        if (c === et.LABELS)\n          r = r.filter(\n            (u) => a[o].domain.includes(u[l])\n          );\n        else {\n          const [u, d] = a[o].domain;\n          r = r.filter(\n            (h) => !(l in h) || h[l] >= u && h[l] <= d\n          );\n        }\n    }), r.filter((o) => i.find((l) => l.name === o[s]));\n  }\n  /**\n   * Charts that have group configs passed into them, only want to retrieve the display data relevant to that chart\n   * @param groups the included datasets for the particular chart\n   */\n  getDisplayData(t) {\n    if (!this.get("data"))\n      return null;\n    const { ACTIVE: n } = It.items.status, r = this.getDataGroups(t), { groupMapsTo: i } = this.getOptions().data;\n    return this.getAllDataFromDomain(t).filter((s) => r.find(\n      (a) => a.name === s[i] && a.status === n\n    ));\n  }\n  getData() {\n    return this.get("data");\n  }\n  isDataEmpty() {\n    return !this.getData().length;\n  }\n  /**\n   * Sets the data for the current instance.\n   *\n   * This method sanitizes the provided data, generates data groups,\n   * and updates the instance\'s state with the sanitized data and data groups.\n   *\n   * @param {any} newData - The new data to be set. This data will be cloned and sanitized.\n   * @returns {any} - The sanitized version of the provided data.\n   */\n  setData(t) {\n    const n = this.sanitize(Sn(t)), r = this.generateDataGroups(n);\n    return this.set({\n      data: n,\n      dataGroups: r\n    }), n;\n  }\n  getDataGroups(t) {\n    return y(this.getOptions(), "data", "loading") ? [] : t ? this.get("dataGroups").filter((n) => t.includes(n.name)) : this.get("dataGroups");\n  }\n  getActiveDataGroups(t) {\n    const { ACTIVE: n } = It.items.status;\n    return this.getDataGroups(t).filter((r) => r.status === n);\n  }\n  getDataGroupNames(t) {\n    return this.getDataGroups(t).map((n) => n.name);\n  }\n  getActiveDataGroupNames(t) {\n    return this.getActiveDataGroups(t).map((n) => n.name);\n  }\n  aggregateBinDataByGroup(t) {\n    return Bw(t, "group");\n  }\n  getBinConfigurations() {\n    const t = this.getDisplayData(), n = this.getOptions(), r = this.services.cartesianScales.getMainXAxisPosition(), i = this.services.cartesianScales.getDomainIdentifier(), s = n.axes[r], { groupMapsTo: a } = n.data, { bins: o = LT.defaultBins } = s, l = Array.isArray(o), c = qw().value((p) => p[i]).thresholds(o)(t);\n    if (l)\n      c[c.length - 1].x1 = o[o.length - 1];\n    else {\n      const p = c[0].x1 - c[0].x0;\n      c[c.length - 1].x1 = +c[c.length - 1].x0 + p;\n    }\n    const u = l ? [o[0], o[o.length - 1]] : [c[0].x0, c[c.length - 1].x1], d = Array.from(new Set(t.map((p) => p[a]))), h = [];\n    return c.forEach((p) => {\n      const f = `${p.x0}-${p.x1}`, g = this.aggregateBinDataByGroup(p);\n      d.forEach((m) => {\n        h.push({\n          group: m,\n          key: f,\n          value: g[m] || 0,\n          bin: p.x0\n        });\n      });\n    }), {\n      bins: c,\n      binsDomain: u\n    };\n  }\n  getBinnedStackedData() {\n    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this.getActiveDataGroupNames(), { bins: i } = this.getBinConfigurations(), s = this.getDataValuesGroupedByKeys({\n      bins: i\n    });\n    return Io().keys(r)(s).map((a, o) => Object.keys(a).filter((l) => !isNaN(l)).map((l) => {\n      const c = a[l];\n      return c[n] = r[o], c;\n    }));\n  }\n  getGroupedData(t) {\n    const n = this.getDisplayData(t), r = {}, { groupMapsTo: i } = this.getOptions().data;\n    return n.map((s) => {\n      const a = s[i];\n      r[a] !== null && r[a] !== void 0 ? r[a].push(s) : r[a] = [s];\n    }), Object.keys(r).map((s) => ({\n      name: s,\n      data: r[s]\n    }));\n  }\n  getStackKeys({ bins: t = null, groups: n = null } = { bins: null, groups: null }) {\n    const r = this.getOptions(), i = this.getDisplayData(n);\n    let s;\n    t ? s = t.map((l) => `${l.x0}:${l.x1}`) : s = Zi(\n      i.map((l) => {\n        const c = this.services.cartesianScales.getDomainIdentifier(l);\n        return l[c] instanceof Date ? zh(l[c]) : l[c] && typeof l[c].toString == "function" ? l[c].toString() : l[c];\n      })\n    );\n    const a = this.services.cartesianScales.domainAxisPosition, o = r.axes[a].scaleType;\n    return o === et.TIME ? s.sort((l, c) => {\n      const u = new Date(l), d = new Date(c);\n      return u - d;\n    }) : (o === et.LOG || o === et.LINEAR) && s.sort((l, c) => l - c), s;\n  }\n  getDataValuesGroupedByKeys({ bins: t = null, groups: n = null }) {\n    const r = this.getOptions(), { groupMapsTo: i } = r.data, s = this.getDisplayData(n), a = this.getDataGroupNames(), o = this.getStackKeys({ bins: t, groups: n });\n    return t ? o.map((l) => {\n      const [c, u] = l.split(":"), d = { x0: c, x1: u }, h = t.find((p) => p.x0.toString() === c.toString());\n      return a.forEach((p) => {\n        d[p] = h.filter(\n          (f) => f[i] === p\n        ).length;\n      }), d;\n    }) : o.map((l) => {\n      const c = { sharedStackKey: l };\n      return a.forEach((u) => {\n        const d = s.find((p) => {\n          const f = this.services.cartesianScales.getDomainIdentifier(p);\n          return p[i] === u && Object.prototype.hasOwnProperty.call(p, f) && (p[f] instanceof Date ? zh(p[f]) === l : p[f].toString() === l);\n        }), h = this.services.cartesianScales.getRangeIdentifier(c);\n        c[u] = d ? d[h] : null;\n      }), c;\n    });\n  }\n  getStackedData({ percentage: t = !1, groups: n = null, divergent: r = !1 }) {\n    const i = this.getOptions(), { groupMapsTo: s } = i.data, a = this.getActiveDataGroupNames(n), o = this.getDataValuesGroupedByKeys({\n      groups: n\n    });\n    if (t) {\n      const l = Nw(o.map((c) => [c.sharedStackKey, 0]));\n      o.forEach((c) => {\n        a.forEach((u) => {\n          l[c.sharedStackKey] += c[u];\n        });\n      }), o.forEach((c) => {\n        a.forEach((u) => {\n          const d = l[c.sharedStackKey];\n          l[c.sharedStackKey] ? c[u] = c[u] / d * 100 : c[u] = 0;\n        });\n      });\n    }\n    return (r ? Io().offset(Zw) : Io()).keys(a)(o).map((l, c) => Object.keys(l).filter((u) => !isNaN(u)).map((u) => {\n      const d = l[u];\n      return d[s] = a[c], d;\n    }));\n  }\n  /**\n   * Retrieves the current options from the instance\'s state.\n   *\n   * @returns {any} - The current options stored in the instance\'s state.\n   */\n  getOptions() {\n    return this.state.options;\n  }\n  set(t, n) {\n    this.state = Object.assign({}, this.state, t);\n    const r = Object.assign(\n      { skipUpdate: !1, animate: !0 },\n      // default configs\n      n\n    );\n    r.skipUpdate || this.update(r.animate);\n  }\n  get(t) {\n    return t ? this.state[t] : this.state;\n  }\n  /**\n   * Updates the current options for the instance.\n   *\n   * This method retrieves the existing options, updates the legend additional items,\n   * and merges the new options with the existing ones. The instance\'s state is then updated\n   * with the merged options.\n   *\n   * @param {any} newOptions - The new options to be set. These options will be merged with the existing options.\n   */\n  setOptions(t) {\n    const n = this.getOptions();\n    Fc(n, t), this.set({\n      options: at(n, t)\n    });\n  }\n  /**\n   *\n   * Updates miscellanous information within the model\n   * such as the color scales, or the legend data labels\n   */\n  update(t = !0) {\n    this.getDisplayData() && (this.updateAllDataGroups(), this.setCustomColorScale(), this.setColorClassNames(), this.services.events.dispatchEvent(T.Model.UPDATE, { animate: t }));\n  }\n  /*\n   * Data labels\n   */\n  toggleDataLabel(t) {\n    const { ACTIVE: n, DISABLED: r } = It.items.status, i = this.getDataGroups(), s = i.some((c) => c.status === r), a = i.filter((c) => c.status === n);\n    if (s)\n      if (a.length === 1 && a[0].name === t)\n        i.forEach((c, u) => {\n          i[u].status = n;\n        });\n      else {\n        const c = i.findIndex((u) => u.name === t);\n        i[c].status = i[c].status === r ? n : r;\n      }\n    else\n      i.forEach((c, u) => {\n        i[u].status = c.name === t ? n : r;\n      });\n    const o = i.filter((c) => c.status === n), l = this.getOptions();\n    i.some((c) => c.status === r) ? l.data.selectedGroups = o.map((c) => c.name) : l.data.selectedGroups = [], this.services.events.dispatchEvent(T.Legend.ITEMS_UPDATE, {\n      dataGroups: i\n    }), this.set({\n      dataGroups: i\n    });\n  }\n  /**\n   * Should the data point be filled?\n   * @param group\n   * @param key\n   * @param data\n   * @param defaultFilled the default for this chart\n   */\n  getIsFilled(t, n, r, i) {\n    const s = this.getOptions();\n    return s.getIsFilled ? s.getIsFilled(t, n, r, i) : i;\n  }\n  getFillColor(t, n, r) {\n    const i = this.getOptions(), s = y(this.colorScale, t);\n    return i.getFillColor ? i.getFillColor(t, n, r, s) : s;\n  }\n  getStrokeColor(t, n, r) {\n    const i = this.getOptions(), s = y(this.colorScale, t);\n    return i.getStrokeColor ? i.getStrokeColor(t, n, r, s) : s;\n  }\n  isUserProvidedColorScaleValid() {\n    const t = y(this.getOptions(), "color", "scale"), n = this.getDataGroups();\n    return t == null || Object.keys(t).length == 0 ? !1 : n.some(\n      (r) => Object.keys(t).includes(r.name)\n    );\n  }\n  getColorClassName(t) {\n    const n = this.colorClassNames(t.dataGroupName);\n    let r = t.originalClassName;\n    return t.classNameTypes.forEach(\n      (i) => r = t.originalClassName ? `${r} ${i}-${n}` : `${i}-${n}`\n    ), r || "";\n  }\n  /**\n   * For charts that might hold an associated status for their dataset\n   */\n  getStatus() {\n    return null;\n  }\n  getAllDataGroupsNames() {\n    return this.allDataGroups;\n  }\n  /**\n   * Converts data provided in the older format to tabular\n   *\n   */\n  transformToTabularData(t) {\n    console.warn(\n      "We\'ve updated the charting data format to be tabular by default. The current format you\'re using is deprecated and will be removed in v1.0, read more here https://charts.carbondesignsystem.com/"\n    );\n    const n = [], { datasets: r, labels: i } = t;\n    return r.forEach((s) => {\n      s.data.forEach((a, o) => {\n        let l;\n        const c = y(s, "label");\n        if (c === null) {\n          const d = y(i, o);\n          d ? l = d : l = "Ungrouped";\n        } else\n          l = c;\n        const u = {\n          group: l,\n          key: i[o]\n        };\n        isNaN(a) ? (u.value = a.value, u.date = a.date) : u.value = a, n.push(u);\n      });\n    }), n;\n  }\n  getTabularDataArray() {\n    return [];\n  }\n  exportToCSV() {\n    const t = this.getTabularDataArray().map(\n      (s) => s.map((a) => `"${(a === "&ndash;" ? "" : a).split(/[,;\'"`]/).map((o) => Kw(o)).join("")}"`)\n    ).map((s) => s.join(",")).join(`\n`), n = this.getOptions();\n    let r = "myChart";\n    const i = y(n, "fileDownload", "fileName");\n    typeof i == "function" ? r = i("csv") : typeof i == "string" && (r = i), this.services.files.downloadCSV(t, `${r}.csv`);\n  }\n  getTabularData(t) {\n    return Array.isArray(t) ? t : this.transformToTabularData(t);\n  }\n  sanitize(t) {\n    return t = this.getTabularData(t), t;\n  }\n  /*\n   * Data groups\n   */\n  updateAllDataGroups() {\n    this.allDataGroups ? this.getDataGroupNames().forEach((t) => {\n      this.allDataGroups.indexOf(t) === -1 && this.allDataGroups.push(t);\n    }) : this.allDataGroups = this.getDataGroupNames();\n  }\n  generateDataGroups(t) {\n    const { groupMapsTo: n } = this.getOptions().data, { ACTIVE: r, DISABLED: i } = It.items.status, s = this.getOptions(), a = Zi(t.map((l) => l[n]));\n    s.data.selectedGroups.length && (s.data.selectedGroups.every(\n      (l) => a.includes(l)\n    ) || (s.data.selectedGroups = []));\n    const o = (l) => !s.data.selectedGroups.length || s.data.selectedGroups.includes(l) ? r : i;\n    return a.map((l) => ({\n      name: l,\n      status: o(l)\n    }));\n  }\n  /*\n   * Fill scales\n   */\n  setCustomColorScale() {\n    if (!this.isUserProvidedColorScaleValid())\n      return;\n    const t = this.getOptions(), n = y(t, "color", "scale");\n    Object.keys(n).forEach((r) => {\n      this.allDataGroups.includes(r) || console.warn(`"${r}" does not exist in data groups.`);\n    }), this.allDataGroups.filter((r) => n[r]).forEach(\n      (r) => this.colorScale[r] = n[r]\n    );\n  }\n  /*\n   * Color palette\n   */\n  setColorClassNames() {\n    const t = y(this.getOptions(), "color", "pairing");\n    let n = y(t, "numberOfVariants");\n    (!n || n < this.allDataGroups.length) && (n = this.allDataGroups.length);\n    let r = y(t, "option");\n    const i = Mm.pairingOptions, s = n > 5 ? 14 : n, a = `${s}-color`;\n    r = r <= i[a] ? r : 1;\n    const o = this.allDataGroups.map(\n      (l, c) => `${s}-${r}-${c % 14 + 1}`\n    );\n    this.colorClassNames = ro().range(o).domain(this.allDataGroups);\n  }\n}\nclass mr extends an {\n  // can\'t be protected as it\'s used by two-dimensional-axes.ts\n  constructor(t) {\n    super(t), this.axisFlavor = Ga.DEFAULT;\n  }\n  // get the scales information\n  // needed for getTabularArray()\n  assignRangeAndDomains() {\n    const { cartesianScales: t } = this.services, n = this.getOptions(), r = t.isDualAxes(), i = {\n      primaryDomain: t.domainAxisPosition,\n      primaryRange: t.rangeAxisPosition,\n      secondaryDomain: null,\n      secondaryRange: null\n    };\n    return r && (i.secondaryDomain = t.secondaryDomainAxisPosition, i.secondaryRange = t.secondaryRangeAxisPosition), Object.keys(i).forEach(\n      (s) => {\n        const a = i[s];\n        t.scales[a] ? i[s] = {\n          position: a,\n          label: t.getScaleLabel(a),\n          identifier: y(n, "axes", a, "mapsTo")\n        } : i[s] = null;\n      }\n    ), i;\n  }\n  getTabularDataArray() {\n    const t = this.getDisplayData(), n = this.getOptions(), { groupMapsTo: r } = n.data, { primaryDomain: i, primaryRange: s, secondaryDomain: a, secondaryRange: o } = this.assignRangeAndDomains(), { number: l, code: c } = y(this.getOptions(), "locale"), u = [\n      "Group",\n      i.label,\n      s.label,\n      ...a ? [a.label] : [],\n      ...o ? [o.label] : []\n    ], d = t.map((h) => [\n      h[r],\n      h[i.identifier] === null ? "&ndash;" : h[i.identifier],\n      h[s.identifier] === null || isNaN(h[s.identifier]) ? "&ndash;" : l(h[s.identifier], c),\n      ...a ? [\n        h[a.identifier] === null ? "&ndash;" : h[a.identifier]\n      ] : [],\n      ...o ? [\n        h[o.identifier] === null || isNaN(h[o.identifier]) ? "&ndash;" : h[o.identifier]\n      ] : []\n    ]);\n    return super.formatTable({ headers: u, cells: d });\n  }\n  setData(t) {\n    let n;\n    if (t && (n = super.setData(t), y(this.getOptions(), "zoomBar", G.TOP, "enabled"))) {\n      const r = y(\n        this.getOptions(),\n        "zoomBar",\n        G.TOP,\n        "data"\n      );\n      this.setZoomBarData(r);\n    }\n    return n;\n  }\n  /**\n   * Sets the zoom bar data for the current instance.\n   *\n   * This method sanitizes the provided zoom bar data or uses the display data if no explicit\n   * zoom data is provided. It normalizes the zoom bar data by aggregating values based on unique\n   * dates and updates the instance\'s state with the normalized data.\n   *\n   * @param {any} [newZoomBarData] - The new zoom bar data to be set. If not provided, the display data will be used.\n   */\n  setZoomBarData(t) {\n    const n = t ? this.sanitize(Sn(t)) : this.getDisplayData();\n    let r = n;\n    const { cartesianScales: i } = this.services;\n    if (n && i.domainAxisPosition && i.rangeAxisPosition) {\n      const s = i.getDomainIdentifier(), a = i.getRangeIdentifier();\n      let o = n.map((l) => l[s].getTime());\n      o = Zi(o).sort(), r = o.map((l) => {\n        let c = 0;\n        const u = {};\n        return n.forEach((d) => {\n          d[s].getTime() === l && (c += d[a]);\n        }), u[s] = new Date(l), u[a] = c, u;\n      });\n    }\n    this.set({ zoomBarData: r });\n  }\n  getZoomBarData() {\n    return this.get("zoomBarData");\n  }\n  sanitizeDateValues(t) {\n    const n = this.getOptions();\n    if (!n.axes)\n      return t;\n    const r = [];\n    return Object.keys(G).forEach((i) => {\n      const s = G[i], a = n.axes[s];\n      if (a && a.scaleType === et.TIME) {\n        const o = a.mapsTo;\n        (o !== null || o !== void 0) && r.push(o);\n      }\n    }), r.length > 0 && t.forEach((i) => {\n      r.forEach((s) => {\n        y(i, s, "getTime") === null && (i[s] = new Date(i[s]));\n      });\n    }), t;\n  }\n  sanitize(t) {\n    return t = super.sanitize(t), t = this.sanitizeDateValues(t), t;\n  }\n}\nlet Qw = class extends mr {\n  constructor(t) {\n    super(t);\n  }\n  getTabularDataArray() {\n    const t = this.getDisplayData(), { number: n, code: r } = y(this.getOptions(), "locale");\n    t.sort((a, o) => a.source.localeCompare(o.source));\n    const i = ["Source", "Target", "Value"], s = [\n      ...t.map((a) => [\n        a.source,\n        a.target,\n        a.value === null ? "&ndash;" : n(a.value, r)\n      ])\n    ];\n    return super.formatTable({ headers: i, cells: s });\n  }\n}, Jw = class extends mr {\n  constructor(t) {\n    super(t);\n  }\n  getBoxQuartiles(t) {\n    return {\n      q_25: Ro(t, 0.25),\n      q_50: Ro(t, 0.5),\n      q_75: Ro(t, 0.75)\n    };\n  }\n  getBoxplotData() {\n    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this.getGroupedData(), i = [];\n    for (const { name: s, data: a } of r) {\n      const o = this.services.cartesianScales.getRangeIdentifier(), l = a.map((_) => _[o]).sort(Jn), c = {\n        [n]: s,\n        counts: l,\n        quartiles: this.getBoxQuartiles(l),\n        outliers: null,\n        whiskers: null\n      }, u = c.quartiles.q_25, d = c.quartiles.q_75, h = (d - u) * 1.5, p = u - h, f = d + h, g = [], m = [];\n      for (const _ of l)\n        _ < p || _ > f ? g.push(_) : m.push(_);\n      c.outliers = g;\n      const v = Bn(m), x = nr(m);\n      c.whiskers = {\n        min: v || Bn([c.quartiles.q_25, c.quartiles.q_50, c.quartiles.q_75]),\n        max: x || nr([c.quartiles.q_25, c.quartiles.q_50, c.quartiles.q_75])\n      }, i.push(c);\n    }\n    return i;\n  }\n  getTabularDataArray() {\n    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this.getBoxplotData(), { number: i, code: s } = y(t, "locale"), a = ["Group", "Minimum", "Q1", "Median", "Q3", "Maximum", "IQR", "Outlier(s)"], o = [\n      ...r.map((l) => {\n        let c = y(l, "outliers");\n        return (c === null || c.length === 0) && (c = ["&ndash;"]), [\n          l[n],\n          y(l, "whiskers", "min") !== null ? i(y(l, "whiskers", "min"), s) : "&ndash;",\n          y(l, "quartiles", "q_25") !== null ? i(y(l, "quartiles", "q_25"), s) : "&ndash;",\n          y(l, "quartiles", "q_50") !== null ? i(y(l, "quartiles", "q_50"), s) : "&ndash;",\n          y(l, "quartiles", "q_75") !== null ? i(y(l, "quartiles", "q_75"), s) : "&ndash;",\n          y(l, "whiskers", "max") !== null ? i(y(l, "whiskers", "max"), s) : "&ndash;",\n          y(l, "quartiles", "q_75") !== null && y(l, "quartiles", "q_25") !== null ? (i(\n            y(l, "quartiles", "q_75") - y(l, "quartiles", "q_25")\n          ), s) : "&ndash;",\n          c.map((u) => i(u, s)).join(",")\n        ];\n      })\n    ];\n    return super.formatTable({ headers: a, cells: o });\n  }\n  setColorClassNames() {\n    const t = y(this.getOptions(), "color", "pairing");\n    let n = y(t, "option");\n    const r = Mm.pairingOptions;\n    n = n <= r["1-color"] ? n : 1;\n    const i = this.allDataGroups.map(() => `1-${n}-1`);\n    this.colorClassNames = ro().range(i).domain(this.allDataGroups);\n  }\n}, t$ = class extends mr {\n  constructor(t) {\n    super(t);\n  }\n  /**\n   * Determines the index of the performance area titles to use\n   * @param datum\n   * @returns number\n   */\n  getMatchingRangeIndexForDatapoint(t) {\n    let n;\n    for (let r = t.ranges.length - 1; r > 0; r--) {\n      const i = t.ranges[r];\n      if (t.value >= i)\n        return n = r, n;\n    }\n    return 0;\n  }\n  getTabularDataArray() {\n    const t = this.getDisplayData(), n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.services.cartesianScales.getRangeIdentifier(), { number: s, code: a } = y(n, "locale"), o = y(n, "bullet", "performanceAreaTitles"), l = ["Title", "Group", "Value", "Target", "Percentage", "Performance"], c = [\n      ...t.map((u) => [\n        u.title,\n        u[r],\n        u.value === null ? "&ndash;" : s(u.value, a),\n        y(u, "marker") === null ? "&ndash;" : s(u.marker, a),\n        y(u, "marker") === null ? "&ndash;" : `${s(Math.floor(u[i] / u.marker * 100), a)}%`,\n        o[this.getMatchingRangeIndexForDatapoint(u)]\n      ])\n    ];\n    return super.formatTable({ headers: l, cells: c });\n  }\n}, e$ = class extends an {\n  constructor(t) {\n    super(t), this._colorScale = void 0, this._matrix = {};\n  }\n  /**\n   * @override\n   * @param value\n   * @returns string\n   */\n  getFillColor(t) {\n    return this._colorScale(t);\n  }\n  /**\n   * Helper function that will generate a dictionary\n   */\n  getCombinedData() {\n    if (Be(this._matrix)) {\n      const t = this.getOptions(), n = this.getDisplayData();\n      !Be(n) && !Be(t.geoData.objects.countries) && (t.geoData.objects.countries.geometries.forEach((r) => {\n        this._matrix[r.properties.NAME] = r;\n      }), n.forEach((r) => {\n        this._matrix[r.name] ? this._matrix[r.name].value = r.value || null : console.warn(`Data point ${r} is missing geographical data.`);\n      }));\n    }\n    return this._matrix;\n  }\n  /**\n   * Generate tabular data from display data\n   * @returns Array<Object>\n   */\n  getTabularDataArray() {\n    const t = this.getDisplayData(), { number: n, code: r } = y(this.getOptions(), "locale"), i = ["Country ID", "Country Name", "Value"], s = [\n      ...t.map((a) => [\n        a.id === null ? "&ndash;" : a.id,\n        a.name,\n        a.value === null ? "&ndash;" : n(a.value, r)\n      ])\n    ];\n    return super.formatTable({ headers: i, cells: s });\n  }\n  // Uses quantize scale to return class names\n  getColorClassName(t) {\n    return `${t.originalClassName || ""} ${this._colorScale(t.value)}`;\n  }\n  setColorClassNames() {\n    const t = y(this.getOptions(), "color");\n    this._colorScale = Fm(this.getDisplayData(), t);\n  }\n}, n$ = class extends an {\n  constructor(t) {\n    super(t), this.parentNode = !1, this.set({ depth: 2 }, { skipUpdate: !0 });\n  }\n  setData(t) {\n    super.setData(t), this.setDataGroups(), t.length === 1 && (this.parentNode = !0), this.setZoom();\n  }\n  setOptions(t) {\n    const n = this.getOptions(), r = at({}, t, this.getZoomOptions(t));\n    Fc(n, r);\n    const i = this.getHierarchyLevel(), s = y(n, "circlePack", "depth");\n    this.set({\n      options: at(n, r),\n      depth: s && s < 4 ? s : i\n    });\n  }\n  getZoomOptions(t) {\n    if (!this.getDisplayData())\n      return {};\n    const n = this.getDisplayData(), r = t || this.getOptions(), i = n.length === 1 && y(n, 0, "children") ? y(n, 0, "children") : n;\n    let s = this.getHierarchyLevel();\n    return i.some((a) => {\n      if (a.children && a.children.some((o) => o.children))\n        return s = 3, !1;\n    }), y(r, "canvasZoom", "enabled") === !0 && s > 2 ? {\n      legend: {\n        additionalItems: [\n          {\n            type: Gt.ZOOM,\n            name: "Click to zoom"\n          }\n        ]\n      }\n    } : null;\n  }\n  setZoom(t) {\n    this.setOptions(this.getZoomOptions(t));\n  }\n  // update the hierarchy level\n  updateHierarchyLevel(t) {\n    this.set({ depth: t });\n  }\n  getHierarchyLevel() {\n    return this.get("depth");\n  }\n  hasParentNode() {\n    return this.parentNode;\n  }\n  // set the datagroup name on the items that are it\'s children\n  setDataGroups() {\n    const t = this.getData(), n = this.getOptions(), { groupMapsTo: r } = n.data, i = t.map((s) => {\n      const a = s[r];\n      return this.setChildrenDataGroup(s, a);\n    });\n    this.set(\n      {\n        data: i\n      },\n      { skipUpdate: !0 }\n    );\n  }\n  // sets name recursively down the node tree\n  setChildrenDataGroup(t, n) {\n    return t.children ? {\n      ...t,\n      dataGroupName: n,\n      children: t.children.map((r) => this.setChildrenDataGroup(r, n))\n    } : { ...t, dataGroupName: n };\n  }\n  getTabularDataArray() {\n    const t = this.getDisplayData(), { number: n, code: r } = y(this.getOptions(), "locale"), i = ["Child", "Parent", "Value"], s = [];\n    return t.forEach((a) => {\n      let o = a.value ? a.value : 0;\n      a.children && (o += this.getChildrenDatums(a.children, a.name, s, 0)), s.push(["&ndash;", a.name, n(o, r)]);\n    }), super.formatTable({ headers: i, cells: s });\n  }\n  /**\n   * Recursively determine the relationship between all the nested elements in the child\n   * @private\n   * @param {any} children - The children nodes to process.\n   * @param {any} parent - The parent node associated with the children.\n   * @param {string[][]} [result=[]] - An array to accumulate the resulting data.\n   * @param {number} [totalSum=0] - The running total sum of values processed.\n   * @returns {number} Sum.\n   */\n  getChildrenDatums(t, n, r = [], i = 0) {\n    const s = n, { number: a, code: o } = y(this.getOptions(), "locale");\n    return t.forEach((l) => {\n      const c = l.name;\n      let u = 0;\n      if (l.children)\n        l.children.length > 0 && (typeof l.value == "number" && (i += l.value), u += this.getChildrenDatums(l.children, c, r, u), r.push([c, s, a(u, o)]), i += u);\n      else {\n        let d = 0;\n        typeof l.value == "number" && (d = l.value, i += l.value), r.push([l.name, s, a(d, o)]);\n      }\n    }), i;\n  }\n}, r$ = class extends an {\n  constructor(t) {\n    super(t);\n  }\n  getTabularData(t) {\n    const n = super.getTabularData(t);\n    return t !== n && n.forEach((r) => {\n      r.key && r.key !== r.group && (r.group = r.key);\n    }), n;\n  }\n  getTabularDataArray() {\n    const t = this.getDisplayData(), n = this.getOptions(), { groupMapsTo: r } = n.data, { valueMapsTo: i } = n.pie, { number: s, code: a } = y(n, "locale"), o = ["Group", "Value"], l = [\n      ...t.map((c) => [\n        c[r],\n        c[i] === null ? "&ndash;" : s(c[i], a)\n      ])\n    ];\n    return super.formatTable({ headers: o, cells: l });\n  }\n  sanitize(t) {\n    return this.getTabularData(t).sort((n, r) => r.value - n.value);\n  }\n}, i$ = class extends an {\n  constructor(t) {\n    super(t);\n  }\n  getDataGroups() {\n    return super.getDataGroups().filter((t) => t.name !== "delta");\n  }\n  getTabularDataArray() {\n    const t = this.getDisplayData(), n = this.getOptions(), { groupMapsTo: r } = n.data, { number: i, code: s } = y(this.getOptions(), "locale"), a = ["Group", "Value"], o = [\n      ...t.map((l) => [\n        l[r],\n        l.value === null ? "&ndash;" : i(l.value, s)\n      ])\n    ];\n    return super.formatTable({ headers: a, cells: o });\n  }\n}, s$ = class extends mr {\n  constructor(t) {\n    super(t), this.axisFlavor = Ga.HOVERABLE, this._colorScale = void 0, this._domains = [], this._ranges = [], this._matrix = {};\n    const n = y(this.getOptions(), "axes");\n    if (y(n, "left", "scaleType") && y(n, "left", "scaleType") !== et.LABELS || y(n, "right", "scaleType") && y(n, "right", "scaleType") !== et.LABELS || y(n, "top", "scaleType") && y(n, "top", "scaleType") !== et.LABELS || y(n, "bottom", "scaleType") && y(n, "bottom", "scaleType") !== et.LABELS)\n      throw Error("Heatmap only supports label scaletypes.");\n  }\n  /**\n   * Get min and maximum value of the display data\n   * @returns Array consisting of smallest and largest values in  data\n   */\n  getValueDomain() {\n    const t = ze(this.getDisplayData(), (r) => r.value), n = Fe().domain(t).nice().domain();\n    if (n[0] > 0)\n      n[0] = 0;\n    else if (n[0] === 0 && n[1] === 0)\n      return [0, 1];\n    return n[0] < 0 && n[1] > 0 && (Math.abs(n[0]) > n[1] ? n[1] = Math.abs(n[0]) : n[0] = -n[1]), n;\n  }\n  /**\n   * @override\n   * @param value\n   * @returns string\n   */\n  getFillColor(t) {\n    return this._colorScale(t);\n  }\n  /**\n   * Generate a list of all unique domains\n   * @returns String[]\n   */\n  getUniqueDomain() {\n    if (Be(this._domains)) {\n      const t = this.getDisplayData(), { cartesianScales: n } = this.services, r = n.getDomainIdentifier(), i = n.getMainXAxisPosition(), s = n.getCustomDomainValuesByposition(i);\n      if (s)\n        return s;\n      this._domains = Array.from(\n        new Set(\n          t.map((a) => a[r])\n        )\n      );\n    }\n    return this._domains;\n  }\n  /**\n   * Generates a list of all unique ranges\n   * @returns String[]\n   */\n  getUniqueRanges() {\n    if (Be(this._ranges)) {\n      const t = this.getDisplayData(), { cartesianScales: n } = this.services, r = n.getRangeIdentifier(), i = n.getMainYAxisPosition(), s = n.getCustomDomainValuesByposition(i);\n      if (s)\n        return s;\n      this._ranges = Array.from(\n        new Set(\n          t.map((a) => a[r])\n        )\n      );\n    }\n    return this._ranges;\n  }\n  /**\n   * Generates a matrix (If doesn\'t exist) and returns it\n   * @returns Object\n   */\n  getMatrix() {\n    if (Be(this._matrix)) {\n      const t = this.getUniqueDomain(), n = this.getUniqueRanges(), r = this.services.cartesianScales.getDomainIdentifier(), i = this.services.cartesianScales.getRangeIdentifier(), s = {};\n      n.forEach((a) => {\n        s[a] = {\n          value: null,\n          index: -1\n        };\n      }), t.forEach((a) => {\n        this._matrix[a] = Sn(s);\n      }), this.getDisplayData().forEach((a, o) => {\n        this._matrix[a[r]][a[i]] = {\n          value: a.value,\n          index: o\n        };\n      });\n    }\n    return this._matrix;\n  }\n  /**\n   * Sets the data for the current instance.\n   *\n   * This method sanitizes the provided data, generates data groups,\n   * and updates the instance\'s state with the sanitized data and data groups.\n   * It also resets the `_domains`, `_ranges`, and `_matrix` attributes to their empty states.\n   *\n   * @param {any} newData - The new data to be set. This data will be cloned and sanitized.\n   * @returns {any} - The sanitized version of the provided data.\n   */\n  setData(t) {\n    const n = this.sanitize(Sn(t)), r = this.generateDataGroups(n);\n    return this.set({\n      data: n,\n      dataGroups: r\n    }), this._domains = [], this._ranges = [], this._matrix = {}, n;\n  }\n  /**\n   * Converts Object matrix into a single array\n   * @returns object[]\n   */\n  getMatrixAsArray() {\n    Be(this._matrix) && this.getMatrix();\n    const t = this.getUniqueDomain(), n = this.getUniqueRanges(), r = this.services.cartesianScales.getDomainIdentifier(), i = this.services.cartesianScales.getRangeIdentifier(), s = [];\n    return t.forEach((a) => {\n      n.forEach((o) => {\n        const l = {\n          value: this._matrix[a][o].value,\n          index: this._matrix[a][o].index\n        };\n        l[r] = a, l[i] = o, s.push(l);\n      });\n    }), s;\n  }\n  /**\n   * Generate tabular data from display data\n   * @returns Array<Object>\n   */\n  getTabularDataArray() {\n    const t = this.getDisplayData(), { primaryDomain: n, primaryRange: r } = this.assignRangeAndDomains(), { number: i, code: s } = y(this.getOptions(), "locale"), a = [n.label, r.label, "Value"], o = [\n      ...t.map((l) => [\n        l[n.identifier] === null ? "&ndash;" : l[n.identifier],\n        l[r.identifier] === null ? "&ndash;" : l[r.identifier],\n        l.value === null ? "&ndash;" : i(l.value, s)\n      ])\n    ];\n    return super.formatTable({ headers: a, cells: o });\n  }\n  // Uses quantize scale to return class names\n  getColorClassName(t) {\n    return `${t.originalClassName} ${this._colorScale(t.value)}`;\n  }\n  setColorClassNames() {\n    const t = this.getOptions(), n = y(t, "color", "gradient", "colors"), r = !Be(n);\n    let i = y(t, "color", "pairing", "option");\n    const s = this.getValueDomain(), a = s[0] < 0 && s[1] > 0 ? "diverge" : "mono";\n    (i < 1 && i > 4 && a === "mono" || i < 1 && i > 2 && a === "diverge") && (i = 1);\n    const o = r ? n : [];\n    if (!r) {\n      const c = a === "diverge" ? 17 : 11;\n      for (let u = 1; u < c + 1; u++)\n        o.push(`fill-${a}-${i}-${u}`);\n    }\n    this._colorScale = Gc().domain(s).range(o);\n    const l = y(this.getOptions(), "color");\n    this._colorScale = Fm(this.getDisplayData(), l);\n  }\n}, a$ = class extends mr {\n  getTabularDataArray() {\n    const t = this.getOptions(), { groupMapsTo: n } = t.data, { number: r, code: i } = y(this.getOptions(), "locale"), s = this.getBinnedStackedData(), a = [\n      gt(t, "bins.rangeLabel") || "Range",\n      ...s.map((l) => gt(l, `0.${n}`))\n    ], o = [\n      ...gt(s, 0).map((l, c) => [\n        `${r(Number(gt(l, "data.x0")), i)}  ${r(\n          Number(gt(l, "data.x1")),\n          i\n        )}`,\n        ...s.map(\n          (u) => r(gt(u[c], `data.${gt(u[c], n)}`), i)\n        )\n      ])\n    ];\n    return super.formatTable({ headers: a, cells: o });\n  }\n};\nclass o$ extends an {\n  constructor(t) {\n    super(t);\n  }\n  getMaximumDomain(t) {\n    return t.reduce((n, r) => n + r.value, 0);\n  }\n  /**\n   * Use a provided color for the bar or default to carbon color if no status provided.\n   * Defaults to carbon color otherwise.\n   * @param group dataset group label\n   */\n  getFillColor(t) {\n    const n = this.getOptions(), r = y(n, "color", "scale"), i = this.getStatus();\n    return r || !i ? super.getFillColor(t) : null;\n  }\n  /**\n   * Get the associated status for the data by checking the ranges\n   */\n  getStatus() {\n    const t = this.getOptions(), n = y(this.getDisplayData()), r = (n == null ? void 0 : n.reduce((a, o) => a + o.value, 0)) ?? 0, i = y(t, "meter", "proportional") ? r : r > 100 ? 100 : r, s = y(t, "meter", "status", "ranges");\n    if (s) {\n      const a = s.filter(\n        (o) => o.range[0] <= i && i <= o.range[1]\n      );\n      if (a.length > 0)\n        return a[0].status;\n    }\n    return null;\n  }\n  getTabularDataArray() {\n    const t = this.getDisplayData(), n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.getStatus(), s = y(n, "meter", "proportional"), { number: a, code: o } = y(this.getOptions(), "locale");\n    let l = [], c = [], u;\n    if (s === null) {\n      u = 100;\n      const d = t[0];\n      l = ["Group", "Value", ...i ? ["Status"] : []], c = [\n        [\n          d[r],\n          d.value === null ? "&ndash;" : a(d.value, o),\n          ...i ? [i] : []\n        ]\n      ];\n    } else\n      u = y(s, "total") || this.getMaximumDomain(t), l = ["Group", "Value", "Percentage of total"], c = [\n        ...t.map((h) => {\n          let p;\n          h.value !== null && h.value !== void 0 ? p = Number(h.value) : p = 0;\n          const f = Number((h.value / u * 100).toFixed(2));\n          return [\n            h[r],\n            h.value === null ? "&ndash;" : a(p, o),\n            a(f, o) + " %"\n          ];\n        })\n      ];\n    return super.formatTable({ headers: l, cells: c });\n  }\n}\nclass l$ extends mr {\n  constructor(t) {\n    super(t);\n  }\n  getTabularDataArray() {\n    const t = this.getOptions(), n = this.getGroupedData(), { angle: r, value: i } = y(t, "radar", "axes"), { number: s, code: a } = y(t, "locale"), o = y(n, "0", "data").map((u) => u[r]), l = ["Group", ...o], c = [\n      ...n.map((u) => [\n        u.name,\n        ...o.map(\n          (d, h) => y(u, "data", h, i) !== null ? s(y(u, "data", h, i), a) : "&ndash;"\n        )\n      ])\n    ];\n    return super.formatTable({ headers: l, cells: c });\n  }\n}\nlet c$ = class extends an {\n  constructor(t) {\n    super(t);\n  }\n  /**\n   * Retrieves and formats tabular data from the display data.\n   *\n   * @returns {any[]} An object containing the headers and cells of the tabular data.\n   */\n  getTabularDataArray() {\n    const t = this.getDisplayData(), n = ["Child", "Parent"], r = [];\n    return t.forEach((i) => {\n      this.getChildrenDatums(i, r), r.push([i.name, "&ndash;"]);\n    }), super.formatTable({ headers: n, cells: r });\n  }\n  /**\n   * Determine the child parent relationship in nested data\n   * @private\n   * @param {any} datum - The datum node to process.\n   * @param {any[]} [result=[]] - An array to accumulate the resulting data.\n   * @returns {any[]} The accumulated result array.\n   */\n  getChildrenDatums(t, n = []) {\n    t.children && t.children.length > 0 && t.children.forEach((r) => {\n      this.getChildrenDatums(r, n), n.push([r.name, t.name]);\n    });\n  }\n};\nclass u$ extends an {\n  constructor(t) {\n    super(t);\n  }\n  getTabularDataArray() {\n    const t = this.getDisplayData(), { number: n, code: r } = y(this.getOptions(), "locale"), i = ["Child", "Group", "Value"], s = [];\n    return t.forEach((a) => {\n      Array.isArray(a.children) ? a.children.forEach((o) => {\n        s.push([\n          o.name,\n          a.name,\n          o.value === null ? "&ndash;" : n(o.value, r)\n        ]);\n      }) : y(a.name) !== null && y(a.value) && s.push(["", a.name, n(a.value, r)]);\n    }), super.formatTable({ headers: i, cells: s });\n  }\n}\nlet h$ = class extends an {\n  constructor(t) {\n    super(t);\n  }\n  getTabularDataArray() {\n    const t = this.getDisplayData(), n = this.getOptions(), { fontSizeMapsTo: r, wordMapsTo: i } = n.wordCloud, { groupMapsTo: s } = n.data, { code: a, number: o } = y(n, "locale"), l = [n.tooltip.wordLabel, "Group", n.tooltip.valueLabel], c = [\n      ...t.map((u) => [\n        u[i],\n        u[s],\n        o(u[r], a)\n      ])\n    ];\n    return super.formatTable({ headers: l, cells: c });\n  }\n};\nvar d$ = /\\s/;\nfunction p$(e) {\n  for (var t = e.length; t-- && d$.test(e.charAt(t)); )\n    ;\n  return t;\n}\nvar f$ = /^\\s+/;\nfunction m$(e) {\n  return e && e.slice(0, p$(e) + 1).replace(f$, "");\n}\nvar Wh = NaN, g$ = /^[-+]0x[0-9a-f]+$/i, v$ = /^0b[01]+$/i, y$ = /^0o[0-7]+$/i, x$ = parseInt;\nfunction zr(e) {\n  if (typeof e == "number")\n    return e;\n  if (Fa(e))\n    return Wh;\n  if (De(e)) {\n    var t = typeof e.valueOf == "function" ? e.valueOf() : e;\n    e = De(t) ? t + "" : t;\n  }\n  if (typeof e != "string")\n    return e === 0 ? e : +e;\n  e = m$(e);\n  var n = v$.test(e);\n  return n || y$.test(e) ? x$(e.slice(2), n ? 2 : 8) : g$.test(e) ? Wh : +e;\n}\nvar No = function() {\n  return We.Date.now();\n}, b$ = "Expected a function", _$ = Math.max, E$ = Math.min;\nfunction ba(e, t, n) {\n  var r, i, s, a, o, l, c = 0, u = !1, d = !1, h = !0;\n  if (typeof e != "function")\n    throw new TypeError(b$);\n  t = zr(t) || 0, De(n) && (u = !!n.leading, d = "maxWait" in n, s = d ? _$(zr(n.maxWait) || 0, t) : s, h = "trailing" in n ? !!n.trailing : h);\n  function p(S) {\n    var M = r, D = i;\n    return r = i = void 0, c = S, a = e.apply(D, M), a;\n  }\n  function f(S) {\n    return c = S, o = setTimeout(v, t), u ? p(S) : a;\n  }\n  function g(S) {\n    var M = S - l, D = S - c, A = t - M;\n    return d ? E$(A, s - D) : A;\n  }\n  function m(S) {\n    var M = S - l, D = S - c;\n    return l === void 0 || M >= t || M < 0 || d && D >= s;\n  }\n  function v() {\n    var S = No();\n    if (m(S))\n      return x(S);\n    o = setTimeout(v, g(S));\n  }\n  function x(S) {\n    return o = void 0, h && r ? p(S) : (r = i = void 0, a);\n  }\n  function _() {\n    o !== void 0 && clearTimeout(o), c = 0, r = l = i = o = void 0;\n  }\n  function E() {\n    return o === void 0 ? a : x(No());\n  }\n  function b() {\n    var S = No(), M = m(S);\n    if (r = arguments, i = this, l = S, M) {\n      if (o === void 0)\n        return f(l);\n      if (d)\n        return clearTimeout(o), o = setTimeout(v, t), p(l);\n    }\n    return o === void 0 && (o = setTimeout(v, t)), a;\n  }\n  return b.cancel = _, b.flush = E, b;\n}\nfunction O$(e, t, n) {\n  e = +e, t = +t, n = (i = arguments.length) < 2 ? (t = e, e = 0, 1) : i < 3 ? 1 : +n;\n  for (var r = -1, i = Math.max(0, Math.ceil((t - e) / n)) | 0, s = new Array(i); ++r < i; )\n    s[r] = e + r * n;\n  return s;\n}\nfunction I(e) {\n  return typeof e == "string" ? new _e([[document.querySelector(e)]], [document.documentElement]) : new _e([[e]], sm);\n}\nfunction gs() {\n  var e = ro().unknown(void 0), t = e.domain, n = e.range, r = 0, i = 1, s, a, o = !1, l = 0, c = 0, u = 0.5;\n  delete e.unknown;\n  function d() {\n    var h = t().length, p = i < r, f = p ? i : r, g = p ? r : i;\n    s = (g - f) / Math.max(1, h - l + c * 2), o && (s = Math.floor(s)), f += (g - f - s * (h - l)) * u, a = s * (1 - l), o && (f = Math.round(f), a = Math.round(a));\n    var m = O$(h).map(function(v) {\n      return f + s * v;\n    });\n    return n(p ? m.reverse() : m);\n  }\n  return e.domain = function(h) {\n    return arguments.length ? (t(h), d()) : t();\n  }, e.range = function(h) {\n    return arguments.length ? ([r, i] = h, r = +r, i = +i, d()) : [r, i];\n  }, e.rangeRound = function(h) {\n    return [r, i] = h, r = +r, i = +i, o = !0, d();\n  }, e.bandwidth = function() {\n    return a;\n  }, e.step = function() {\n    return s;\n  }, e.round = function(h) {\n    return arguments.length ? (o = !!h, d()) : o;\n  }, e.padding = function(h) {\n    return arguments.length ? (l = Math.min(1, c = +h), d()) : l;\n  }, e.paddingInner = function(h) {\n    return arguments.length ? (l = Math.min(1, h), d()) : l;\n  }, e.paddingOuter = function(h) {\n    return arguments.length ? (c = +h, d()) : c;\n  }, e.align = function(h) {\n    return arguments.length ? (u = Math.max(0, Math.min(1, h)), d()) : u;\n  }, e.copy = function() {\n    return gs(t(), [r, i]).round(o).paddingInner(l).paddingOuter(c).align(u);\n  }, ii.apply(d(), arguments);\n}\nfunction qm(e, t) {\n  e = e.slice();\n  var n = 0, r = e.length - 1, i = e[n], s = e[r], a;\n  return s < i && (a = n, n = r, r = a, a = i, i = s, s = a), e[n] = t.floor(i), e[r] = t.ceil(s), e;\n}\nconst Po = /* @__PURE__ */ new Date(), Uo = /* @__PURE__ */ new Date();\nfunction Wt(e, t, n, r) {\n  function i(s) {\n    return e(s = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+s)), s;\n  }\n  return i.floor = (s) => (e(s = /* @__PURE__ */ new Date(+s)), s), i.ceil = (s) => (e(s = new Date(s - 1)), t(s, 1), e(s), s), i.round = (s) => {\n    const a = i(s), o = i.ceil(s);\n    return s - a < o - s ? a : o;\n  }, i.offset = (s, a) => (t(s = /* @__PURE__ */ new Date(+s), a == null ? 1 : Math.floor(a)), s), i.range = (s, a, o) => {\n    const l = [];\n    if (s = i.ceil(s), o = o == null ? 1 : Math.floor(o), !(s < a) || !(o > 0)) return l;\n    let c;\n    do\n      l.push(c = /* @__PURE__ */ new Date(+s)), t(s, o), e(s);\n    while (c < s && s < a);\n    return l;\n  }, i.filter = (s) => Wt((a) => {\n    if (a >= a) for (; e(a), !s(a); ) a.setTime(a - 1);\n  }, (a, o) => {\n    if (a >= a)\n      if (o < 0) for (; ++o <= 0; )\n        for (; t(a, -1), !s(a); )\n          ;\n      else for (; --o >= 0; )\n        for (; t(a, 1), !s(a); )\n          ;\n  }), n && (i.count = (s, a) => (Po.setTime(+s), Uo.setTime(+a), e(Po), e(Uo), Math.floor(n(Po, Uo))), i.every = (s) => (s = Math.floor(s), !isFinite(s) || !(s > 0) ? null : s > 1 ? i.filter(r ? (a) => r(a) % s === 0 : (a) => i.count(0, a) % s === 0) : i)), i;\n}\nconst _a = Wt(() => {\n}, (e, t) => {\n  e.setTime(+e + t);\n}, (e, t) => t - e);\n_a.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Wt((t) => {\n  t.setTime(Math.floor(t / e) * e);\n}, (t, n) => {\n  t.setTime(+t + n * e);\n}, (t, n) => (n - t) / e) : _a);\n_a.range;\nconst bn = 1e3, Ce = bn * 60, _n = Ce * 60, $n = _n * 24, Wc = $n * 7, qh = $n * 30, Bo = $n * 365, Ur = Wt((e) => {\n  e.setTime(e - e.getMilliseconds());\n}, (e, t) => {\n  e.setTime(+e + t * bn);\n}, (e, t) => (t - e) / bn, (e) => e.getUTCSeconds());\nUr.range;\nconst qc = Wt((e) => {\n  e.setTime(e - e.getMilliseconds() - e.getSeconds() * bn);\n}, (e, t) => {\n  e.setTime(+e + t * Ce);\n}, (e, t) => (t - e) / Ce, (e) => e.getMinutes());\nqc.range;\nconst S$ = Wt((e) => {\n  e.setUTCSeconds(0, 0);\n}, (e, t) => {\n  e.setTime(+e + t * Ce);\n}, (e, t) => (t - e) / Ce, (e) => e.getUTCMinutes());\nS$.range;\nconst Yc = Wt((e) => {\n  e.setTime(e - e.getMilliseconds() - e.getSeconds() * bn - e.getMinutes() * Ce);\n}, (e, t) => {\n  e.setTime(+e + t * _n);\n}, (e, t) => (t - e) / _n, (e) => e.getHours());\nYc.range;\nconst T$ = Wt((e) => {\n  e.setUTCMinutes(0, 0, 0);\n}, (e, t) => {\n  e.setTime(+e + t * _n);\n}, (e, t) => (t - e) / _n, (e) => e.getUTCHours());\nT$.range;\nconst vs = Wt(\n  (e) => e.setHours(0, 0, 0, 0),\n  (e, t) => e.setDate(e.getDate() + t),\n  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * Ce) / $n,\n  (e) => e.getDate() - 1\n);\nvs.range;\nconst Xc = Wt((e) => {\n  e.setUTCHours(0, 0, 0, 0);\n}, (e, t) => {\n  e.setUTCDate(e.getUTCDate() + t);\n}, (e, t) => (t - e) / $n, (e) => e.getUTCDate() - 1);\nXc.range;\nconst w$ = Wt((e) => {\n  e.setUTCHours(0, 0, 0, 0);\n}, (e, t) => {\n  e.setUTCDate(e.getUTCDate() + t);\n}, (e, t) => (t - e) / $n, (e) => Math.floor(e / $n));\nw$.range;\nfunction gr(e) {\n  return Wt((t) => {\n    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);\n  }, (t, n) => {\n    t.setDate(t.getDate() + n * 7);\n  }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Ce) / Wc);\n}\nconst ao = gr(0), Ea = gr(1), $$ = gr(2), M$ = gr(3), Qr = gr(4), C$ = gr(5), A$ = gr(6);\nao.range;\nEa.range;\n$$.range;\nM$.range;\nQr.range;\nC$.range;\nA$.range;\nfunction vr(e) {\n  return Wt((t) => {\n    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);\n  }, (t, n) => {\n    t.setUTCDate(t.getUTCDate() + n * 7);\n  }, (t, n) => (n - t) / Wc);\n}\nconst Ym = vr(0), Oa = vr(1), L$ = vr(2), k$ = vr(3), Jr = vr(4), D$ = vr(5), R$ = vr(6);\nYm.range;\nOa.range;\nL$.range;\nk$.range;\nJr.range;\nD$.range;\nR$.range;\nconst Zc = Wt((e) => {\n  e.setDate(1), e.setHours(0, 0, 0, 0);\n}, (e, t) => {\n  e.setMonth(e.getMonth() + t);\n}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());\nZc.range;\nconst I$ = Wt((e) => {\n  e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);\n}, (e, t) => {\n  e.setUTCMonth(e.getUTCMonth() + t);\n}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());\nI$.range;\nconst Mn = Wt((e) => {\n  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);\n}, (e, t) => {\n  e.setFullYear(e.getFullYear() + t);\n}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());\nMn.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Wt((t) => {\n  t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);\n}, (t, n) => {\n  t.setFullYear(t.getFullYear() + n * e);\n});\nMn.range;\nconst ar = Wt((e) => {\n  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);\n}, (e, t) => {\n  e.setUTCFullYear(e.getUTCFullYear() + t);\n}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());\nar.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Wt((t) => {\n  t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);\n}, (t, n) => {\n  t.setUTCFullYear(t.getUTCFullYear() + n * e);\n});\nar.range;\nfunction N$(e, t, n, r, i, s) {\n  const a = [\n    [Ur, 1, bn],\n    [Ur, 5, 5 * bn],\n    [Ur, 15, 15 * bn],\n    [Ur, 30, 30 * bn],\n    [s, 1, Ce],\n    [s, 5, 5 * Ce],\n    [s, 15, 15 * Ce],\n    [s, 30, 30 * Ce],\n    [i, 1, _n],\n    [i, 3, 3 * _n],\n    [i, 6, 6 * _n],\n    [i, 12, 12 * _n],\n    [r, 1, $n],\n    [r, 2, 2 * $n],\n    [n, 1, Wc],\n    [t, 1, qh],\n    [t, 3, 3 * qh],\n    [e, 1, Bo]\n  ];\n  function o(c, u, d) {\n    const h = u < c;\n    h && ([c, u] = [u, c]);\n    const p = d && typeof d.range == "function" ? d : l(c, u, d), f = p ? p.range(c, +u + 1) : [];\n    return h ? f.reverse() : f;\n  }\n  function l(c, u, d) {\n    const h = Math.abs(u - c) / d, p = Cc(([, , m]) => m).right(a, h);\n    if (p === a.length) return e.every(El(c / Bo, u / Bo, d));\n    if (p === 0) return _a.every(Math.max(El(c, u, d), 1));\n    const [f, g] = a[h / a[p - 1][2] < a[p][2] / h ? p - 1 : p];\n    return f.every(g);\n  }\n  return [o, l];\n}\nconst [P$, U$] = N$(Mn, Zc, ao, vs, Yc, qc);\nfunction Ho(e) {\n  if (0 <= e.y && e.y < 100) {\n    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);\n    return t.setFullYear(e.y), t;\n  }\n  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);\n}\nfunction Vo(e) {\n  if (0 <= e.y && e.y < 100) {\n    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));\n    return t.setUTCFullYear(e.y), t;\n  }\n  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));\n}\nfunction gi(e, t, n) {\n  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };\n}\nfunction B$(e) {\n  var t = e.dateTime, n = e.date, r = e.time, i = e.periods, s = e.days, a = e.shortDays, o = e.months, l = e.shortMonths, c = vi(i), u = yi(i), d = vi(s), h = yi(s), p = vi(a), f = yi(a), g = vi(o), m = yi(o), v = vi(l), x = yi(l), _ = {\n    a: L,\n    A: k,\n    b: U,\n    B: Z,\n    c: null,\n    d: Jh,\n    e: Jh,\n    f: lM,\n    g: yM,\n    G: bM,\n    H: sM,\n    I: aM,\n    j: oM,\n    L: Xm,\n    m: cM,\n    M: uM,\n    p: j,\n    q: F,\n    Q: nd,\n    s: rd,\n    S: hM,\n    u: dM,\n    U: pM,\n    V: fM,\n    w: mM,\n    W: gM,\n    x: null,\n    X: null,\n    y: vM,\n    Y: xM,\n    Z: _M,\n    "%": ed\n  }, E = {\n    a: Y,\n    A: ot,\n    b: Q,\n    B: q,\n    c: null,\n    d: td,\n    e: td,\n    f: TM,\n    g: IM,\n    G: PM,\n    H: EM,\n    I: OM,\n    j: SM,\n    L: Km,\n    m: wM,\n    M: $M,\n    p: tt,\n    q: lt,\n    Q: nd,\n    s: rd,\n    S: MM,\n    u: CM,\n    U: AM,\n    V: LM,\n    w: kM,\n    W: DM,\n    x: null,\n    X: null,\n    y: RM,\n    Y: NM,\n    Z: UM,\n    "%": ed\n  }, b = {\n    a: R,\n    A: $,\n    b: H,\n    B: P,\n    c: B,\n    d: Kh,\n    e: Kh,\n    f: eM,\n    g: Zh,\n    G: Xh,\n    H: Qh,\n    I: Qh,\n    j: K$,\n    L: tM,\n    m: Z$,\n    M: Q$,\n    p: A,\n    q: X$,\n    Q: rM,\n    s: iM,\n    S: J$,\n    u: F$,\n    U: j$,\n    V: W$,\n    w: z$,\n    W: q$,\n    x: O,\n    X: w,\n    y: Zh,\n    Y: Xh,\n    Z: Y$,\n    "%": nM\n  };\n  _.x = S(n, _), _.X = S(r, _), _.c = S(t, _), E.x = S(n, E), E.X = S(r, E), E.c = S(t, E);\n  function S(z, W) {\n    return function(X) {\n      var V = [], ut = -1, st = 0, Dt = z.length, Nt, nt, yt;\n      for (X instanceof Date || (X = /* @__PURE__ */ new Date(+X)); ++ut < Dt; )\n        z.charCodeAt(ut) === 37 && (V.push(z.slice(st, ut)), (nt = Yh[Nt = z.charAt(++ut)]) != null ? Nt = z.charAt(++ut) : nt = Nt === "e" ? " " : "0", (yt = W[Nt]) && (Nt = yt(X, nt)), V.push(Nt), st = ut + 1);\n      return V.push(z.slice(st, ut)), V.join("");\n    };\n  }\n  function M(z, W) {\n    return function(X) {\n      var V = gi(1900, void 0, 1), ut = D(V, z, X += "", 0), st, Dt;\n      if (ut != X.length) return null;\n      if ("Q" in V) return new Date(V.Q);\n      if ("s" in V) return new Date(V.s * 1e3 + ("L" in V ? V.L : 0));\n      if (W && !("Z" in V) && (V.Z = 0), "p" in V && (V.H = V.H % 12 + V.p * 12), V.m === void 0 && (V.m = "q" in V ? V.q : 0), "V" in V) {\n        if (V.V < 1 || V.V > 53) return null;\n        "w" in V || (V.w = 1), "Z" in V ? (st = Vo(gi(V.y, 0, 1)), Dt = st.getUTCDay(), st = Dt > 4 || Dt === 0 ? Oa.ceil(st) : Oa(st), st = Xc.offset(st, (V.V - 1) * 7), V.y = st.getUTCFullYear(), V.m = st.getUTCMonth(), V.d = st.getUTCDate() + (V.w + 6) % 7) : (st = Ho(gi(V.y, 0, 1)), Dt = st.getDay(), st = Dt > 4 || Dt === 0 ? Ea.ceil(st) : Ea(st), st = vs.offset(st, (V.V - 1) * 7), V.y = st.getFullYear(), V.m = st.getMonth(), V.d = st.getDate() + (V.w + 6) % 7);\n      } else ("W" in V || "U" in V) && ("w" in V || (V.w = "u" in V ? V.u % 7 : "W" in V ? 1 : 0), Dt = "Z" in V ? Vo(gi(V.y, 0, 1)).getUTCDay() : Ho(gi(V.y, 0, 1)).getDay(), V.m = 0, V.d = "W" in V ? (V.w + 6) % 7 + V.W * 7 - (Dt + 5) % 7 : V.w + V.U * 7 - (Dt + 6) % 7);\n      return "Z" in V ? (V.H += V.Z / 100 | 0, V.M += V.Z % 100, Vo(V)) : Ho(V);\n    };\n  }\n  function D(z, W, X, V) {\n    for (var ut = 0, st = W.length, Dt = X.length, Nt, nt; ut < st; ) {\n      if (V >= Dt) return -1;\n      if (Nt = W.charCodeAt(ut++), Nt === 37) {\n        if (Nt = W.charAt(ut++), nt = b[Nt in Yh ? W.charAt(ut++) : Nt], !nt || (V = nt(z, X, V)) < 0) return -1;\n      } else if (Nt != X.charCodeAt(V++))\n        return -1;\n    }\n    return V;\n  }\n  function A(z, W, X) {\n    var V = c.exec(W.slice(X));\n    return V ? (z.p = u.get(V[0].toLowerCase()), X + V[0].length) : -1;\n  }\n  function R(z, W, X) {\n    var V = p.exec(W.slice(X));\n    return V ? (z.w = f.get(V[0].toLowerCase()), X + V[0].length) : -1;\n  }\n  function $(z, W, X) {\n    var V = d.exec(W.slice(X));\n    return V ? (z.w = h.get(V[0].toLowerCase()), X + V[0].length) : -1;\n  }\n  function H(z, W, X) {\n    var V = v.exec(W.slice(X));\n    return V ? (z.m = x.get(V[0].toLowerCase()), X + V[0].length) : -1;\n  }\n  function P(z, W, X) {\n    var V = g.exec(W.slice(X));\n    return V ? (z.m = m.get(V[0].toLowerCase()), X + V[0].length) : -1;\n  }\n  function B(z, W, X) {\n    return D(z, t, W, X);\n  }\n  function O(z, W, X) {\n    return D(z, n, W, X);\n  }\n  function w(z, W, X) {\n    return D(z, r, W, X);\n  }\n  function L(z) {\n    return a[z.getDay()];\n  }\n  function k(z) {\n    return s[z.getDay()];\n  }\n  function U(z) {\n    return l[z.getMonth()];\n  }\n  function Z(z) {\n    return o[z.getMonth()];\n  }\n  function j(z) {\n    return i[+(z.getHours() >= 12)];\n  }\n  function F(z) {\n    return 1 + ~~(z.getMonth() / 3);\n  }\n  function Y(z) {\n    return a[z.getUTCDay()];\n  }\n  function ot(z) {\n    return s[z.getUTCDay()];\n  }\n  function Q(z) {\n    return l[z.getUTCMonth()];\n  }\n  function q(z) {\n    return o[z.getUTCMonth()];\n  }\n  function tt(z) {\n    return i[+(z.getUTCHours() >= 12)];\n  }\n  function lt(z) {\n    return 1 + ~~(z.getUTCMonth() / 3);\n  }\n  return {\n    format: function(z) {\n      var W = S(z += "", _);\n      return W.toString = function() {\n        return z;\n      }, W;\n    },\n    parse: function(z) {\n      var W = M(z += "", !1);\n      return W.toString = function() {\n        return z;\n      }, W;\n    },\n    utcFormat: function(z) {\n      var W = S(z += "", E);\n      return W.toString = function() {\n        return z;\n      }, W;\n    },\n    utcParse: function(z) {\n      var W = M(z += "", !0);\n      return W.toString = function() {\n        return z;\n      }, W;\n    }\n  };\n}\nvar Yh = { "-": "", _: " ", 0: "0" }, Yt = /^\\s*\\d+/, H$ = /^%/, V$ = /[\\\\^$*+?|[\\]().{}]/g;\nfunction vt(e, t, n) {\n  var r = e < 0 ? "-" : "", i = (r ? -e : e) + "", s = i.length;\n  return r + (s < n ? new Array(n - s + 1).join(t) + i : i);\n}\nfunction G$(e) {\n  return e.replace(V$, "\\\\$&");\n}\nfunction vi(e) {\n  return new RegExp("^(?:" + e.map(G$).join("|") + ")", "i");\n}\nfunction yi(e) {\n  return new Map(e.map((t, n) => [t.toLowerCase(), n]));\n}\nfunction z$(e, t, n) {\n  var r = Yt.exec(t.slice(n, n + 1));\n  return r ? (e.w = +r[0], n + r[0].length) : -1;\n}\nfunction F$(e, t, n) {\n  var r = Yt.exec(t.slice(n, n + 1));\n  return r ? (e.u = +r[0], n + r[0].length) : -1;\n}\nfunction j$(e, t, n) {\n  var r = Yt.exec(t.slice(n, n + 2));\n  return r ? (e.U = +r[0], n + r[0].length) : -1;\n}\nfunction W$(e, t, n) {\n  var r = Yt.exec(t.slice(n, n + 2));\n  return r ? (e.V = +r[0], n + r[0].length) : -1;\n}\nfunction q$(e, t, n) {\n  var r = Yt.exec(t.slice(n, n + 2));\n  return r ? (e.W = +r[0], n + r[0].length) : -1;\n}\nfunction Xh(e, t, n) {\n  var r = Yt.exec(t.slice(n, n + 4));\n  return r ? (e.y = +r[0], n + r[0].length) : -1;\n}\nfunction Zh(e, t, n) {\n  var r = Yt.exec(t.slice(n, n + 2));\n  return r ? (e.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3), n + r[0].length) : -1;\n}\nfunction Y$(e, t, n) {\n  var r = /^(Z)|([+-]\\d\\d)(?::?(\\d\\d))?/.exec(t.slice(n, n + 6));\n  return r ? (e.Z = r[1] ? 0 : -(r[2] + (r[3] || "00")), n + r[0].length) : -1;\n}\nfunction X$(e, t, n) {\n  var r = Yt.exec(t.slice(n, n + 1));\n  return r ? (e.q = r[0] * 3 - 3, n + r[0].length) : -1;\n}\nfunction Z$(e, t, n) {\n  var r = Yt.exec(t.slice(n, n + 2));\n  return r ? (e.m = r[0] - 1, n + r[0].length) : -1;\n}\nfunction Kh(e, t, n) {\n  var r = Yt.exec(t.slice(n, n + 2));\n  return r ? (e.d = +r[0], n + r[0].length) : -1;\n}\nfunction K$(e, t, n) {\n  var r = Yt.exec(t.slice(n, n + 3));\n  return r ? (e.m = 0, e.d = +r[0], n + r[0].length) : -1;\n}\nfunction Qh(e, t, n) {\n  var r = Yt.exec(t.slice(n, n + 2));\n  return r ? (e.H = +r[0], n + r[0].length) : -1;\n}\nfunction Q$(e, t, n) {\n  var r = Yt.exec(t.slice(n, n + 2));\n  return r ? (e.M = +r[0], n + r[0].length) : -1;\n}\nfunction J$(e, t, n) {\n  var r = Yt.exec(t.slice(n, n + 2));\n  return r ? (e.S = +r[0], n + r[0].length) : -1;\n}\nfunction tM(e, t, n) {\n  var r = Yt.exec(t.slice(n, n + 3));\n  return r ? (e.L = +r[0], n + r[0].length) : -1;\n}\nfunction eM(e, t, n) {\n  var r = Yt.exec(t.slice(n, n + 6));\n  return r ? (e.L = Math.floor(r[0] / 1e3), n + r[0].length) : -1;\n}\nfunction nM(e, t, n) {\n  var r = H$.exec(t.slice(n, n + 1));\n  return r ? n + r[0].length : -1;\n}\nfunction rM(e, t, n) {\n  var r = Yt.exec(t.slice(n));\n  return r ? (e.Q = +r[0], n + r[0].length) : -1;\n}\nfunction iM(e, t, n) {\n  var r = Yt.exec(t.slice(n));\n  return r ? (e.s = +r[0], n + r[0].length) : -1;\n}\nfunction Jh(e, t) {\n  return vt(e.getDate(), t, 2);\n}\nfunction sM(e, t) {\n  return vt(e.getHours(), t, 2);\n}\nfunction aM(e, t) {\n  return vt(e.getHours() % 12 || 12, t, 2);\n}\nfunction oM(e, t) {\n  return vt(1 + vs.count(Mn(e), e), t, 3);\n}\nfunction Xm(e, t) {\n  return vt(e.getMilliseconds(), t, 3);\n}\nfunction lM(e, t) {\n  return Xm(e, t) + "000";\n}\nfunction cM(e, t) {\n  return vt(e.getMonth() + 1, t, 2);\n}\nfunction uM(e, t) {\n  return vt(e.getMinutes(), t, 2);\n}\nfunction hM(e, t) {\n  return vt(e.getSeconds(), t, 2);\n}\nfunction dM(e) {\n  var t = e.getDay();\n  return t === 0 ? 7 : t;\n}\nfunction pM(e, t) {\n  return vt(ao.count(Mn(e) - 1, e), t, 2);\n}\nfunction Zm(e) {\n  var t = e.getDay();\n  return t >= 4 || t === 0 ? Qr(e) : Qr.ceil(e);\n}\nfunction fM(e, t) {\n  return e = Zm(e), vt(Qr.count(Mn(e), e) + (Mn(e).getDay() === 4), t, 2);\n}\nfunction mM(e) {\n  return e.getDay();\n}\nfunction gM(e, t) {\n  return vt(Ea.count(Mn(e) - 1, e), t, 2);\n}\nfunction vM(e, t) {\n  return vt(e.getFullYear() % 100, t, 2);\n}\nfunction yM(e, t) {\n  return e = Zm(e), vt(e.getFullYear() % 100, t, 2);\n}\nfunction xM(e, t) {\n  return vt(e.getFullYear() % 1e4, t, 4);\n}\nfunction bM(e, t) {\n  var n = e.getDay();\n  return e = n >= 4 || n === 0 ? Qr(e) : Qr.ceil(e), vt(e.getFullYear() % 1e4, t, 4);\n}\nfunction _M(e) {\n  var t = e.getTimezoneOffset();\n  return (t > 0 ? "-" : (t *= -1, "+")) + vt(t / 60 | 0, "0", 2) + vt(t % 60, "0", 2);\n}\nfunction td(e, t) {\n  return vt(e.getUTCDate(), t, 2);\n}\nfunction EM(e, t) {\n  return vt(e.getUTCHours(), t, 2);\n}\nfunction OM(e, t) {\n  return vt(e.getUTCHours() % 12 || 12, t, 2);\n}\nfunction SM(e, t) {\n  return vt(1 + Xc.count(ar(e), e), t, 3);\n}\nfunction Km(e, t) {\n  return vt(e.getUTCMilliseconds(), t, 3);\n}\nfunction TM(e, t) {\n  return Km(e, t) + "000";\n}\nfunction wM(e, t) {\n  return vt(e.getUTCMonth() + 1, t, 2);\n}\nfunction $M(e, t) {\n  return vt(e.getUTCMinutes(), t, 2);\n}\nfunction MM(e, t) {\n  return vt(e.getUTCSeconds(), t, 2);\n}\nfunction CM(e) {\n  var t = e.getUTCDay();\n  return t === 0 ? 7 : t;\n}\nfunction AM(e, t) {\n  return vt(Ym.count(ar(e) - 1, e), t, 2);\n}\nfunction Qm(e) {\n  var t = e.getUTCDay();\n  return t >= 4 || t === 0 ? Jr(e) : Jr.ceil(e);\n}\nfunction LM(e, t) {\n  return e = Qm(e), vt(Jr.count(ar(e), e) + (ar(e).getUTCDay() === 4), t, 2);\n}\nfunction kM(e) {\n  return e.getUTCDay();\n}\nfunction DM(e, t) {\n  return vt(Oa.count(ar(e) - 1, e), t, 2);\n}\nfunction RM(e, t) {\n  return vt(e.getUTCFullYear() % 100, t, 2);\n}\nfunction IM(e, t) {\n  return e = Qm(e), vt(e.getUTCFullYear() % 100, t, 2);\n}\nfunction NM(e, t) {\n  return vt(e.getUTCFullYear() % 1e4, t, 4);\n}\nfunction PM(e, t) {\n  var n = e.getUTCDay();\n  return e = n >= 4 || n === 0 ? Jr(e) : Jr.ceil(e), vt(e.getUTCFullYear() % 1e4, t, 4);\n}\nfunction UM() {\n  return "+0000";\n}\nfunction ed() {\n  return "%";\n}\nfunction nd(e) {\n  return +e;\n}\nfunction rd(e) {\n  return Math.floor(+e / 1e3);\n}\nvar Sr, Jm;\nBM({\n  dateTime: "%x, %X",\n  date: "%-m/%-d/%Y",\n  time: "%-I:%M:%S %p",\n  periods: ["AM", "PM"],\n  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],\n  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],\n  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],\n  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]\n});\nfunction BM(e) {\n  return Sr = B$(e), Jm = Sr.format, Sr.parse, Sr.utcFormat, Sr.utcParse, Sr;\n}\nfunction HM(e) {\n  return new Date(e);\n}\nfunction VM(e) {\n  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);\n}\nfunction tg(e, t, n, r, i, s, a, o, l, c) {\n  var u = wm(), d = u.invert, h = u.domain, p = c(".%L"), f = c(":%S"), g = c("%I:%M"), m = c("%I %p"), v = c("%a %d"), x = c("%b %d"), _ = c("%B"), E = c("%Y");\n  function b(S) {\n    return (l(S) < S ? p : o(S) < S ? f : a(S) < S ? g : s(S) < S ? m : r(S) < S ? i(S) < S ? v : x : n(S) < S ? _ : E)(S);\n  }\n  return u.invert = function(S) {\n    return new Date(d(S));\n  }, u.domain = function(S) {\n    return arguments.length ? h(Array.from(S, VM)) : h().map(HM);\n  }, u.ticks = function(S) {\n    var M = h();\n    return e(M[0], M[M.length - 1], S ?? 10);\n  }, u.tickFormat = function(S, M) {\n    return M == null ? b : c(M);\n  }, u.nice = function(S) {\n    var M = h();\n    return (!S || typeof S.range != "function") && (S = t(M[0], M[M.length - 1], S ?? 10)), S ? h(qm(M, S)) : u;\n  }, u.copy = function() {\n    return Vc(u, tg(e, t, n, r, i, s, a, o, l, c));\n  }, u;\n}\nfunction eg() {\n  return ii.apply(tg(P$, U$, Mn, Zc, ao, vs, Yc, qc, Ur, Jm).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);\n}\nconst id = Math.abs, Jt = Math.atan2, qn = Math.cos, GM = Math.max, Go = Math.min, Ze = Math.sin, Br = Math.sqrt, ne = 1e-12, ns = Math.PI, Sa = ns / 2, Ks = 2 * ns;\nfunction zM(e) {\n  return e > 1 ? 0 : e < -1 ? ns : Math.acos(e);\n}\nfunction sd(e) {\n  return e >= 1 ? Sa : e <= -1 ? -Sa : Math.asin(e);\n}\nfunction ng(e) {\n  this._context = e;\n}\nng.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;\n  },\n  point: function(e, t) {\n    switch (e = +e, t = +t, this._point) {\n      case 0:\n        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);\n        break;\n      case 1:\n        this._point = 2;\n      // falls through\n      default:\n        this._context.lineTo(e, t);\n        break;\n    }\n  }\n};\nfunction oo(e) {\n  return new ng(e);\n}\nfunction Hn() {\n}\nfunction rg(e) {\n  this._context = e;\n}\nrg.prototype = {\n  areaStart: Hn,\n  areaEnd: Hn,\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    this._point && this._context.closePath();\n  },\n  point: function(e, t) {\n    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));\n  }\n};\nfunction ig(e) {\n  return new rg(e);\n}\nfunction FM(e, t) {\n  if (e.match(/^[a-z]+:\\/\\//i))\n    return e;\n  if (e.match(/^\\/\\//))\n    return window.location.protocol + e;\n  if (e.match(/^[a-z]+:/i))\n    return e;\n  const n = document.implementation.createHTMLDocument(), r = n.createElement("base"), i = n.createElement("a");\n  return n.head.appendChild(r), n.body.appendChild(i), t && (r.href = t), i.href = e, i.href;\n}\nconst jM = /* @__PURE__ */ (() => {\n  let e = 0;\n  const t = () => (\n    // eslint-disable-next-line no-bitwise\n    `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4)\n  );\n  return () => (e += 1, `u${t()}${e}`);\n})();\nfunction On(e) {\n  const t = [];\n  for (let n = 0, r = e.length; n < r; n++)\n    t.push(e[n]);\n  return t;\n}\nfunction Ta(e, t) {\n  const n = (e.ownerDocument.defaultView || window).getComputedStyle(e).getPropertyValue(t);\n  return n ? parseFloat(n.replace("px", "")) : 0;\n}\nfunction WM(e) {\n  const t = Ta(e, "border-left-width"), n = Ta(e, "border-right-width");\n  return e.clientWidth + t + n;\n}\nfunction qM(e) {\n  const t = Ta(e, "border-top-width"), n = Ta(e, "border-bottom-width");\n  return e.clientHeight + t + n;\n}\nfunction sg(e, t = {}) {\n  const n = t.width || WM(e), r = t.height || qM(e);\n  return { width: n, height: r };\n}\nfunction YM() {\n  let e, t;\n  try {\n    t = process;\n  } catch {\n  }\n  const n = t && t.env ? t.env.devicePixelRatio : null;\n  return n && (e = parseInt(n, 10), Number.isNaN(e) && (e = 1)), e || window.devicePixelRatio || 1;\n}\nconst ve = 16384;\nfunction XM(e) {\n  (e.width > ve || e.height > ve) && (e.width > ve && e.height > ve ? e.width > e.height ? (e.height *= ve / e.width, e.width = ve) : (e.width *= ve / e.height, e.height = ve) : e.width > ve ? (e.height *= ve / e.width, e.width = ve) : (e.width *= ve / e.height, e.height = ve));\n}\nfunction wa(e) {\n  return new Promise((t, n) => {\n    const r = new Image();\n    r.decode = () => t(r), r.onload = () => t(r), r.onerror = n, r.crossOrigin = "anonymous", r.decoding = "async", r.src = e;\n  });\n}\nasync function ZM(e) {\n  return Promise.resolve().then(() => new XMLSerializer().serializeToString(e)).then(encodeURIComponent).then((t) => `data:image/svg+xml;charset=utf-8,${t}`);\n}\nasync function KM(e, t, n) {\n  const r = "http://www.w3.org/2000/svg", i = document.createElementNS(r, "svg"), s = document.createElementNS(r, "foreignObject");\n  return i.setAttribute("width", `${t}`), i.setAttribute("height", `${n}`), i.setAttribute("viewBox", `0 0 ${t} ${n}`), s.setAttribute("width", "100%"), s.setAttribute("height", "100%"), s.setAttribute("x", "0"), s.setAttribute("y", "0"), s.setAttribute("externalResourcesRequired", "true"), i.appendChild(s), s.appendChild(e), ZM(i);\n}\nconst pe = (e, t) => {\n  if (e instanceof t)\n    return !0;\n  const n = Object.getPrototypeOf(e);\n  return n === null ? !1 : n.constructor.name === t.name || pe(n, t);\n};\nfunction QM(e) {\n  const t = e.getPropertyValue("content");\n  return `${e.cssText} content: \'${t.replace(/\'|"/g, "")}\';`;\n}\nfunction JM(e) {\n  return On(e).map((t) => {\n    const n = e.getPropertyValue(t), r = e.getPropertyPriority(t);\n    return `${t}: ${n}${r ? " !important" : ""};`;\n  }).join(" ");\n}\nfunction t2(e, t, n) {\n  const r = `.${e}:${t}`, i = n.cssText ? QM(n) : JM(n);\n  return document.createTextNode(`${r}{${i}}`);\n}\nfunction ad(e, t, n) {\n  const r = window.getComputedStyle(e, n), i = r.getPropertyValue("content");\n  if (i === "" || i === "none")\n    return;\n  const s = jM();\n  try {\n    t.className = `${t.className} ${s}`;\n  } catch {\n    return;\n  }\n  const a = document.createElement("style");\n  a.appendChild(t2(s, n, r)), t.appendChild(a);\n}\nfunction e2(e, t) {\n  ad(e, t, ":before"), ad(e, t, ":after");\n}\nconst od = "application/font-woff", ld = "image/jpeg", n2 = {\n  woff: od,\n  woff2: od,\n  ttf: "application/font-truetype",\n  eot: "application/vnd.ms-fontobject",\n  png: "image/png",\n  jpg: ld,\n  jpeg: ld,\n  gif: "image/gif",\n  tiff: "image/tiff",\n  svg: "image/svg+xml",\n  webp: "image/webp"\n};\nfunction r2(e) {\n  const t = /\\.([^./]*?)$/g.exec(e);\n  return t ? t[1] : "";\n}\nfunction Kc(e) {\n  const t = r2(e).toLowerCase();\n  return n2[t] || "";\n}\nfunction i2(e) {\n  return e.split(/,/)[1];\n}\nfunction Rl(e) {\n  return e.search(/^(data:)/) !== -1;\n}\nfunction s2(e, t) {\n  return `data:${t};base64,${e}`;\n}\nasync function ag(e, t, n) {\n  const r = await fetch(e, t);\n  if (r.status === 404)\n    throw new Error(`Resource "${r.url}" not found`);\n  const i = await r.blob();\n  return new Promise((s, a) => {\n    const o = new FileReader();\n    o.onerror = a, o.onloadend = () => {\n      try {\n        s(n({ res: r, result: o.result }));\n      } catch (l) {\n        a(l);\n      }\n    }, o.readAsDataURL(i);\n  });\n}\nconst zo = {};\nfunction a2(e, t, n) {\n  let r = e.replace(/\\?.*/, "");\n  return n && (r = e), /ttf|otf|eot|woff2?/i.test(r) && (r = r.replace(/.*\\//, "")), t ? `[${t}]${r}` : r;\n}\nasync function Qc(e, t, n) {\n  const r = a2(e, t, n.includeQueryParams);\n  if (zo[r] != null)\n    return zo[r];\n  n.cacheBust && (e += (/\\?/.test(e) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime());\n  let i;\n  try {\n    const s = await ag(e, n.fetchRequestInit, ({ res: a, result: o }) => (t || (t = a.headers.get("Content-Type") || ""), i2(o)));\n    i = s2(s, t);\n  } catch (s) {\n    i = n.imagePlaceholder || "";\n    let a = `Failed to fetch resource: ${e}`;\n    s && (a = typeof s == "string" ? s : s.message), a && console.warn(a);\n  }\n  return zo[r] = i, i;\n}\nasync function o2(e) {\n  const t = e.toDataURL();\n  return t === "data:," ? e.cloneNode(!1) : wa(t);\n}\nasync function l2(e, t) {\n  if (e.currentSrc) {\n    const s = document.createElement("canvas"), a = s.getContext("2d");\n    s.width = e.clientWidth, s.height = e.clientHeight, a == null || a.drawImage(e, 0, 0, s.width, s.height);\n    const o = s.toDataURL();\n    return wa(o);\n  }\n  const n = e.poster, r = Kc(n), i = await Qc(n, r, t);\n  return wa(i);\n}\nasync function c2(e) {\n  var t;\n  try {\n    if (!((t = e == null ? void 0 : e.contentDocument) === null || t === void 0) && t.body)\n      return await lo(e.contentDocument.body, {}, !0);\n  } catch {\n  }\n  return e.cloneNode(!1);\n}\nasync function u2(e, t) {\n  return pe(e, HTMLCanvasElement) ? o2(e) : pe(e, HTMLVideoElement) ? l2(e, t) : pe(e, HTMLIFrameElement) ? c2(e) : e.cloneNode(!1);\n}\nconst h2 = (e) => e.tagName != null && e.tagName.toUpperCase() === "SLOT";\nasync function d2(e, t, n) {\n  var r, i;\n  let s = [];\n  return h2(e) && e.assignedNodes ? s = On(e.assignedNodes()) : pe(e, HTMLIFrameElement) && !((r = e.contentDocument) === null || r === void 0) && r.body ? s = On(e.contentDocument.body.childNodes) : s = On(((i = e.shadowRoot) !== null && i !== void 0 ? i : e).childNodes), s.length === 0 || pe(e, HTMLVideoElement) || await s.reduce((a, o) => a.then(() => lo(o, n)).then((l) => {\n    l && t.appendChild(l);\n  }), Promise.resolve()), t;\n}\nfunction p2(e, t) {\n  const n = t.style;\n  if (!n)\n    return;\n  const r = window.getComputedStyle(e);\n  r.cssText ? (n.cssText = r.cssText, n.transformOrigin = r.transformOrigin) : On(r).forEach((i) => {\n    let s = r.getPropertyValue(i);\n    i === "font-size" && s.endsWith("px") && (s = `${Math.floor(parseFloat(s.substring(0, s.length - 2))) - 0.1}px`), pe(e, HTMLIFrameElement) && i === "display" && s === "inline" && (s = "block"), i === "d" && t.getAttribute("d") && (s = `path(${t.getAttribute("d")})`), n.setProperty(i, s, r.getPropertyPriority(i));\n  });\n}\nfunction f2(e, t) {\n  pe(e, HTMLTextAreaElement) && (t.innerHTML = e.value), pe(e, HTMLInputElement) && t.setAttribute("value", e.value);\n}\nfunction m2(e, t) {\n  if (pe(e, HTMLSelectElement)) {\n    const n = t, r = Array.from(n.children).find((i) => e.value === i.getAttribute("value"));\n    r && r.setAttribute("selected", "");\n  }\n}\nfunction g2(e, t) {\n  return pe(t, Element) && (p2(e, t), e2(e, t), f2(e, t), m2(e, t)), t;\n}\nasync function v2(e, t) {\n  const n = e.querySelectorAll ? e.querySelectorAll("use") : [];\n  if (n.length === 0)\n    return e;\n  const r = {};\n  for (let s = 0; s < n.length; s++) {\n    const a = n[s].getAttribute("xlink:href");\n    if (a) {\n      const o = e.querySelector(a), l = document.querySelector(a);\n      !o && l && !r[a] && (r[a] = await lo(l, t, !0));\n    }\n  }\n  const i = Object.values(r);\n  if (i.length) {\n    const s = "http://www.w3.org/1999/xhtml", a = document.createElementNS(s, "svg");\n    a.setAttribute("xmlns", s), a.style.position = "absolute", a.style.width = "0", a.style.height = "0", a.style.overflow = "hidden", a.style.display = "none";\n    const o = document.createElementNS(s, "defs");\n    a.appendChild(o);\n    for (let l = 0; l < i.length; l++)\n      o.appendChild(i[l]);\n    e.appendChild(a);\n  }\n  return e;\n}\nasync function lo(e, t, n) {\n  return !n && t.filter && !t.filter(e) ? null : Promise.resolve(e).then((r) => u2(r, t)).then((r) => d2(e, r, t)).then((r) => g2(e, r)).then((r) => v2(r, t));\n}\nconst og = /url\\(([\'"]?)([^\'"]+?)\\1\\)/g, y2 = /url\\([^)]+\\)\\s*format\\((["\']?)([^"\']+)\\1\\)/g, x2 = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g;\nfunction b2(e) {\n  const t = e.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, "\\\\$1");\n  return new RegExp(`(url\\\\([\'"]?)(${t})([\'"]?\\\\))`, "g");\n}\nfunction _2(e) {\n  const t = [];\n  return e.replace(og, (n, r, i) => (t.push(i), n)), t.filter((n) => !Rl(n));\n}\nasync function E2(e, t, n, r, i) {\n  try {\n    const s = n ? FM(t, n) : t, a = Kc(t);\n    let o;\n    return i || (o = await Qc(s, a, r)), e.replace(b2(t), `$1${o}$3`);\n  } catch {\n  }\n  return e;\n}\nfunction O2(e, { preferredFontFormat: t }) {\n  return t ? e.replace(x2, (n) => {\n    for (; ; ) {\n      const [r, , i] = y2.exec(n) || [];\n      if (!i)\n        return "";\n      if (i === t)\n        return `src: ${r};`;\n    }\n  }) : e;\n}\nfunction lg(e) {\n  return e.search(og) !== -1;\n}\nasync function cg(e, t, n) {\n  if (!lg(e))\n    return e;\n  const r = O2(e, n);\n  return _2(r).reduce((i, s) => i.then((a) => E2(a, s, t, n)), Promise.resolve(r));\n}\nasync function Ls(e, t, n) {\n  var r;\n  const i = (r = t.style) === null || r === void 0 ? void 0 : r.getPropertyValue(e);\n  if (i) {\n    const s = await cg(i, null, n);\n    return t.style.setProperty(e, s, t.style.getPropertyPriority(e)), !0;\n  }\n  return !1;\n}\nasync function S2(e, t) {\n  await Ls("background", e, t) || await Ls("background-image", e, t), await Ls("mask", e, t) || await Ls("mask-image", e, t);\n}\nasync function T2(e, t) {\n  const n = pe(e, HTMLImageElement);\n  if (!(n && !Rl(e.src)) && !(pe(e, SVGImageElement) && !Rl(e.href.baseVal)))\n    return;\n  const r = n ? e.src : e.href.baseVal, i = await Qc(r, Kc(r), t);\n  await new Promise((s, a) => {\n    e.onload = s, e.onerror = a;\n    const o = e;\n    o.decode && (o.decode = s), o.loading === "lazy" && (o.loading = "eager"), n ? (e.srcset = "", e.src = i) : e.href.baseVal = i;\n  });\n}\nasync function w2(e, t) {\n  const n = On(e.childNodes).map((r) => ug(r, t));\n  await Promise.all(n).then(() => e);\n}\nasync function ug(e, t) {\n  pe(e, Element) && (await S2(e, t), await T2(e, t), await w2(e, t));\n}\nfunction $2(e, t) {\n  const { style: n } = e;\n  t.backgroundColor && (n.backgroundColor = t.backgroundColor), t.width && (n.width = `${t.width}px`), t.height && (n.height = `${t.height}px`);\n  const r = t.style;\n  return r != null && Object.keys(r).forEach((i) => {\n    n[i] = r[i];\n  }), e;\n}\nconst cd = {};\nasync function ud(e) {\n  let t = cd[e];\n  if (t != null)\n    return t;\n  const n = await (await fetch(e)).text();\n  return t = { url: e, cssText: n }, cd[e] = t, t;\n}\nasync function hd(e, t) {\n  let n = e.cssText;\n  const r = /url\\(["\']?([^"\')]+)["\']?\\)/g, i = (n.match(/url\\([^)]+\\)/g) || []).map(async (s) => {\n    let a = s.replace(r, "$1");\n    return a.startsWith("https://") || (a = new URL(a, e.url).href), ag(a, t.fetchRequestInit, ({ result: o }) => (n = n.replace(s, `url(${o})`), [s, o]));\n  });\n  return Promise.all(i).then(() => n);\n}\nfunction dd(e) {\n  if (e == null)\n    return [];\n  const t = [], n = /(\\/\\*[\\s\\S]*?\\*\\/)/gi;\n  let r = e.replace(n, "");\n  const i = new RegExp("((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})", "gi");\n  for (; ; ) {\n    const l = i.exec(r);\n    if (l === null)\n      break;\n    t.push(l[0]);\n  }\n  r = r.replace(i, "");\n  const s = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi, a = "((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})", o = new RegExp(a, "gi");\n  for (; ; ) {\n    let l = s.exec(r);\n    if (l === null) {\n      if (l = o.exec(r), l === null)\n        break;\n      s.lastIndex = o.lastIndex;\n    } else\n      o.lastIndex = s.lastIndex;\n    t.push(l[0]);\n  }\n  return t;\n}\nasync function M2(e, t) {\n  const n = [], r = [];\n  return e.forEach((i) => {\n    if ("cssRules" in i)\n      try {\n        On(i.cssRules || []).forEach((s, a) => {\n          if (s.type === CSSRule.IMPORT_RULE) {\n            let o = a + 1;\n            const l = s.href, c = ud(l).then((u) => hd(u, t)).then((u) => dd(u).forEach((d) => {\n              try {\n                i.insertRule(d, d.startsWith("@import") ? o += 1 : i.cssRules.length);\n              } catch (h) {\n                console.error("Error inserting rule from remote css", {\n                  rule: d,\n                  error: h\n                });\n              }\n            })).catch((u) => {\n              console.error("Error loading remote css", u.toString());\n            });\n            r.push(c);\n          }\n        });\n      } catch (s) {\n        const a = e.find((o) => o.href == null) || document.styleSheets[0];\n        i.href != null && r.push(ud(i.href).then((o) => hd(o, t)).then((o) => dd(o).forEach((l) => {\n          a.insertRule(l, i.cssRules.length);\n        })).catch((o) => {\n          console.error("Error loading remote stylesheet", o);\n        })), console.error("Error inlining remote css file", s);\n      }\n  }), Promise.all(r).then(() => (e.forEach((i) => {\n    if ("cssRules" in i)\n      try {\n        On(i.cssRules || []).forEach((s) => {\n          n.push(s);\n        });\n      } catch (s) {\n        console.error(`Error while reading CSS rules from ${i.href}`, s);\n      }\n  }), n));\n}\nfunction C2(e) {\n  return e.filter((t) => t.type === CSSRule.FONT_FACE_RULE).filter((t) => lg(t.style.getPropertyValue("src")));\n}\nasync function A2(e, t) {\n  if (e.ownerDocument == null)\n    throw new Error("Provided element is not within a Document");\n  const n = On(e.ownerDocument.styleSheets), r = await M2(n, t);\n  return C2(r);\n}\nasync function L2(e, t) {\n  const n = await A2(e, t);\n  return (await Promise.all(n.map((r) => {\n    const i = r.parentStyleSheet ? r.parentStyleSheet.href : null;\n    return cg(r.cssText, i, t);\n  }))).join(`\n`);\n}\nasync function k2(e, t) {\n  const n = t.fontEmbedCSS != null ? t.fontEmbedCSS : t.skipFonts ? null : await L2(e, t);\n  if (n) {\n    const r = document.createElement("style"), i = document.createTextNode(n);\n    r.appendChild(i), e.firstChild ? e.insertBefore(r, e.firstChild) : e.appendChild(r);\n  }\n}\nasync function D2(e, t = {}) {\n  const { width: n, height: r } = sg(e, t), i = await lo(e, t, !0);\n  return await k2(i, t), await ug(i, t), $2(i, t), await KM(i, n, r);\n}\nasync function hg(e, t = {}) {\n  const { width: n, height: r } = sg(e, t), i = await D2(e, t), s = await wa(i), a = document.createElement("canvas"), o = a.getContext("2d"), l = t.pixelRatio || YM(), c = t.canvasWidth || n, u = t.canvasHeight || r;\n  return a.width = c * l, a.height = u * l, t.skipAutoScale || XM(a), a.style.width = `${c}`, a.style.height = `${u}`, t.backgroundColor && (o.fillStyle = t.backgroundColor, o.fillRect(0, 0, a.width, a.height)), o.drawImage(s, 0, 0, a.width, a.height), a;\n}\nasync function R2(e, t = {}) {\n  return (await hg(e, t)).toDataURL();\n}\nasync function I2(e, t = {}) {\n  return (await hg(e, t)).toDataURL("image/jpeg", t.quality || 1);\n}\nlet Dn = class {\n  constructor(t, n) {\n    this.model = t, this.services = n, this.init();\n  }\n  init() {\n  }\n  update() {\n  }\n  // Used to pass down information to the components\n  setModel(t) {\n    this.model = t;\n  }\n  // Used to pass down services to the components\n  setServices(t) {\n    this.services = t;\n  }\n};\nconst N2 = "DONT_STYLE_ME_css_styles_verifier";\nlet N = class Il extends Dn {\n  // initialized in initializeID() called by init()\n  constructor(t, n) {\n    super(t, n);\n  }\n  static getHTMLElementSize(t) {\n    return {\n      width: t.clientWidth,\n      height: t.clientHeight\n    };\n  }\n  static getSVGElementSize(t, n = {\n    useAttrs: !1,\n    useClientDimensions: !1,\n    useBBox: !1,\n    useBoundingRect: !1\n  }) {\n    t.attr || (t = I(t));\n    const r = {\n      width: 0,\n      height: 0\n    }, i = (h) => {\n      h && Object.keys(r).forEach((p) => {\n        if (h[p]) {\n          const f = h[p], g = parseFloat(f);\n          f && g > r[p] && ("" + f).indexOf("%") === -1 && (r[p] = g);\n        }\n      });\n    }, s = {\n      width: t.attr("width"),\n      height: t.attr("height")\n    }, a = t.node();\n    let o, l, c, u;\n    try {\n      typeof a.getBBox == "function" && (o = a.getBBox(), l = {\n        width: o.width,\n        height: o.height\n      });\n    } catch (h) {\n      console.error(h);\n    }\n    try {\n      typeof (a == null ? void 0 : a.getBoundingClientRect) == "function" && (c = a.getBoundingClientRect(), u = {\n        width: c.width,\n        height: c.height\n      });\n    } catch (h) {\n      console.error(h);\n    }\n    let d;\n    if (a instanceof SVGSVGElement && (d = {\n      width: a.clientWidth,\n      height: a.clientHeight\n    }), n) {\n      if (n.useAttrs && (i(s), r.width > 0 && r.height > 0))\n        return r;\n      if (n.useClientDimensions && (i(d), r.width > 0 && r.height > 0))\n        return d;\n      if (n.useBBox && (i(l), r.width > 0 && r.height > 0))\n        return l;\n      if (n.useBoundingRect && (i(u), r.width > 0 && r.height > 0))\n        return u;\n    }\n    try {\n      const h = {\n        width: y(t.node(), "width", "baseVal", "value"),\n        height: y(t.node(), "height", "baseVal", "value")\n      };\n      i(h);\n    } catch {\n      i(d), i(l), i(s);\n    }\n    return r;\n  }\n  static appendOrSelect(t, n) {\n    const r = t.select(`${n}`);\n    if (r.empty()) {\n      let i = n.split("#"), s, a;\n      return i.length === 2 ? (s = i[0], i = i[1].split("."), a = i[0]) : (i = n.split("."), s = i[0]), t.append(s).attr("id", a).attr("class", i.slice(1).join(" "));\n    }\n    return r;\n  }\n  init() {\n    this.initializeID(), this.styleHolderElement(), this.addMainContainer(), this.model.getOptions().resizable && this.addResizeListener(), this.addHolderListeners(), this.handleFullscreenChange();\n  }\n  getChartID() {\n    return this.chartID;\n  }\n  getElementOffset(t, n = !1) {\n    const r = { left: 0, top: 0 }, i = t.getBoundingClientRect(), s = n ? { left: 0, top: 0 } : this.getHolder().getBoundingClientRect();\n    try {\n      r.left = i.left - s.left, r.top = i.top - s.top;\n    } catch (a) {\n      console.error(a);\n    }\n    return r;\n  }\n  generateElementIDString(t) {\n    return `chart-${this.chartID}-${t}`;\n  }\n  initializeID() {\n    this.chartID = Math.floor((1 + Math.random()) * 281474976710656).toString(16);\n  }\n  addMainContainer() {\n    const t = this.model.getOptions(), n = y(t, "style", "prefix"), r = I(this.getHolder()).append("div").classed(`${ue}--${n}--chart-wrapper`, !0).attr("id", `chart-${this.getChartID()}`).style("height", "100%").style("width", "100%");\n    r.append("g").attr("class", N2), this.mainContainer = r.node();\n  }\n  update() {\n    this.styleHolderElement();\n  }\n  styleHolderElement() {\n    const t = this.getHolder(), { width: n, height: r, theme: i } = this.model.getOptions();\n    n !== this.width && (t.style.width = n, this.width = n), r !== this.height && (t.style.height = r, this.height = r), I(this.getHolder()).classed(`${ue}--chart-holder`, !0).attr("data-carbon-theme", i);\n  }\n  getHolder() {\n    return this.model.get("holder");\n  }\n  exportToJPG() {\n    const t = this, n = this.model.getOptions(), r = this.getHolder(), i = I(r);\n    i.classed("filled", !0), I2(this.getMainContainer(), {\n      quality: 1,\n      // Remove toolbar\n      filter: (s) => !(s.classList && s.classList.contains("cds--cc--toolbar"))\n    }).then(function(s) {\n      var a;\n      let o = "myChart";\n      const l = y(n, "fileDownload", "fileName");\n      typeof l == "function" ? o = l("jpg") : typeof l == "string" && (o = l), (a = t.services.files) == null || a.downloadImage(s, `${o}.jpg`), i.classed("filled", !1);\n    });\n  }\n  exportToPNG() {\n    const t = this, n = this.model.getOptions(), r = this.getHolder(), i = I(r);\n    i.classed("filled", !0), R2(this.getMainContainer(), {\n      quality: 1,\n      // Remove toolbar\n      filter: (s) => !(s.classList && s.classList.contains("cds--cc--toolbar"))\n    }).then(function(s) {\n      var a;\n      let o = "myChart";\n      const l = y(n, "fileDownload", "fileName");\n      typeof l == "function" ? o = l("png") : typeof l == "string" && (o = l), (a = t.services.files) == null || a.downloadImage(s, `${o}.png`), i.classed("filled", !1);\n    }).catch(function(s) {\n      console.error("oops, something went wrong!", s);\n    });\n  }\n  isFullScreenMode() {\n    return I(this.getHolder()).classed("fullscreen");\n  }\n  toggleFullscreen() {\n    const t = this.getHolder();\n    I(t).classed("fullscreen") && (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) ? document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.msExitFullscreen && document.msExitFullscreen() : t.requestFullscreen ? t.requestFullscreen() : t.webkitRequestFullscreen ? t.webkitRequestFullscreen() : t.mozRequestFullScreen ? t.mozRequestFullScreen() : t.msRequestFullscreen && t.msRequestFullscreen();\n  }\n  handleFullscreenChange() {\n    document.addEventListener("fullscreenchange", () => {\n      const t = I(this.getHolder()), n = t.classed("fullscreen");\n      t.classed("fullscreen", !n);\n    });\n  }\n  setSVGMaxHeight() {\n    if (!this.model.getOptions().height) {\n      const { height: t } = Il.getSVGElementSize(\n        I(this.mainContainer),\n        {\n          useBBox: !0\n        }\n      ), n = I(this.mainContainer).attr("class"), r = I(this.mainContainer).selectAll(`.${n} > svg`);\n      let i = 0;\n      r.nodes().forEach(function(s) {\n        i += Number(\n          Il.getSVGElementSize(I(s), {\n            useBBox: !0\n          }).height\n        );\n      }), i <= t ? I(this.mainContainer).attr("height", i) : I(this.mainContainer).attr("height", "100%");\n    }\n  }\n  getMainContainer() {\n    return this.mainContainer;\n  }\n  addHolderListeners() {\n    const t = this.getHolder();\n    t && I(t).on("mouseover", () => {\n      var n;\n      (n = this.services.events) == null || n.dispatchEvent(T.Chart.MOUSEOVER);\n    }).on("mouseout", () => {\n      var n;\n      (n = this.services.events) == null || n.dispatchEvent(T.Chart.MOUSEOUT);\n    });\n  }\n  addResizeListener() {\n    const t = this.getHolder();\n    if (!t)\n      return;\n    let n = t.clientWidth, r = t.clientHeight;\n    const i = ba(() => {\n      var s;\n      t && (Math.abs(n - t.clientWidth) > 1 || Math.abs(r - t.clientHeight) > 1) && (n = t.clientWidth, r = t.clientHeight, (s = this.services.events) == null || s.dispatchEvent(T.Chart.RESIZE));\n    }, 12.5);\n    new ResizeObserver(i).observe(t);\n  }\n}, Nl = class dg extends Dn {\n  static appendOrUpdateLinearGradient(t) {\n    let n = t.svg.select(`defs linearGradient#${t.id}`);\n    n.empty() && (n = t.svg.append("defs").append("linearGradient").attr("id", t.id).attr("x1", t.x1).attr("x2", t.x2).attr("y1", t.y1).attr("y2", t.y2)), n.selectAll("stop").remove(), n.selectAll("stop").data(t.stops).enter().append("stop").attr("offset", (r) => r.offset).style("stop-color", (r) => r.color).style("stop-opacity", (r) => r.opacity);\n  }\n  static getOffsetRatio(t) {\n    return (Math.abs(t[1]) * 100 / Math.abs(t[0] - t[1])).toFixed(2) + "%";\n  }\n  static getStops(t, n) {\n    const r = t[0] < 0 && t[1] > 0;\n    let i = [\n      {\n        offset: "0%",\n        color: n,\n        opacity: "0.6"\n      },\n      {\n        offset: "80%",\n        color: n,\n        opacity: "0"\n      }\n    ];\n    return r && (i = [\n      {\n        offset: "0%",\n        color: n,\n        opacity: "0.6"\n      },\n      {\n        offset: dg.getOffsetRatio(t),\n        color: n,\n        opacity: "0"\n      },\n      {\n        offset: "100%",\n        color: n,\n        opacity: "0.6"\n      }\n    ]), i;\n  }\n};\nfunction pd(e) {\n  const t = P2(pg(e), 360);\n  return Nn(t, [0, 10]) || Nn(t, [350, 0]) ? {\n    textAnchor: dn.START,\n    dominantBaseline: pn.MIDDLE\n  } : Nn(t, [10, 80]) ? {\n    textAnchor: dn.START,\n    dominantBaseline: pn.HANGING\n  } : Nn(t, [80, 100]) ? {\n    textAnchor: dn.MIDDLE,\n    dominantBaseline: pn.HANGING\n  } : Nn(t, [100, 170]) ? {\n    textAnchor: dn.END,\n    dominantBaseline: pn.HANGING\n  } : Nn(t, [170, 190]) ? {\n    textAnchor: dn.END,\n    dominantBaseline: pn.MIDDLE\n  } : Nn(t, [190, 260]) ? {\n    textAnchor: dn.END,\n    dominantBaseline: pn.BASELINE\n  } : Nn(t, [260, 280]) ? {\n    textAnchor: dn.MIDDLE,\n    dominantBaseline: pn.BASELINE\n  } : {\n    textAnchor: dn.START,\n    dominantBaseline: pn.BASELINE\n  };\n}\nfunction P2(e, t) {\n  return (e % t + t) % t;\n}\nfunction Nn(e, [t, n]) {\n  return e >= t && e <= n;\n}\nfunction pg(e) {\n  return e * (180 / Math.PI);\n}\nfunction Ut(e, t, n = { x: 0, y: 0 }) {\n  const r = t * Math.cos(e) + n.x, i = t * Math.sin(e) + n.y;\n  return { x: isNaN(r) ? 0 : r, y: isNaN(i) ? 0 : i };\n}\nfunction U2(e, t) {\n  return t * Math.sin(e - Math.PI / 2);\n}\nfunction B2(e, t, n, r) {\n  for (var i = -1, s = e == null ? 0 : e.length; ++i < s; )\n    n = t(n, e[i], i, e);\n  return n;\n}\nfunction H2(e) {\n  return function(t) {\n    return e == null ? void 0 : e[t];\n  };\n}\nvar V2 = {\n  // Latin-1 Supplement block.\n  : "A",\n  : "A",\n  : "A",\n  : "A",\n  : "A",\n  : "A",\n  : "a",\n  : "a",\n  : "a",\n  : "a",\n  : "a",\n  : "a",\n  : "C",\n  : "c",\n  : "D",\n  : "d",\n  : "E",\n  : "E",\n  : "E",\n  : "E",\n  : "e",\n  : "e",\n  : "e",\n  : "e",\n  : "I",\n  : "I",\n  : "I",\n  : "I",\n  : "i",\n  : "i",\n  : "i",\n  : "i",\n  : "N",\n  : "n",\n  : "O",\n  : "O",\n  : "O",\n  : "O",\n  : "O",\n  : "O",\n  : "o",\n  : "o",\n  : "o",\n  : "o",\n  : "o",\n  : "o",\n  : "U",\n  : "U",\n  : "U",\n  : "U",\n  : "u",\n  : "u",\n  : "u",\n  : "u",\n  : "Y",\n  : "y",\n  : "y",\n  : "Ae",\n  : "ae",\n  : "Th",\n  : "th",\n  : "ss",\n  // Latin Extended-A block.\n  : "A",\n  : "A",\n  : "A",\n  : "a",\n  : "a",\n  : "a",\n  : "C",\n  : "C",\n  : "C",\n  : "C",\n  : "c",\n  : "c",\n  : "c",\n  : "c",\n  : "D",\n  : "D",\n  : "d",\n  : "d",\n  : "E",\n  : "E",\n  : "E",\n  : "E",\n  : "E",\n  : "e",\n  : "e",\n  : "e",\n  : "e",\n  : "e",\n  : "G",\n  : "G",\n  : "G",\n  : "G",\n  : "g",\n  : "g",\n  : "g",\n  : "g",\n  : "H",\n  : "H",\n  : "h",\n  : "h",\n  : "I",\n  : "I",\n  : "I",\n  : "I",\n  : "I",\n  : "i",\n  : "i",\n  : "i",\n  : "i",\n  : "i",\n  : "J",\n  : "j",\n  : "K",\n  : "k",\n  : "k",\n  : "L",\n  : "L",\n  : "L",\n  : "L",\n  : "L",\n  : "l",\n  : "l",\n  : "l",\n  : "l",\n  : "l",\n  : "N",\n  : "N",\n  : "N",\n  : "N",\n  : "n",\n  : "n",\n  : "n",\n  : "n",\n  : "O",\n  : "O",\n  : "O",\n  : "o",\n  : "o",\n  : "o",\n  : "R",\n  : "R",\n  : "R",\n  : "r",\n  : "r",\n  : "r",\n  : "S",\n  : "S",\n  : "S",\n  : "S",\n  : "s",\n  : "s",\n  : "s",\n  : "s",\n  : "T",\n  : "T",\n  : "T",\n  : "t",\n  : "t",\n  : "t",\n  : "U",\n  : "U",\n  : "U",\n  : "U",\n  : "U",\n  : "U",\n  : "u",\n  : "u",\n  : "u",\n  : "u",\n  : "u",\n  : "u",\n  : "W",\n  : "w",\n  : "Y",\n  : "y",\n  : "Y",\n  : "Z",\n  : "Z",\n  : "Z",\n  : "z",\n  : "z",\n  : "z",\n  : "IJ",\n  : "ij",\n  : "Oe",\n  : "oe",\n  : "\'n",\n  : "s"\n}, G2 = H2(V2), z2 = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g, F2 = "\\\\u0300-\\\\u036f", j2 = "\\\\ufe20-\\\\ufe2f", W2 = "\\\\u20d0-\\\\u20ff", q2 = F2 + j2 + W2, Y2 = "[" + q2 + "]", X2 = RegExp(Y2, "g");\nfunction Z2(e) {\n  return e = us(e), e && e.replace(z2, G2).replace(X2, "");\n}\nvar K2 = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\nfunction Q2(e) {\n  return e.match(K2) || [];\n}\nvar J2 = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\nfunction tC(e) {\n  return J2.test(e);\n}\nvar fg = "\\\\ud800-\\\\udfff", eC = "\\\\u0300-\\\\u036f", nC = "\\\\ufe20-\\\\ufe2f", rC = "\\\\u20d0-\\\\u20ff", iC = eC + nC + rC, mg = "\\\\u2700-\\\\u27bf", gg = "a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff", sC = "\\\\xac\\\\xb1\\\\xd7\\\\xf7", aC = "\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf", oC = "\\\\u2000-\\\\u206f", lC = " \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000", vg = "A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde", cC = "\\\\ufe0e\\\\ufe0f", yg = sC + aC + oC + lC, xg = "[\']", fd = "[" + yg + "]", uC = "[" + iC + "]", bg = "\\\\d+", hC = "[" + mg + "]", _g = "[" + gg + "]", Eg = "[^" + fg + yg + bg + mg + gg + vg + "]", dC = "\\\\ud83c[\\\\udffb-\\\\udfff]", pC = "(?:" + uC + "|" + dC + ")", fC = "[^" + fg + "]", Og = "(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}", Sg = "[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]", Ar = "[" + vg + "]", mC = "\\\\u200d", md = "(?:" + _g + "|" + Eg + ")", gC = "(?:" + Ar + "|" + Eg + ")", gd = "(?:" + xg + "(?:d|ll|m|re|s|t|ve))?", vd = "(?:" + xg + "(?:D|LL|M|RE|S|T|VE))?", Tg = pC + "?", wg = "[" + cC + "]?", vC = "(?:" + mC + "(?:" + [fC, Og, Sg].join("|") + ")" + wg + Tg + ")*", yC = "\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])", xC = "\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])", bC = wg + Tg + vC, _C = "(?:" + [hC, Og, Sg].join("|") + ")" + bC, EC = RegExp([\n  Ar + "?" + _g + "+" + gd + "(?=" + [fd, Ar, "$"].join("|") + ")",\n  gC + "+" + vd + "(?=" + [fd, Ar + md, "$"].join("|") + ")",\n  Ar + "?" + md + "+" + gd,\n  Ar + "+" + vd,\n  xC,\n  yC,\n  bg,\n  _C\n].join("|"), "g");\nfunction OC(e) {\n  return e.match(EC) || [];\n}\nfunction SC(e, t, n) {\n  return e = us(e), t = t, t === void 0 ? tC(e) ? OC(e) : Q2(e) : e.match(t) || [];\n}\nvar TC = "[\']", wC = RegExp(TC, "g");\nfunction $g(e) {\n  return function(t) {\n    return B2(SC(Z2(t).replace(wC, "")), e, "");\n  };\n}\nfunction $C(e, t, n) {\n  return e === e && (n !== void 0 && (e = e <= n ? e : n), t !== void 0 && (e = e >= t ? e : t)), e;\n}\nfunction Mg(e, t, n) {\n  return n === void 0 && (n = t, t = void 0), n !== void 0 && (n = zr(n), n = n === n ? n : 0), t !== void 0 && (t = zr(t), t = t === t ? t : 0), $C(zr(e), t, n);\n}\nvar MC = "Expected a function";\nfunction CC(e, t, n) {\n  if (typeof e != "function")\n    throw new TypeError(MC);\n  return setTimeout(function() {\n    e.apply(void 0, n);\n  }, t);\n}\nvar AC = yc(function(e, t, n) {\n  return CC(e, zr(t) || 0, n);\n});\nfunction LC(e, t) {\n  var n = -1, r = fr(e) ? Array(e.length) : [];\n  return jc(e, function(i, s, a) {\n    r[++n] = t(i, s, a);\n  }), r;\n}\nfunction kC(e, t) {\n  var n = Kt(e) ? fc : LC;\n  return n(e, Ja(t));\n}\nvar DC = 1 / 0;\nfunction RC(e, t) {\n  return Ka(kC(e, t), DC);\n}\nfunction Cg(e, t) {\n  return Qa(e, t);\n}\nvar Tr = $g(function(e, t, n) {\n  return e + (n ? "-" : "") + t.toLowerCase();\n});\nfunction IC(e, t) {\n  var n;\n  return jc(e, function(r, i, s) {\n    return n = t(r, i, s), !n;\n  }), !!n;\n}\nfunction NC(e, t, n) {\n  var r = Kt(e) ? Bf : IC;\n  return r(e, Ja(t));\n}\nclass or {\n  constructor() {\n    this._partials = new Float64Array(32), this._n = 0;\n  }\n  add(t) {\n    const n = this._partials;\n    let r = 0;\n    for (let i = 0; i < this._n && i < 32; i++) {\n      const s = n[i], a = t + s, o = Math.abs(t) < Math.abs(s) ? t - (a - s) : s - (a - t);\n      o && (n[r++] = o), t = a;\n    }\n    return n[r] = t, this._n = r + 1, this;\n  }\n  valueOf() {\n    const t = this._partials;\n    let n = this._n, r, i, s, a = 0;\n    if (n > 0) {\n      for (a = t[--n]; n > 0 && (r = a, i = t[--n], a = r + i, s = i - (a - r), !s); )\n        ;\n      n > 0 && (s < 0 && t[n - 1] < 0 || s > 0 && t[n - 1] > 0) && (i = s * 2, r = a + i, i == r - a && (a = r));\n    }\n    return a;\n  }\n}\nfunction* PC(e) {\n  for (const t of e)\n    yield* t;\n}\nfunction Ag(e) {\n  return Array.from(PC(e));\n}\nfunction UC(e) {\n  return e;\n}\nvar Qs = 1, Js = 2, Pl = 3, Ci = 4, yd = 1e-6;\nfunction BC(e) {\n  return "translate(" + e + ",0)";\n}\nfunction HC(e) {\n  return "translate(0," + e + ")";\n}\nfunction VC(e) {\n  return (t) => +e(t);\n}\nfunction GC(e, t) {\n  return t = Math.max(0, e.bandwidth() - t * 2) / 2, e.round() && (t = Math.round(t)), (n) => +e(n) + t;\n}\nfunction zC() {\n  return !this.__axis;\n}\nfunction co(e, t) {\n  var n = [], r = null, i = null, s = 6, a = 6, o = 3, l = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : 0.5, c = e === Qs || e === Ci ? -1 : 1, u = e === Ci || e === Js ? "x" : "y", d = e === Qs || e === Pl ? BC : HC;\n  function h(p) {\n    var f = r ?? (t.ticks ? t.ticks.apply(t, n) : t.domain()), g = i ?? (t.tickFormat ? t.tickFormat.apply(t, n) : UC), m = Math.max(s, 0) + o, v = t.range(), x = +v[0] + l, _ = +v[v.length - 1] + l, E = (t.bandwidth ? GC : VC)(t.copy(), l), b = p.selection ? p.selection() : p, S = b.selectAll(".domain").data([null]), M = b.selectAll(".tick").data(f, t).order(), D = M.exit(), A = M.enter().append("g").attr("class", "tick"), R = M.select("line"), $ = M.select("text");\n    S = S.merge(S.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), M = M.merge(A), R = R.merge(A.append("line").attr("stroke", "currentColor").attr(u + "2", c * s)), $ = $.merge(A.append("text").attr("fill", "currentColor").attr(u, c * m).attr("dy", e === Qs ? "0em" : e === Pl ? "0.71em" : "0.32em")), p !== b && (S = S.transition(p), M = M.transition(p), R = R.transition(p), $ = $.transition(p), D = D.transition(p).attr("opacity", yd).attr("transform", function(H) {\n      return isFinite(H = E(H)) ? d(H + l) : this.getAttribute("transform");\n    }), A.attr("opacity", yd).attr("transform", function(H) {\n      var P = this.parentNode.__axis;\n      return d((P && isFinite(P = P(H)) ? P : E(H)) + l);\n    })), D.remove(), S.attr("d", e === Ci || e === Js ? a ? "M" + c * a + "," + x + "H" + l + "V" + _ + "H" + c * a : "M" + l + "," + x + "V" + _ : a ? "M" + x + "," + c * a + "V" + l + "H" + _ + "V" + c * a : "M" + x + "," + l + "H" + _), M.attr("opacity", 1).attr("transform", function(H) {\n      return d(E(H) + l);\n    }), R.attr(u + "2", c * s), $.attr(u, c * m).text(g), b.filter(zC).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", e === Js ? "start" : e === Ci ? "end" : "middle"), b.each(function() {\n      this.__axis = E;\n    });\n  }\n  return h.scale = function(p) {\n    return arguments.length ? (t = p, h) : t;\n  }, h.ticks = function() {\n    return n = Array.from(arguments), h;\n  }, h.tickArguments = function(p) {\n    return arguments.length ? (n = p == null ? [] : Array.from(p), h) : n.slice();\n  }, h.tickValues = function(p) {\n    return arguments.length ? (r = p == null ? null : Array.from(p), h) : r && r.slice();\n  }, h.tickFormat = function(p) {\n    return arguments.length ? (i = p, h) : i;\n  }, h.tickSize = function(p) {\n    return arguments.length ? (s = a = +p, h) : s;\n  }, h.tickSizeInner = function(p) {\n    return arguments.length ? (s = +p, h) : s;\n  }, h.tickSizeOuter = function(p) {\n    return arguments.length ? (a = +p, h) : a;\n  }, h.tickPadding = function(p) {\n    return arguments.length ? (o = +p, h) : o;\n  }, h.offset = function(p) {\n    return arguments.length ? (l = +p, h) : l;\n  }, h;\n}\nfunction FC(e) {\n  return co(Qs, e);\n}\nfunction jC(e) {\n  return co(Js, e);\n}\nfunction Jc(e) {\n  return co(Pl, e);\n}\nfunction Lg(e) {\n  return co(Ci, e);\n}\nconst Ul = { capture: !0, passive: !1 };\nfunction Bl(e) {\n  e.preventDefault(), e.stopImmediatePropagation();\n}\nfunction WC(e) {\n  var t = e.document.documentElement, n = I(e).on("dragstart.drag", Bl, Ul);\n  "onselectstart" in t ? n.on("selectstart.drag", Bl, Ul) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");\n}\nfunction qC(e, t) {\n  var n = e.document.documentElement, r = I(e).on("dragstart.drag", null);\n  t && (r.on("click.drag", Bl, Ul), setTimeout(function() {\n    r.on("click.drag", null);\n  }, 0)), "onselectstart" in n ? r.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);\n}\nfunction YC(e, t) {\n  for (var n = new Array(t), r = 0; r < t; ++r) n[r] = e(r / (t - 1));\n  return n;\n}\nconst XC = (e) => +e, Fo = (e) => () => e;\nfunction ZC(e, {\n  sourceEvent: t,\n  target: n,\n  selection: r,\n  mode: i,\n  dispatch: s\n}) {\n  Object.defineProperties(this, {\n    type: { value: e, enumerable: !0, configurable: !0 },\n    sourceEvent: { value: t, enumerable: !0, configurable: !0 },\n    target: { value: n, enumerable: !0, configurable: !0 },\n    selection: { value: r, enumerable: !0, configurable: !0 },\n    mode: { value: i, enumerable: !0, configurable: !0 },\n    _: { value: s }\n  });\n}\nfunction KC(e) {\n  e.stopImmediatePropagation();\n}\nfunction jo(e) {\n  e.preventDefault(), e.stopImmediatePropagation();\n}\nvar xd = { name: "drag" }, Wo = { name: "space" }, wr = { name: "handle" }, $r = { name: "center" };\nconst { abs: bd, max: te, min: ee } = Math;\nfunction _d(e) {\n  return [+e[0], +e[1]];\n}\nfunction Ed(e) {\n  return [_d(e[0]), _d(e[1])];\n}\nvar ta = {\n  name: "x",\n  handles: ["w", "e"].map(Hl),\n  input: function(e, t) {\n    return e == null ? null : [[+e[0], t[0][1]], [+e[1], t[1][1]]];\n  },\n  output: function(e) {\n    return e && [e[0][0], e[1][0]];\n  }\n}, qo = {}, hn = {\n  overlay: "crosshair",\n  selection: "move",\n  n: "ns-resize",\n  e: "ew-resize",\n  s: "ns-resize",\n  w: "ew-resize",\n  nw: "nwse-resize",\n  ne: "nesw-resize",\n  se: "nwse-resize",\n  sw: "nesw-resize"\n}, Od = {\n  e: "w",\n  w: "e",\n  nw: "ne",\n  ne: "nw",\n  se: "sw",\n  sw: "se"\n}, Sd = {\n  n: "s",\n  s: "n",\n  nw: "sw",\n  ne: "se",\n  se: "ne",\n  sw: "nw"\n}, QC = {\n  overlay: 1,\n  selection: 1,\n  n: null,\n  e: 1,\n  s: null,\n  w: -1,\n  nw: -1,\n  ne: 1,\n  se: 1,\n  sw: -1\n}, JC = {\n  overlay: 1,\n  selection: 1,\n  n: -1,\n  e: null,\n  s: 1,\n  w: null,\n  nw: -1,\n  ne: -1,\n  se: 1,\n  sw: 1\n};\nfunction Hl(e) {\n  return { type: e };\n}\nfunction tA(e) {\n  return !e.ctrlKey && !e.button;\n}\nfunction eA() {\n  var e = this.ownerSVGElement || this;\n  return e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];\n}\nfunction nA() {\n  return navigator.maxTouchPoints || "ontouchstart" in this;\n}\nfunction Yo(e) {\n  for (; !e.__brush; ) if (!(e = e.parentNode)) return;\n  return e.__brush;\n}\nfunction rA(e) {\n  return e[0][0] === e[1][0] || e[0][1] === e[1][1];\n}\nfunction kg() {\n  return iA(ta);\n}\nfunction iA(e) {\n  var t = eA, n = tA, r = nA, i = !0, s = Lc("start", "brush", "end"), a = 6, o;\n  function l(m) {\n    var v = m.property("__brush", g).selectAll(".overlay").data([Hl("overlay")]);\n    v.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", hn.overlay).merge(v).each(function() {\n      var _ = Yo(this).extent;\n      I(this).attr("x", _[0][0]).attr("y", _[0][1]).attr("width", _[1][0] - _[0][0]).attr("height", _[1][1] - _[0][1]);\n    }), m.selectAll(".selection").data([Hl("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", hn.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");\n    var x = m.selectAll(".handle").data(e.handles, function(_) {\n      return _.type;\n    });\n    x.exit().remove(), x.enter().append("rect").attr("class", function(_) {\n      return "handle handle--" + _.type;\n    }).attr("cursor", function(_) {\n      return hn[_.type];\n    }), m.each(c).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", h).filter(r).on("touchstart.brush", h).on("touchmove.brush", p).on("touchend.brush touchcancel.brush", f).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");\n  }\n  l.move = function(m, v, x) {\n    m.tween ? m.on("start.brush", function(_) {\n      u(this, arguments).beforestart().start(_);\n    }).on("interrupt.brush end.brush", function(_) {\n      u(this, arguments).end(_);\n    }).tween("brush", function() {\n      var _ = this, E = _.__brush, b = u(_, arguments), S = E.selection, M = e.input(typeof v == "function" ? v.apply(this, arguments) : v, E.extent), D = fs(S, M);\n      function A(R) {\n        E.selection = R === 1 && M === null ? null : D(R), c.call(_), b.brush();\n      }\n      return S !== null && M !== null ? A : A(1);\n    }) : m.each(function() {\n      var _ = this, E = arguments, b = _.__brush, S = e.input(typeof v == "function" ? v.apply(_, E) : v, b.extent), M = u(_, E).beforestart();\n      Cl(_), b.selection = S === null ? null : S, c.call(_), M.start(x).brush(x).end(x);\n    });\n  }, l.clear = function(m, v) {\n    l.move(m, null, v);\n  };\n  function c() {\n    var m = I(this), v = Yo(this).selection;\n    v ? (m.selectAll(".selection").style("display", null).attr("x", v[0][0]).attr("y", v[0][1]).attr("width", v[1][0] - v[0][0]).attr("height", v[1][1] - v[0][1]), m.selectAll(".handle").style("display", null).attr("x", function(x) {\n      return x.type[x.type.length - 1] === "e" ? v[1][0] - a / 2 : v[0][0] - a / 2;\n    }).attr("y", function(x) {\n      return x.type[0] === "s" ? v[1][1] - a / 2 : v[0][1] - a / 2;\n    }).attr("width", function(x) {\n      return x.type === "n" || x.type === "s" ? v[1][0] - v[0][0] + a : a;\n    }).attr("height", function(x) {\n      return x.type === "e" || x.type === "w" ? v[1][1] - v[0][1] + a : a;\n    })) : m.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);\n  }\n  function u(m, v, x) {\n    var _ = m.__brush.emitter;\n    return _ && (!x || !_.clean) ? _ : new d(m, v, x);\n  }\n  function d(m, v, x) {\n    this.that = m, this.args = v, this.state = m.__brush, this.active = 0, this.clean = x;\n  }\n  d.prototype = {\n    beforestart: function() {\n      return ++this.active === 1 && (this.state.emitter = this, this.starting = !0), this;\n    },\n    start: function(m, v) {\n      return this.starting ? (this.starting = !1, this.emit("start", m, v)) : this.emit("brush", m), this;\n    },\n    brush: function(m, v) {\n      return this.emit("brush", m, v), this;\n    },\n    end: function(m, v) {\n      return --this.active === 0 && (delete this.state.emitter, this.emit("end", m, v)), this;\n    },\n    emit: function(m, v, x) {\n      var _ = I(this.that).datum();\n      s.call(\n        m,\n        this.that,\n        new ZC(m, {\n          sourceEvent: v,\n          target: l,\n          selection: e.output(this.state.selection),\n          mode: x,\n          dispatch: s\n        }),\n        _\n      );\n    }\n  };\n  function h(m) {\n    if (o && !m.touches || !n.apply(this, arguments)) return;\n    var v = this, x = m.target.__data__.type, _ = (i && m.metaKey ? x = "overlay" : x) === "selection" ? xd : i && m.altKey ? $r : wr, E = e === qo ? null : QC[x], b = e === ta ? null : JC[x], S = Yo(v), M = S.extent, D = S.selection, A = M[0][0], R, $, H = M[0][1], P, B, O = M[1][0], w, L, k = M[1][1], U, Z, j = 0, F = 0, Y, ot = E && b && i && m.shiftKey, Q, q, tt = Array.from(m.touches || [m], (nt) => {\n      const yt = nt.identifier;\n      return nt = rr(nt, v), nt.point0 = nt.slice(), nt.identifier = yt, nt;\n    });\n    Cl(v);\n    var lt = u(v, arguments, !0).beforestart();\n    if (x === "overlay") {\n      D && (Y = !0);\n      const nt = [tt[0], tt[1] || tt[0]];\n      S.selection = D = [[\n        R = e === qo ? A : ee(nt[0][0], nt[1][0]),\n        P = e === ta ? H : ee(nt[0][1], nt[1][1])\n      ], [\n        w = e === qo ? O : te(nt[0][0], nt[1][0]),\n        U = e === ta ? k : te(nt[0][1], nt[1][1])\n      ]], tt.length > 1 && ut(m);\n    } else\n      R = D[0][0], P = D[0][1], w = D[1][0], U = D[1][1];\n    $ = R, B = P, L = w, Z = U;\n    var z = I(v).attr("pointer-events", "none"), W = z.selectAll(".overlay").attr("cursor", hn[x]);\n    if (m.touches)\n      lt.moved = V, lt.ended = st;\n    else {\n      var X = I(m.view).on("mousemove.brush", V, !0).on("mouseup.brush", st, !0);\n      i && X.on("keydown.brush", Dt, !0).on("keyup.brush", Nt, !0), WC(m.view);\n    }\n    c.call(v), lt.start(m, _.name);\n    function V(nt) {\n      for (const yt of nt.changedTouches || [nt])\n        for (const Se of tt)\n          Se.identifier === yt.identifier && (Se.cur = rr(yt, v));\n      if (ot && !Q && !q && tt.length === 1) {\n        const yt = tt[0];\n        bd(yt.cur[0] - yt[0]) > bd(yt.cur[1] - yt[1]) ? q = !0 : Q = !0;\n      }\n      for (const yt of tt)\n        yt.cur && (yt[0] = yt.cur[0], yt[1] = yt.cur[1]);\n      Y = !0, jo(nt), ut(nt);\n    }\n    function ut(nt) {\n      const yt = tt[0], Se = yt.point0;\n      var ge;\n      switch (j = yt[0] - Se[0], F = yt[1] - Se[1], _) {\n        case Wo:\n        case xd: {\n          E && (j = te(A - R, ee(O - w, j)), $ = R + j, L = w + j), b && (F = te(H - P, ee(k - U, F)), B = P + F, Z = U + F);\n          break;\n        }\n        case wr: {\n          tt[1] ? (E && ($ = te(A, ee(O, tt[0][0])), L = te(A, ee(O, tt[1][0])), E = 1), b && (B = te(H, ee(k, tt[0][1])), Z = te(H, ee(k, tt[1][1])), b = 1)) : (E < 0 ? (j = te(A - R, ee(O - R, j)), $ = R + j, L = w) : E > 0 && (j = te(A - w, ee(O - w, j)), $ = R, L = w + j), b < 0 ? (F = te(H - P, ee(k - P, F)), B = P + F, Z = U) : b > 0 && (F = te(H - U, ee(k - U, F)), B = P, Z = U + F));\n          break;\n        }\n        case $r: {\n          E && ($ = te(A, ee(O, R - j * E)), L = te(A, ee(O, w + j * E))), b && (B = te(H, ee(k, P - F * b)), Z = te(H, ee(k, U + F * b)));\n          break;\n        }\n      }\n      L < $ && (E *= -1, ge = R, R = w, w = ge, ge = $, $ = L, L = ge, x in Od && W.attr("cursor", hn[x = Od[x]])), Z < B && (b *= -1, ge = P, P = U, U = ge, ge = B, B = Z, Z = ge, x in Sd && W.attr("cursor", hn[x = Sd[x]])), S.selection && (D = S.selection), Q && ($ = D[0][0], L = D[1][0]), q && (B = D[0][1], Z = D[1][1]), (D[0][0] !== $ || D[0][1] !== B || D[1][0] !== L || D[1][1] !== Z) && (S.selection = [[$, B], [L, Z]], c.call(v), lt.brush(nt, _.name));\n    }\n    function st(nt) {\n      if (KC(nt), nt.touches) {\n        if (nt.touches.length) return;\n        o && clearTimeout(o), o = setTimeout(function() {\n          o = null;\n        }, 500);\n      } else\n        qC(nt.view, Y), X.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);\n      z.attr("pointer-events", "all"), W.attr("cursor", hn.overlay), S.selection && (D = S.selection), rA(D) && (S.selection = null, c.call(v)), lt.end(nt, _.name);\n    }\n    function Dt(nt) {\n      switch (nt.keyCode) {\n        case 16: {\n          ot = E && b;\n          break;\n        }\n        case 18: {\n          _ === wr && (E && (w = L - j * E, R = $ + j * E), b && (U = Z - F * b, P = B + F * b), _ = $r, ut(nt));\n          break;\n        }\n        case 32: {\n          (_ === wr || _ === $r) && (E < 0 ? w = L - j : E > 0 && (R = $ - j), b < 0 ? U = Z - F : b > 0 && (P = B - F), _ = Wo, W.attr("cursor", hn.selection), ut(nt));\n          break;\n        }\n        default:\n          return;\n      }\n      jo(nt);\n    }\n    function Nt(nt) {\n      switch (nt.keyCode) {\n        case 16: {\n          ot && (Q = q = ot = !1, ut(nt));\n          break;\n        }\n        case 18: {\n          _ === $r && (E < 0 ? w = L : E > 0 && (R = $), b < 0 ? U = Z : b > 0 && (P = B), _ = wr, ut(nt));\n          break;\n        }\n        case 32: {\n          _ === Wo && (nt.altKey ? (E && (w = L - j * E, R = $ + j * E), b && (U = Z - F * b, P = B + F * b), _ = $r) : (E < 0 ? w = L : E > 0 && (R = $), b < 0 ? U = Z : b > 0 && (P = B), _ = wr), W.attr("cursor", hn[x]), ut(nt));\n          break;\n        }\n        default:\n          return;\n      }\n      jo(nt);\n    }\n  }\n  function p(m) {\n    u(this, arguments).moved(m);\n  }\n  function f(m) {\n    u(this, arguments).ended(m);\n  }\n  function g() {\n    var m = this.__brush || { selection: null };\n    return m.extent = Ed(t.apply(this, arguments)), m.dim = e, m;\n  }\n  return l.extent = function(m) {\n    return arguments.length ? (t = typeof m == "function" ? m : Fo(Ed(m)), l) : t;\n  }, l.filter = function(m) {\n    return arguments.length ? (n = typeof m == "function" ? m : Fo(!!m), l) : n;\n  }, l.touchable = function(m) {\n    return arguments.length ? (r = typeof m == "function" ? m : Fo(!!m), l) : r;\n  }, l.handleSize = function(m) {\n    return arguments.length ? (a = +m, l) : a;\n  }, l.keyModifiers = function(m) {\n    return arguments.length ? (i = !!m, l) : i;\n  }, l.on = function() {\n    var m = s.on.apply(s, arguments);\n    return m === s ? l : m;\n  }, l;\n}\nconst Vl = Math.PI, Gl = 2 * Vl, Xn = 1e-6, sA = Gl - Xn;\nfunction Dg(e) {\n  this._ += e[0];\n  for (let t = 1, n = e.length; t < n; ++t)\n    this._ += arguments[t] + e[t];\n}\nfunction aA(e) {\n  let t = Math.floor(e);\n  if (!(t >= 0)) throw new Error(`invalid digits: ${e}`);\n  if (t > 15) return Dg;\n  const n = 10 ** t;\n  return function(r) {\n    this._ += r[0];\n    for (let i = 1, s = r.length; i < s; ++i)\n      this._ += Math.round(arguments[i] * n) / n + r[i];\n  };\n}\nlet tu = class {\n  constructor(t) {\n    this._x0 = this._y0 = // start of current subpath\n    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? Dg : aA(t);\n  }\n  moveTo(t, n) {\n    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;\n  }\n  closePath() {\n    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);\n  }\n  lineTo(t, n) {\n    this._append`L${this._x1 = +t},${this._y1 = +n}`;\n  }\n  quadraticCurveTo(t, n, r, i) {\n    this._append`Q${+t},${+n},${this._x1 = +r},${this._y1 = +i}`;\n  }\n  bezierCurveTo(t, n, r, i, s, a) {\n    this._append`C${+t},${+n},${+r},${+i},${this._x1 = +s},${this._y1 = +a}`;\n  }\n  arcTo(t, n, r, i, s) {\n    if (t = +t, n = +n, r = +r, i = +i, s = +s, s < 0) throw new Error(`negative radius: ${s}`);\n    let a = this._x1, o = this._y1, l = r - t, c = i - n, u = a - t, d = o - n, h = u * u + d * d;\n    if (this._x1 === null)\n      this._append`M${this._x1 = t},${this._y1 = n}`;\n    else if (h > Xn) if (!(Math.abs(d * l - c * u) > Xn) || !s)\n      this._append`L${this._x1 = t},${this._y1 = n}`;\n    else {\n      let p = r - a, f = i - o, g = l * l + c * c, m = p * p + f * f, v = Math.sqrt(g), x = Math.sqrt(h), _ = s * Math.tan((Vl - Math.acos((g + h - m) / (2 * v * x))) / 2), E = _ / x, b = _ / v;\n      Math.abs(E - 1) > Xn && this._append`L${t + E * u},${n + E * d}`, this._append`A${s},${s},0,0,${+(d * p > u * f)},${this._x1 = t + b * l},${this._y1 = n + b * c}`;\n    }\n  }\n  arc(t, n, r, i, s, a) {\n    if (t = +t, n = +n, r = +r, a = !!a, r < 0) throw new Error(`negative radius: ${r}`);\n    let o = r * Math.cos(i), l = r * Math.sin(i), c = t + o, u = n + l, d = 1 ^ a, h = a ? i - s : s - i;\n    this._x1 === null ? this._append`M${c},${u}` : (Math.abs(this._x1 - c) > Xn || Math.abs(this._y1 - u) > Xn) && this._append`L${c},${u}`, r && (h < 0 && (h = h % Gl + Gl), h > sA ? this._append`A${r},${r},0,1,${d},${t - o},${n - l}A${r},${r},0,1,${d},${this._x1 = c},${this._y1 = u}` : h > Xn && this._append`A${r},${r},0,${+(h >= Vl)},${d},${this._x1 = t + r * Math.cos(s)},${this._y1 = n + r * Math.sin(s)}`);\n  }\n  rect(t, n, r, i) {\n    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${r = +r}v${+i}h${-r}Z`;\n  }\n  toString() {\n    return this._;\n  }\n};\nfunction Rg() {\n  return new tu();\n}\nRg.prototype = tu.prototype;\nvar Tt = 1e-6, oA = 1e-12, ft = Math.PI, de = ft / 2, Td = ft / 4, Ee = ft * 2, se = 180 / ft, Bt = ft / 180, Ot = Math.abs, Ig = Math.atan, lr = Math.atan2, St = Math.cos, lA = Math.exp, cA = Math.log, xt = Math.sin, Un = Math.sign || function(e) {\n  return e > 0 ? 1 : e < 0 ? -1 : 0;\n}, je = Math.sqrt, uA = Math.tan;\nfunction hA(e) {\n  return e > 1 ? 0 : e < -1 ? ft : Math.acos(e);\n}\nfunction Cn(e) {\n  return e > 1 ? de : e < -1 ? -de : Math.asin(e);\n}\nfunction Ae() {\n}\nfunction $a(e, t) {\n  e && $d.hasOwnProperty(e.type) && $d[e.type](e, t);\n}\nvar wd = {\n  Feature: function(e, t) {\n    $a(e.geometry, t);\n  },\n  FeatureCollection: function(e, t) {\n    for (var n = e.features, r = -1, i = n.length; ++r < i; ) $a(n[r].geometry, t);\n  }\n}, $d = {\n  Sphere: function(e, t) {\n    t.sphere();\n  },\n  Point: function(e, t) {\n    e = e.coordinates, t.point(e[0], e[1], e[2]);\n  },\n  MultiPoint: function(e, t) {\n    for (var n = e.coordinates, r = -1, i = n.length; ++r < i; ) e = n[r], t.point(e[0], e[1], e[2]);\n  },\n  LineString: function(e, t) {\n    zl(e.coordinates, t, 0);\n  },\n  MultiLineString: function(e, t) {\n    for (var n = e.coordinates, r = -1, i = n.length; ++r < i; ) zl(n[r], t, 0);\n  },\n  Polygon: function(e, t) {\n    Md(e.coordinates, t);\n  },\n  MultiPolygon: function(e, t) {\n    for (var n = e.coordinates, r = -1, i = n.length; ++r < i; ) Md(n[r], t);\n  },\n  GeometryCollection: function(e, t) {\n    for (var n = e.geometries, r = -1, i = n.length; ++r < i; ) $a(n[r], t);\n  }\n};\nfunction zl(e, t, n) {\n  var r = -1, i = e.length - n, s;\n  for (t.lineStart(); ++r < i; ) s = e[r], t.point(s[0], s[1], s[2]);\n  t.lineEnd();\n}\nfunction Md(e, t) {\n  var n = -1, r = e.length;\n  for (t.polygonStart(); ++n < r; ) zl(e[n], t, 1);\n  t.polygonEnd();\n}\nfunction Lr(e, t) {\n  e && wd.hasOwnProperty(e.type) ? wd[e.type](e, t) : $a(e, t);\n}\nfunction Fl(e) {\n  return [lr(e[1], e[0]), Cn(e[2])];\n}\nfunction ti(e) {\n  var t = e[0], n = e[1], r = St(n);\n  return [r * St(t), r * xt(t), xt(n)];\n}\nfunction ks(e, t) {\n  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];\n}\nfunction Ma(e, t) {\n  return [e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]];\n}\nfunction Xo(e, t) {\n  e[0] += t[0], e[1] += t[1], e[2] += t[2];\n}\nfunction Ds(e, t) {\n  return [e[0] * t, e[1] * t, e[2] * t];\n}\nfunction jl(e) {\n  var t = je(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);\n  e[0] /= t, e[1] /= t, e[2] /= t;\n}\nfunction Wl(e, t) {\n  function n(r, i) {\n    return r = e(r, i), t(r[0], r[1]);\n  }\n  return e.invert && t.invert && (n.invert = function(r, i) {\n    return r = t.invert(r, i), r && e.invert(r[0], r[1]);\n  }), n;\n}\nfunction ql(e, t) {\n  return Ot(e) > ft && (e -= Math.round(e / Ee) * Ee), [e, t];\n}\nql.invert = ql;\nfunction Ng(e, t, n) {\n  return (e %= Ee) ? t || n ? Wl(Ad(e), Ld(t, n)) : Ad(e) : t || n ? Ld(t, n) : ql;\n}\nfunction Cd(e) {\n  return function(t, n) {\n    return t += e, Ot(t) > ft && (t -= Math.round(t / Ee) * Ee), [t, n];\n  };\n}\nfunction Ad(e) {\n  var t = Cd(e);\n  return t.invert = Cd(-e), t;\n}\nfunction Ld(e, t) {\n  var n = St(e), r = xt(e), i = St(t), s = xt(t);\n  function a(o, l) {\n    var c = St(l), u = St(o) * c, d = xt(o) * c, h = xt(l), p = h * n + u * r;\n    return [\n      lr(d * i - p * s, u * n - h * r),\n      Cn(p * i + d * s)\n    ];\n  }\n  return a.invert = function(o, l) {\n    var c = St(l), u = St(o) * c, d = xt(o) * c, h = xt(l), p = h * i - d * s;\n    return [\n      lr(d * i + h * s, u * n + p * r),\n      Cn(p * n - u * r)\n    ];\n  }, a;\n}\nfunction dA(e) {\n  e = Ng(e[0] * Bt, e[1] * Bt, e.length > 2 ? e[2] * Bt : 0);\n  function t(n) {\n    return n = e(n[0] * Bt, n[1] * Bt), n[0] *= se, n[1] *= se, n;\n  }\n  return t.invert = function(n) {\n    return n = e.invert(n[0] * Bt, n[1] * Bt), n[0] *= se, n[1] *= se, n;\n  }, t;\n}\nfunction pA(e, t, n, r, i, s) {\n  if (n) {\n    var a = St(t), o = xt(t), l = r * n;\n    i == null ? (i = t + r * Ee, s = t - l / 2) : (i = kd(a, i), s = kd(a, s), (r > 0 ? i < s : i > s) && (i += r * Ee));\n    for (var c, u = i; r > 0 ? u > s : u < s; u -= l)\n      c = Fl([a, -o * St(u), -o * xt(u)]), e.point(c[0], c[1]);\n  }\n}\nfunction kd(e, t) {\n  t = ti(t), t[0] -= e, jl(t);\n  var n = hA(-t[1]);\n  return ((-t[2] < 0 ? -n : n) + Ee - Tt) % Ee;\n}\nfunction Pg() {\n  var e = [], t;\n  return {\n    point: function(n, r, i) {\n      t.push([n, r, i]);\n    },\n    lineStart: function() {\n      e.push(t = []);\n    },\n    lineEnd: Ae,\n    rejoin: function() {\n      e.length > 1 && e.push(e.pop().concat(e.shift()));\n    },\n    result: function() {\n      var n = e;\n      return e = [], t = null, n;\n    }\n  };\n}\nfunction ea(e, t) {\n  return Ot(e[0] - t[0]) < Tt && Ot(e[1] - t[1]) < Tt;\n}\nfunction Rs(e, t, n, r) {\n  this.x = e, this.z = t, this.o = n, this.e = r, this.v = !1, this.n = this.p = null;\n}\nfunction Ug(e, t, n, r, i) {\n  var s = [], a = [], o, l;\n  if (e.forEach(function(f) {\n    if (!((g = f.length - 1) <= 0)) {\n      var g, m = f[0], v = f[g], x;\n      if (ea(m, v)) {\n        if (!m[2] && !v[2]) {\n          for (i.lineStart(), o = 0; o < g; ++o) i.point((m = f[o])[0], m[1]);\n          i.lineEnd();\n          return;\n        }\n        v[0] += 2 * Tt;\n      }\n      s.push(x = new Rs(m, f, null, !0)), a.push(x.o = new Rs(m, null, x, !1)), s.push(x = new Rs(v, f, null, !1)), a.push(x.o = new Rs(v, null, x, !0));\n    }\n  }), !!s.length) {\n    for (a.sort(t), Dd(s), Dd(a), o = 0, l = a.length; o < l; ++o)\n      a[o].e = n = !n;\n    for (var c = s[0], u, d; ; ) {\n      for (var h = c, p = !0; h.v; ) if ((h = h.n) === c) return;\n      u = h.z, i.lineStart();\n      do {\n        if (h.v = h.o.v = !0, h.e) {\n          if (p)\n            for (o = 0, l = u.length; o < l; ++o) i.point((d = u[o])[0], d[1]);\n          else\n            r(h.x, h.n.x, 1, i);\n          h = h.n;\n        } else {\n          if (p)\n            for (u = h.p.z, o = u.length - 1; o >= 0; --o) i.point((d = u[o])[0], d[1]);\n          else\n            r(h.x, h.p.x, -1, i);\n          h = h.p;\n        }\n        h = h.o, u = h.z, p = !p;\n      } while (!h.v);\n      i.lineEnd();\n    }\n  }\n}\nfunction Dd(e) {\n  if (t = e.length) {\n    for (var t, n = 0, r = e[0], i; ++n < t; )\n      r.n = i = e[n], i.p = r, r = i;\n    r.n = i = e[0], i.p = r;\n  }\n}\nfunction Zo(e) {\n  return Ot(e[0]) <= ft ? e[0] : Un(e[0]) * ((Ot(e[0]) + ft) % Ee - ft);\n}\nfunction fA(e, t) {\n  var n = Zo(t), r = t[1], i = xt(r), s = [xt(n), -St(n), 0], a = 0, o = 0, l = new or();\n  i === 1 ? r = de + Tt : i === -1 && (r = -de - Tt);\n  for (var c = 0, u = e.length; c < u; ++c)\n    if (h = (d = e[c]).length)\n      for (var d, h, p = d[h - 1], f = Zo(p), g = p[1] / 2 + Td, m = xt(g), v = St(g), x = 0; x < h; ++x, f = E, m = S, v = M, p = _) {\n        var _ = d[x], E = Zo(_), b = _[1] / 2 + Td, S = xt(b), M = St(b), D = E - f, A = D >= 0 ? 1 : -1, R = A * D, $ = R > ft, H = m * S;\n        if (l.add(lr(H * A * xt(R), v * M + H * St(R))), a += $ ? D + A * Ee : D, $ ^ f >= n ^ E >= n) {\n          var P = Ma(ti(p), ti(_));\n          jl(P);\n          var B = Ma(s, P);\n          jl(B);\n          var O = ($ ^ D >= 0 ? -1 : 1) * Cn(B[2]);\n          (r > O || r === O && (P[0] || P[1])) && (o += $ ^ D >= 0 ? 1 : -1);\n        }\n      }\n  return (a < -1e-6 || a < Tt && l < -1e-12) ^ o & 1;\n}\nfunction Bg(e, t, n, r) {\n  return function(i) {\n    var s = t(i), a = Pg(), o = t(a), l = !1, c, u, d, h = {\n      point: p,\n      lineStart: g,\n      lineEnd: m,\n      polygonStart: function() {\n        h.point = v, h.lineStart = x, h.lineEnd = _, u = [], c = [];\n      },\n      polygonEnd: function() {\n        h.point = p, h.lineStart = g, h.lineEnd = m, u = Ag(u);\n        var E = fA(c, r);\n        u.length ? (l || (i.polygonStart(), l = !0), Ug(u, gA, E, n, i)) : E && (l || (i.polygonStart(), l = !0), i.lineStart(), n(null, null, 1, i), i.lineEnd()), l && (i.polygonEnd(), l = !1), u = c = null;\n      },\n      sphere: function() {\n        i.polygonStart(), i.lineStart(), n(null, null, 1, i), i.lineEnd(), i.polygonEnd();\n      }\n    };\n    function p(E, b) {\n      e(E, b) && i.point(E, b);\n    }\n    function f(E, b) {\n      s.point(E, b);\n    }\n    function g() {\n      h.point = f, s.lineStart();\n    }\n    function m() {\n      h.point = p, s.lineEnd();\n    }\n    function v(E, b) {\n      d.push([E, b]), o.point(E, b);\n    }\n    function x() {\n      o.lineStart(), d = [];\n    }\n    function _() {\n      v(d[0][0], d[0][1]), o.lineEnd();\n      var E = o.clean(), b = a.result(), S, M = b.length, D, A, R;\n      if (d.pop(), c.push(d), d = null, !!M) {\n        if (E & 1) {\n          if (A = b[0], (D = A.length - 1) > 0) {\n            for (l || (i.polygonStart(), l = !0), i.lineStart(), S = 0; S < D; ++S) i.point((R = A[S])[0], R[1]);\n            i.lineEnd();\n          }\n          return;\n        }\n        M > 1 && E & 2 && b.push(b.pop().concat(b.shift())), u.push(b.filter(mA));\n      }\n    }\n    return h;\n  };\n}\nfunction mA(e) {\n  return e.length > 1;\n}\nfunction gA(e, t) {\n  return ((e = e.x)[0] < 0 ? e[1] - de - Tt : de - e[1]) - ((t = t.x)[0] < 0 ? t[1] - de - Tt : de - t[1]);\n}\nconst Rd = Bg(\n  function() {\n    return !0;\n  },\n  vA,\n  xA,\n  [-ft, -de]\n);\nfunction vA(e) {\n  var t = NaN, n = NaN, r = NaN, i;\n  return {\n    lineStart: function() {\n      e.lineStart(), i = 1;\n    },\n    point: function(s, a) {\n      var o = s > 0 ? ft : -ft, l = Ot(s - t);\n      Ot(l - ft) < Tt ? (e.point(t, n = (n + a) / 2 > 0 ? de : -de), e.point(r, n), e.lineEnd(), e.lineStart(), e.point(o, n), e.point(s, n), i = 0) : r !== o && l >= ft && (Ot(t - r) < Tt && (t -= r * Tt), Ot(s - o) < Tt && (s -= o * Tt), n = yA(t, n, s, a), e.point(r, n), e.lineEnd(), e.lineStart(), e.point(o, n), i = 0), e.point(t = s, n = a), r = o;\n    },\n    lineEnd: function() {\n      e.lineEnd(), t = n = NaN;\n    },\n    clean: function() {\n      return 2 - i;\n    }\n  };\n}\nfunction yA(e, t, n, r) {\n  var i, s, a = xt(e - n);\n  return Ot(a) > Tt ? Ig((xt(t) * (s = St(r)) * xt(n) - xt(r) * (i = St(t)) * xt(e)) / (i * s * a)) : (t + r) / 2;\n}\nfunction xA(e, t, n, r) {\n  var i;\n  if (e == null)\n    i = n * de, r.point(-ft, i), r.point(0, i), r.point(ft, i), r.point(ft, 0), r.point(ft, -i), r.point(0, -i), r.point(-ft, -i), r.point(-ft, 0), r.point(-ft, i);\n  else if (Ot(e[0] - t[0]) > Tt) {\n    var s = e[0] < t[0] ? ft : -ft;\n    i = n * s / 2, r.point(-s, i), r.point(0, i), r.point(s, i);\n  } else\n    r.point(t[0], t[1]);\n}\nfunction bA(e) {\n  var t = St(e), n = 2 * Bt, r = t > 0, i = Ot(t) > Tt;\n  function s(u, d, h, p) {\n    pA(p, e, n, h, u, d);\n  }\n  function a(u, d) {\n    return St(u) * St(d) > t;\n  }\n  function o(u) {\n    var d, h, p, f, g;\n    return {\n      lineStart: function() {\n        f = p = !1, g = 1;\n      },\n      point: function(m, v) {\n        var x = [m, v], _, E = a(m, v), b = r ? E ? 0 : c(m, v) : E ? c(m + (m < 0 ? ft : -ft), v) : 0;\n        if (!d && (f = p = E) && u.lineStart(), E !== p && (_ = l(d, x), (!_ || ea(d, _) || ea(x, _)) && (x[2] = 1)), E !== p)\n          g = 0, E ? (u.lineStart(), _ = l(x, d), u.point(_[0], _[1])) : (_ = l(d, x), u.point(_[0], _[1], 2), u.lineEnd()), d = _;\n        else if (i && d && r ^ E) {\n          var S;\n          !(b & h) && (S = l(x, d, !0)) && (g = 0, r ? (u.lineStart(), u.point(S[0][0], S[0][1]), u.point(S[1][0], S[1][1]), u.lineEnd()) : (u.point(S[1][0], S[1][1]), u.lineEnd(), u.lineStart(), u.point(S[0][0], S[0][1], 3)));\n        }\n        E && (!d || !ea(d, x)) && u.point(x[0], x[1]), d = x, p = E, h = b;\n      },\n      lineEnd: function() {\n        p && u.lineEnd(), d = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function() {\n        return g | (f && p) << 1;\n      }\n    };\n  }\n  function l(u, d, h) {\n    var p = ti(u), f = ti(d), g = [1, 0, 0], m = Ma(p, f), v = ks(m, m), x = m[0], _ = v - x * x;\n    if (!_) return !h && u;\n    var E = t * v / _, b = -t * x / _, S = Ma(g, m), M = Ds(g, E), D = Ds(m, b);\n    Xo(M, D);\n    var A = S, R = ks(M, A), $ = ks(A, A), H = R * R - $ * (ks(M, M) - 1);\n    if (!(H < 0)) {\n      var P = je(H), B = Ds(A, (-R - P) / $);\n      if (Xo(B, M), B = Fl(B), !h) return B;\n      var O = u[0], w = d[0], L = u[1], k = d[1], U;\n      w < O && (U = O, O = w, w = U);\n      var Z = w - O, j = Ot(Z - ft) < Tt, F = j || Z < Tt;\n      if (!j && k < L && (U = L, L = k, k = U), F ? j ? L + k > 0 ^ B[1] < (Ot(B[0] - O) < Tt ? L : k) : L <= B[1] && B[1] <= k : Z > ft ^ (O <= B[0] && B[0] <= w)) {\n        var Y = Ds(A, (-R + P) / $);\n        return Xo(Y, M), [B, Fl(Y)];\n      }\n    }\n  }\n  function c(u, d) {\n    var h = r ? e : ft - e, p = 0;\n    return u < -h ? p |= 1 : u > h && (p |= 2), d < -h ? p |= 4 : d > h && (p |= 8), p;\n  }\n  return Bg(a, o, s, r ? [0, -e] : [-ft, e - ft]);\n}\nfunction _A(e, t, n, r, i, s) {\n  var a = e[0], o = e[1], l = t[0], c = t[1], u = 0, d = 1, h = l - a, p = c - o, f;\n  if (f = n - a, !(!h && f > 0)) {\n    if (f /= h, h < 0) {\n      if (f < u) return;\n      f < d && (d = f);\n    } else if (h > 0) {\n      if (f > d) return;\n      f > u && (u = f);\n    }\n    if (f = i - a, !(!h && f < 0)) {\n      if (f /= h, h < 0) {\n        if (f > d) return;\n        f > u && (u = f);\n      } else if (h > 0) {\n        if (f < u) return;\n        f < d && (d = f);\n      }\n      if (f = r - o, !(!p && f > 0)) {\n        if (f /= p, p < 0) {\n          if (f < u) return;\n          f < d && (d = f);\n        } else if (p > 0) {\n          if (f > d) return;\n          f > u && (u = f);\n        }\n        if (f = s - o, !(!p && f < 0)) {\n          if (f /= p, p < 0) {\n            if (f > d) return;\n            f > u && (u = f);\n          } else if (p > 0) {\n            if (f < u) return;\n            f < d && (d = f);\n          }\n          return u > 0 && (e[0] = a + u * h, e[1] = o + u * p), d < 1 && (t[0] = a + d * h, t[1] = o + d * p), !0;\n        }\n      }\n    }\n  }\n}\nvar Is = 1e9, Ns = -1e9;\nfunction EA(e, t, n, r) {\n  function i(c, u) {\n    return e <= c && c <= n && t <= u && u <= r;\n  }\n  function s(c, u, d, h) {\n    var p = 0, f = 0;\n    if (c == null || (p = a(c, d)) !== (f = a(u, d)) || l(c, u) < 0 ^ d > 0)\n      do\n        h.point(p === 0 || p === 3 ? e : n, p > 1 ? r : t);\n      while ((p = (p + d + 4) % 4) !== f);\n    else\n      h.point(u[0], u[1]);\n  }\n  function a(c, u) {\n    return Ot(c[0] - e) < Tt ? u > 0 ? 0 : 3 : Ot(c[0] - n) < Tt ? u > 0 ? 2 : 1 : Ot(c[1] - t) < Tt ? u > 0 ? 1 : 0 : u > 0 ? 3 : 2;\n  }\n  function o(c, u) {\n    return l(c.x, u.x);\n  }\n  function l(c, u) {\n    var d = a(c, 1), h = a(u, 1);\n    return d !== h ? d - h : d === 0 ? u[1] - c[1] : d === 1 ? c[0] - u[0] : d === 2 ? c[1] - u[1] : u[0] - c[0];\n  }\n  return function(c) {\n    var u = c, d = Pg(), h, p, f, g, m, v, x, _, E, b, S, M = {\n      point: D,\n      lineStart: H,\n      lineEnd: P,\n      polygonStart: R,\n      polygonEnd: $\n    };\n    function D(O, w) {\n      i(O, w) && u.point(O, w);\n    }\n    function A() {\n      for (var O = 0, w = 0, L = p.length; w < L; ++w)\n        for (var k = p[w], U = 1, Z = k.length, j = k[0], F, Y, ot = j[0], Q = j[1]; U < Z; ++U)\n          F = ot, Y = Q, j = k[U], ot = j[0], Q = j[1], Y <= r ? Q > r && (ot - F) * (r - Y) > (Q - Y) * (e - F) && ++O : Q <= r && (ot - F) * (r - Y) < (Q - Y) * (e - F) && --O;\n      return O;\n    }\n    function R() {\n      u = d, h = [], p = [], S = !0;\n    }\n    function $() {\n      var O = A(), w = S && O, L = (h = Ag(h)).length;\n      (w || L) && (c.polygonStart(), w && (c.lineStart(), s(null, null, 1, c), c.lineEnd()), L && Ug(h, o, O, s, c), c.polygonEnd()), u = c, h = p = f = null;\n    }\n    function H() {\n      M.point = B, p && p.push(f = []), b = !0, E = !1, x = _ = NaN;\n    }\n    function P() {\n      h && (B(g, m), v && E && d.rejoin(), h.push(d.result())), M.point = D, E && u.lineEnd();\n    }\n    function B(O, w) {\n      var L = i(O, w);\n      if (p && f.push([O, w]), b)\n        g = O, m = w, v = L, b = !1, L && (u.lineStart(), u.point(O, w));\n      else if (L && E) u.point(O, w);\n      else {\n        var k = [x = Math.max(Ns, Math.min(Is, x)), _ = Math.max(Ns, Math.min(Is, _))], U = [O = Math.max(Ns, Math.min(Is, O)), w = Math.max(Ns, Math.min(Is, w))];\n        _A(k, U, e, t, n, r) ? (E || (u.lineStart(), u.point(k[0], k[1])), u.point(U[0], U[1]), L || u.lineEnd(), S = !1) : L && (u.lineStart(), u.point(O, w), S = !1);\n      }\n      x = O, _ = w, E = L;\n    }\n    return M;\n  };\n}\nconst Yl = (e) => e;\nvar Ko = new or(), Xl = new or(), Hg, Vg, Zl, Kl, xn = {\n  point: Ae,\n  lineStart: Ae,\n  lineEnd: Ae,\n  polygonStart: function() {\n    xn.lineStart = OA, xn.lineEnd = TA;\n  },\n  polygonEnd: function() {\n    xn.lineStart = xn.lineEnd = xn.point = Ae, Ko.add(Ot(Xl)), Xl = new or();\n  },\n  result: function() {\n    var e = Ko / 2;\n    return Ko = new or(), e;\n  }\n};\nfunction OA() {\n  xn.point = SA;\n}\nfunction SA(e, t) {\n  xn.point = Gg, Hg = Zl = e, Vg = Kl = t;\n}\nfunction Gg(e, t) {\n  Xl.add(Kl * e - Zl * t), Zl = e, Kl = t;\n}\nfunction TA() {\n  Gg(Hg, Vg);\n}\nvar ei = 1 / 0, Ca = ei, rs = -ei, Aa = rs, La = {\n  point: wA,\n  lineStart: Ae,\n  lineEnd: Ae,\n  polygonStart: Ae,\n  polygonEnd: Ae,\n  result: function() {\n    var e = [[ei, Ca], [rs, Aa]];\n    return rs = Aa = -(Ca = ei = 1 / 0), e;\n  }\n};\nfunction wA(e, t) {\n  e < ei && (ei = e), e > rs && (rs = e), t < Ca && (Ca = t), t > Aa && (Aa = t);\n}\nvar Ql = 0, Jl = 0, Ai = 0, ka = 0, Da = 0, Hr = 0, tc = 0, ec = 0, Li = 0, zg, Fg, Qe, Je, Me = {\n  point: cr,\n  lineStart: Id,\n  lineEnd: Nd,\n  polygonStart: function() {\n    Me.lineStart = CA, Me.lineEnd = AA;\n  },\n  polygonEnd: function() {\n    Me.point = cr, Me.lineStart = Id, Me.lineEnd = Nd;\n  },\n  result: function() {\n    var e = Li ? [tc / Li, ec / Li] : Hr ? [ka / Hr, Da / Hr] : Ai ? [Ql / Ai, Jl / Ai] : [NaN, NaN];\n    return Ql = Jl = Ai = ka = Da = Hr = tc = ec = Li = 0, e;\n  }\n};\nfunction cr(e, t) {\n  Ql += e, Jl += t, ++Ai;\n}\nfunction Id() {\n  Me.point = $A;\n}\nfunction $A(e, t) {\n  Me.point = MA, cr(Qe = e, Je = t);\n}\nfunction MA(e, t) {\n  var n = e - Qe, r = t - Je, i = je(n * n + r * r);\n  ka += i * (Qe + e) / 2, Da += i * (Je + t) / 2, Hr += i, cr(Qe = e, Je = t);\n}\nfunction Nd() {\n  Me.point = cr;\n}\nfunction CA() {\n  Me.point = LA;\n}\nfunction AA() {\n  jg(zg, Fg);\n}\nfunction LA(e, t) {\n  Me.point = jg, cr(zg = Qe = e, Fg = Je = t);\n}\nfunction jg(e, t) {\n  var n = e - Qe, r = t - Je, i = je(n * n + r * r);\n  ka += i * (Qe + e) / 2, Da += i * (Je + t) / 2, Hr += i, i = Je * e - Qe * t, tc += i * (Qe + e), ec += i * (Je + t), Li += i * 3, cr(Qe = e, Je = t);\n}\nfunction Wg(e) {\n  this._context = e;\n}\nWg.prototype = {\n  _radius: 4.5,\n  pointRadius: function(e) {\n    return this._radius = e, this;\n  },\n  polygonStart: function() {\n    this._line = 0;\n  },\n  polygonEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    this._line === 0 && this._context.closePath(), this._point = NaN;\n  },\n  point: function(e, t) {\n    switch (this._point) {\n      case 0: {\n        this._context.moveTo(e, t), this._point = 1;\n        break;\n      }\n      case 1: {\n        this._context.lineTo(e, t);\n        break;\n      }\n      default: {\n        this._context.moveTo(e + this._radius, t), this._context.arc(e, t, this._radius, 0, Ee);\n        break;\n      }\n    }\n  },\n  result: Ae\n};\nvar nc = new or(), Qo, qg, Yg, ki, Di, is = {\n  point: Ae,\n  lineStart: function() {\n    is.point = kA;\n  },\n  lineEnd: function() {\n    Qo && Xg(qg, Yg), is.point = Ae;\n  },\n  polygonStart: function() {\n    Qo = !0;\n  },\n  polygonEnd: function() {\n    Qo = null;\n  },\n  result: function() {\n    var e = +nc;\n    return nc = new or(), e;\n  }\n};\nfunction kA(e, t) {\n  is.point = Xg, qg = ki = e, Yg = Di = t;\n}\nfunction Xg(e, t) {\n  ki -= e, Di -= t, nc.add(je(ki * ki + Di * Di)), ki = e, Di = t;\n}\nlet Pd, Ra, Ud, Bd;\nclass Hd {\n  constructor(t) {\n    this._append = t == null ? Zg : DA(t), this._radius = 4.5, this._ = "";\n  }\n  pointRadius(t) {\n    return this._radius = +t, this;\n  }\n  polygonStart() {\n    this._line = 0;\n  }\n  polygonEnd() {\n    this._line = NaN;\n  }\n  lineStart() {\n    this._point = 0;\n  }\n  lineEnd() {\n    this._line === 0 && (this._ += "Z"), this._point = NaN;\n  }\n  point(t, n) {\n    switch (this._point) {\n      case 0: {\n        this._append`M${t},${n}`, this._point = 1;\n        break;\n      }\n      case 1: {\n        this._append`L${t},${n}`;\n        break;\n      }\n      default: {\n        if (this._append`M${t},${n}`, this._radius !== Ud || this._append !== Ra) {\n          const r = this._radius, i = this._;\n          this._ = "", this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`, Ud = r, Ra = this._append, Bd = this._, this._ = i;\n        }\n        this._ += Bd;\n        break;\n      }\n    }\n  }\n  result() {\n    const t = this._;\n    return this._ = "", t.length ? t : null;\n  }\n}\nfunction Zg(e) {\n  let t = 1;\n  this._ += e[0];\n  for (const n = e.length; t < n; ++t)\n    this._ += arguments[t] + e[t];\n}\nfunction DA(e) {\n  const t = Math.floor(e);\n  if (!(t >= 0)) throw new RangeError(`invalid digits: ${e}`);\n  if (t > 15) return Zg;\n  if (t !== Pd) {\n    const n = 10 ** t;\n    Pd = t, Ra = function(r) {\n      let i = 1;\n      this._ += r[0];\n      for (const s = r.length; i < s; ++i)\n        this._ += Math.round(arguments[i] * n) / n + r[i];\n    };\n  }\n  return Ra;\n}\nfunction RA(e, t) {\n  let n = 3, r = 4.5, i, s;\n  function a(o) {\n    return o && (typeof r == "function" && s.pointRadius(+r.apply(this, arguments)), Lr(o, i(s))), s.result();\n  }\n  return a.area = function(o) {\n    return Lr(o, i(xn)), xn.result();\n  }, a.measure = function(o) {\n    return Lr(o, i(is)), is.result();\n  }, a.bounds = function(o) {\n    return Lr(o, i(La)), La.result();\n  }, a.centroid = function(o) {\n    return Lr(o, i(Me)), Me.result();\n  }, a.projection = function(o) {\n    return arguments.length ? (i = o == null ? (e = null, Yl) : (e = o).stream, a) : e;\n  }, a.context = function(o) {\n    return arguments.length ? (s = o == null ? (t = null, new Hd(n)) : new Wg(t = o), typeof r != "function" && s.pointRadius(r), a) : t;\n  }, a.pointRadius = function(o) {\n    return arguments.length ? (r = typeof o == "function" ? o : (s.pointRadius(+o), +o), a) : r;\n  }, a.digits = function(o) {\n    if (!arguments.length) return n;\n    if (o == null) n = null;\n    else {\n      const l = Math.floor(o);\n      if (!(l >= 0)) throw new RangeError(`invalid digits: ${o}`);\n      n = l;\n    }\n    return t === null && (s = new Hd(n)), a;\n  }, a.projection(e).digits(n).context(t);\n}\nfunction eu(e) {\n  return function(t) {\n    var n = new rc();\n    for (var r in e) n[r] = e[r];\n    return n.stream = t, n;\n  };\n}\nfunction rc() {\n}\nrc.prototype = {\n  constructor: rc,\n  point: function(e, t) {\n    this.stream.point(e, t);\n  },\n  sphere: function() {\n    this.stream.sphere();\n  },\n  lineStart: function() {\n    this.stream.lineStart();\n  },\n  lineEnd: function() {\n    this.stream.lineEnd();\n  },\n  polygonStart: function() {\n    this.stream.polygonStart();\n  },\n  polygonEnd: function() {\n    this.stream.polygonEnd();\n  }\n};\nfunction nu(e, t, n) {\n  var r = e.clipExtent && e.clipExtent();\n  return e.scale(150).translate([0, 0]), r != null && e.clipExtent(null), Lr(n, e.stream(La)), t(La.result()), r != null && e.clipExtent(r), e;\n}\nfunction Kg(e, t, n) {\n  return nu(e, function(r) {\n    var i = t[1][0] - t[0][0], s = t[1][1] - t[0][1], a = Math.min(i / (r[1][0] - r[0][0]), s / (r[1][1] - r[0][1])), o = +t[0][0] + (i - a * (r[1][0] + r[0][0])) / 2, l = +t[0][1] + (s - a * (r[1][1] + r[0][1])) / 2;\n    e.scale(150 * a).translate([o, l]);\n  }, n);\n}\nfunction IA(e, t, n) {\n  return Kg(e, [[0, 0], t], n);\n}\nfunction NA(e, t, n) {\n  return nu(e, function(r) {\n    var i = +t, s = i / (r[1][0] - r[0][0]), a = (i - s * (r[1][0] + r[0][0])) / 2, o = -s * r[0][1];\n    e.scale(150 * s).translate([a, o]);\n  }, n);\n}\nfunction PA(e, t, n) {\n  return nu(e, function(r) {\n    var i = +t, s = i / (r[1][1] - r[0][1]), a = -s * r[0][0], o = (i - s * (r[1][1] + r[0][1])) / 2;\n    e.scale(150 * s).translate([a, o]);\n  }, n);\n}\nvar Vd = 16, UA = St(30 * Bt);\nfunction Gd(e, t) {\n  return +t ? HA(e, t) : BA(e);\n}\nfunction BA(e) {\n  return eu({\n    point: function(t, n) {\n      t = e(t, n), this.stream.point(t[0], t[1]);\n    }\n  });\n}\nfunction HA(e, t) {\n  function n(r, i, s, a, o, l, c, u, d, h, p, f, g, m) {\n    var v = c - r, x = u - i, _ = v * v + x * x;\n    if (_ > 4 * t && g--) {\n      var E = a + h, b = o + p, S = l + f, M = je(E * E + b * b + S * S), D = Cn(S /= M), A = Ot(Ot(S) - 1) < Tt || Ot(s - d) < Tt ? (s + d) / 2 : lr(b, E), R = e(A, D), $ = R[0], H = R[1], P = $ - r, B = H - i, O = x * P - v * B;\n      (O * O / _ > t || Ot((v * P + x * B) / _ - 0.5) > 0.3 || a * h + o * p + l * f < UA) && (n(r, i, s, a, o, l, $, H, A, E /= M, b /= M, S, g, m), m.point($, H), n($, H, A, E, b, S, c, u, d, h, p, f, g, m));\n    }\n  }\n  return function(r) {\n    var i, s, a, o, l, c, u, d, h, p, f, g, m = {\n      point: v,\n      lineStart: x,\n      lineEnd: E,\n      polygonStart: function() {\n        r.polygonStart(), m.lineStart = b;\n      },\n      polygonEnd: function() {\n        r.polygonEnd(), m.lineStart = x;\n      }\n    };\n    function v(D, A) {\n      D = e(D, A), r.point(D[0], D[1]);\n    }\n    function x() {\n      d = NaN, m.point = _, r.lineStart();\n    }\n    function _(D, A) {\n      var R = ti([D, A]), $ = e(D, A);\n      n(d, h, u, p, f, g, d = $[0], h = $[1], u = D, p = R[0], f = R[1], g = R[2], Vd, r), r.point(d, h);\n    }\n    function E() {\n      m.point = v, r.lineEnd();\n    }\n    function b() {\n      x(), m.point = S, m.lineEnd = M;\n    }\n    function S(D, A) {\n      _(i = D, A), s = d, a = h, o = p, l = f, c = g, m.point = _;\n    }\n    function M() {\n      n(d, h, u, p, f, g, s, a, i, o, l, c, Vd, r), m.lineEnd = E, E();\n    }\n    return m;\n  };\n}\nvar VA = eu({\n  point: function(e, t) {\n    this.stream.point(e * Bt, t * Bt);\n  }\n});\nfunction GA(e) {\n  return eu({\n    point: function(t, n) {\n      var r = e(t, n);\n      return this.stream.point(r[0], r[1]);\n    }\n  });\n}\nfunction zA(e, t, n, r, i) {\n  function s(a, o) {\n    return a *= r, o *= i, [t + e * a, n - e * o];\n  }\n  return s.invert = function(a, o) {\n    return [(a - t) / e * r, (n - o) / e * i];\n  }, s;\n}\nfunction zd(e, t, n, r, i, s) {\n  if (!s) return zA(e, t, n, r, i);\n  var a = St(s), o = xt(s), l = a * e, c = o * e, u = a / e, d = o / e, h = (o * n - a * t) / e, p = (o * t + a * n) / e;\n  function f(g, m) {\n    return g *= r, m *= i, [l * g - c * m + t, n - c * g - l * m];\n  }\n  return f.invert = function(g, m) {\n    return [r * (u * g - d * m + h), i * (p - d * g - u * m)];\n  }, f;\n}\nfunction uo(e) {\n  return Qg(function() {\n    return e;\n  })();\n}\nfunction Qg(e) {\n  var t, n = 150, r = 480, i = 250, s = 0, a = 0, o = 0, l = 0, c = 0, u, d = 0, h = 1, p = 1, f = null, g = Rd, m = null, v, x, _, E = Yl, b = 0.5, S, M, D, A, R;\n  function $(O) {\n    return D(O[0] * Bt, O[1] * Bt);\n  }\n  function H(O) {\n    return O = D.invert(O[0], O[1]), O && [O[0] * se, O[1] * se];\n  }\n  $.stream = function(O) {\n    return A && R === O ? A : A = VA(GA(u)(g(S(E(R = O)))));\n  }, $.preclip = function(O) {\n    return arguments.length ? (g = O, f = void 0, B()) : g;\n  }, $.postclip = function(O) {\n    return arguments.length ? (E = O, m = v = x = _ = null, B()) : E;\n  }, $.clipAngle = function(O) {\n    return arguments.length ? (g = +O ? bA(f = O * Bt) : (f = null, Rd), B()) : f * se;\n  }, $.clipExtent = function(O) {\n    return arguments.length ? (E = O == null ? (m = v = x = _ = null, Yl) : EA(m = +O[0][0], v = +O[0][1], x = +O[1][0], _ = +O[1][1]), B()) : m == null ? null : [[m, v], [x, _]];\n  }, $.scale = function(O) {\n    return arguments.length ? (n = +O, P()) : n;\n  }, $.translate = function(O) {\n    return arguments.length ? (r = +O[0], i = +O[1], P()) : [r, i];\n  }, $.center = function(O) {\n    return arguments.length ? (s = O[0] % 360 * Bt, a = O[1] % 360 * Bt, P()) : [s * se, a * se];\n  }, $.rotate = function(O) {\n    return arguments.length ? (o = O[0] % 360 * Bt, l = O[1] % 360 * Bt, c = O.length > 2 ? O[2] % 360 * Bt : 0, P()) : [o * se, l * se, c * se];\n  }, $.angle = function(O) {\n    return arguments.length ? (d = O % 360 * Bt, P()) : d * se;\n  }, $.reflectX = function(O) {\n    return arguments.length ? (h = O ? -1 : 1, P()) : h < 0;\n  }, $.reflectY = function(O) {\n    return arguments.length ? (p = O ? -1 : 1, P()) : p < 0;\n  }, $.precision = function(O) {\n    return arguments.length ? (S = Gd(M, b = O * O), B()) : je(b);\n  }, $.fitExtent = function(O, w) {\n    return Kg($, O, w);\n  }, $.fitSize = function(O, w) {\n    return IA($, O, w);\n  }, $.fitWidth = function(O, w) {\n    return NA($, O, w);\n  }, $.fitHeight = function(O, w) {\n    return PA($, O, w);\n  };\n  function P() {\n    var O = zd(n, 0, 0, h, p, d).apply(null, t(s, a)), w = zd(n, r - O[0], i - O[1], h, p, d);\n    return u = Ng(o, l, c), M = Wl(t, w), D = Wl(u, M), S = Gd(M, b), B();\n  }\n  function B() {\n    return A = R = null, $;\n  }\n  return function() {\n    return t = e.apply(this, arguments), $.invert = t.invert && H, P();\n  };\n}\nfunction Jg(e) {\n  var t = 0, n = ft / 3, r = Qg(e), i = r(t, n);\n  return i.parallels = function(s) {\n    return arguments.length ? r(t = s[0] * Bt, n = s[1] * Bt) : [t * se, n * se];\n  }, i;\n}\nfunction FA(e) {\n  var t = St(e);\n  function n(r, i) {\n    return [r * t, xt(i) / t];\n  }\n  return n.invert = function(r, i) {\n    return [r / t, Cn(i * t)];\n  }, n;\n}\nfunction jA(e, t) {\n  var n = xt(e), r = (n + xt(t)) / 2;\n  if (Ot(r) < Tt) return FA(e);\n  var i = 1 + n * (2 * r - n), s = je(i) / r;\n  function a(o, l) {\n    var c = je(i - 2 * r * xt(l)) / r;\n    return [c * xt(o *= r), s - c * St(o)];\n  }\n  return a.invert = function(o, l) {\n    var c = s - l, u = lr(o, Ot(c)) * Un(c);\n    return c * r < 0 && (u -= ft * Un(o) * Un(c)), [u / r, Cn((i - (o * o + c * c) * r * r) / (2 * r))];\n  }, a;\n}\nfunction tv() {\n  return Jg(jA).scale(155.424).center([0, 33.6442]);\n}\nfunction WA() {\n  return tv().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);\n}\nfunction ru(e, t) {\n  return [e, cA(uA((de + t) / 2))];\n}\nru.invert = function(e, t) {\n  return [e, 2 * Ig(lA(t)) - de];\n};\nfunction qA() {\n  return YA(ru).scale(961 / Ee);\n}\nfunction YA(e) {\n  var t = uo(e), n = t.center, r = t.scale, i = t.translate, s = t.clipExtent, a = null, o, l, c;\n  t.scale = function(d) {\n    return arguments.length ? (r(d), u()) : r();\n  }, t.translate = function(d) {\n    return arguments.length ? (i(d), u()) : i();\n  }, t.center = function(d) {\n    return arguments.length ? (n(d), u()) : n();\n  }, t.clipExtent = function(d) {\n    return arguments.length ? (d == null ? a = o = l = c = null : (a = +d[0][0], o = +d[0][1], l = +d[1][0], c = +d[1][1]), u()) : a == null ? null : [[a, o], [l, c]];\n  };\n  function u() {\n    var d = ft * r(), h = t(dA(t.rotate()).invert([0, 0]));\n    return s(a == null ? [[h[0] - d, h[1] - d], [h[0] + d, h[1] + d]] : e === ru ? [[Math.max(h[0] - d, a), o], [Math.min(h[0] + d, l), c]] : [[a, Math.max(h[1] - d, o)], [l, Math.min(h[1] + d, c)]]);\n  }\n  return u();\n}\nfunction Ia(e, t) {\n  return [e, t];\n}\nIa.invert = Ia;\nfunction XA() {\n  return uo(Ia).scale(152.63);\n}\nfunction ZA(e, t) {\n  var n = St(e), r = e === t ? xt(e) : (n - St(t)) / (t - e), i = n / r + e;\n  if (Ot(r) < Tt) return Ia;\n  function s(a, o) {\n    var l = i - o, c = r * a;\n    return [l * xt(c), i - l * St(c)];\n  }\n  return s.invert = function(a, o) {\n    var l = i - o, c = lr(a, Ot(l)) * Un(l);\n    return l * r < 0 && (c -= ft * Un(a) * Un(l)), [c / r, i - Un(r) * je(a * a + l * l)];\n  }, s;\n}\nfunction KA() {\n  return Jg(ZA).scale(131.154).center([0, 13.9389]);\n}\nvar Hi = 1.340264, Vi = -0.081106, Gi = 893e-6, zi = 3796e-6, Na = je(3) / 2, QA = 12;\nfunction ev(e, t) {\n  var n = Cn(Na * xt(t)), r = n * n, i = r * r * r;\n  return [\n    e * St(n) / (Na * (Hi + 3 * Vi * r + i * (7 * Gi + 9 * zi * r))),\n    n * (Hi + Vi * r + i * (Gi + zi * r))\n  ];\n}\nev.invert = function(e, t) {\n  for (var n = t, r = n * n, i = r * r * r, s = 0, a, o, l; s < QA && (o = n * (Hi + Vi * r + i * (Gi + zi * r)) - t, l = Hi + 3 * Vi * r + i * (7 * Gi + 9 * zi * r), n -= a = o / l, r = n * n, i = r * r * r, !(Ot(a) < oA)); ++s)\n    ;\n  return [\n    Na * e * (Hi + 3 * Vi * r + i * (7 * Gi + 9 * zi * r)) / St(n),\n    Cn(xt(n) / Na)\n  ];\n};\nfunction JA() {\n  return uo(ev).scale(177.158);\n}\nfunction nv(e, t) {\n  var n = t * t, r = n * n;\n  return [\n    e * (0.8707 - 0.131979 * n + r * (-0.013791 + r * (3971e-6 * n - 1529e-6 * r))),\n    t * (1.007226 + n * (0.015085 + r * (-0.044475 + 0.028874 * n - 5916e-6 * r)))\n  ];\n}\nnv.invert = function(e, t) {\n  var n = t, r = 25, i;\n  do {\n    var s = n * n, a = s * s;\n    n -= i = (n * (1.007226 + s * (0.015085 + a * (-0.044475 + 0.028874 * s - 5916e-6 * a))) - t) / (1.007226 + s * (0.015085 * 3 + a * (-0.044475 * 7 + 0.028874 * 9 * s - 5916e-6 * 11 * a)));\n  } while (Ot(i) > Tt && --r > 0);\n  return [\n    e / (0.8707 + (s = n * n) * (-0.131979 + s * (-0.013791 + s * s * s * (3971e-6 - 1529e-6 * s)))),\n    n\n  ];\n};\nfunction tL() {\n  return uo(nv).scale(175.295);\n}\nfunction eL(e, t) {\n  return e.parent === t.parent ? 1 : 2;\n}\nfunction nL(e) {\n  return e.reduce(rL, 0) / e.length;\n}\nfunction rL(e, t) {\n  return e + t.x;\n}\nfunction iL(e) {\n  return 1 + e.reduce(sL, 0);\n}\nfunction sL(e, t) {\n  return Math.max(e, t.y);\n}\nfunction aL(e) {\n  for (var t; t = e.children; ) e = t[0];\n  return e;\n}\nfunction oL(e) {\n  for (var t; t = e.children; ) e = t[t.length - 1];\n  return e;\n}\nfunction lL() {\n  var e = eL, t = 1, n = 1, r = !1;\n  function i(s) {\n    var a, o = 0;\n    s.eachAfter(function(h) {\n      var p = h.children;\n      p ? (h.x = nL(p), h.y = iL(p)) : (h.x = a ? o += e(h, a) : 0, h.y = 0, a = h);\n    });\n    var l = aL(s), c = oL(s), u = l.x - e(l, c) / 2, d = c.x + e(c, l) / 2;\n    return s.eachAfter(r ? function(h) {\n      h.x = (h.x - s.x) * t, h.y = (s.y - h.y) * n;\n    } : function(h) {\n      h.x = (h.x - u) / (d - u) * t, h.y = (1 - (s.y ? h.y / s.y : 1)) * n;\n    });\n  }\n  return i.separation = function(s) {\n    return arguments.length ? (e = s, i) : e;\n  }, i.size = function(s) {\n    return arguments.length ? (r = !1, t = +s[0], n = +s[1], i) : r ? null : [t, n];\n  }, i.nodeSize = function(s) {\n    return arguments.length ? (r = !0, t = +s[0], n = +s[1], i) : r ? [t, n] : null;\n  }, i;\n}\nfunction cL(e) {\n  var t = 0, n = e.children, r = n && n.length;\n  if (!r) t = 1;\n  else for (; --r >= 0; ) t += n[r].value;\n  e.value = t;\n}\nfunction uL() {\n  return this.eachAfter(cL);\n}\nfunction hL(e, t) {\n  let n = -1;\n  for (const r of this)\n    e.call(t, r, ++n, this);\n  return this;\n}\nfunction dL(e, t) {\n  for (var n = this, r = [n], i, s, a = -1; n = r.pop(); )\n    if (e.call(t, n, ++a, this), i = n.children)\n      for (s = i.length - 1; s >= 0; --s)\n        r.push(i[s]);\n  return this;\n}\nfunction pL(e, t) {\n  for (var n = this, r = [n], i = [], s, a, o, l = -1; n = r.pop(); )\n    if (i.push(n), s = n.children)\n      for (a = 0, o = s.length; a < o; ++a)\n        r.push(s[a]);\n  for (; n = i.pop(); )\n    e.call(t, n, ++l, this);\n  return this;\n}\nfunction fL(e, t) {\n  let n = -1;\n  for (const r of this)\n    if (e.call(t, r, ++n, this))\n      return r;\n}\nfunction mL(e) {\n  return this.eachAfter(function(t) {\n    for (var n = +e(t.data) || 0, r = t.children, i = r && r.length; --i >= 0; ) n += r[i].value;\n    t.value = n;\n  });\n}\nfunction gL(e) {\n  return this.eachBefore(function(t) {\n    t.children && t.children.sort(e);\n  });\n}\nfunction vL(e) {\n  for (var t = this, n = yL(t, e), r = [t]; t !== n; )\n    t = t.parent, r.push(t);\n  for (var i = r.length; e !== n; )\n    r.splice(i, 0, e), e = e.parent;\n  return r;\n}\nfunction yL(e, t) {\n  if (e === t) return e;\n  var n = e.ancestors(), r = t.ancestors(), i = null;\n  for (e = n.pop(), t = r.pop(); e === t; )\n    i = e, e = n.pop(), t = r.pop();\n  return i;\n}\nfunction xL() {\n  for (var e = this, t = [e]; e = e.parent; )\n    t.push(e);\n  return t;\n}\nfunction bL() {\n  return Array.from(this);\n}\nfunction _L() {\n  var e = [];\n  return this.eachBefore(function(t) {\n    t.children || e.push(t);\n  }), e;\n}\nfunction EL() {\n  var e = this, t = [];\n  return e.each(function(n) {\n    n !== e && t.push({ source: n.parent, target: n });\n  }), t;\n}\nfunction* OL() {\n  var e = this, t, n = [e], r, i, s;\n  do\n    for (t = n.reverse(), n = []; e = t.pop(); )\n      if (yield e, r = e.children)\n        for (i = 0, s = r.length; i < s; ++i)\n          n.push(r[i]);\n  while (n.length);\n}\nfunction ys(e, t) {\n  e instanceof Map ? (e = [void 0, e], t === void 0 && (t = wL)) : t === void 0 && (t = TL);\n  for (var n = new ss(e), r, i = [n], s, a, o, l; r = i.pop(); )\n    if ((a = t(r.data)) && (l = (a = Array.from(a)).length))\n      for (r.children = a, o = l - 1; o >= 0; --o)\n        i.push(s = a[o] = new ss(a[o])), s.parent = r, s.depth = r.depth + 1;\n  return n.eachBefore(ML);\n}\nfunction SL() {\n  return ys(this).eachBefore($L);\n}\nfunction TL(e) {\n  return e.children;\n}\nfunction wL(e) {\n  return Array.isArray(e) ? e[1] : null;\n}\nfunction $L(e) {\n  e.data.value !== void 0 && (e.value = e.data.value), e.data = e.data.data;\n}\nfunction ML(e) {\n  var t = 0;\n  do\n    e.height = t;\n  while ((e = e.parent) && e.height < ++t);\n}\nfunction ss(e) {\n  this.data = e, this.depth = this.height = 0, this.parent = null;\n}\nss.prototype = ys.prototype = {\n  constructor: ss,\n  count: uL,\n  each: hL,\n  eachAfter: pL,\n  eachBefore: dL,\n  find: fL,\n  sum: mL,\n  sort: gL,\n  path: vL,\n  ancestors: xL,\n  descendants: bL,\n  leaves: _L,\n  links: EL,\n  copy: SL,\n  [Symbol.iterator]: OL\n};\nfunction CL(e) {\n  return e == null ? null : rv(e);\n}\nfunction rv(e) {\n  if (typeof e != "function") throw new Error();\n  return e;\n}\nfunction Kn() {\n  return 0;\n}\nfunction kr(e) {\n  return function() {\n    return e;\n  };\n}\nconst AL = 1664525, LL = 1013904223, Fd = 4294967296;\nfunction kL() {\n  let e = 1;\n  return () => (e = (AL * e + LL) % Fd) / Fd;\n}\nfunction DL(e) {\n  return typeof e == "object" && "length" in e ? e : Array.from(e);\n}\nfunction RL(e, t) {\n  let n = e.length, r, i;\n  for (; n; )\n    i = t() * n-- | 0, r = e[n], e[n] = e[i], e[i] = r;\n  return e;\n}\nfunction IL(e, t) {\n  for (var n = 0, r = (e = RL(Array.from(e), t)).length, i = [], s, a; n < r; )\n    s = e[n], a && iv(a, s) ? ++n : (a = PL(i = NL(i, s)), n = 0);\n  return a;\n}\nfunction NL(e, t) {\n  var n, r;\n  if (Jo(t, e)) return [t];\n  for (n = 0; n < e.length; ++n)\n    if (Ps(t, e[n]) && Jo(Ri(e[n], t), e))\n      return [e[n], t];\n  for (n = 0; n < e.length - 1; ++n)\n    for (r = n + 1; r < e.length; ++r)\n      if (Ps(Ri(e[n], e[r]), t) && Ps(Ri(e[n], t), e[r]) && Ps(Ri(e[r], t), e[n]) && Jo(sv(e[n], e[r], t), e))\n        return [e[n], e[r], t];\n  throw new Error();\n}\nfunction Ps(e, t) {\n  var n = e.r - t.r, r = t.x - e.x, i = t.y - e.y;\n  return n < 0 || n * n < r * r + i * i;\n}\nfunction iv(e, t) {\n  var n = e.r - t.r + Math.max(e.r, t.r, 1) * 1e-9, r = t.x - e.x, i = t.y - e.y;\n  return n > 0 && n * n > r * r + i * i;\n}\nfunction Jo(e, t) {\n  for (var n = 0; n < t.length; ++n)\n    if (!iv(e, t[n]))\n      return !1;\n  return !0;\n}\nfunction PL(e) {\n  switch (e.length) {\n    case 1:\n      return UL(e[0]);\n    case 2:\n      return Ri(e[0], e[1]);\n    case 3:\n      return sv(e[0], e[1], e[2]);\n  }\n}\nfunction UL(e) {\n  return {\n    x: e.x,\n    y: e.y,\n    r: e.r\n  };\n}\nfunction Ri(e, t) {\n  var n = e.x, r = e.y, i = e.r, s = t.x, a = t.y, o = t.r, l = s - n, c = a - r, u = o - i, d = Math.sqrt(l * l + c * c);\n  return {\n    x: (n + s + l / d * u) / 2,\n    y: (r + a + c / d * u) / 2,\n    r: (d + i + o) / 2\n  };\n}\nfunction sv(e, t, n) {\n  var r = e.x, i = e.y, s = e.r, a = t.x, o = t.y, l = t.r, c = n.x, u = n.y, d = n.r, h = r - a, p = r - c, f = i - o, g = i - u, m = l - s, v = d - s, x = r * r + i * i - s * s, _ = x - a * a - o * o + l * l, E = x - c * c - u * u + d * d, b = p * f - h * g, S = (f * E - g * _) / (b * 2) - r, M = (g * m - f * v) / b, D = (p * _ - h * E) / (b * 2) - i, A = (h * v - p * m) / b, R = M * M + A * A - 1, $ = 2 * (s + S * M + D * A), H = S * S + D * D - s * s, P = -(Math.abs(R) > 1e-6 ? ($ + Math.sqrt($ * $ - 4 * R * H)) / (2 * R) : H / $);\n  return {\n    x: r + S + M * P,\n    y: i + D + A * P,\n    r: P\n  };\n}\nfunction jd(e, t, n) {\n  var r = e.x - t.x, i, s, a = e.y - t.y, o, l, c = r * r + a * a;\n  c ? (s = t.r + n.r, s *= s, l = e.r + n.r, l *= l, s > l ? (i = (c + l - s) / (2 * c), o = Math.sqrt(Math.max(0, l / c - i * i)), n.x = e.x - i * r - o * a, n.y = e.y - i * a + o * r) : (i = (c + s - l) / (2 * c), o = Math.sqrt(Math.max(0, s / c - i * i)), n.x = t.x + i * r - o * a, n.y = t.y + i * a + o * r)) : (n.x = t.x + n.r, n.y = t.y);\n}\nfunction Wd(e, t) {\n  var n = e.r + t.r - 1e-6, r = t.x - e.x, i = t.y - e.y;\n  return n > 0 && n * n > r * r + i * i;\n}\nfunction qd(e) {\n  var t = e._, n = e.next._, r = t.r + n.r, i = (t.x * n.r + n.x * t.r) / r, s = (t.y * n.r + n.y * t.r) / r;\n  return i * i + s * s;\n}\nfunction Us(e) {\n  this._ = e, this.next = null, this.previous = null;\n}\nfunction BL(e, t) {\n  if (!(s = (e = DL(e)).length)) return 0;\n  var n, r, i, s, a, o, l, c, u, d, h;\n  if (n = e[0], n.x = 0, n.y = 0, !(s > 1)) return n.r;\n  if (r = e[1], n.x = -r.r, r.x = n.r, r.y = 0, !(s > 2)) return n.r + r.r;\n  jd(r, n, i = e[2]), n = new Us(n), r = new Us(r), i = new Us(i), n.next = i.previous = r, r.next = n.previous = i, i.next = r.previous = n;\n  t: for (l = 3; l < s; ++l) {\n    jd(n._, r._, i = e[l]), i = new Us(i), c = r.next, u = n.previous, d = r._.r, h = n._.r;\n    do\n      if (d <= h) {\n        if (Wd(c._, i._)) {\n          r = c, n.next = r, r.previous = n, --l;\n          continue t;\n        }\n        d += c._.r, c = c.next;\n      } else {\n        if (Wd(u._, i._)) {\n          n = u, n.next = r, r.previous = n, --l;\n          continue t;\n        }\n        h += u._.r, u = u.previous;\n      }\n    while (c !== u.next);\n    for (i.previous = n, i.next = r, n.next = r.previous = r = i, a = qd(n); (i = i.next) !== r; )\n      (o = qd(i)) < a && (n = i, a = o);\n    r = n.next;\n  }\n  for (n = [r._], i = r; (i = i.next) !== r; ) n.push(i._);\n  for (i = IL(n, t), l = 0; l < s; ++l) n = e[l], n.x -= i.x, n.y -= i.y;\n  return i.r;\n}\nfunction HL(e) {\n  return Math.sqrt(e.value);\n}\nfunction VL() {\n  var e = null, t = 1, n = 1, r = Kn;\n  function i(s) {\n    const a = kL();\n    return s.x = t / 2, s.y = n / 2, e ? s.eachBefore(Yd(e)).eachAfter(tl(r, 0.5, a)).eachBefore(Xd(1)) : s.eachBefore(Yd(HL)).eachAfter(tl(Kn, 1, a)).eachAfter(tl(r, s.r / Math.min(t, n), a)).eachBefore(Xd(Math.min(t, n) / (2 * s.r))), s;\n  }\n  return i.radius = function(s) {\n    return arguments.length ? (e = CL(s), i) : e;\n  }, i.size = function(s) {\n    return arguments.length ? (t = +s[0], n = +s[1], i) : [t, n];\n  }, i.padding = function(s) {\n    return arguments.length ? (r = typeof s == "function" ? s : kr(+s), i) : r;\n  }, i;\n}\nfunction Yd(e) {\n  return function(t) {\n    t.children || (t.r = Math.max(0, +e(t) || 0));\n  };\n}\nfunction tl(e, t, n) {\n  return function(r) {\n    if (i = r.children) {\n      var i, s, a = i.length, o = e(r) * t || 0, l;\n      if (o) for (s = 0; s < a; ++s) i[s].r += o;\n      if (l = BL(i, n), o) for (s = 0; s < a; ++s) i[s].r -= o;\n      r.r = l + o;\n    }\n  };\n}\nfunction Xd(e) {\n  return function(t) {\n    var n = t.parent;\n    t.r *= e, n && (t.x = n.x + e * t.x, t.y = n.y + e * t.y);\n  };\n}\nfunction GL(e) {\n  e.x0 = Math.round(e.x0), e.y0 = Math.round(e.y0), e.x1 = Math.round(e.x1), e.y1 = Math.round(e.y1);\n}\nfunction zL(e, t, n, r, i) {\n  for (var s = e.children, a, o = -1, l = s.length, c = e.value && (r - t) / e.value; ++o < l; )\n    a = s[o], a.y0 = n, a.y1 = i, a.x0 = t, a.x1 = t += a.value * c;\n}\nfunction FL(e, t) {\n  return e.parent === t.parent ? 1 : 2;\n}\nfunction el(e) {\n  var t = e.children;\n  return t ? t[0] : e.t;\n}\nfunction nl(e) {\n  var t = e.children;\n  return t ? t[t.length - 1] : e.t;\n}\nfunction jL(e, t, n) {\n  var r = n / (t.i - e.i);\n  t.c -= r, t.s += n, e.c += r, t.z += n, t.m += n;\n}\nfunction WL(e) {\n  for (var t = 0, n = 0, r = e.children, i = r.length, s; --i >= 0; )\n    s = r[i], s.z += t, s.m += t, t += s.s + (n += s.c);\n}\nfunction qL(e, t, n) {\n  return e.a.parent === t.parent ? e.a : n;\n}\nfunction na(e, t) {\n  this._ = e, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = t;\n}\nna.prototype = Object.create(ss.prototype);\nfunction YL(e) {\n  for (var t = new na(e, 0), n, r = [t], i, s, a, o; n = r.pop(); )\n    if (s = n._.children)\n      for (n.children = new Array(o = s.length), a = o - 1; a >= 0; --a)\n        r.push(i = n.children[a] = new na(s[a], a)), i.parent = n;\n  return (t.parent = new na(null, 0)).children = [t], t;\n}\nfunction XL() {\n  var e = FL, t = 1, n = 1, r = null;\n  function i(c) {\n    var u = YL(c);\n    if (u.eachAfter(s), u.parent.m = -u.z, u.eachBefore(a), r) c.eachBefore(l);\n    else {\n      var d = c, h = c, p = c;\n      c.eachBefore(function(x) {\n        x.x < d.x && (d = x), x.x > h.x && (h = x), x.depth > p.depth && (p = x);\n      });\n      var f = d === h ? 1 : e(d, h) / 2, g = f - d.x, m = t / (h.x + f + g), v = n / (p.depth || 1);\n      c.eachBefore(function(x) {\n        x.x = (x.x + g) * m, x.y = x.depth * v;\n      });\n    }\n    return c;\n  }\n  function s(c) {\n    var u = c.children, d = c.parent.children, h = c.i ? d[c.i - 1] : null;\n    if (u) {\n      WL(c);\n      var p = (u[0].z + u[u.length - 1].z) / 2;\n      h ? (c.z = h.z + e(c._, h._), c.m = c.z - p) : c.z = p;\n    } else h && (c.z = h.z + e(c._, h._));\n    c.parent.A = o(c, h, c.parent.A || d[0]);\n  }\n  function a(c) {\n    c._.x = c.z + c.parent.m, c.m += c.parent.m;\n  }\n  function o(c, u, d) {\n    if (u) {\n      for (var h = c, p = c, f = u, g = h.parent.children[0], m = h.m, v = p.m, x = f.m, _ = g.m, E; f = nl(f), h = el(h), f && h; )\n        g = el(g), p = nl(p), p.a = c, E = f.z + x - h.z - m + e(f._, h._), E > 0 && (jL(qL(f, c, d), c, E), m += E, v += E), x += f.m, m += h.m, _ += g.m, v += p.m;\n      f && !nl(p) && (p.t = f, p.m += x - v), h && !el(g) && (g.t = h, g.m += m - _, d = c);\n    }\n    return d;\n  }\n  function l(c) {\n    c.x *= t, c.y = c.depth * n;\n  }\n  return i.separation = function(c) {\n    return arguments.length ? (e = c, i) : e;\n  }, i.size = function(c) {\n    return arguments.length ? (r = !1, t = +c[0], n = +c[1], i) : r ? null : [t, n];\n  }, i.nodeSize = function(c) {\n    return arguments.length ? (r = !0, t = +c[0], n = +c[1], i) : r ? [t, n] : null;\n  }, i;\n}\nfunction ZL(e, t, n, r, i) {\n  for (var s = e.children, a, o = -1, l = s.length, c = e.value && (i - n) / e.value; ++o < l; )\n    a = s[o], a.x0 = t, a.x1 = r, a.y0 = n, a.y1 = n += a.value * c;\n}\nvar KL = (1 + Math.sqrt(5)) / 2;\nfunction QL(e, t, n, r, i, s) {\n  for (var a = [], o = t.children, l, c, u = 0, d = 0, h = o.length, p, f, g = t.value, m, v, x, _, E, b, S; u < h; ) {\n    p = i - n, f = s - r;\n    do\n      m = o[d++].value;\n    while (!m && d < h);\n    for (v = x = m, b = Math.max(f / p, p / f) / (g * e), S = m * m * b, E = Math.max(x / S, S / v); d < h; ++d) {\n      if (m += c = o[d].value, c < v && (v = c), c > x && (x = c), S = m * m * b, _ = Math.max(x / S, S / v), _ > E) {\n        m -= c;\n        break;\n      }\n      E = _;\n    }\n    a.push(l = { value: m, dice: p < f, children: o.slice(u, d) }), l.dice ? zL(l, n, r, i, g ? r += f * m / g : s) : ZL(l, n, r, g ? n += p * m / g : i, s), g -= m, u = d;\n  }\n  return a;\n}\nconst JL = function e(t) {\n  function n(r, i, s, a, o) {\n    QL(t, r, i, s, a, o);\n  }\n  return n.ratio = function(r) {\n    return e((r = +r) > 1 ? r : 1);\n  }, n;\n}(KL);\nfunction tk() {\n  var e = JL, t = !1, n = 1, r = 1, i = [0], s = Kn, a = Kn, o = Kn, l = Kn, c = Kn;\n  function u(h) {\n    return h.x0 = h.y0 = 0, h.x1 = n, h.y1 = r, h.eachBefore(d), i = [0], t && h.eachBefore(GL), h;\n  }\n  function d(h) {\n    var p = i[h.depth], f = h.x0 + p, g = h.y0 + p, m = h.x1 - p, v = h.y1 - p;\n    m < f && (f = m = (f + m) / 2), v < g && (g = v = (g + v) / 2), h.x0 = f, h.y0 = g, h.x1 = m, h.y1 = v, h.children && (p = i[h.depth + 1] = s(h) / 2, f += c(h) - p, g += a(h) - p, m -= o(h) - p, v -= l(h) - p, m < f && (f = m = (f + m) / 2), v < g && (g = v = (g + v) / 2), e(h, f, g, m, v));\n  }\n  return u.round = function(h) {\n    return arguments.length ? (t = !!h, u) : t;\n  }, u.size = function(h) {\n    return arguments.length ? (n = +h[0], r = +h[1], u) : [n, r];\n  }, u.tile = function(h) {\n    return arguments.length ? (e = rv(h), u) : e;\n  }, u.padding = function(h) {\n    return arguments.length ? u.paddingInner(h).paddingOuter(h) : u.paddingInner();\n  }, u.paddingInner = function(h) {\n    return arguments.length ? (s = typeof h == "function" ? h : kr(+h), u) : s;\n  }, u.paddingOuter = function(h) {\n    return arguments.length ? u.paddingTop(h).paddingRight(h).paddingBottom(h).paddingLeft(h) : u.paddingTop();\n  }, u.paddingTop = function(h) {\n    return arguments.length ? (a = typeof h == "function" ? h : kr(+h), u) : a;\n  }, u.paddingRight = function(h) {\n    return arguments.length ? (o = typeof h == "function" ? h : kr(+h), u) : o;\n  }, u.paddingBottom = function(h) {\n    return arguments.length ? (l = typeof h == "function" ? h : kr(+h), u) : l;\n  }, u.paddingLeft = function(h) {\n    return arguments.length ? (c = typeof h == "function" ? h : kr(+h), u) : c;\n  }, u;\n}\nfunction ho(e) {\n  let t = 3;\n  return e.digits = function(n) {\n    if (!arguments.length) return t;\n    if (n == null)\n      t = null;\n    else {\n      const r = Math.floor(n);\n      if (!(r >= 0)) throw new RangeError(`invalid digits: ${n}`);\n      t = r;\n    }\n    return e;\n  }, () => new tu(t);\n}\nfunction ek(e) {\n  return e.innerRadius;\n}\nfunction nk(e) {\n  return e.outerRadius;\n}\nfunction rk(e) {\n  return e.startAngle;\n}\nfunction ik(e) {\n  return e.endAngle;\n}\nfunction sk(e) {\n  return e && e.padAngle;\n}\nfunction ak(e, t, n, r, i, s, a, o) {\n  var l = n - e, c = r - t, u = a - i, d = o - s, h = d * l - u * c;\n  if (!(h * h < ne))\n    return h = (u * (t - s) - d * (e - i)) / h, [e + h * l, t + h * c];\n}\nfunction Bs(e, t, n, r, i, s, a) {\n  var o = e - n, l = t - r, c = (a ? s : -s) / Br(o * o + l * l), u = c * l, d = -c * o, h = e + u, p = t + d, f = n + u, g = r + d, m = (h + f) / 2, v = (p + g) / 2, x = f - h, _ = g - p, E = x * x + _ * _, b = i - s, S = h * g - f * p, M = (_ < 0 ? -1 : 1) * Br(GM(0, b * b * E - S * S)), D = (S * _ - x * M) / E, A = (-S * x - _ * M) / E, R = (S * _ + x * M) / E, $ = (-S * x + _ * M) / E, H = D - m, P = A - v, B = R - m, O = $ - v;\n  return H * H + P * P > B * B + O * O && (D = R, A = $), {\n    cx: D,\n    cy: A,\n    x01: -u,\n    y01: -d,\n    x11: D * (i / b - 1),\n    y11: A * (i / b - 1)\n  };\n}\nfunction as() {\n  var e = ek, t = nk, n = dt(0), r = null, i = rk, s = ik, a = sk, o = null, l = ho(c);\n  function c() {\n    var u, d, h = +e.apply(this, arguments), p = +t.apply(this, arguments), f = i.apply(this, arguments) - Sa, g = s.apply(this, arguments) - Sa, m = id(g - f), v = g > f;\n    if (o || (o = u = l()), p < h && (d = p, p = h, h = d), !(p > ne)) o.moveTo(0, 0);\n    else if (m > Ks - ne)\n      o.moveTo(p * qn(f), p * Ze(f)), o.arc(0, 0, p, f, g, !v), h > ne && (o.moveTo(h * qn(g), h * Ze(g)), o.arc(0, 0, h, g, f, v));\n    else {\n      var x = f, _ = g, E = f, b = g, S = m, M = m, D = a.apply(this, arguments) / 2, A = D > ne && (r ? +r.apply(this, arguments) : Br(h * h + p * p)), R = Go(id(p - h) / 2, +n.apply(this, arguments)), $ = R, H = R, P, B;\n      if (A > ne) {\n        var O = sd(A / h * Ze(D)), w = sd(A / p * Ze(D));\n        (S -= O * 2) > ne ? (O *= v ? 1 : -1, E += O, b -= O) : (S = 0, E = b = (f + g) / 2), (M -= w * 2) > ne ? (w *= v ? 1 : -1, x += w, _ -= w) : (M = 0, x = _ = (f + g) / 2);\n      }\n      var L = p * qn(x), k = p * Ze(x), U = h * qn(b), Z = h * Ze(b);\n      if (R > ne) {\n        var j = p * qn(_), F = p * Ze(_), Y = h * qn(E), ot = h * Ze(E), Q;\n        if (m < ns)\n          if (Q = ak(L, k, Y, ot, j, F, U, Z)) {\n            var q = L - Q[0], tt = k - Q[1], lt = j - Q[0], z = F - Q[1], W = 1 / Ze(zM((q * lt + tt * z) / (Br(q * q + tt * tt) * Br(lt * lt + z * z))) / 2), X = Br(Q[0] * Q[0] + Q[1] * Q[1]);\n            $ = Go(R, (h - X) / (W - 1)), H = Go(R, (p - X) / (W + 1));\n          } else\n            $ = H = 0;\n      }\n      M > ne ? H > ne ? (P = Bs(Y, ot, L, k, p, H, v), B = Bs(j, F, U, Z, p, H, v), o.moveTo(P.cx + P.x01, P.cy + P.y01), H < R ? o.arc(P.cx, P.cy, H, Jt(P.y01, P.x01), Jt(B.y01, B.x01), !v) : (o.arc(P.cx, P.cy, H, Jt(P.y01, P.x01), Jt(P.y11, P.x11), !v), o.arc(0, 0, p, Jt(P.cy + P.y11, P.cx + P.x11), Jt(B.cy + B.y11, B.cx + B.x11), !v), o.arc(B.cx, B.cy, H, Jt(B.y11, B.x11), Jt(B.y01, B.x01), !v))) : (o.moveTo(L, k), o.arc(0, 0, p, x, _, !v)) : o.moveTo(L, k), !(h > ne) || !(S > ne) ? o.lineTo(U, Z) : $ > ne ? (P = Bs(U, Z, j, F, h, -$, v), B = Bs(L, k, Y, ot, h, -$, v), o.lineTo(P.cx + P.x01, P.cy + P.y01), $ < R ? o.arc(P.cx, P.cy, $, Jt(P.y01, P.x01), Jt(B.y01, B.x01), !v) : (o.arc(P.cx, P.cy, $, Jt(P.y01, P.x01), Jt(P.y11, P.x11), !v), o.arc(0, 0, h, Jt(P.cy + P.y11, P.cx + P.x11), Jt(B.cy + B.y11, B.cx + B.x11), v), o.arc(B.cx, B.cy, $, Jt(B.y11, B.x11), Jt(B.y01, B.x01), !v))) : o.arc(0, 0, h, b, E, v);\n    }\n    if (o.closePath(), u) return o = null, u + "" || null;\n  }\n  return c.centroid = function() {\n    var u = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, d = (+i.apply(this, arguments) + +s.apply(this, arguments)) / 2 - ns / 2;\n    return [qn(d) * u, Ze(d) * u];\n  }, c.innerRadius = function(u) {\n    return arguments.length ? (e = typeof u == "function" ? u : dt(+u), c) : e;\n  }, c.outerRadius = function(u) {\n    return arguments.length ? (t = typeof u == "function" ? u : dt(+u), c) : t;\n  }, c.cornerRadius = function(u) {\n    return arguments.length ? (n = typeof u == "function" ? u : dt(+u), c) : n;\n  }, c.padRadius = function(u) {\n    return arguments.length ? (r = u == null ? null : typeof u == "function" ? u : dt(+u), c) : r;\n  }, c.startAngle = function(u) {\n    return arguments.length ? (i = typeof u == "function" ? u : dt(+u), c) : i;\n  }, c.endAngle = function(u) {\n    return arguments.length ? (s = typeof u == "function" ? u : dt(+u), c) : s;\n  }, c.padAngle = function(u) {\n    return arguments.length ? (a = typeof u == "function" ? u : dt(+u), c) : a;\n  }, c.context = function(u) {\n    return arguments.length ? (o = u ?? null, c) : o;\n  }, c;\n}\nfunction iu(e) {\n  return e[0];\n}\nfunction su(e) {\n  return e[1];\n}\nfunction xs(e, t) {\n  var n = dt(!0), r = null, i = oo, s = null, a = ho(o);\n  e = typeof e == "function" ? e : e === void 0 ? iu : dt(e), t = typeof t == "function" ? t : t === void 0 ? su : dt(t);\n  function o(l) {\n    var c, u = (l = so(l)).length, d, h = !1, p;\n    for (r == null && (s = i(p = a())), c = 0; c <= u; ++c)\n      !(c < u && n(d = l[c], c, l)) === h && ((h = !h) ? s.lineStart() : s.lineEnd()), h && s.point(+e(d, c, l), +t(d, c, l));\n    if (p) return s = null, p + "" || null;\n  }\n  return o.x = function(l) {\n    return arguments.length ? (e = typeof l == "function" ? l : dt(+l), o) : e;\n  }, o.y = function(l) {\n    return arguments.length ? (t = typeof l == "function" ? l : dt(+l), o) : t;\n  }, o.defined = function(l) {\n    return arguments.length ? (n = typeof l == "function" ? l : dt(!!l), o) : n;\n  }, o.curve = function(l) {\n    return arguments.length ? (i = l, r != null && (s = i(r)), o) : i;\n  }, o.context = function(l) {\n    return arguments.length ? (l == null ? r = s = null : s = i(r = l), o) : r;\n  }, o;\n}\nfunction au(e, t, n) {\n  var r = null, i = dt(!0), s = null, a = oo, o = null, l = ho(c);\n  e = typeof e == "function" ? e : e === void 0 ? iu : dt(+e), t = typeof t == "function" ? t : dt(t === void 0 ? 0 : +t), n = typeof n == "function" ? n : n === void 0 ? su : dt(+n);\n  function c(d) {\n    var h, p, f, g = (d = so(d)).length, m, v = !1, x, _ = new Array(g), E = new Array(g);\n    for (s == null && (o = a(x = l())), h = 0; h <= g; ++h) {\n      if (!(h < g && i(m = d[h], h, d)) === v)\n        if (v = !v)\n          p = h, o.areaStart(), o.lineStart();\n        else {\n          for (o.lineEnd(), o.lineStart(), f = h - 1; f >= p; --f)\n            o.point(_[f], E[f]);\n          o.lineEnd(), o.areaEnd();\n        }\n      v && (_[h] = +e(m, h, d), E[h] = +t(m, h, d), o.point(r ? +r(m, h, d) : _[h], n ? +n(m, h, d) : E[h]));\n    }\n    if (x) return o = null, x + "" || null;\n  }\n  function u() {\n    return xs().defined(i).curve(a).context(s);\n  }\n  return c.x = function(d) {\n    return arguments.length ? (e = typeof d == "function" ? d : dt(+d), r = null, c) : e;\n  }, c.x0 = function(d) {\n    return arguments.length ? (e = typeof d == "function" ? d : dt(+d), c) : e;\n  }, c.x1 = function(d) {\n    return arguments.length ? (r = d == null ? null : typeof d == "function" ? d : dt(+d), c) : r;\n  }, c.y = function(d) {\n    return arguments.length ? (t = typeof d == "function" ? d : dt(+d), n = null, c) : t;\n  }, c.y0 = function(d) {\n    return arguments.length ? (t = typeof d == "function" ? d : dt(+d), c) : t;\n  }, c.y1 = function(d) {\n    return arguments.length ? (n = d == null ? null : typeof d == "function" ? d : dt(+d), c) : n;\n  }, c.lineX0 = c.lineY0 = function() {\n    return u().x(e).y(t);\n  }, c.lineY1 = function() {\n    return u().x(e).y(n);\n  }, c.lineX1 = function() {\n    return u().x(r).y(t);\n  }, c.defined = function(d) {\n    return arguments.length ? (i = typeof d == "function" ? d : dt(!!d), c) : i;\n  }, c.curve = function(d) {\n    return arguments.length ? (a = d, s != null && (o = a(s)), c) : a;\n  }, c.context = function(d) {\n    return arguments.length ? (d == null ? s = o = null : o = a(s = d), c) : s;\n  }, c;\n}\nfunction ok(e, t) {\n  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;\n}\nfunction lk(e) {\n  return e;\n}\nfunction ck() {\n  var e = lk, t = ok, n = null, r = dt(0), i = dt(Ks), s = dt(0);\n  function a(o) {\n    var l, c = (o = so(o)).length, u, d, h = 0, p = new Array(c), f = new Array(c), g = +r.apply(this, arguments), m = Math.min(Ks, Math.max(-Ks, i.apply(this, arguments) - g)), v, x = Math.min(Math.abs(m) / c, s.apply(this, arguments)), _ = x * (m < 0 ? -1 : 1), E;\n    for (l = 0; l < c; ++l)\n      (E = f[p[l] = l] = +e(o[l], l, o)) > 0 && (h += E);\n    for (t != null ? p.sort(function(b, S) {\n      return t(f[b], f[S]);\n    }) : n != null && p.sort(function(b, S) {\n      return n(o[b], o[S]);\n    }), l = 0, d = h ? (m - c * _) / h : 0; l < c; ++l, g = v)\n      u = p[l], E = f[u], v = g + (E > 0 ? E * d : 0) + _, f[u] = {\n        data: o[u],\n        index: l,\n        value: E,\n        startAngle: g,\n        endAngle: v,\n        padAngle: x\n      };\n    return f;\n  }\n  return a.value = function(o) {\n    return arguments.length ? (e = typeof o == "function" ? o : dt(+o), a) : e;\n  }, a.sortValues = function(o) {\n    return arguments.length ? (t = o, n = null, a) : t;\n  }, a.sort = function(o) {\n    return arguments.length ? (n = o, t = null, a) : n;\n  }, a.startAngle = function(o) {\n    return arguments.length ? (r = typeof o == "function" ? o : dt(+o), a) : r;\n  }, a.endAngle = function(o) {\n    return arguments.length ? (i = typeof o == "function" ? o : dt(+o), a) : i;\n  }, a.padAngle = function(o) {\n    return arguments.length ? (s = typeof o == "function" ? o : dt(+o), a) : s;\n  }, a;\n}\nvar uk = ov(oo);\nfunction av(e) {\n  this._curve = e;\n}\nav.prototype = {\n  areaStart: function() {\n    this._curve.areaStart();\n  },\n  areaEnd: function() {\n    this._curve.areaEnd();\n  },\n  lineStart: function() {\n    this._curve.lineStart();\n  },\n  lineEnd: function() {\n    this._curve.lineEnd();\n  },\n  point: function(e, t) {\n    this._curve.point(t * Math.sin(e), t * -Math.cos(e));\n  }\n};\nfunction ov(e) {\n  function t(n) {\n    return new av(e(n));\n  }\n  return t._curve = e, t;\n}\nfunction hk(e) {\n  var t = e.curve;\n  return e.angle = e.x, delete e.x, e.radius = e.y, delete e.y, e.curve = function(n) {\n    return arguments.length ? t(ov(n)) : t()._curve;\n  }, e;\n}\nfunction dk() {\n  return hk(xs().curve(uk));\n}\nclass pk {\n  constructor(t, n) {\n    this._context = t, this._x = n;\n  }\n  areaStart() {\n    this._line = 0;\n  }\n  areaEnd() {\n    this._line = NaN;\n  }\n  lineStart() {\n    this._point = 0;\n  }\n  lineEnd() {\n    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;\n  }\n  point(t, n) {\n    switch (t = +t, n = +n, this._point) {\n      case 0: {\n        this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);\n        break;\n      }\n      case 1:\n        this._point = 2;\n      // falls through\n      default: {\n        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, n, t, n) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + n) / 2, t, this._y0, t, n);\n        break;\n      }\n    }\n    this._x0 = t, this._y0 = n;\n  }\n}\nfunction fk(e) {\n  return new pk(e, !0);\n}\nfunction mk(e) {\n  return e.source;\n}\nfunction gk(e) {\n  return e.target;\n}\nfunction vk(e) {\n  let t = mk, n = gk, r = iu, i = su, s = null, a = null, o = ho(l);\n  function l() {\n    let c;\n    const u = kw.call(arguments), d = t.apply(this, u), h = n.apply(this, u);\n    if (s == null && (a = e(c = o())), a.lineStart(), u[0] = d, a.point(+r.apply(this, u), +i.apply(this, u)), u[0] = h, a.point(+r.apply(this, u), +i.apply(this, u)), a.lineEnd(), c) return a = null, c + "" || null;\n  }\n  return l.source = function(c) {\n    return arguments.length ? (t = c, l) : t;\n  }, l.target = function(c) {\n    return arguments.length ? (n = c, l) : n;\n  }, l.x = function(c) {\n    return arguments.length ? (r = typeof c == "function" ? c : dt(+c), l) : r;\n  }, l.y = function(c) {\n    return arguments.length ? (i = typeof c == "function" ? c : dt(+c), l) : i;\n  }, l.context = function(c) {\n    return arguments.length ? (c == null ? s = a = null : a = e(s = c), l) : s;\n  }, l;\n}\nfunction yk() {\n  return vk(fk);\n}\nlet mt = class {\n  constructor(t, n, r) {\n    if (this.type = "", this.renderType = rt.HTML, this.id = "", this.parent = void 0, this.configs = {}, this.model = t, this.services = n, r && (this.configs = r, this.configs.id)) {\n      const i = y(this.model.getOptions(), "style", "prefix");\n      this.id = `${i}--${this.configs.id}`;\n    }\n    this.parent || this.setParent(\n      I(\n        this.services.domUtils.getMainContainer()\n      )\n    );\n  }\n  init() {\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(t = !0) {\n    console.error("Error: Component did not provide the required render function.");\n  }\n  destroy() {\n  }\n  // Used to pass down information to the components\n  setModel(t) {\n    this.model = t;\n  }\n  // Used to pass down information to the components\n  setServices(t) {\n    this.services = t;\n  }\n  setParent(t) {\n    var n;\n    const r = this.parent;\n    if (this.parent = t, !(r && r.node() === t.node()) && this.type) {\n      const i = y(this.model.getOptions(), "style", "prefix");\n      (n = this.parent) == null || n.classed(`${ue}--${i}--${this.type}`, !0), r && r.classed(`${ue}--${i}--${this.type}`, !1);\n    }\n  }\n  getParent() {\n    return this.parent;\n  }\n  getComponentContainer(t = { ariaLabel: null, isPresentational: !1, withinChartClip: !1 }) {\n    if (this.type) {\n      const n = y(this.model.getOptions(), "style", "prefix"), r = this.id ? `#${this.id}` : "", i = N.appendOrSelect(\n        this.parent,\n        `${this.renderType === rt.SVG ? "svg" : "div"}${r}.${ue}--${n}--${this.type}`\n      );\n      if (t.ariaLabel && i.attr("aria-label", t.ariaLabel), t.isPresentational && i.attr("role", "presentation"), t.withinChartClip) {\n        const s = this.model.get("chartClipId");\n        if (s) {\n          const a = I(`#${s}`).select("rect");\n          a.size() !== 0 && parseFloat(a.attr("height")) > 0 && i.attr("clip-path", `url(#${s})`);\n        }\n      }\n      return i.attr("width", "100%").attr("height", "100%");\n    }\n    return this.parent;\n  }\n  /**\n   * graphs used in combo charts share a model with global options but can receive their own local options.\n   * this function retrieves the global options and merges it with any options passed into this\n   * component\'s config.options object.\n   */\n  getOptions() {\n    return this.configs.options ? at({}, this.model.getOptions(), this.configs.options) : this.model.getOptions();\n  }\n};\n/*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE */\nconst {\n  entries: lv,\n  setPrototypeOf: Zd,\n  isFrozen: xk,\n  getPrototypeOf: bk,\n  getOwnPropertyDescriptor: _k\n} = Object;\nlet {\n  freeze: oe,\n  seal: Re,\n  create: cv\n} = Object, {\n  apply: ic,\n  construct: sc\n} = typeof Reflect < "u" && Reflect;\noe || (oe = function(e) {\n  return e;\n});\nRe || (Re = function(e) {\n  return e;\n});\nic || (ic = function(e, t, n) {\n  return e.apply(t, n);\n});\nsc || (sc = function(e, t) {\n  return new e(...t);\n});\nconst Hs = le(Array.prototype.forEach), Ek = le(Array.prototype.lastIndexOf), Kd = le(Array.prototype.pop), xi = le(Array.prototype.push), Ok = le(Array.prototype.splice), ra = le(String.prototype.toLowerCase), rl = le(String.prototype.toString), Qd = le(String.prototype.match), bi = le(String.prototype.replace), Sk = le(String.prototype.indexOf), Tk = le(String.prototype.trim), Ue = le(Object.prototype.hasOwnProperty), ie = le(RegExp.prototype.test), _i = wk(TypeError);\nfunction le(e) {\n  return function(t) {\n    t instanceof RegExp && (t.lastIndex = 0);\n    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)\n      r[i - 1] = arguments[i];\n    return ic(e, t, r);\n  };\n}\nfunction wk(e) {\n  return function() {\n    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)\n      n[r] = arguments[r];\n    return sc(e, n);\n  };\n}\nfunction pt(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ra;\n  Zd && Zd(e, null);\n  let r = t.length;\n  for (; r--; ) {\n    let i = t[r];\n    if (typeof i == "string") {\n      const s = n(i);\n      s !== i && (xk(t) || (t[r] = s), i = s);\n    }\n    e[i] = !0;\n  }\n  return e;\n}\nfunction $k(e) {\n  for (let t = 0; t < e.length; t++)\n    Ue(e, t) || (e[t] = null);\n  return e;\n}\nfunction mn(e) {\n  const t = cv(null);\n  for (const [n, r] of lv(e))\n    Ue(e, n) && (Array.isArray(r) ? t[n] = $k(r) : r && typeof r == "object" && r.constructor === Object ? t[n] = mn(r) : t[n] = r);\n  return t;\n}\nfunction Ei(e, t) {\n  for (; e !== null; ) {\n    const r = _k(e, t);\n    if (r) {\n      if (r.get)\n        return le(r.get);\n      if (typeof r.value == "function")\n        return le(r.value);\n    }\n    e = bk(e);\n  }\n  function n() {\n    return null;\n  }\n  return n;\n}\nconst Jd = oe(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), il = oe(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), sl = oe(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), Mk = oe(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), al = oe(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), Ck = oe(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), tp = oe(["#text"]), ep = oe(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), ol = oe(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), np = oe(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Vs = oe(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), Ak = Re(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm), Lk = Re(/<%[\\w\\W]*|[\\w\\W]*%>/gm), kk = Re(/\\$\\{[\\w\\W]*/gm), Dk = Re(/^data-[\\-\\w.\\u00B7-\\uFFFF]+$/), Rk = Re(/^aria-[\\-\\w]+$/), uv = Re(\n  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i\n  // eslint-disable-line no-useless-escape\n), Ik = Re(/^(?:\\w+script|data):/i), Nk = Re(\n  /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g\n  // eslint-disable-line no-control-regex\n), hv = Re(/^html$/i), Pk = Re(/^[a-z][.\\w]*(-[.\\w]+)+$/i);\nvar rp = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  ARIA_ATTR: Rk,\n  ATTR_WHITESPACE: Nk,\n  CUSTOM_ELEMENT: Pk,\n  DATA_ATTR: Dk,\n  DOCTYPE_NAME: hv,\n  ERB_EXPR: Lk,\n  IS_ALLOWED_URI: uv,\n  IS_SCRIPT_OR_DATA: Ik,\n  MUSTACHE_EXPR: Ak,\n  TMPLIT_EXPR: kk\n});\nconst Oi = {\n  element: 1,\n  text: 3,\n  // Deprecated\n  progressingInstruction: 7,\n  comment: 8,\n  document: 9\n}, Uk = function() {\n  return typeof window > "u" ? null : window;\n}, Bk = function(e, t) {\n  if (typeof e != "object" || typeof e.createPolicy != "function")\n    return null;\n  let n = null;\n  const r = "data-tt-policy-suffix";\n  t && t.hasAttribute(r) && (n = t.getAttribute(r));\n  const i = "dompurify" + (n ? "#" + n : "");\n  try {\n    return e.createPolicy(i, {\n      createHTML(s) {\n        return s;\n      },\n      createScriptURL(s) {\n        return s;\n      }\n    });\n  } catch {\n    return console.warn("TrustedTypes policy " + i + " could not be created."), null;\n  }\n}, ip = function() {\n  return {\n    afterSanitizeAttributes: [],\n    afterSanitizeElements: [],\n    afterSanitizeShadowDOM: [],\n    beforeSanitizeAttributes: [],\n    beforeSanitizeElements: [],\n    beforeSanitizeShadowDOM: [],\n    uponSanitizeAttribute: [],\n    uponSanitizeElement: [],\n    uponSanitizeShadowNode: []\n  };\n};\nfunction dv() {\n  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Uk();\n  const t = (C) => dv(C);\n  if (t.version = "3.2.6", t.removed = [], !e || !e.document || e.document.nodeType !== Oi.document || !e.Element)\n    return t.isSupported = !1, t;\n  let {\n    document: n\n  } = e;\n  const r = n, i = r.currentScript, {\n    DocumentFragment: s,\n    HTMLTemplateElement: a,\n    Node: o,\n    Element: l,\n    NodeFilter: c,\n    NamedNodeMap: u = e.NamedNodeMap || e.MozNamedAttrMap,\n    HTMLFormElement: d,\n    DOMParser: h,\n    trustedTypes: p\n  } = e, f = l.prototype, g = Ei(f, "cloneNode"), m = Ei(f, "remove"), v = Ei(f, "nextSibling"), x = Ei(f, "childNodes"), _ = Ei(f, "parentNode");\n  if (typeof a == "function") {\n    const C = n.createElement("template");\n    C.content && C.content.ownerDocument && (n = C.content.ownerDocument);\n  }\n  let E, b = "";\n  const {\n    implementation: S,\n    createNodeIterator: M,\n    createDocumentFragment: D,\n    getElementsByTagName: A\n  } = n, {\n    importNode: R\n  } = r;\n  let $ = ip();\n  t.isSupported = typeof lv == "function" && typeof _ == "function" && S && S.createHTMLDocument !== void 0;\n  const {\n    MUSTACHE_EXPR: H,\n    ERB_EXPR: P,\n    TMPLIT_EXPR: B,\n    DATA_ATTR: O,\n    ARIA_ATTR: w,\n    IS_SCRIPT_OR_DATA: L,\n    ATTR_WHITESPACE: k,\n    CUSTOM_ELEMENT: U\n  } = rp;\n  let {\n    IS_ALLOWED_URI: Z\n  } = rp, j = null;\n  const F = pt({}, [...Jd, ...il, ...sl, ...al, ...tp]);\n  let Y = null;\n  const ot = pt({}, [...ep, ...ol, ...np, ...Vs]);\n  let Q = Object.seal(cv(null, {\n    tagNameCheck: {\n      writable: !0,\n      configurable: !1,\n      enumerable: !0,\n      value: null\n    },\n    attributeNameCheck: {\n      writable: !0,\n      configurable: !1,\n      enumerable: !0,\n      value: null\n    },\n    allowCustomizedBuiltInElements: {\n      writable: !0,\n      configurable: !1,\n      enumerable: !0,\n      value: !1\n    }\n  })), q = null, tt = null, lt = !0, z = !0, W = !1, X = !0, V = !1, ut = !0, st = !1, Dt = !1, Nt = !1, nt = !1, yt = !1, Se = !1, ge = !0, oi = !1;\n  const li = "user-content-";\n  let Fn = !0, Ie = !1, yr = {}, xr = null;\n  const xu = pt({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);\n  let bu = null;\n  const _u = pt({}, ["audio", "video", "img", "source", "image", "track"]);\n  let yo = null;\n  const Eu = pt({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), _s = "http://www.w3.org/1998/Math/MathML", Es = "http://www.w3.org/2000/svg", on = "http://www.w3.org/1999/xhtml";\n  let br = on, xo = !1, bo = null;\n  const n0 = pt({}, [_s, Es, on], rl);\n  let Os = pt({}, ["mi", "mo", "mn", "ms", "mtext"]), Ss = pt({}, ["annotation-xml"]);\n  const r0 = pt({}, ["title", "style", "font", "a", "script"]);\n  let ci = null;\n  const i0 = ["application/xhtml+xml", "text/html"], s0 = "text/html";\n  let qt = null, _r = null;\n  const a0 = n.createElement("form"), Ou = function(C) {\n    return C instanceof RegExp || C instanceof Function;\n  }, _o = function() {\n    let C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    if (!(_r && _r === C)) {\n      if ((!C || typeof C != "object") && (C = {}), C = mn(C), ci = // eslint-disable-next-line unicorn/prefer-includes\n      i0.indexOf(C.PARSER_MEDIA_TYPE) === -1 ? s0 : C.PARSER_MEDIA_TYPE, qt = ci === "application/xhtml+xml" ? rl : ra, j = Ue(C, "ALLOWED_TAGS") ? pt({}, C.ALLOWED_TAGS, qt) : F, Y = Ue(C, "ALLOWED_ATTR") ? pt({}, C.ALLOWED_ATTR, qt) : ot, bo = Ue(C, "ALLOWED_NAMESPACES") ? pt({}, C.ALLOWED_NAMESPACES, rl) : n0, yo = Ue(C, "ADD_URI_SAFE_ATTR") ? pt(mn(Eu), C.ADD_URI_SAFE_ATTR, qt) : Eu, bu = Ue(C, "ADD_DATA_URI_TAGS") ? pt(mn(_u), C.ADD_DATA_URI_TAGS, qt) : _u, xr = Ue(C, "FORBID_CONTENTS") ? pt({}, C.FORBID_CONTENTS, qt) : xu, q = Ue(C, "FORBID_TAGS") ? pt({}, C.FORBID_TAGS, qt) : mn({}), tt = Ue(C, "FORBID_ATTR") ? pt({}, C.FORBID_ATTR, qt) : mn({}), yr = Ue(C, "USE_PROFILES") ? C.USE_PROFILES : !1, lt = C.ALLOW_ARIA_ATTR !== !1, z = C.ALLOW_DATA_ATTR !== !1, W = C.ALLOW_UNKNOWN_PROTOCOLS || !1, X = C.ALLOW_SELF_CLOSE_IN_ATTR !== !1, V = C.SAFE_FOR_TEMPLATES || !1, ut = C.SAFE_FOR_XML !== !1, st = C.WHOLE_DOCUMENT || !1, nt = C.RETURN_DOM || !1, yt = C.RETURN_DOM_FRAGMENT || !1, Se = C.RETURN_TRUSTED_TYPE || !1, Nt = C.FORCE_BODY || !1, ge = C.SANITIZE_DOM !== !1, oi = C.SANITIZE_NAMED_PROPS || !1, Fn = C.KEEP_CONTENT !== !1, Ie = C.IN_PLACE || !1, Z = C.ALLOWED_URI_REGEXP || uv, br = C.NAMESPACE || on, Os = C.MATHML_TEXT_INTEGRATION_POINTS || Os, Ss = C.HTML_INTEGRATION_POINTS || Ss, Q = C.CUSTOM_ELEMENT_HANDLING || {}, C.CUSTOM_ELEMENT_HANDLING && Ou(C.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Q.tagNameCheck = C.CUSTOM_ELEMENT_HANDLING.tagNameCheck), C.CUSTOM_ELEMENT_HANDLING && Ou(C.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Q.attributeNameCheck = C.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), C.CUSTOM_ELEMENT_HANDLING && typeof C.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Q.allowCustomizedBuiltInElements = C.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), V && (z = !1), yt && (nt = !0), yr && (j = pt({}, tp), Y = [], yr.html === !0 && (pt(j, Jd), pt(Y, ep)), yr.svg === !0 && (pt(j, il), pt(Y, ol), pt(Y, Vs)), yr.svgFilters === !0 && (pt(j, sl), pt(Y, ol), pt(Y, Vs)), yr.mathMl === !0 && (pt(j, al), pt(Y, np), pt(Y, Vs))), C.ADD_TAGS && (j === F && (j = mn(j)), pt(j, C.ADD_TAGS, qt)), C.ADD_ATTR && (Y === ot && (Y = mn(Y)), pt(Y, C.ADD_ATTR, qt)), C.ADD_URI_SAFE_ATTR && pt(yo, C.ADD_URI_SAFE_ATTR, qt), C.FORBID_CONTENTS && (xr === xu && (xr = mn(xr)), pt(xr, C.FORBID_CONTENTS, qt)), Fn && (j["#text"] = !0), st && pt(j, ["html", "head", "body"]), j.table && (pt(j, ["tbody"]), delete q.tbody), C.TRUSTED_TYPES_POLICY) {\n        if (typeof C.TRUSTED_TYPES_POLICY.createHTML != "function")\n          throw _i(\'TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.\');\n        if (typeof C.TRUSTED_TYPES_POLICY.createScriptURL != "function")\n          throw _i(\'TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.\');\n        E = C.TRUSTED_TYPES_POLICY, b = E.createHTML("");\n      } else\n        E === void 0 && (E = Bk(p, i)), E !== null && typeof b == "string" && (b = E.createHTML(""));\n      oe && oe(C), _r = C;\n    }\n  }, Su = pt({}, [...il, ...sl, ...Mk]), Tu = pt({}, [...al, ...Ck]), o0 = function(C) {\n    let J = _(C);\n    (!J || !J.tagName) && (J = {\n      namespaceURI: br,\n      tagName: "template"\n    });\n    const K = ra(C.tagName), bt = ra(J.tagName);\n    return bo[C.namespaceURI] ? C.namespaceURI === Es ? J.namespaceURI === on ? K === "svg" : J.namespaceURI === _s ? K === "svg" && (bt === "annotation-xml" || Os[bt]) : !!Su[K] : C.namespaceURI === _s ? J.namespaceURI === on ? K === "math" : J.namespaceURI === Es ? K === "math" && Ss[bt] : !!Tu[K] : C.namespaceURI === on ? J.namespaceURI === Es && !Ss[bt] || J.namespaceURI === _s && !Os[bt] ? !1 : !Tu[K] && (r0[K] || !Su[K]) : !!(ci === "application/xhtml+xml" && bo[C.namespaceURI]) : !1;\n  }, jn = function(C) {\n    xi(t.removed, {\n      element: C\n    });\n    try {\n      _(C).removeChild(C);\n    } catch {\n      m(C);\n    }\n  }, Er = function(C, J) {\n    try {\n      xi(t.removed, {\n        attribute: J.getAttributeNode(C),\n        from: J\n      });\n    } catch {\n      xi(t.removed, {\n        attribute: null,\n        from: J\n      });\n    }\n    if (J.removeAttribute(C), C === "is")\n      if (nt || yt)\n        try {\n          jn(J);\n        } catch {\n        }\n      else\n        try {\n          J.setAttribute(C, "");\n        } catch {\n        }\n  }, wu = function(C) {\n    let J = null, K = null;\n    if (Nt)\n      C = "<remove></remove>" + C;\n    else {\n      const Pt = Qd(C, /^[\\r\\n\\t ]+/);\n      K = Pt && Pt[0];\n    }\n    ci === "application/xhtml+xml" && br === on && (C = \'<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>\' + C + "</body></html>");\n    const bt = E ? E.createHTML(C) : C;\n    if (br === on)\n      try {\n        J = new h().parseFromString(bt, ci);\n      } catch {\n      }\n    if (!J || !J.documentElement) {\n      J = S.createDocument(br, "template", null);\n      try {\n        J.documentElement.innerHTML = xo ? b : bt;\n      } catch {\n      }\n    }\n    const Xt = J.body || J.documentElement;\n    return C && K && Xt.insertBefore(n.createTextNode(K), Xt.childNodes[0] || null), br === on ? A.call(J, st ? "html" : "body")[0] : st ? J.documentElement : Xt;\n  }, $u = function(C) {\n    return M.call(\n      C.ownerDocument || C,\n      C,\n      // eslint-disable-next-line no-bitwise\n      c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT | c.SHOW_PROCESSING_INSTRUCTION | c.SHOW_CDATA_SECTION,\n      null\n    );\n  }, Eo = function(C) {\n    return C instanceof d && (typeof C.nodeName != "string" || typeof C.textContent != "string" || typeof C.removeChild != "function" || !(C.attributes instanceof u) || typeof C.removeAttribute != "function" || typeof C.setAttribute != "function" || typeof C.namespaceURI != "string" || typeof C.insertBefore != "function" || typeof C.hasChildNodes != "function");\n  }, Mu = function(C) {\n    return typeof o == "function" && C instanceof o;\n  };\n  function ln(C, J, K) {\n    Hs(C, (bt) => {\n      bt.call(t, J, K, _r);\n    });\n  }\n  const Cu = function(C) {\n    let J = null;\n    if (ln($.beforeSanitizeElements, C, null), Eo(C))\n      return jn(C), !0;\n    const K = qt(C.nodeName);\n    if (ln($.uponSanitizeElement, C, {\n      tagName: K,\n      allowedTags: j\n    }), ut && C.hasChildNodes() && !Mu(C.firstElementChild) && ie(/<[/\\w!]/g, C.innerHTML) && ie(/<[/\\w!]/g, C.textContent) || C.nodeType === Oi.progressingInstruction || ut && C.nodeType === Oi.comment && ie(/<[/\\w]/g, C.data))\n      return jn(C), !0;\n    if (!j[K] || q[K]) {\n      if (!q[K] && Lu(K) && (Q.tagNameCheck instanceof RegExp && ie(Q.tagNameCheck, K) || Q.tagNameCheck instanceof Function && Q.tagNameCheck(K)))\n        return !1;\n      if (Fn && !xr[K]) {\n        const bt = _(C) || C.parentNode, Xt = x(C) || C.childNodes;\n        if (Xt && bt) {\n          const Pt = Xt.length;\n          for (let cn = Pt - 1; cn >= 0; --cn) {\n            const Ne = g(Xt[cn], !0);\n            Ne.__removalCount = (C.__removalCount || 0) + 1, bt.insertBefore(Ne, v(C));\n          }\n        }\n      }\n      return jn(C), !0;\n    }\n    return C instanceof l && !o0(C) || (K === "noscript" || K === "noembed" || K === "noframes") && ie(/<\\/no(script|embed|frames)/i, C.innerHTML) ? (jn(C), !0) : (V && C.nodeType === Oi.text && (J = C.textContent, Hs([H, P, B], (bt) => {\n      J = bi(J, bt, " ");\n    }), C.textContent !== J && (xi(t.removed, {\n      element: C.cloneNode()\n    }), C.textContent = J)), ln($.afterSanitizeElements, C, null), !1);\n  }, Au = function(C, J, K) {\n    if (ge && (J === "id" || J === "name") && (K in n || K in a0))\n      return !1;\n    if (!(z && !tt[J] && ie(O, J)) && !(lt && ie(w, J))) {\n      if (!Y[J] || tt[J]) {\n        if (\n          // First condition does a very basic check if a) it\'s basically a valid custom element tagname AND\n          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n          !(Lu(C) && (Q.tagNameCheck instanceof RegExp && ie(Q.tagNameCheck, C) || Q.tagNameCheck instanceof Function && Q.tagNameCheck(C)) && (Q.attributeNameCheck instanceof RegExp && ie(Q.attributeNameCheck, J) || Q.attributeNameCheck instanceof Function && Q.attributeNameCheck(J)) || // Alternative, second condition checks if it\'s an `is`-attribute, AND\n          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n          J === "is" && Q.allowCustomizedBuiltInElements && (Q.tagNameCheck instanceof RegExp && ie(Q.tagNameCheck, K) || Q.tagNameCheck instanceof Function && Q.tagNameCheck(K)))\n        ) return !1;\n      } else if (!yo[J] && !ie(Z, bi(K, k, "")) && !((J === "src" || J === "xlink:href" || J === "href") && C !== "script" && Sk(K, "data:") === 0 && bu[C]) && !(W && !ie(L, bi(K, k, ""))) && K)\n        return !1;\n    }\n    return !0;\n  }, Lu = function(C) {\n    return C !== "annotation-xml" && Qd(C, U);\n  }, ku = function(C) {\n    ln($.beforeSanitizeAttributes, C, null);\n    const {\n      attributes: J\n    } = C;\n    if (!J || Eo(C))\n      return;\n    const K = {\n      attrName: "",\n      attrValue: "",\n      keepAttr: !0,\n      allowedAttributes: Y,\n      forceKeepAttr: void 0\n    };\n    let bt = J.length;\n    for (; bt--; ) {\n      const Xt = J[bt], {\n        name: Pt,\n        namespaceURI: cn,\n        value: Ne\n      } = Xt, Xe = qt(Pt), Oo = Ne;\n      let Qt = Pt === "value" ? Oo : Tk(Oo);\n      if (K.attrName = Xe, K.attrValue = Qt, K.keepAttr = !0, K.forceKeepAttr = void 0, ln($.uponSanitizeAttribute, C, K), Qt = K.attrValue, oi && (Xe === "id" || Xe === "name") && (Er(Pt, C), Qt = li + Qt), ut && ie(/((--!?|])>)|<\\/(style|title)/i, Qt)) {\n        Er(Pt, C);\n        continue;\n      }\n      if (K.forceKeepAttr)\n        continue;\n      if (!K.keepAttr) {\n        Er(Pt, C);\n        continue;\n      }\n      if (!X && ie(/\\/>/i, Qt)) {\n        Er(Pt, C);\n        continue;\n      }\n      V && Hs([H, P, B], (c0) => {\n        Qt = bi(Qt, c0, " ");\n      });\n      const Du = qt(C.nodeName);\n      if (!Au(Du, Xe, Qt)) {\n        Er(Pt, C);\n        continue;\n      }\n      if (E && typeof p == "object" && typeof p.getAttributeType == "function" && !cn)\n        switch (p.getAttributeType(Du, Xe)) {\n          case "TrustedHTML": {\n            Qt = E.createHTML(Qt);\n            break;\n          }\n          case "TrustedScriptURL": {\n            Qt = E.createScriptURL(Qt);\n            break;\n          }\n        }\n      if (Qt !== Oo)\n        try {\n          cn ? C.setAttributeNS(cn, Pt, Qt) : C.setAttribute(Pt, Qt), Eo(C) ? jn(C) : Kd(t.removed);\n        } catch {\n          Er(Pt, C);\n        }\n    }\n    ln($.afterSanitizeAttributes, C, null);\n  }, l0 = function C(J) {\n    let K = null;\n    const bt = $u(J);\n    for (ln($.beforeSanitizeShadowDOM, J, null); K = bt.nextNode(); )\n      ln($.uponSanitizeShadowNode, K, null), Cu(K), ku(K), K.content instanceof s && C(K.content);\n    ln($.afterSanitizeShadowDOM, J, null);\n  };\n  return t.sanitize = function(C) {\n    let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, K = null, bt = null, Xt = null, Pt = null;\n    if (xo = !C, xo && (C = "\x3c!--\x3e"), typeof C != "string" && !Mu(C))\n      if (typeof C.toString == "function") {\n        if (C = C.toString(), typeof C != "string")\n          throw _i("dirty is not a string, aborting");\n      } else\n        throw _i("toString is not a function");\n    if (!t.isSupported)\n      return C;\n    if (Dt || _o(J), t.removed = [], typeof C == "string" && (Ie = !1), Ie) {\n      if (C.nodeName) {\n        const Xe = qt(C.nodeName);\n        if (!j[Xe] || q[Xe])\n          throw _i("root node is forbidden and cannot be sanitized in-place");\n      }\n    } else if (C instanceof o)\n      K = wu("\x3c!----\x3e"), bt = K.ownerDocument.importNode(C, !0), bt.nodeType === Oi.element && bt.nodeName === "BODY" || bt.nodeName === "HTML" ? K = bt : K.appendChild(bt);\n    else {\n      if (!nt && !V && !st && // eslint-disable-next-line unicorn/prefer-includes\n      C.indexOf("<") === -1)\n        return E && Se ? E.createHTML(C) : C;\n      if (K = wu(C), !K)\n        return nt ? null : Se ? b : "";\n    }\n    K && Nt && jn(K.firstChild);\n    const cn = $u(Ie ? C : K);\n    for (; Xt = cn.nextNode(); )\n      Cu(Xt), ku(Xt), Xt.content instanceof s && l0(Xt.content);\n    if (Ie)\n      return C;\n    if (nt) {\n      if (yt)\n        for (Pt = D.call(K.ownerDocument); K.firstChild; )\n          Pt.appendChild(K.firstChild);\n      else\n        Pt = K;\n      return (Y.shadowroot || Y.shadowrootmode) && (Pt = R.call(r, Pt, !0)), Pt;\n    }\n    let Ne = st ? K.outerHTML : K.innerHTML;\n    return st && j["!doctype"] && K.ownerDocument && K.ownerDocument.doctype && K.ownerDocument.doctype.name && ie(hv, K.ownerDocument.doctype.name) && (Ne = "<!DOCTYPE " + K.ownerDocument.doctype.name + `>\n` + Ne), V && Hs([H, P, B], (Xe) => {\n      Ne = bi(Ne, Xe, " ");\n    }), E && Se ? E.createHTML(Ne) : Ne;\n  }, t.setConfig = function() {\n    let C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    _o(C), Dt = !0;\n  }, t.clearConfig = function() {\n    _r = null, Dt = !1;\n  }, t.isValidAttribute = function(C, J, K) {\n    _r || _o({});\n    const bt = qt(C), Xt = qt(J);\n    return Au(bt, Xt, K);\n  }, t.addHook = function(C, J) {\n    typeof J == "function" && xi($[C], J);\n  }, t.removeHook = function(C, J) {\n    if (J !== void 0) {\n      const K = Ek($[C], J);\n      return K === -1 ? void 0 : Ok($[C], K, 1)[0];\n    }\n    return Kd($[C]);\n  }, t.removeHooks = function(C) {\n    $[C] = [];\n  }, t.removeAllHooks = function() {\n    $ = ip();\n  }, t;\n}\nvar ou = dv();\nconst Gs = (e) => ou.sanitize(e, {\n  USE_PROFILES: {\n    html: !0,\n    svg: !0,\n    svgFilters: !0\n  }\n}), Hk = (e) => ou.sanitize(e, {\n  NAMESPACE: "http://www.w3.org/2000/svg",\n  USE_PROFILES: {\n    html: !0,\n    svg: !0,\n    svgFilters: !0\n  }\n}), en = (e) => ou.sanitize(e, { ALLOWED_TAGS: [] }), pv = class fv extends mt {\n  constructor() {\n    super(...arguments), this.type = "toolbar", this.renderType = rt.HTML;\n  }\n  init() {\n    const t = () => this.updateOverflowMenu(!1);\n    this.services.events.addEventListener(T.Toolbar.SHOW_OVERFLOW_MENU, () => {\n      this.renderOverflowMenu(), document.body.addEventListener("click", t);\n    }), this.services.events.addEventListener(T.Toolbar.HIDE_OVERFLOW_MENU, () => {\n      document.body.removeEventListener("click", t);\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(t = !0) {\n    const n = this.getComponentContainer({\n      ariaLabel: "toolbar"\n    }).attr("role", "group");\n    if (y(this.getOptions(), "data", "loading"))\n      n.html(""), this.overflowMenu = null;\n    else {\n      this.overflowMenu || (this.overflowMenu = n.append("div").attr(\n        "class",\n        "cds--overflow-menu-options cds--overflow-menu--flip cds--overflow-menu-options cds--overflow-menu--flip"\n      ).attr("tabindex", -1).html("<ul role=\'menu\'></ul>"));\n      const { buttonList: r, overflowMenuItemList: i } = this.getControlConfigs();\n      i && r.push(this.getOverflowButtonConfig());\n      const s = n.selectAll("div.toolbar-control").data(r, (l) => l.id);\n      s.exit().remove();\n      const a = s.enter().append("div").attr("class", "toolbar-control cds--overflow-menu cds--overflow-menu"), o = this;\n      a.merge(s).classed("disabled", (l) => l.shouldBeDisabled()).attr("role", "button").attr("aria-disabled", (l) => l.shouldBeDisabled()).attr("aria-label", (l) => l.title).html((l) => `\n\t\t\t<button\n\t\t\t\tclass="cds--overflow-menu__trigger cds--overflow-menu__trigger"\n\t\t\t\taria-haspopup="true" aria-expanded="false" id="${this.services.domUtils.generateElementIDString(\n        `control-${en(l.id)}`\n      )}" aria-label="${en(l.title)}">\n\t\t\t\t<svg focusable="false" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" class="cds--overflow-menu__icon cds--overflow-menu__icon" viewBox="0 0 32 32" aria-hidden="true">\n\t\t\t\t\t${Hk(l.iconSVG.content)}\n\t\t\t\t</svg>\n\t\t\t</button>`).each(function(l, c) {\n        I(this).select("svg").style("pointer-events", "none").style("will-change", "transform").style("width", l.iconSVG.width !== void 0 ? l.iconSVG.width : "20px").style("height", l.iconSVG.height !== void 0 ? l.iconSVG.height : "20px"), I(this).select("button").on("mouseover focus", function(u) {\n          const d = I(this);\n          d.classed("hovered", !0), o.services.events.dispatchEvent(T.Toolbar.SHOW_TOOLTIP, {\n            event: u,\n            hoveredElement: d,\n            content: l.title,\n            noWrap: !0,\n            placements: ["top", "bottom"]\n          });\n        }).on("mouseout blur", function() {\n          o.services.events.dispatchEvent(T.Toolbar.HIDE_TOOLTIP);\n        }).on("click", (u) => {\n          l.shouldBeDisabled() || o.triggerFunctionAndEvent(l, u, this);\n        }).on("keydown", (u) => {\n          u.key && u.key === "Enter" || u.key === " " ? (u.preventDefault(), o.triggerFunctionAndEvent(l, u, this)) : u.key && u.key === "ArrowLeft" ? o.focusOnPreviousEnabledToolbarItem(c) : u.key && u.key === "ArrowRight" && o.focusOnNextEnabledToolbarItem(c);\n        });\n      }), this.overflowButton = this.getComponentContainer().select(\n        `button.cds--overflow-menu__trigger#${this.services.domUtils.generateElementIDString(\n          "control-toolbar-overflow-menu"\n        )}`\n      );\n    }\n  }\n  renderOverflowMenu() {\n    const { overflowMenuItemList: t } = this.getControlConfigs(), n = this.overflowMenu.select("ul").selectAll("li.cds--overflow-menu-options__option").data(t, (i) => y(i, "id"));\n    n.exit().remove();\n    const r = n.enter().append("li").attr("id", (i) => this.services.domUtils.generateElementIDString(`control-${i.id}`)).attr("class", "cds--overflow-menu-options__option cds--overflow-menu-options__option").attr("role", "menuitem").attr("tabindex", 1);\n    r.append("button").attr("class", "cds--overflow-menu-options__btn cds--overflow-menu-options__btn"), r.merge(n).classed("cds--overflow-menu-options__option--disabled", (i) => i.shouldBeDisabled()).classed("cds--overflow-menu-options__option--disabled", (i) => i.shouldBeDisabled()).attr("aria-disabled", (i) => i.shouldBeDisabled()).selectAll("button").text((i) => i.title);\n  }\n  isOverflowMenuOpen() {\n    return this.overflowMenu.classed("is-open");\n  }\n  // show/hide overflow menu\n  updateOverflowMenu(t) {\n    this.overflowMenu && (this.overflowMenu.classed("is-open", t), this.overflowButton && (this.overflowButton.attr("aria-expanded", t), I(this.overflowButton.node().parentNode).classed("cds--overflow-menu--open", t).classed("cds--overflow-menu--open", t)), t ? this.services.events.dispatchEvent(T.Toolbar.SHOW_OVERFLOW_MENU) : this.services.events.dispatchEvent(T.Toolbar.HIDE_OVERFLOW_MENU));\n  }\n  // Toolbar controllers\n  focusOnPreviousEnabledToolbarItem(t) {\n    const n = this.getToolbarButtonItems();\n    let r = n.length;\n    for (let i = t - 1; i >= 0; i--)\n      if (!n[i].shouldBeDisabled()) {\n        r = i;\n        break;\n      }\n    if (r < n.length) {\n      const i = I(\n        `button#${this.services.domUtils.generateElementIDString(\n          `control-${n[r].id}`\n        )}`\n      ).node();\n      "focus" in i && i.focus();\n    }\n  }\n  focusOnNextEnabledToolbarItem(t) {\n    const n = this.getToolbarButtonItems();\n    let r = -1;\n    for (let i = t + 1; i < n.length; i++)\n      if (!n[i].shouldBeDisabled()) {\n        r = i;\n        break;\n      }\n    if (r > -1) {\n      const i = I(\n        `button#${this.services.domUtils.generateElementIDString(\n          `control-${n[r].id}`\n        )}`\n      ).node();\n      "focus" in i && i.focus();\n    }\n  }\n  focusOnPreviousEnabledMenuItem(t) {\n    const n = this.getOverflowMenuItems();\n    let r = n.length;\n    for (let i = t - 1; i >= 0; i--)\n      if (!n[i].shouldBeDisabled()) {\n        r = i;\n        break;\n      }\n    if (r < n.length) {\n      const i = I(\n        `#${this.services.domUtils.generateElementIDString(\n          `control-${n[r].id}`\n        )} button`\n      ).node();\n      "focus" in i && i.focus();\n    }\n  }\n  focusOnNextEnabledMenuItem(t) {\n    const n = this.getOverflowMenuItems();\n    let r = -1;\n    for (let i = t + 1; i < n.length; i++)\n      if (!n[i].shouldBeDisabled()) {\n        r = i;\n        break;\n      }\n    if (r > -1) {\n      const i = I(\n        `#${this.services.domUtils.generateElementIDString(\n          `control-${n[r].id}`\n        )} button`\n      ).node();\n      "focus" in i && i.focus();\n    }\n  }\n  toggleOverflowMenu(t) {\n    if (this.isOverflowMenuOpen())\n      this.updateOverflowMenu(!1);\n    else {\n      this.updateOverflowMenu(!0);\n      const n = this;\n      this.getOverflowMenuItems().forEach((r, i) => {\n        const s = I(\n          `#${this.services.domUtils.generateElementIDString(`control-${r.id}`)}`\n        );\n        s !== null && (s.on("click", () => {\n          n.triggerFunctionAndEvent(r, t, s.node()), n.updateOverflowMenu(!1);\n        }), s.on("keydown", (a) => {\n          a && a.key === "Enter" ? n.triggerFunctionAndEvent(r, t, s.node()) : a && a.key === "ArrowUp" ? n.focusOnPreviousEnabledMenuItem(i) : a && a.key === "ArrowDown" ? n.focusOnNextEnabledMenuItem(i) : a && a.key === "Escape" && n.updateOverflowMenu(!1), a.preventDefault();\n        }));\n      }), n.focusOnNextEnabledMenuItem(-1);\n    }\n    t && t.stopImmediatePropagation();\n  }\n  // Calls passed function && dispatches event\n  triggerFunctionAndEvent(t, n, r) {\n    typeof t.shouldBeDisabled == "function" && t.shouldBeDisabled() || (typeof t.clickFunction == "function" && t.clickFunction(n), this.services.events.dispatchEvent(T.Toolbar.BUTTON_CLICK, {\n      control: t,\n      event: n,\n      element: r\n    }));\n  }\n  getControlConfigs() {\n    const t = y(this.getOptions(), "toolbar", "numberOfIcons") - 1, n = y(this.getOptions(), "toolbar", "controls"), r = [], i = [], s = [];\n    return n.forEach((a) => {\n      let o = null;\n      if (a.type === _t.CUSTOM)\n        y(a, "id") === null && (a.id = `toolbar-button-${fv.buttonID++}`), y(a, "shouldBeDisabled") === null && (a.shouldBeDisabled = () => !1), o = a;\n      else {\n        const l = this.services.domUtils.isFullScreenMode();\n        a.type === _t.MAKE_FULLSCREEN && l ? a.type = _t.EXIT_FULLSCREEN : a.type === _t.EXIT_FULLSCREEN && !l && (a.type = _t.MAKE_FULLSCREEN), o = this.getControlConfigByType(a.type);\n      }\n      o && (o.text = a.text ? a.text : a.type, o.id.indexOf("toolbar-export") !== -1 ? r.push(o) : i.length < t ? y(o, "iconSVG", "content") === null ? s.push(o) : i.push(o) : s.push(o));\n    }), s.push(...r), s.length ? {\n      buttonList: i,\n      overflowMenuItemList: s\n    } : {\n      buttonList: i\n    };\n  }\n  getToolbarButtonItems() {\n    const { buttonList: t, overflowMenuItemList: n } = this.getControlConfigs();\n    return n && t.push(this.getOverflowButtonConfig()), t || [];\n  }\n  getOverflowMenuItems() {\n    const { overflowMenuItemList: t } = this.getControlConfigs();\n    return t || [];\n  }\n  // special button config for overflow button\n  getOverflowButtonConfig() {\n    const { moreOptions: t } = y(\n      this.model.getOptions(),\n      "locale",\n      "translations",\n      "toolbar"\n    );\n    return {\n      id: "toolbar-overflow-menu",\n      title: t,\n      shouldBeDisabled: () => !1,\n      iconSVG: {\n        content: `<circle cx="16" cy="8" r="2"></circle>\n\t\t\t\t<circle cx="16" cy="16" r="2"></circle>\n\t\t\t\t<circle cx="16" cy="24" r="2"></circle>`\n      },\n      clickFunction: (n) => this.toggleOverflowMenu(n)\n    };\n  }\n  getControlConfigByType(t) {\n    const n = this.services.zoom && this.services.zoom.isZoomBarEnabled() && !this.services.zoom.isEmptyState(), r = this.model.getDisplayData(), i = this.model.getOptions(), {\n      exportAsCSV: s,\n      exportAsJPG: a,\n      exportAsPNG: o,\n      zoomIn: l,\n      zoomOut: c,\n      resetZoom: u,\n      makeFullScreen: d,\n      exitFullScreen: h,\n      showAsTable: p\n    } = y(i, "locale", "translations", "toolbar");\n    let f;\n    switch (t) {\n      case _t.ZOOM_IN:\n        n && (f = {\n          id: "toolbar-zoomIn",\n          title: l,\n          shouldBeDisabled: () => this.services.zoom.isMinZoomDomain(),\n          iconSVG: {\n            content: this.getControlIconByType(t)\n          },\n          clickFunction: () => this.services.zoom.zoomIn()\n        });\n        break;\n      case _t.ZOOM_OUT:\n        n && (f = {\n          id: "toolbar-zoomOut",\n          title: c,\n          shouldBeDisabled: () => this.services.zoom.isMaxZoomDomain(),\n          iconSVG: {\n            content: this.getControlIconByType(t)\n          },\n          clickFunction: () => this.services.zoom.zoomOut()\n        });\n        break;\n      case _t.RESET_ZOOM:\n        n && (f = {\n          id: "toolbar-resetZoom",\n          title: u,\n          shouldBeDisabled: () => this.services.zoom.isMaxZoomDomain(),\n          iconSVG: {\n            content: this.getControlIconByType(t)\n          },\n          clickFunction: () => this.services.zoom.resetZoomDomain()\n        });\n        break;\n      case _t.MAKE_FULLSCREEN:\n        f = {\n          id: "toolbar-makefullscreen",\n          iconSVG: {\n            content: this.getControlIconByType(t),\n            width: "15px",\n            height: "15px"\n          },\n          title: d,\n          shouldBeDisabled: () => !1,\n          clickFunction: () => {\n            this.services.domUtils.toggleFullscreen();\n          }\n        };\n        break;\n      case _t.EXIT_FULLSCREEN:\n        f = {\n          id: "toolbar-exitfullscreen",\n          iconSVG: {\n            content: this.getControlIconByType(t),\n            width: "15px",\n            height: "15px"\n          },\n          title: h,\n          shouldBeDisabled: () => !1,\n          clickFunction: () => {\n            this.services.domUtils.toggleFullscreen();\n          }\n        };\n        break;\n      case _t.SHOW_AS_DATATABLE:\n        f = {\n          id: "toolbar-showasdatatable",\n          iconSVG: {\n            content: this.getControlIconByType(t)\n          },\n          title: p,\n          shouldBeDisabled: () => r.length === 0,\n          clickFunction: () => this.services.events.dispatchEvent(T.Modal.SHOW)\n        };\n        break;\n      case _t.EXPORT_CSV:\n        f = {\n          id: "toolbar-export-CSV",\n          title: s,\n          shouldBeDisabled: () => !1,\n          iconSVG: {\n            content: this.getControlIconByType(t)\n          },\n          clickFunction: () => this.model.exportToCSV()\n        };\n        break;\n      case _t.EXPORT_PNG:\n        f = {\n          id: "toolbar-export-PNG",\n          title: o,\n          shouldBeDisabled: () => !1,\n          iconSVG: {\n            content: this.getControlIconByType(t)\n          },\n          clickFunction: () => this.services.domUtils.exportToPNG()\n        };\n        break;\n      case _t.EXPORT_JPG:\n        f = {\n          id: "toolbar-export-JPG",\n          title: a,\n          shouldBeDisabled: () => !1,\n          iconSVG: {\n            content: this.getControlIconByType(t)\n          },\n          clickFunction: () => this.services.domUtils.exportToJPG()\n        };\n        break;\n      // add more toolbar control configuration here\n      default:\n        throw Error("Not supported toolbar control type: " + t);\n    }\n    return f;\n  }\n  getControlIconByType(t) {\n    switch (t) {\n      case _t.ZOOM_IN:\n        return `<polygon points="19 13 15 13 15 9 13 9 13 13 9 13 9 15 13 15 13 19 15 19 15 15 19 15 19 13"/>\n\t\t\t\t\t\t<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>`;\n      case _t.ZOOM_OUT:\n        return `<rect x="9" y="13" width="10" height="2"/>\n\t\t\t\t\t\t<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>`;\n      case _t.RESET_ZOOM:\n        return \'<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>\';\n      case _t.MAKE_FULLSCREEN:\n        return \'<polygon points="21 2 21 4 26.59 4 17 13.58 18.41 15 28 5.41 28 11 30 11 30 2 21 2"/><polygon points="15 18.42 13.59 17 4 26.59 4 21 2 21 2 30 11 30 11 28 5.41 28 15 18.42"/>\';\n      case _t.EXIT_FULLSCREEN:\n        return \'<polygon points="4 18 4 20 10.586 20 2 28.582 3.414 30 12 21.414 12 28 14 28 14 18 4 18"/><polygon points="30 3.416 28.592 2 20 10.586 20 4 18 4 18 14 28 14 28 12 21.414 12 30 3.416"/>\';\n      case _t.SHOW_AS_DATATABLE:\n        return \'<rect x="4" y="6" width="18" height="2"/><rect x="4" y="12" width="18" height="2"/><rect x="4" y="18" width="18" height="2"/><rect x="4" y="24" width="18" height="2"/><rect x="26" y="6" width="2" height="2"/><rect x="26" y="12" width="2" height="2"/><rect x="26" y="18" width="2" height="2"/><rect x="26" y="24" width="2" height="2"/>\';\n      case _t.EXPORT_CSV:\n        return \'<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>\';\n      case _t.EXPORT_JPG:\n        return \'<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>\';\n      case _t.EXPORT_PNG:\n        return \'<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>\';\n      // add more icons here\n      // svg icon must be with 32x32 viewBox\n      default:\n        throw Error("Not supported toolbar control type: " + t);\n    }\n  }\n};\npv.buttonID = 0;\nlet po = pv;\nconst mv = class gv extends mt {\n  constructor(t, n, r, i) {\n    super(t, n, i), this.type = "layout", this.configs = i, this.children = r, this._instanceID = gv.instanceID++, this.init();\n  }\n  init() {\n    this.children.forEach((t) => {\n      t.components.forEach((n) => {\n        n.init();\n      });\n    });\n  }\n  getPreferedAndFixedSizeSum() {\n    const t = this.parent;\n    let n = 0;\n    return t.selectAll(`div.layout-child-${this._instanceID}`).filter((r) => {\n      const i = y(r, "growth");\n      return i === ct.PREFERRED || i === ct.FIXED;\n    }).each(function(r) {\n      n += r.size;\n    }), n;\n  }\n  getNumOfStretchChildren() {\n    return this.parent.selectAll(`div.layout-child-${this._instanceID}`).filter((t) => y(t, "growth") === ct.STRETCH).size();\n  }\n  render(t = !0) {\n    const n = this.model.getOptions(), r = this.parent, { width: i, height: s } = N.getHTMLElementSize(r.node()), a = this.configs.direction === At.ROW || this.configs.direction === At.ROW_REVERSE, o = y(this.model.getOptions(), "style", "prefix"), l = r.classed(\n      `${ue}--${o}--layout-row`,\n      this.configs.direction === At.ROW\n    ).classed(\n      `${ue}--${o}--layout-row-reverse`,\n      this.configs.direction === At.ROW_REVERSE\n    ).classed(\n      `${ue}--${o}--layout-column`,\n      this.configs.direction === At.COLUMN\n    ).classed(\n      `${ue}--${o}--layout-column-reverse`,\n      this.configs.direction === At.COLUMN_REVERSE\n    ).classed(\n      `${ue}--${o}--layout-alignitems-center`,\n      this.configs.alignItems === ni.CENTER\n    ).selectAll(`div.layout-child-${this._instanceID}`).data(this.children, (u) => u.id);\n    l.enter().append("div").merge(r.selectAll(`div.layout-child-${this._instanceID}`)).attr("class", (u) => `layout-child layout-child-${this._instanceID} ${u.id}`).each(function(u) {\n      u.components.forEach((d) => {\n        var h;\n        const p = I(this), f = y(u, "renderType") === rt.SVG;\n        d.setParent(\n          f ? N.appendOrSelect(p, "svg.layout-svg-wrapper").attr("width", "100%").attr("height", "100%") : p\n        ), f && !p.select("svg.layout-svg-wrapper").attr("aria-label") && p.select("svg.layout-svg-wrapper").attr("aria-label", ((h = n == null ? void 0 : n.accessibility) == null ? void 0 : h.svgAriaLabel) || (n == null ? void 0 : n.title));\n        const g = y(u, "growth");\n        (g === ct.PREFERRED || g === ct.FIXED) && d.render(t);\n      });\n    }), r.selectAll(`div.layout-child-${this._instanceID}`).style("height", null).style("width", null).each(function(u) {\n      const d = y(u, "growth"), h = y(u, "renderType") === rt.SVG ? N.getSVGElementSize(I(this).select("svg.layout-svg-wrapper"), {\n        useBBox: !0\n      }) : N.getHTMLElementSize(this);\n      if (d === ct.PREFERRED) {\n        const p = a ? h.width : h.height, f = a ? i : s;\n        u.size = p / f * 100;\n      }\n    }), l.exit().remove(), this.children.filter((u) => y(u, "growth") === ct.STRETCH).forEach((u) => {\n      u.size = (100 - +this.getPreferedAndFixedSizeSum()) / +this.getNumOfStretchChildren();\n    });\n    const c = r.selectAll(`div.layout-child-${this._instanceID}`).data(this.children, (u) => u.id);\n    a ? c.style("width", (u) => `${u.size / 100 * i}px`).style("height", "100%") : c.style("height", (u) => `${u.size / 100 * s}px`).style("width", "100%"), c.each(function(u) {\n      u.components.forEach((d) => {\n        y(u, "growth") === ct.STRETCH && d.render(t);\n      });\n    });\n  }\n  // Pass on model to children as well\n  setModel(t) {\n    super.setModel(t), this.children.forEach((n) => {\n      n.components.forEach((r) => r.setModel(t));\n    });\n  }\n  // Pass on essentials to children as well\n  setServices(t) {\n    super.setServices(t), this.children.forEach((n) => {\n      n.components.forEach((r) => r.setServices(t));\n    });\n  }\n  destroy() {\n    this.children.forEach((t) => {\n      t.components.forEach((n) => n.destroy());\n    });\n  }\n};\nmv.instanceID = Math.floor(Math.random() * 99999999999);\nlet be = mv;\nclass An extends mt {\n  constructor() {\n    super(...arguments), this.type = "spacer";\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(t = !1) {\n    this.getComponentContainer({\n      isPresentational: !0\n    }).style("width", `${this.configs.size || Rh.default.size}px`).style("height", `${this.configs.size || Rh.default.size}px`).attr("opacity", 0);\n  }\n}\nclass fo extends mt {\n  constructor(t, n, r) {\n    super(t, n, r), this.type = "modal", this.isEventListenerAdded = !1, this.handleShowModal = () => {\n      const i = this.services.domUtils.getChartID();\n      this.modal.attr("data-modal", !0).attr("class", "cds--modal").attr("role", "dialog").attr("aria-modal", !0).attr("aria-labelledby", `${i}__modal-title`).attr("aria-describedby", `${i}__modal-description`).attr("tabindex", -1).style("opacity", 1).style("visibility", "visible"), this.modal.html(this.getModalHTML()), this.modal.select("div.cds--modal-footer button.cds--btn").on("click", () => this.model.exportToCSV()), this.modal.on("click", this.handleHideModal), this.modal.select(".cds--modal-container").on("click", (s) => {\n        s.stopPropagation();\n      }), this.modal.select(".cds--modal-close").on("click", this.handleHideModal), typeof window < "u" && window.addEventListener("keydown", this.handleEscapeKey);\n    }, this.handleEscapeKey = (i) => {\n      i.key === "Escape" && this.handleHideModal();\n    }, this.handleHideModal = () => {\n      this.modal.attr("role", null).attr("aria-modal", null).attr("aria-labelledby", null).attr("aria-describedby", null).attr("tabindex", null).style("opacity", 0).style("visibility", "hidden"), this.modal.on("click", null), this.modal.select(".cds--modal-container").on("click", null), this.modal.select(".cds--modal-close").on("click", null), typeof window < "u" && window.removeEventListener("keydown", this.handleEscapeKey);\n    }, this.init();\n  }\n  addEventListeners() {\n    this.services.events.addEventListener(T.Modal.SHOW, this.handleShowModal);\n  }\n  removeEventListeners() {\n    this.services.events.removeEventListener(T.Modal.SHOW, this.handleShowModal);\n  }\n  getModalHTML() {\n    const t = this.services.domUtils.getChartID(), n = this.model.getOptions(), { title: r, downloadAsCSV: i } = y(n, "locale", "translations", "tabularRep"), s = y(n, "style", "prefix"), a = this.model.getTabularDataArray();\n    return `\n\t\t<div class="cds--modal-container">\n\t\t\t<div class="cds--modal-header">\n\n\t\t\t\t<p class="cds--modal-header__label cds--type-delta" id="modal-title">${r}</p>\n\n\t\t\t\t<p class="cds--modal-header__heading cds--type-beta" id="${t}__modal-description">${en(\n      n.title\n    )}</p>\n\n\t\t\t\t<button class="cds--modal-close" type="button" data-modal-close aria-label="close modal"  data-modal-primary-focus>\n\t\t\t\t\t<svg focusable="false" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" fill="currentColor" aria-label="Close" width="20" height="20" viewBox="0 0 32 32" role="img" class="cds--modal-close__icon">\n\t\t\t\t\t\t<path d="M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z"></path>\n\t\t\t\t\t</svg>\n\t\t\t\t</button>\n\t\t\t</div>\n\n\t\t\t<div class="cds--modal-content">\n\t\t\t\t<table class="cds--data-table cds--data-table--no-border">\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t${gt(a, 0).map(\n      (o) => `<th scope="col">\n\t\t\t\t\t\t\t\t<div class="cds--table-header-label">${en(o)}</div>\n\t\t\t\t\t\t\t</th>`\n    ).join("")}\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>${a.slice(1).map(\n      (o) => `\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t${o.map((l) => `<td>${en(l)}</td>`).join("")}\n\t\t\t\t\t\t\t</tr>`\n    ).join("")}\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\n\t\t\t<div class="cds--modal-footer">\n\t\t\t  <div class="${ue}--${s}-modal-footer-spacer"></div>\n\t\t\t  <button class="cds--btn cds--btn--primary" type="button" data-modal-primary-focus>${i}</button>\n\t\t\t</div>\n\t\t</div>`;\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(t = !1) {\n    const n = this.model.getOptions();\n    if (!this.isEventListenerAdded) {\n      const r = I(this.services.domUtils.getHolder()), i = y(n, "style", "prefix");\n      this.modal = N.appendOrSelect(r, `div.${ue}--${i}--modal`), this.addEventListeners(), this.isEventListenerAdded = !0;\n    }\n  }\n  destroy() {\n    this.removeEventListeners(), this.isEventListenerAdded = !1;\n  }\n}\nclass bs extends mt {\n  constructor() {\n    super(...arguments), this.type = "title", this.renderType = rt.HTML;\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(t = !1) {\n    const n = this.getComponentContainer(), r = y(this.getOptions(), "title"), i = n.selectAll("p.title").data([r]);\n    if (i.enter().append("p").classed("title", !0).attr("role", "heading").attr("aria-level", 2).merge(i).html((s) => en(s)), i.node() && i.node().offsetWidth < i.node().scrollWidth) {\n      const s = this;\n      i.on("mouseover", function(a) {\n        s.services.events.dispatchEvent(T.Tooltip.SHOW, {\n          event: a,\n          hoveredElement: i,\n          content: i.text()\n        });\n      }).on("mousemove", function(a) {\n        s.services.events.dispatchEvent(T.Tooltip.MOVE, {\n          event: a\n        });\n      }).on("mouseout", function() {\n        s.services.events.dispatchEvent(T.Tooltip.HIDE);\n      });\n    }\n    i.exit().remove();\n  }\n  /**\n   * Truncates title creating ellipses and attaching tooltip for exposing full title.\n   */\n  truncateTitle(t, n) {\n    if (n <= 0)\n      return;\n    const r = t.text();\n    if (t.node().getComputedTextLength() > n) {\n      t.append("tspan").text("...");\n      const i = N.appendOrSelect(t, "tspan").node().getComputedTextLength(), s = t.text(), a = this.getSubstringIndex(\n        t.node(),\n        0,\n        s.length - 1,\n        n - i\n      );\n      t.html(s.substring(0, a - 1)).append("tspan").text("...");\n      const o = this;\n      t.on("mouseover", function(l) {\n        o.services.events.dispatchEvent(T.Tooltip.SHOW, {\n          event: l,\n          hoveredElement: t,\n          content: r\n        });\n      }).on("mousemove", function(l) {\n        o.services.events.dispatchEvent(T.Tooltip.MOVE, {\n          event: l\n        });\n      }).on("mouseout", function() {\n        o.services.events.dispatchEvent(T.Tooltip.HIDE);\n      });\n    }\n  }\n  // computes the maximum space a title can take\n  getMaxTitleWidth() {\n    return N.getSVGElementSize(this.parent.node(), {\n      useAttrs: !0\n    }).width;\n  }\n  /**\n   * Returns the index for a maximum length substring that is less than the width parameter.\n   * @param title the title node used for getting the text lengths of substrings\n   * @param start the start index for the binary search\n   * @param end the end index for the binary search\n   * @param width the width of the svg container that holds the title\n   */\n  getSubstringIndex(t, n, r, i) {\n    const s = Math.floor((r + n) / 2);\n    return t.getSubStringLength(0, s) > i ? this.getSubstringIndex(t, n, s, i) : t.getSubStringLength(0, s) < i ? t.getSubStringLength(0, s + 1) > i ? s : this.getSubstringIndex(t, s, r, i) : s;\n  }\n}\nclass lu extends mt {\n  constructor() {\n    super(...arguments), this.type = "legend", this.renderType = rt.HTML;\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(t = !1) {\n    const n = this.getOptions(), r = y(n, "legend"), i = y(r, "alignment"), s = y(n, "legend", "orientation");\n    let a = this.model.getDataGroups();\n    const { DISABLED: o } = It.items.status, l = a.some((x) => x.status === o), c = y(r, "order"), u = this.getComponentContainer().classed("center-aligned", i === jt.CENTER).classed("right-aligned", i === jt.RIGHT).classed(s, !0).classed("has-deactivated-items", l).attr("role", ht.GROUP).attr("aria-label", "Data groups").attr("data-name", "legend-items");\n    c && (a = this.sortDataGroups(a, c));\n    const d = u.selectAll("div.legend-item").data(a, (x) => x.name), h = d.enter().append("div").attr("class", "legend-item");\n    h.merge(u.selectAll("div.legend-item")).classed("active", function(x) {\n      return x.status === It.items.status.ACTIVE;\n    });\n    const p = y(this.getOptions(), "legend", "clickable");\n    u.classed("clickable", p && a.length > 1);\n    const f = It.checkbox.radius, g = h.append("div").classed("checkbox", !0), m = g.merge(d.select("div.checkbox")).attr("role", ht.CHECKBOX).attr("tabindex", p ? 0 : -1).attr(\n      "aria-labelledby",\n      (x, _) => this.services.domUtils.generateElementIDString(`legend-datagroup-${_}-title`)\n    ).attr("aria-checked", ({ status: x }) => x === It.items.status.ACTIVE).attr("width", f * 2).attr("height", f * 2).attr(\n      "class",\n      (x) => this.model.getColorClassName({\n        classNameTypes: [it.BACKGROUND],\n        dataGroupName: x.name,\n        originalClassName: "checkbox"\n      })\n    ).style(\n      "background",\n      (x) => x.status === It.items.status.ACTIVE ? this.model.getFillColor(x.name) || this.model.getStrokeColor(x.name) : null\n    ).classed("active", function(x) {\n      return x.status === It.items.status.ACTIVE;\n    });\n    g.append("svg").attr("focusable", !1).attr("preserveAspectRatio", "xMidYMid meet").attr("xmlns", "http://www.w3.org/2000/svg").attr("width", "11").attr("height", "11").attr("viewBox", "0 0 31 28").attr("aria-hidden", !0).style("will-change", "transform").append("path").attr("d", "M13 21.2l-7.1-7.1-1.4 1.4 7.1 7.1L13 24 27.1 9.9l-1.4-1.5z"), h.append("p").merge(d.select("p"));\n    const v = y(n, "legend", "additionalItems");\n    if (v && a.length) {\n      const x = this, _ = u.selectAll("div.additional-item").data(v);\n      _.exit().remove();\n      const E = _.enter().append("div").merge(_).classed("legend-item", !0).classed("additional", !0).attr(\n        "aria-labelledby",\n        (M, D) => this.services.domUtils.generateElementIDString(\n          `legend-datagroup-${m.size() + D}-title`\n        )\n      );\n      E.selectAll("*").remove();\n      let b, S = 1;\n      E.append("svg").classed("icon", !0).each(function(M) {\n        const D = I(this);\n        !b || b != M.type ? (b = M.type, S = 1) : S++, x.addAdditionalItem(D, M, S);\n      }), E.append("p").merge(E.select("p")), this.truncateLegendText();\n    }\n    d.exit().on("mouseover", null).on("click", null).on("mouseout", null).remove(), p && h.size() > 1 && this.addEventListeners();\n  }\n  sortDataGroups(t, n) {\n    if (t.sort(\n      (r, i) => n.indexOf(r.name) - n.indexOf(i.name)\n    ), n.length < t.length) {\n      const r = t.length - n.length;\n      return t.slice(r).concat(t.slice(0, r));\n    }\n    return t;\n  }\n  addAdditionalItem(t, n, r) {\n    const { width: i, height: s } = It.area;\n    if (n.type === Gt.RADIUS ? t.style("width", `${s}px`).style("height", `${s}px`) : t.style("width", `${i}px`).style("height", `${s}px`), n.type === Gt.RADIUS) {\n      const { iconData: a, fill: o, stroke: l } = It.radius;\n      t.attr("fill", "none").selectAll("circle").data(a).enter().append("circle").classed("radius", !0).attr("role", ht.IMG).attr("aria-label", "radius").attr("cx", (c) => c.cx).attr("cy", (c) => c.cy).attr("r", (c) => c.r).style("fill", n.fill ? n.fill : o).style("stroke", n.stroke ? n.stroke : l);\n    } else if (n.type === Gt.LINE) {\n      const a = It.line;\n      t.select("line.line").empty() && t.append("line").classed(`line-${r}`, !0).attr("role", ht.IMG).attr("aria-label", "line").attr("x1", 0).attr("y1", a.yPosition).attr("x2", i).attr("y2", a.yPosition).style("stroke", n.stroke ? n.stroke : a.stroke).style("stroke-width", a.strokeWidth);\n    } else if (n.type === Gt.AREA)\n      t.select("rect.area").empty() && t.append("rect").classed(`area-${r}`, !0).attr("role", ht.IMG).attr("aria-label", "area").attr("width", i).attr("height", s).style(\n        "fill",\n        r > 3 && !n.fill ? It.area.fill : n.fill\n      ).style("stroke", n.stroke);\n    else if (n.type === Gt.SIZE) {\n      const { iconData: a, fill: o, stroke: l } = It.size;\n      t.attr("fill", "none").attr("role", ht.IMG).attr("aria-label", "size").selectAll("rect").data(a).enter().append("rect").classed("size", !0).attr("width", (c) => c.width).attr("height", (c) => c.height).attr("y", () => 0).style("fill", n.fill ? n.fill : o).style("stroke", n.stroke ? n.stroke : l).style("stroke-width", 1);\n    } else if (n.type === Gt.QUARTILE) {\n      const { iconData: a } = It.quartile;\n      t.selectAll("rect").attr("role", ht.IMG).attr("aria-label", "quartile").data(a).enter().append("rect").attr("class", (o, l) => `quartile-${l === 0 ? "wrapper" : "line"}`).attr("x", (o) => o.x).attr("y", (o) => o.y).attr("width", (o) => o.width).attr("height", (o) => o.height);\n    } else if (n.type === Gt.ZOOM) {\n      const { iconData: a, color: o } = y(It, "zoom"), l = t.attr("role", ht.IMG).attr("aria-label", "zoom").selectAll("g.icon").data(a).enter();\n      l.append("g").attr("x", (c) => c.x).attr("y", (c) => c.y).attr("width", (c) => c.width).attr("height", (c) => c.height).append("polygon").attr(\n        "points",\n        "7.7 4.82 5.78 4.82 5.78 2.89 4.82 2.89 4.82 4.82 2.89 4.82 2.89 5.78 4.82 5.78 4.82 7.7 5.78 7.7 5.78 5.78 7.7 5.78 7.7 4.82"\n      ).attr("fill", () => n.color ? n.color : o), l.append("path").attr(\n        "d",\n        "M9.36,8.67A5.22,5.22,0,0,0,10.59,5.3,5.3,5.3,0,1,0,5.3,10.59,5.22,5.22,0,0,0,8.67,9.36L12.32,13l.68-.68Zm-4.06,1A4.34,4.34,0,1,1,9.63,5.3,4.33,4.33,0,0,1,5.3,9.63Z"\n      ).attr("fill", () => n.color ? n.color : o);\n    }\n  }\n  truncateLegendText() {\n    const t = this.getComponentContainer(), n = y(this.getOptions(), "legend", "truncation"), r = y(n, "type"), i = y(n, "threshold"), s = y(n, "numCharacter"), a = t.selectAll("div.legend-item p");\n    a.attr("id", function() {\n      return (this.parentNode.querySelector("div.checkbox") || this.parentNode).getAttribute("aria-labelledby");\n    }), r !== Ve.NONE ? a.html(function(o) {\n      const l = en(o.name);\n      return l.length > i && l.length !== s ? es(l, r, s) : l;\n    }) : a.html((o) => en(o.name));\n  }\n  addEventListeners() {\n    const t = this, n = this.getComponentContainer(), r = this.getOptions(), i = y(r, "legend"), s = y(i, "truncation");\n    n.selectAll("div.legend-item").on("mouseover", function(a) {\n      t.services.events.dispatchEvent(T.Legend.ITEM_HOVER, {\n        hoveredElement: I(this)\n      });\n      const o = I(this);\n      o.select("div.checkbox").classed("hovered", !0);\n      const l = o.datum();\n      l.name.length > s.threshold && s.numCharacter < l.name.length && s.type !== Ve.NONE && t.services.events.dispatchEvent(T.Tooltip.SHOW, {\n        event: a,\n        hoveredElement: o,\n        content: l.name\n      });\n    }).on("mousemove", function(a) {\n      I(this).datum().name.length > s.threshold && s.type !== Ve.NONE && t.services.events.dispatchEvent(T.Tooltip.MOVE, {\n        event: a\n      });\n    }).on("click", function() {\n      t.services.events.dispatchEvent(T.Legend.ITEM_CLICK, {\n        clickedElement: I(this)\n      });\n      const a = I(this).datum();\n      t.model.toggleDataLabel(a.name);\n    }).on("mouseout", function() {\n      const a = I(this);\n      a.select("div.checkbox").classed("hovered", !1), a.datum().name.length > s.threshold && s.type !== Ve.NONE && t.services.events.dispatchEvent(T.Tooltip.HIDE), t.services.events.dispatchEvent(T.Legend.ITEM_MOUSEOUT, {\n        hoveredElement: a\n      });\n    }), n.selectAll("div.legend-item div.checkbox").on("keyup", function(a) {\n      a.key && a.key === "Tab" && t.services.events.dispatchEvent(T.Legend.ITEM_HOVER, {\n        hoveredElement: I(this)\n      });\n    }), n.selectAll("div.legend-item div.checkbox").on("keydown", function(a, o) {\n      a.key && a.key === " " ? (a.preventDefault(), t.model.toggleDataLabel(o.name)) : a.key && a.key === "Tab" && t.services.events.dispatchEvent(T.Legend.ITEM_MOUSEOUT, {\n        hoveredElement: I(this)\n      });\n    }), n.selectAll("g.additional-item").on("mouseover", function(a) {\n      const o = I(this), l = o.datum();\n      l.name.length > s.threshold && t.services.events.dispatchEvent(T.Tooltip.SHOW, {\n        event: a,\n        hoveredElement: o,\n        content: l.name\n      });\n    });\n  }\n}\nclass vv extends mt {\n  constructor(t, n, r) {\n    super(t, n, r), this.type = "chart-clip", this.renderType = rt.SVG, this.chartClipId = "chart-clip-id-" + Math.floor(Math.random() * 99999999999), this.init();\n  }\n  init() {\n    this.model.set({ chartClipId: this.chartClipId }, { skipUpdate: !0 });\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(t = !0) {\n    this.createClipPath();\n  }\n  createClipPath() {\n    const t = this.parent, { cartesianScales: n } = this.services;\n    if (!n) throw new Error("Service cartesianScales was undefined");\n    const r = n.getMainXScale(), i = n.getMainYScale(), [s, a] = r.range(), [o, l] = i.range();\n    if (!t)\n      throw new Error("svg is undefined");\n    this.chartClipPath = N.appendOrSelect(\n      t,\n      `clipPath.${this.type}`\n    ).attr("id", this.chartClipId);\n    const c = N.appendOrSelect(this.chartClipPath, `rect.${this.type}`);\n    a - s > 0 && c.attr("x", s).attr("y", l).attr("width", a - s).attr("height", o - l), this.chartClipPath.merge(c).lower();\n  }\n}\nclass Vk extends vv {\n  constructor() {\n    super(...arguments), this.type = "canvas-chart-clip", this.chartClipId = "canvas-chart-clip-id-" + Math.floor(Math.random() * 99999999999);\n  }\n  createClipPath() {\n    const t = this.parent, { width: n, height: r } = N.getSVGElementSize(this.parent, {\n      useAttrs: !0\n    });\n    this.chartClipPath = N.appendOrSelect(t, `clipPath.${this.type}`).attr(\n      "id",\n      this.chartClipId\n    );\n    const i = N.appendOrSelect(this.chartClipPath, `rect.${this.type}`);\n    i.attr("x", 0).attr("y", 0).attr("width", n).attr("height", r), this.chartClipPath.merge(i).lower();\n  }\n}\nvar Mr, Vt;\n(function(e) {\n  e.LEFT = "left", e.RIGHT = "right", e.TOP = "top", e.BOTTOM = "bottom";\n})(Vt || (Vt = {}));\nvar sp = (Mr = {}, Mr[Vt.LEFT] = function(e, t, n) {\n  return {\n    top: e.top - Math.round(t.offsetHeight / 2) + Math.round(n.height / 2),\n    left: Math.round(e.left - t.offsetWidth)\n  };\n}, Mr[Vt.RIGHT] = function(e, t, n) {\n  return {\n    top: e.top - Math.round(t.offsetHeight / 2) + Math.round(n.height / 2),\n    left: Math.round(e.left + n.width)\n  };\n}, Mr[Vt.TOP] = function(e, t, n) {\n  return {\n    top: Math.round(e.top - t.offsetHeight),\n    left: e.left - Math.round(t.offsetWidth / 2) + Math.round(n.width / 2)\n  };\n}, Mr[Vt.BOTTOM] = function(e, t, n) {\n  return {\n    top: Math.round(e.top + n.height),\n    left: e.left - Math.round(t.offsetWidth / 2) + Math.round(n.width / 2)\n  };\n}, Mr), ap = typeof window < "u" ? window : {\n  innerHeight: 0,\n  innerWidth: 0\n}, mo = (\n  /** @class */\n  function() {\n    function e(t) {\n      t === void 0 && (t = {}), this.positions = sp, this.positions = Object.assign({}, sp, t);\n    }\n    return e.prototype.getRelativeOffset = function(t) {\n      for (var n = {\n        left: t.offsetLeft,\n        top: t.offsetTop\n      }; t.offsetParent && getComputedStyle(t.offsetParent).position === "static"; )\n        n.left += t.offsetLeft, n.top += t.offsetTop, t = t.offsetParent;\n      return n;\n    }, e.prototype.getAbsoluteOffset = function(t) {\n      for (var n = t, r = {\n        top: 0,\n        left: 0\n      }; n.offsetParent; ) {\n        var i = getComputedStyle(n.offsetParent);\n        i.position === "static" && i.marginLeft && i.marginTop && (parseInt(i.marginTop, 10) && (r.top += parseInt(i.marginTop, 10)), parseInt(i.marginLeft, 10) && (r.left += parseInt(i.marginLeft, 10))), n = n.offsetParent;\n      }\n      var s = t.getBoundingClientRect(), a = document.body.getBoundingClientRect();\n      return {\n        top: s.top - a.top + r.top,\n        left: s.left - a.left + r.left\n      };\n    }, e.prototype.findRelative = function(t, n, r) {\n      var i = this.getRelativeOffset(t), s = t.getBoundingClientRect();\n      return this.calculatePosition(i, s, n, r);\n    }, e.prototype.findAbsolute = function(t, n, r) {\n      var i = this.getAbsoluteOffset(t), s = t.getBoundingClientRect();\n      return this.calculatePosition(i, s, n, r);\n    }, e.prototype.findPosition = function(t, n, r, i) {\n      i === void 0 && (i = this.getAbsoluteOffset.bind(this));\n      var s = i(t), a = t.getBoundingClientRect();\n      return this.calculatePosition(s, a, n, r);\n    }, e.prototype.findPositionAt = function(t, n, r) {\n      return this.calculatePosition(t, { top: 0, left: 0, height: 0, width: 0 }, n, r);\n    }, e.prototype.getPlacementBox = function(t, n) {\n      var r = t.offsetHeight + n.top, i = t.offsetWidth + n.left;\n      return {\n        top: n.top,\n        bottom: r,\n        left: n.left,\n        right: i\n      };\n    }, e.prototype.addOffset = function(t, n, r) {\n      return n === void 0 && (n = 0), r === void 0 && (r = 0), Object.assign({}, t, {\n        top: t.top + n,\n        left: t.left + r\n      });\n    }, e.prototype.setElement = function(t, n) {\n      t.style.top = n.top + "px", t.style.left = n.left + "px";\n    }, e.prototype.findBestPlacement = function(t, n, r, i, s) {\n      var a = this;\n      i === void 0 && (i = this.defaultContainerFunction.bind(this)), s === void 0 && (s = this.findPosition.bind(this));\n      var o = r.map(function(l) {\n        var c = s(t, n, l), u = a.getPlacementBox(n, c), d = 0, h = 0, p = i();\n        u.top < p.top ? d = p.top - u.top : u.bottom > p.height && (d = u.bottom - p.height), u.left < p.left ? h = p.left - u.left : u.right > p.width && (h = u.right - p.width), d && !h ? h = 1 : h && !d && (d = 1);\n        var f = n.offsetHeight * n.offsetWidth, g = d * h, m = f - g, v = m / f;\n        return {\n          placement: l,\n          weight: v\n        };\n      });\n      return o.sort(function(l, c) {\n        return c.weight - l.weight;\n      }), o[0].placement;\n    }, e.prototype.findBestPlacementAt = function(t, n, r, i) {\n      var s = this;\n      i === void 0 && (i = this.defaultContainerFunction.bind(this));\n      var a = function(o, l, c) {\n        return s.findPositionAt(t, l, c);\n      };\n      return this.findBestPlacement(null, n, r, i, a);\n    }, e.prototype.defaultContainerFunction = function() {\n      return {\n        // we go with window here, because that\'s going to be the simple/common case\n        top: 0,\n        left: 0,\n        height: ap.innerHeight,\n        width: ap.innerWidth\n      };\n    }, e.prototype.calculatePosition = function(t, n, r, i) {\n      return this.positions[i] ? this.positions[i](t, r, n) : (console.error("No function found for placement, defaulting to 0,0"), { left: 0, top: 0 });\n    }, e;\n  }()\n);\nnew mo();\nclass cu extends mt {\n  constructor(t, n, r) {\n    super(t, n, r), this.type = "tooltip", this.renderType = rt.HTML, this.isEventListenerAdded = !1, this.lastTriggeredEventType = "", this.positionService = new mo(), this.handleShowTooltip = (i) => {\n      const s = i.detail.data || i.detail.items, a = I(i.detail.event.target).datum();\n      let o;\n      const l = this.formatItems(this.getItems(i));\n      i.detail.content ? o = `<div class="title-tooltip"><p>${Gs(i.detail.content)}</p></div>` : o = Gs(this.getTooltipHTML(l));\n      const c = N.appendOrSelect(this.tooltip, "div.content-box");\n      if (y(this.getOptions(), "tooltip", "customHTML"))\n        if (i.detail.content) {\n          const u = `<div class="title-tooltip"><p>${Gs(\n            i.detail.content\n          )}</p></div>`;\n          c.html(u);\n        } else\n          c.html(\n            `<div class="title-tooltip"><p>${Gs(\n              this.model.getOptions().tooltip.customHTML(s, o, a)\n            )}</p></div>`\n          );\n      else\n        c.html(o);\n      c.selectAll(".datapoint-tooltip").each(function(u, d) {\n        const h = l[d];\n        l[d] && l[d].color && I(this).select(".tooltip-color").attr("class", "tooltip-color").style("background-color", h.color);\n      }), this.positionTooltip(i), this.tooltip.classed("hidden", !1).attr("aria-hidden", !1), this.lastTriggeredEventType = i.type;\n    }, this.handleHideTooltip = () => {\n      this.tooltip.classed("hidden", !0).attr("aria-hidden", !0);\n    }, this.init();\n  }\n  addTooltipEventListener() {\n    this.services.events.addEventListener(T.Tooltip.MOVE, (t) => {\n      this.lastTriggeredEventType !== T.Toolbar.SHOW_TOOLTIP && this.tooltip.classed("hidden") === !1 && this.positionTooltip(t);\n    }), this.services.events.addEventListener(T.Tooltip.SHOW, this.handleShowTooltip), this.services.events.addEventListener(T.Tooltip.HIDE, this.handleHideTooltip), this.services.events.addEventListener(T.Chart.MOUSEOUT, this.handleHideTooltip), this.services.events.addEventListener(T.Toolbar.SHOW_TOOLTIP, this.handleShowTooltip), this.services.events.addEventListener(T.Toolbar.HIDE_TOOLTIP, this.handleHideTooltip);\n  }\n  removeTooltipEventListener() {\n    this.services.events.removeEventListener(T.Tooltip.MOVE, null), this.services.events.removeEventListener(T.Tooltip.SHOW, this.handleShowTooltip), this.services.events.removeEventListener(T.Tooltip.HIDE, this.handleHideTooltip), this.services.events.removeEventListener(T.Chart.MOUSEOUT, this.handleHideTooltip), this.services.events.removeEventListener(T.Toolbar.SHOW_TOOLTIP, this.handleShowTooltip), this.services.events.removeEventListener(T.Toolbar.HIDE_TOOLTIP, this.handleHideTooltip);\n  }\n  getItems(t) {\n    return t.detail.items ? t.detail.items : [];\n  }\n  formatItems(t) {\n    const n = this.getOptions(), r = y(n, "tooltip", "truncation", "type"), i = y(n, "tooltip", "truncation", "threshold"), s = y(n, "tooltip", "truncation", "numCharacter");\n    return r !== Ve.NONE ? t.map((a) => {\n      const o = a.labelIcon ? 12 : 0;\n      return a.value = this.valueFormatter(a.value, a.label), a.label && a.label.length + o > i && (a.label = es(a.label, r, s)), a.value && a.value.length > i && (a.value = es(a.value, r, s)), a;\n    }) : t.map((a) => (a.value = this.valueFormatter(a.value, a.label), a));\n  }\n  getTooltipHTML(t) {\n    return \'<ul class="multi-tooltip">\' + t.map(\n      (n) => `<li>\n\t\t\t\t\t<div class="datapoint-tooltip${n.bold ? " bold" : ""}">\n\t\t\t\t\t\t${n.class || n.color ? `<div class="tooltip-color ${n.class}"></div>` : ""}\n\t\t\t\t\t\t<div class="label">\n\t\t\t\t\t\t<p>${n.label || ""}</p>\n\t\t\t\t\t\t${n.labelIcon ? `<span class="label-icon"/>${n.labelIcon}</span>` : ""}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t${n.value === void 0 || n.value === null ? "" : `<p class="value"/>${n.value}</p>`}\n\t\t\t\t\t</div>\n\t\t\t\t</li>`\n    ).join("") + "</ul>";\n  }\n  isDate(t) {\n    return t instanceof Date;\n  }\n  valueFormatter(t, n) {\n    const r = this.getOptions(), i = y(r, "tooltip", "valueFormatter"), {\n      code: s,\n      number: a,\n      date: o\n    } = y(r, "locale");\n    if (i)\n      return i(t, n);\n    if (this.isDate(t))\n      return o(t, s, { month: "short", day: "numeric", year: "numeric" });\n    try {\n      if (typeof t == "string" && /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{3}Z/.test(t)) {\n        const l = new Date(t);\n        return o(l, s, {\n          month: "short",\n          day: "numeric",\n          year: "numeric"\n        });\n      }\n    } catch {\n    }\n    return a(t, s);\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(t = !1) {\n    const n = this.getOptions(), r = y(n, "tooltip", "enabled");\n    if (r) {\n      const i = I(this.services.domUtils.getHolder()), s = y(n, "style", "prefix");\n      this.tooltip = N.appendOrSelect(i, `div.${ue}--${s}--tooltip`), this.tooltip.style("max-width", null).attr("role", "tooltip"), this.isEventListenerAdded || (this.addTooltipEventListener(), this.isEventListenerAdded = !0), this.tooltip.classed("hidden", !0);\n    } else !r && this.isEventListenerAdded && (this.removeTooltipEventListener(), this.isEventListenerAdded = !1);\n  }\n  addOffsetByPlacement(t, n, r) {\n    const i = Object.assign({}, t);\n    return n == Vt.LEFT ? i.left -= r : n == Vt.RIGHT ? i.left += r : n == Vt.TOP ? i.top -= r : n == Vt.BOTTOM && (i.top += r), i;\n  }\n  positionTooltip(t) {\n    const n = this.services.domUtils.getHolder(), r = n.offsetWidth, i = n.offsetHeight, s = this.tooltip.node(), a = this.getOptions(), o = y(a, "zoomBar", "top", "enabled"), l = !!y(t, "detail", "noWrap"), c = Array.isArray(y(t, "detail", "placements")), u = c ? y(t, "detail", "placements") : [Vt.RIGHT, Vt.LEFT, Vt.TOP, Vt.BOTTOM];\n    let d, { horizontalOffset: h } = Ih;\n    const { defaultOffset: p } = Ih;\n    if (this.tooltip.select("div.title-tooltip").classed("title-tooltip-nowrap", l), c) {\n      const m = y(t, "detail", "event", "target"), v = this.services.domUtils.getElementOffset(m, !0);\n      d = this.positionService.findBestPlacementAt(\n        v,\n        s,\n        u,\n        () => ({\n          top: 0,\n          left: 0,\n          width: r,\n          height: i\n        })\n      );\n      let x = this.positionService.findPosition(\n        m,\n        s,\n        d,\n        () => this.services.domUtils.getElementOffset(m)\n      );\n      x = this.addOffsetByPlacement(x, d, p), this.positionService.setElement(s, x);\n      return;\n    }\n    let f = y(t, "detail", "mousePosition");\n    if (!f)\n      f = rr(y(t, "detail", "event"), n);\n    else {\n      const m = y(a, "zoomBar", "top", "type"), v = ye.height[m];\n      o && (f[1] += v + ye.spacerHeight);\n    }\n    f[0] / r > 0.9 ? d = Vt.LEFT : f[0] / r < 0.1 ? d = Vt.RIGHT : d = this.positionService.findBestPlacementAt(\n      {\n        left: f[0],\n        top: f[1]\n      },\n      s,\n      u,\n      () => ({\n        top: void 0,\n        // properties were never set to optional (probably should)\n        left: void 0,\n        // ditto\n        width: r,\n        height: i\n      })\n    ), d === Vt.LEFT && (h *= -1);\n    const g = this.positionService.findPositionAt(\n      {\n        left: f[0] + h,\n        top: f[1]\n      },\n      s,\n      d\n    );\n    this.positionService.setElement(s, g);\n  }\n}\nconst yv = class ia extends mt {\n  constructor() {\n    super(...arguments), this.type = "grid-brush", this.renderType = rt.SVG, this.selectionSelector = "rect.selection", this.frontSelectionSelector = "rect.frontSelection";\n  }\n  // needs to match the class name in _grid-brush.scss\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(t = !0) {\n    const n = this.parent, r = this.getComponentContainer({\n      isPresentational: !0\n    });\n    if (!n) throw new Error("SVG was not defined");\n    const i = N.appendOrSelect(\n      n,\n      "svg.chart-grid-backdrop"\n    ), s = N.appendOrSelect(i, `g.${this.type}`), a = N.appendOrSelect(s, this.selectionSelector), { width: o, height: l } = N.getSVGElementSize(i, {\n      useAttrs: !0\n    }), { cartesianScales: c } = this.services, u = c.getMainXScaleType(), d = c.getMainXScale(), [h] = d.range();\n    r.attr("transform", `translate(${h},0)`);\n    const p = N.appendOrSelect(r, this.frontSelectionSelector);\n    if (d && u === et.TIME) {\n      let f = this.model.get("zoomDomain");\n      f === void 0 && (f = this.services.zoom.getDefaultZoomBarDomain(), f && this.model.set({ zoomDomain: f }, { animate: !1 }));\n      const g = (b) => {\n        const S = b[1] - b[0];\n        let M = "0," + S.toString();\n        const D = Math.floor(l / ia.DASH_LENGTH), A = D * ia.DASH_LENGTH;\n        for (let R = 0; R < D; R++)\n          M += "," + ia.DASH_LENGTH;\n        M += "," + (l - A), D % 2 === 1 && (M += ",0"), M += "," + S.toString(), M += "," + l.toString(), p.attr("stroke-dasharray", M);\n      }, m = (b) => {\n        const S = b.selection;\n        S === null || S[0] === S[1] || (p.attr("x", parseFloat(a.attr("x")) + parseFloat(i.attr("x"))).attr("y", a.attr("y")).attr("width", a.attr("width")).attr("height", a.attr("height")).style("cursor", "pointer").style("display", null), g(S));\n      }, v = (b, S) => {\n        const M = eg().range([0, o]).domain(f);\n        let D = [M.invert(b), M.invert(S)];\n        D[0].valueOf() === D[1].valueOf() && (D = this.services.zoom.getDefaultZoomBarDomain()), (f[0].valueOf() !== D[0].valueOf() || f[1].valueOf() !== D[1].valueOf()) && this.services.zoom.handleDomainChange(D);\n      };\n      let x;\n      const _ = (b) => {\n        const S = b.selection;\n        S !== null && (v(S[0], S[1]), s.call(x.move, null), p.style("display", "none"));\n      };\n      l != 0 && o != 0 && (x = kg().extent([\n        [0, 0],\n        [o - 1, l]\n      ]).on("start brush end", m).on("end.brushed", _), s.call(x));\n      const E = this.services.zoom.getZoomRatio();\n      i.on("click", function(b) {\n        if (b.shiftKey) {\n          const S = this.services.domUtils.getHolder(), M = rr(s.node(), S)[0];\n          let D = M - o * E / 2;\n          D < 0 && (D = 0);\n          let A = M + o * E / 2;\n          A > o && (A = o), v(D, A);\n        }\n      });\n    }\n  }\n};\nyv.DASH_LENGTH = 4;\nlet Gk = yv;\nclass zk extends mt {\n  constructor() {\n    super(...arguments), this.type = "zoom-bar", this.renderType = rt.SVG, this.MIN_SELECTION_DIFF = 9e-10, this.brushSelector = "g.zoom-bar-brush", this.clipId = "zoomBarClip-" + Math.floor(Math.random() * 99999999999), this.brush = kg(), this.highlightStrokeWidth = 1;\n  }\n  init() {\n    this.services.events.addEventListener(T.ZoomBar.UPDATE, this.render.bind(this));\n    const t = y(this.getOptions(), "zoomBar", G.TOP, "data");\n    this.model.setZoomBarData(t);\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(t = !0) {\n    const n = this.getComponentContainer({\n      ariaLabel: "zoom bar"\n    }), r = this.services.zoom.isZoomBarLoading(G.TOP), i = this.services.zoom.isZoomBarLocked(G.TOP), s = y(this.getOptions(), "zoomBar", G.TOP, "type"), a = y(this.getOptions(), "axes", G.BOTTOM, "highlights"), o = ye.height[s], { width: l } = N.getSVGElementSize(this.parent, {\n      useAttrs: !0\n    });\n    if (l === 0)\n      return;\n    let c = 0;\n    const u = this.model.get("axesMargins");\n    u && u.left && (c = u.left);\n    const d = N.appendOrSelect(n, "svg.zoom-container").attr("width", "100%").attr("height", o).attr("opacity", 1);\n    if (N.appendOrSelect(n, "rect.zoom-spacer").attr("x", 0).attr("y", o).attr("width", "100%").attr("height", ye.spacerHeight).attr("opacity", 1).attr("fill", "none"), s === Ke.GRAPH_VIEW ? N.appendOrSelect(d, "rect.zoom-bg").attr("x", c).attr("y", 0).attr("width", l - c).attr("height", "100%").classed("zoom-bg-skeleton", r).style(\n      "stroke",\n      r ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null\n    ) : s === Ke.SLIDER_VIEW && N.appendOrSelect(d, "rect.zoom-slider-bg").attr("x", c).attr("y", o / 2 - 1).attr("width", l - c).attr("height", 2).classed("zoom-slider-bg-skeleton", r).style(\n      "stroke",\n      r ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null\n    ), r) {\n      this.renderSkeleton(d, c, l);\n      return;\n    }\n    const { cartesianScales: h } = this.services, p = h.getMainXScale(), f = h.getMainYScale(), g = h.getMainXScaleType();\n    if (p && g === et.TIME) {\n      let m = this.services.zoom.getZoomBarData();\n      if (Be(m) || m.length === 1)\n        return;\n      this.xScale = p.copy(), this.yScale = f.copy();\n      const v = this.services.zoom.getDefaultZoomBarDomain(m);\n      m = this.compensateDataForDefaultDomain(m, v);\n      const x = this.model.get("initialZoomDomain"), _ = y(\n        this.getOptions(),\n        "zoomBar",\n        G.TOP,\n        "initialZoomDomain"\n      );\n      _ && _[0] && _[1] && (_[0] = new Date(_[0]), _[1] = new Date(_[1])), _ && !(x && x[0].valueOf() === _[0].valueOf() && x[1].valueOf() === _[1].valueOf()) ? this.model.set(\n        {\n          // use a new object instead of newInitialZoomDomain\n          initialZoomDomain: at([], _),\n          zoomDomain: _ ? at([], _) : v\n        },\n        { skipUpdate: !0 }\n      ) : _ === null && x !== null && this.model.set(\n        {\n          initialZoomDomain: null,\n          zoomDomain: at([], v)\n        },\n        { skipUpdate: !0 }\n      ), this.xScale.range([c, l]).domain(v), this.maxSelectionRange = this.xScale.range(), this.yScale.range([0, o - 6]).domain(ze(m, (S) => S.value));\n      const E = this.model.get("zoomDomain");\n      if (s === Ke.GRAPH_VIEW && (this.renderZoomBarArea(d, "path.zoom-graph-area-unselected", m, null), this.updateClipPath(n, this.clipId, 0, 0, 0, 0), this.renderZoomBarArea(d, "path.zoom-graph-area", m, this.clipId), this.renderZoomBarBaseline(d, c, l), a)) {\n        const S = a.highlightStartMapsTo, M = a.highlightEndMapsTo, D = a.color, A = a.labelMapsTo;\n        a.data.forEach((R, $) => {\n          N.appendOrSelect(d, `rect.highlight-${$}`).attr("height", o - 2 * this.highlightStrokeWidth).attr("y", this.highlightStrokeWidth).attr("x", this.xScale(R[S])).attr(\n            "width",\n            this.xScale(R[M]) - this.xScale(R[S])\n          ).style(\n            "fill",\n            D && D.scale[R[A]] ? D.scale[R[A]] : null\n          ).style("fill-opacity", 0.1).style(\n            "stroke",\n            D && D.scale[R[A]] ? D.scale[R[A]] : null\n          ).style("stroke-dasharray", "2, 2").attr("stroke-width", "1px");\n        });\n      }\n      this.addBrushEventListener(E, c, l);\n      const b = N.appendOrSelect(n, this.brushSelector).call(this.brush);\n      if (E !== void 0) if (E[0].valueOf() === E[1].valueOf())\n        b.call(this.brush.move, this.xScale.range()), this.updateBrushHandle(this.getComponentContainer(), this.xScale.range());\n      else {\n        const S = E.map((M) => this.xScale(M));\n        S[1] - S[0] < this.MIN_SELECTION_DIFF || (b.call(this.brush.move, S), this.updateBrushHandle(this.getComponentContainer(), S));\n      }\n      i && (this.brush.filter(() => !1), b.selectAll("rect").attr("cursor", "auto"));\n    }\n  }\n  addBrushEventListener(t, n, r) {\n    const i = (o) => {\n      const l = o.selection;\n      l === null ? this.handleBrushedEvent(o, t, this.xScale, this.xScale.range()) : l[0] === l[1] || this.handleBrushedEvent(o, t, this.xScale, l);\n    }, s = y(this.getOptions(), "zoomBar", G.TOP, "type"), a = ye.height[s];\n    this.brush.extent([\n      [n, 0],\n      [r, a]\n    ]).on("start brush end", null).on("start brush end", i);\n  }\n  // brush event listener\n  handleBrushedEvent(t, n, r, i) {\n    const s = [r.invert(i[0]), r.invert(i[1])];\n    if (this.updateBrushHandle(this.getComponentContainer(), i), t.sourceEvent != null && (t.sourceEvent.type === "mousemove" || t.sourceEvent.type === "mouseup" || t.sourceEvent.type === "mousedown" || t.sourceEvent.type === "touchstart" || t.sourceEvent.type === "touchmove" || t.sourceEvent.type === "touchend")) {\n      (n === void 0 || n[0] !== s[0] || n[1] !== s[1]) && this.services.zoom.handleDomainChange(s, {\n        dispatchEvent: !1\n      });\n      let a;\n      t.type === "start" ? a = T.ZoomBar.SELECTION_START : t.type === "brush" ? a = T.ZoomBar.SELECTION_IN_PROGRESS : t.type === "end" && (a = T.ZoomBar.SELECTION_END, this.services.events.dispatchEvent(T.ZoomDomain.CHANGE, {\n        newDomain: s\n      })), this.services.events.dispatchEvent(a, {\n        selection: i,\n        newDomain: s\n      });\n    }\n  }\n  updateBrushHandle(t, n) {\n    const r = this, i = ye.handleWidth, s = y(this.getOptions(), "zoomBar", G.TOP, "type"), a = ye.height[s], o = -i / 2, l = ye.handleBarWidth, c = s === Ke.GRAPH_VIEW ? ye.handleBarHeight : 6, u = -l / 2, d = (a - c) / 2;\n    t.select(this.brushSelector).selectAll("rect.handle").data([{ type: "w" }, { type: "e" }]).attr("x", function(p) {\n      if (p.type === "w")\n        return Math.max(n[0] + o, r.maxSelectionRange[0]);\n      if (p.type === "e")\n        return Math.min(n[1] + o, r.maxSelectionRange[1] - i);\n    }).attr("y", 0).attr("width", i).attr("height", a).attr("cursor", "ew-resize").style("display", null);\n    const h = t.select(this.brushSelector).selectAll("rect.handle-bar").data([{ type: "w" }, { type: "e" }]);\n    h.enter().append("rect").attr("class", function(p) {\n      return "handle-bar handle-bar--" + p.type;\n    }), h.attr("x", function(p) {\n      if (p.type === "w")\n        return Math.max(\n          n[0] + u,\n          r.maxSelectionRange[0] - o + u\n        );\n      if (p.type === "e")\n        return Math.min(\n          n[1] + u,\n          r.maxSelectionRange[1] + o + u\n        );\n    }).attr("y", d).attr("width", l).attr("height", c).attr("cursor", "ew-resize"), s === Ke.SLIDER_VIEW && this.updateSliderSelectedArea(n), this.updateClipPath(\n      t,\n      this.clipId,\n      n[0],\n      0,\n      n[1] - n[0],\n      a\n    );\n  }\n  updateSliderSelectedArea(t) {\n    const n = y(this.getOptions(), "zoomBar", G.TOP, "type"), r = ye.height[n], i = this.getComponentContainer().select("svg.zoom-container");\n    N.appendOrSelect(i, "rect.zoom-slider-selected-area").attr("x", t[0]).attr("y", r / 2 - 1).attr("width", t[1] - t[0]).attr("height", 2);\n  }\n  renderZoomBarArea(t, n, r, i) {\n    const { cartesianScales: s } = this.services, a = s.getMainXAxisPosition(), o = s.getMainYAxisPosition(), l = s.getMainXScaleType(), c = s.getMainYScaleType(), u = (v, x, _) => (E) => s.getValueFromScale(v, x, _, E), d = u(this.xScale, l, a), h = u(this.yScale, c, o), p = y(this.getOptions(), "zoomBar", G.TOP, "type"), f = ye.height[p], g = au().x((v) => d(v)).y0(f).y1((v) => f - h(v)), m = N.appendOrSelect(t, n).datum(r).attr("d", g);\n    i && m.attr("clip-path", `url(#${i})`);\n  }\n  updateClipPath(t, n, r, i, s, a) {\n    const o = N.appendOrSelect(t, "clipPath").attr("id", n);\n    N.appendOrSelect(o, "rect").attr("x", r).attr("y", i).attr("width", s).attr("height", a);\n  }\n  // assume the domains in data are already sorted\n  compensateDataForDefaultDomain(t, n) {\n    if (!t || t.length < 2)\n      return;\n    const r = Sn(t), i = this.services.cartesianScales.getDomainIdentifier(), s = this.services.cartesianScales.getRangeIdentifier();\n    if (Number(n[0]) < Number(r[0][i])) {\n      const a = {};\n      a[i] = n[0], a[s] = 0, r.unshift(a);\n    }\n    if (Number(n[1]) > Number(r[r.length - 1][i])) {\n      const a = {};\n      a[i] = n[1], a[s] = 0, r.push(a);\n    }\n    return r;\n  }\n  renderZoomBarBaseline(t, n, r, i = !1) {\n    const s = y(\n      this.model.getOptions(),\n      "zoomBar",\n      G.TOP,\n      "type"\n    ), a = ye.height[s], o = xs()([\n      [n, a],\n      [r, a]\n    ]);\n    N.appendOrSelect(t, "path.zoom-bg-baseline").attr("d", o).classed("zoom-bg-baseline-skeleton", i).style(\n      "stroke",\n      i ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null\n    );\n  }\n  renderSkeleton(t, n, r) {\n    this.renderZoomBarArea(t, "path.zoom-graph-area-unselected", [], null), this.renderZoomBarArea(t, "path.zoom-graph-area", [], this.clipId), this.brush.on("start brush end", null), N.appendOrSelect(this.getComponentContainer(), this.brushSelector).html(null), y(this.getOptions(), "zoomBar", G.TOP, "type") === Ke.GRAPH_VIEW && this.renderZoomBarBaseline(t, n, r, !0);\n  }\n  destroy() {\n    this.brush.on("start brush end", null), this.services.events.removeEventListener(T.ZoomBar.UPDATE, this.render.bind(this));\n  }\n}\nclass Fk extends mt {\n  constructor(t, n) {\n    super(t, n), this.type = "threshold", this.renderType = rt.SVG, this.positionService = new mo();\n  }\n  render(t = !1) {\n    const n = y(this.getOptions(), "axes"), r = [];\n    Object.keys(n).forEach((c) => {\n      if (Object.values(G).includes(c)) {\n        const u = n[c];\n        u.thresholds && u.thresholds.length > 0 && r.push({\n          axisPosition: c,\n          thresholds: u.thresholds,\n          correspondingDatasets: u == null ? void 0 : u.correspondingDatasets,\n          mapsTo: u == null ? void 0 : u.mapsTo\n        });\n      }\n    });\n    const i = this.getComponentContainer({\n      ariaLabel: "threshold lines",\n      withinChartClip: !0\n    }).selectAll("g.axis-thresholds").data(r, (c) => c.axisPosition);\n    i.exit().attr("opacity", 0).remove();\n    const s = i.enter().append("g").merge(i);\n    s.attr("class", (c) => `axis-thresholds ${c.axisPosition}`);\n    const a = s.selectAll("g.threshold-group").data(\n      (c) => c.thresholds.map((u) => (u.axisPosition = c.axisPosition, u.datum = this.constructDatumObj(c, u), u))\n    );\n    a.exit().attr("opacity", 0).remove();\n    const o = a.enter().append("g");\n    o.append("line").attr("class", "threshold-line"), o.append("rect").attr("class", "threshold-hoverable-area"), o.merge(a).attr("class", "threshold-group");\n    const l = this;\n    s.each(function({ axisPosition: c }) {\n      const u = l.services.cartesianScales.getScaleByPosition(\n        c\n      ), d = l.services.cartesianScales.getScaleTypeByPosition(c);\n      let h = null, p = null;\n      c === G.LEFT || c === G.RIGHT ? (p = u, h = l.services.cartesianScales.getMainXScale()) : (h = u, p = l.services.cartesianScales.getMainYScale());\n      const f = d === et.LABELS, [g, m] = h.range(), [v, x] = p.range(), { cartesianScales: _ } = l.services, E = _.getOrientation(), b = (R) => _.getDomainValue(R), S = (R) => _.getRangeValue(R), [M, D] = En(\n        b,\n        S,\n        E\n      ), A = I(this);\n      c === G.TOP || c === G.BOTTOM ? (A.selectAll("line.threshold-line").transition().call(\n        (R) => l.services.transitions.setupTransition({\n          transition: R,\n          name: "threshold-line-update",\n          animate: t\n        })\n      ).attr("y1", x).attr("y2", v).attr(\n        "x1",\n        ({ datum: R }) => M(R) + (f ? u.step() / 2 : 0)\n      ).attr(\n        "x2",\n        ({ datum: R }) => M(R) + (f ? u.step() / 2 : 0)\n      ).style("stroke", ({ fillColor: R }) => R), A.selectAll("rect.threshold-hoverable-area").attr("x", 0).attr("y", ({ datum: R }) => -M(R)).attr("width", Math.abs(v - x)).classed("rotate", !0)) : (A.selectAll("line.threshold-line").transition().call(\n        (R) => l.services.transitions.setupTransition({\n          transition: R,\n          name: "threshold-line-update",\n          animate: t\n        })\n      ).attr("x1", g).attr("x2", m).attr(\n        "y1",\n        ({ datum: R }) => D(R) + (f ? u.step() / 2 : 0)\n      ).attr(\n        "y2",\n        ({ datum: R }) => D(R) + (f ? u.step() / 2 : 0)\n      ).style("stroke", ({ fillColor: R }) => R), A.selectAll("rect.threshold-hoverable-area").attr("x", g).attr("y", ({ datum: R }) => D(R)).attr("width", Math.abs(m - g)).classed("rotate", !1));\n    }), this.services.events.addEventListener(T.Threshold.SHOW, (c) => {\n      this.setThresholdLabelPosition(c.detail), this.label.classed("hidden", !1);\n    }), this.services.events.addEventListener(T.Threshold.HIDE, () => {\n      this.label.classed("hidden", !0);\n    }), this.appendThresholdLabel(), this.addEventListeners();\n  }\n  getFormattedValue(t) {\n    const { value: n, axisPosition: r } = t, i = this.getOptions(), s = this.services.cartesianScales.getScaleTypeByPosition(r), { code: a, number: o } = y(i, "locale");\n    if (s === et.TIME) {\n      const l = [G.LEFT, G.RIGHT].includes(r), c = this.services.cartesianScales.getMainXScale(), u = this.services.cartesianScales.getMainYScale(), d = l ? u : c, h = y(i, "timeScale"), p = Dl(\n        d.ticks(),\n        y(h, "timeInterval")\n      );\n      return kl(n, 0, d.ticks(), p, h, i.locale);\n    }\n    return o(n, a);\n  }\n  appendThresholdLabel() {\n    const t = I(this.services.domUtils.getHolder()), n = y(this.getOptions(), "style", "prefix");\n    this.label = N.appendOrSelect(\n      t,\n      `div.${ue}--${n}--threshold--label`\n    ).classed("hidden", !0);\n  }\n  setThresholdLabelPosition({ event: t, datum: n }) {\n    const r = this.services.domUtils.getHolder(), i = rr(t, r), s = n.valueFormatter ? n.valueFormatter(n.value) : this.getFormattedValue(n);\n    this.label.html(en(`${n.label || "Threshold"}: ${s}`)).style("background-color", n.fillColor);\n    const a = this.label.node(), o = this.positionService.findBestPlacementAt(\n      {\n        left: i[0],\n        top: i[1]\n      },\n      a,\n      [Vt.RIGHT, Vt.LEFT, Vt.TOP, Vt.BOTTOM],\n      () => ({\n        top: void 0,\n        // other package lists this as non-optional\n        left: void 0,\n        // ditto\n        width: r.offsetWidth,\n        height: r.offsetHeight\n      })\n    ), l = this.positionService.findPositionAt(\n      {\n        left: i[0],\n        top: i[1]\n      },\n      a,\n      o\n    );\n    this.positionService.setElement(a, l);\n  }\n  // Constructs object to pass in scale functions\n  constructDatumObj(t, n) {\n    const r = {};\n    return t.correspondingDatasets && (r.group = y(t, "correspondingDatasets", 0)), r[t.mapsTo] = n.value, r;\n  }\n  addEventListeners() {\n    const t = this;\n    this.getComponentContainer({ withinChartClip: !0 }).selectAll("rect.threshold-hoverable-area").on("mouseover mousemove", function(n) {\n      I(this.parentNode).select("line.threshold-line").classed("active", !0), t.services.events.dispatchEvent(T.Threshold.SHOW, {\n        event: n,\n        hoveredElement: I(this),\n        datum: I(this).datum()\n      });\n    }).on("mouseout", function(n) {\n      I(this.parentNode).select("line.threshold-line").classed("active", !1), t.services.events.dispatchEvent(T.Threshold.HIDE, {\n        event: n,\n        hoveredElement: I(this),\n        datum: I(this).datum()\n      });\n    });\n  }\n}\nclass jk extends mt {\n  constructor(t, n) {\n    super(t, n), this.type = "highlight", this.renderType = rt.SVG, this.positionService = new mo(), this.highlightStrokeWidth = 1;\n  }\n  render(t = !1) {\n    const n = y(this.getOptions(), "axes"), r = [];\n    Object.keys(n).forEach((c) => {\n      if (Object.values(G).includes(c)) {\n        const u = n[c];\n        u.highlights && u.highlights.data.length > 0 && r.push({\n          axisPosition: c,\n          highlightStartMapsTo: u.highlights.highlightStartMapsTo,\n          highlightEndMapsTo: u.highlights.highlightEndMapsTo,\n          labelMapsTo: u.highlights.labelMapsTo,\n          highlight: u.highlights.data,\n          color: u.highlights.color\n        });\n      }\n    });\n    const i = this.getComponentContainer({\n      ariaLabel: "highlight areas",\n      withinChartClip: !0\n    }).selectAll("g.axis-highlight").data(r, (c) => c.axisPosition);\n    i.exit().attr("opacity", 0).remove();\n    const s = i.enter().append("g").merge(i);\n    s.attr("class", (c) => `axis-highlight ${c.axisPosition}`);\n    const a = s.selectAll("g.highlight-group").data(\n      (c) => c.highlight.map((u) => (u.axisPosition = c.axisPosition, u.highlightStartMapsTo = c.highlightStartMapsTo, u.labelMapsTo = c.labelMapsTo, u.color = c.color, u.highlightEndMapsTo = c.highlightEndMapsTo, u))\n    );\n    a.exit().attr("opacity", 0).remove();\n    const o = a.enter().append("g");\n    o.append("rect").attr("class", "highlight-bar"), o.append("line").attr("class", "highlight-line"), o.merge(a).attr("class", "highlight-group");\n    const l = this;\n    s.each(function({ axisPosition: c }) {\n      const u = l.services.cartesianScales.getMainXScale(), d = l.services.cartesianScales.getMainYScale(), [h, p] = u.range(), [f, g] = d.range(), { cartesianScales: m } = l.services, v = m.getOrientation(), x = (M) => m.getDomainValue(M), _ = (M) => m.getRangeValue(M), [E, b] = En(\n        x,\n        _,\n        v\n      ), S = I(this);\n      c === G.TOP || c === G.BOTTOM ? S.selectAll("rect.highlight-bar").transition().call(\n        (M) => l.services.transitions.setupTransition({\n          transition: M,\n          name: "highlight-bar-update",\n          animate: t\n        })\n      ).attr("y", Math.max(g + l.highlightStrokeWidth, 0)).attr("height", Math.max(f - 2 * l.highlightStrokeWidth, 0)).attr("x", ({ highlightStartMapsTo: M, ...D }) => E(D[M])).attr(\n        "width",\n        ({ highlightStartMapsTo: M, highlightEndMapsTo: D, ...A }) => Math.max(E(A[D]) - E(A[M]), 0)\n      ).style("stroke", ({ color: M, labelMapsTo: D, ...A }) => M && M.scale[A[D]] ? M.scale[A[D]] : null).style("stroke-dasharray", "2, 2").attr("stroke-width", l.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", ({ color: M, labelMapsTo: D, ...A }) => M && M.scale[A[D]] ? M.scale[A[D]] : null) : S.selectAll("rect.highlight-bar").transition().call(\n        (M) => l.services.transitions.setupTransition({\n          transition: M,\n          name: "highlight-bar-update",\n          animate: t\n        })\n      ).attr("x", h).attr("width", Math.max(p - h, 0)).attr("y", ({ highlightEndMapsTo: M, ...D }) => b(D[M])).attr(\n        "height",\n        ({ highlightStartMapsTo: M, highlightEndMapsTo: D, ...A }) => Math.max(b(A[M]) - b(A[D]), 0)\n      ).style("stroke", ({ color: M, labelMapsTo: D, ...A }) => M && M.scale[A[D]] ? M.scale[A[D]] : null).style("stroke-dasharray", "2, 2").attr("stroke-width", l.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", ({ color: M, labelMapsTo: D, ...A }) => M && M.scale[A[D]] ? M.scale[A[D]] : null);\n    });\n  }\n}\nclass xv extends cu {\n  getItems(t) {\n    if (t.detail.items)\n      return t.detail.items;\n    const { data: n } = t.detail;\n    if (!n || !n.length || !n[0])\n      return [];\n    const r = this.getOptions(), { cartesianScales: i } = this.services, s = i.getDomainIdentifier(), a = i.isDualAxes(), { groupMapsTo: o } = r.data, l = i.getDomainLabel();\n    let c = i.getRangeLabel();\n    const u = n[0][s];\n    let d;\n    if (n.length === 1) {\n      const h = n[0], p = i.getRangeIdentifier(h);\n      if (a) {\n        const g = i.getRangeAxisPosition({\n          datum: h,\n          groups: [h[o]]\n        });\n        c = i.getScaleLabel(g);\n      }\n      const f = h[p];\n      d = [\n        {\n          label: l,\n          value: u\n        },\n        ...Array.isArray(f) && f.length === 2 ? [\n          {\n            label: "Start",\n            value: f[0]\n          },\n          {\n            label: "End",\n            value: f[1]\n          }\n        ] : [\n          {\n            label: c,\n            value: h[p]\n          }\n        ]\n      ], t.detail.additionalItems && t.detail.additionalItems.forEach(\n        (g) => d.push({\n          label: g.label,\n          value: g.value\n        })\n      ), d.push({\n        label: gt(r, "locale.translations.group") || gt(r, "tooltip.groupLabel"),\n        value: h[o],\n        color: this.model.getFillColor(h[o]),\n        class: this.model.getColorClassName({\n          classNameTypes: [it.TOOLTIP],\n          dataGroupName: h[o]\n        })\n      });\n    } else if (n.length > 1 && (d = [\n      {\n        label: l,\n        value: u\n      }\n    ], d = d.concat(\n      n.map((h) => {\n        const p = h[i.getRangeIdentifier(h)];\n        return {\n          label: h[o],\n          value: Array.isArray(p) && p.length === 2 ? `${p[0]} - ${p[1]}` : p,\n          color: this.model.getFillColor(h[o]),\n          class: this.model.getColorClassName({\n            classNameTypes: [it.TOOLTIP],\n            dataGroupName: h[o]\n          })\n        };\n      }).sort((h, p) => p.value - h.value)\n    ), !a && y(r, "tooltip", "showTotal") === !0)) {\n      const h = i.getRangeIdentifier();\n      d.push({\n        label: gt(r, "locale.translations.total") || gt(r, "tooltip.totalLabel") || "Total",\n        value: n.reduce(\n          (p, f) => p + f[h],\n          0\n        ),\n        bold: !0\n      });\n    }\n    return d;\n  }\n}\nfunction op(e, t) {\n  let n;\n  if (t === void 0)\n    for (const r of e)\n      r != null && (n < r || n === void 0 && r >= r) && (n = r);\n  else {\n    let r = -1;\n    for (let i of e)\n      (i = t(i, ++r, e)) != null && (n < i || n === void 0 && i >= i) && (n = i);\n  }\n  return n;\n}\nfunction Wk(e, t) {\n  let n;\n  if (t === void 0)\n    for (const r of e)\n      r != null && (n > r || n === void 0 && r >= r) && (n = r);\n  else {\n    let r = -1;\n    for (let i of e)\n      (i = t(i, ++r, e)) != null && (n > i || n === void 0 && i >= i) && (n = i);\n  }\n  return n;\n}\nfunction ll(e, t) {\n  let n = 0;\n  if (t === void 0)\n    for (let r of e)\n      (r = +r) && (n += r);\n  else {\n    let r = -1;\n    for (let i of e)\n      (i = +t(i, ++r, e)) && (n += i);\n  }\n  return n;\n}\nfunction qk(e) {\n  return e.depth;\n}\nfunction Yk(e, t) {\n  return t - 1 - e.height;\n}\nfunction bv(e, t) {\n  return e.sourceLinks.length ? e.depth : t - 1;\n}\nfunction zs(e) {\n  return function() {\n    return e;\n  };\n}\nfunction lp(e, t) {\n  return Pa(e.source, t.source) || e.index - t.index;\n}\nfunction cp(e, t) {\n  return Pa(e.target, t.target) || e.index - t.index;\n}\nfunction Pa(e, t) {\n  return e.y0 - t.y0;\n}\nfunction cl(e) {\n  return e.value;\n}\nfunction Xk(e) {\n  return e.index;\n}\nfunction Zk(e) {\n  return e.nodes;\n}\nfunction Kk(e) {\n  return e.links;\n}\nfunction up(e, t) {\n  const n = e.get(t);\n  if (!n) throw new Error("missing: " + t);\n  return n;\n}\nfunction hp({ nodes: e }) {\n  for (const t of e) {\n    let n = t.y0, r = n;\n    for (const i of t.sourceLinks)\n      i.y0 = n + i.width / 2, n += i.width;\n    for (const i of t.targetLinks)\n      i.y1 = r + i.width / 2, r += i.width;\n  }\n}\nfunction Qk() {\n  let e = 0, t = 0, n = 1, r = 1, i = 24, s = 8, a, o = Xk, l = bv, c, u, d = Zk, h = Kk, p = 6;\n  function f() {\n    const O = { nodes: d.apply(null, arguments), links: h.apply(null, arguments) };\n    return g(O), m(O), v(O), x(O), b(O), hp(O), O;\n  }\n  f.update = function(O) {\n    return hp(O), O;\n  }, f.nodeId = function(O) {\n    return arguments.length ? (o = typeof O == "function" ? O : zs(O), f) : o;\n  }, f.nodeAlign = function(O) {\n    return arguments.length ? (l = typeof O == "function" ? O : zs(O), f) : l;\n  }, f.nodeSort = function(O) {\n    return arguments.length ? (c = O, f) : c;\n  }, f.nodeWidth = function(O) {\n    return arguments.length ? (i = +O, f) : i;\n  }, f.nodePadding = function(O) {\n    return arguments.length ? (s = a = +O, f) : s;\n  }, f.nodes = function(O) {\n    return arguments.length ? (d = typeof O == "function" ? O : zs(O), f) : d;\n  }, f.links = function(O) {\n    return arguments.length ? (h = typeof O == "function" ? O : zs(O), f) : h;\n  }, f.linkSort = function(O) {\n    return arguments.length ? (u = O, f) : u;\n  }, f.size = function(O) {\n    return arguments.length ? (e = t = 0, n = +O[0], r = +O[1], f) : [n - e, r - t];\n  }, f.extent = function(O) {\n    return arguments.length ? (e = +O[0][0], n = +O[1][0], t = +O[0][1], r = +O[1][1], f) : [[e, t], [n, r]];\n  }, f.iterations = function(O) {\n    return arguments.length ? (p = +O, f) : p;\n  };\n  function g({ nodes: O, links: w }) {\n    for (const [k, U] of O.entries())\n      U.index = k, U.sourceLinks = [], U.targetLinks = [];\n    const L = new Map(O.map((k, U) => [o(k, U, O), k]));\n    for (const [k, U] of w.entries()) {\n      U.index = k;\n      let { source: Z, target: j } = U;\n      typeof Z != "object" && (Z = U.source = up(L, Z)), typeof j != "object" && (j = U.target = up(L, j)), Z.sourceLinks.push(U), j.targetLinks.push(U);\n    }\n    if (u != null)\n      for (const { sourceLinks: k, targetLinks: U } of O)\n        k.sort(u), U.sort(u);\n  }\n  function m({ nodes: O }) {\n    for (const w of O)\n      w.value = w.fixedValue === void 0 ? Math.max(ll(w.sourceLinks, cl), ll(w.targetLinks, cl)) : w.fixedValue;\n  }\n  function v({ nodes: O }) {\n    const w = O.length;\n    let L = new Set(O), k = /* @__PURE__ */ new Set(), U = 0;\n    for (; L.size; ) {\n      for (const Z of L) {\n        Z.depth = U;\n        for (const { target: j } of Z.sourceLinks)\n          k.add(j);\n      }\n      if (++U > w) throw new Error("circular link");\n      L = k, k = /* @__PURE__ */ new Set();\n    }\n  }\n  function x({ nodes: O }) {\n    const w = O.length;\n    let L = new Set(O), k = /* @__PURE__ */ new Set(), U = 0;\n    for (; L.size; ) {\n      for (const Z of L) {\n        Z.height = U;\n        for (const { source: j } of Z.targetLinks)\n          k.add(j);\n      }\n      if (++U > w) throw new Error("circular link");\n      L = k, k = /* @__PURE__ */ new Set();\n    }\n  }\n  function _({ nodes: O }) {\n    const w = op(O, (U) => U.depth) + 1, L = (n - e - i) / (w - 1), k = new Array(w);\n    for (const U of O) {\n      const Z = Math.max(0, Math.min(w - 1, Math.floor(l.call(null, U, w))));\n      U.layer = Z, U.x0 = e + Z * L, U.x1 = U.x0 + i, k[Z] ? k[Z].push(U) : k[Z] = [U];\n    }\n    if (c) for (const U of k)\n      U.sort(c);\n    return k;\n  }\n  function E(O) {\n    const w = Wk(O, (L) => (r - t - (L.length - 1) * a) / ll(L, cl));\n    for (const L of O) {\n      let k = t;\n      for (const U of L) {\n        U.y0 = k, U.y1 = k + U.value * w, k = U.y1 + a;\n        for (const Z of U.sourceLinks)\n          Z.width = Z.value * w;\n      }\n      k = (r - k + a) / (L.length + 1);\n      for (let U = 0; U < L.length; ++U) {\n        const Z = L[U];\n        Z.y0 += k * (U + 1), Z.y1 += k * (U + 1);\n      }\n      H(L);\n    }\n  }\n  function b(O) {\n    const w = _(O);\n    a = Math.min(s, (r - t) / (op(w, (L) => L.length) - 1)), E(w);\n    for (let L = 0; L < p; ++L) {\n      const k = Math.pow(0.99, L), U = Math.max(1 - k, (L + 1) / p);\n      M(w, k, U), S(w, k, U);\n    }\n  }\n  function S(O, w, L) {\n    for (let k = 1, U = O.length; k < U; ++k) {\n      const Z = O[k];\n      for (const j of Z) {\n        let F = 0, Y = 0;\n        for (const { source: Q, value: q } of j.targetLinks) {\n          let tt = q * (j.layer - Q.layer);\n          F += P(Q, j) * tt, Y += tt;\n        }\n        if (!(Y > 0)) continue;\n        let ot = (F / Y - j.y0) * w;\n        j.y0 += ot, j.y1 += ot, $(j);\n      }\n      c === void 0 && Z.sort(Pa), D(Z, L);\n    }\n  }\n  function M(O, w, L) {\n    for (let k = O.length, U = k - 2; U >= 0; --U) {\n      const Z = O[U];\n      for (const j of Z) {\n        let F = 0, Y = 0;\n        for (const { target: Q, value: q } of j.sourceLinks) {\n          let tt = q * (Q.layer - j.layer);\n          F += B(j, Q) * tt, Y += tt;\n        }\n        if (!(Y > 0)) continue;\n        let ot = (F / Y - j.y0) * w;\n        j.y0 += ot, j.y1 += ot, $(j);\n      }\n      c === void 0 && Z.sort(Pa), D(Z, L);\n    }\n  }\n  function D(O, w) {\n    const L = O.length >> 1, k = O[L];\n    R(O, k.y0 - a, L - 1, w), A(O, k.y1 + a, L + 1, w), R(O, r, O.length - 1, w), A(O, t, 0, w);\n  }\n  function A(O, w, L, k) {\n    for (; L < O.length; ++L) {\n      const U = O[L], Z = (w - U.y0) * k;\n      Z > 1e-6 && (U.y0 += Z, U.y1 += Z), w = U.y1 + a;\n    }\n  }\n  function R(O, w, L, k) {\n    for (; L >= 0; --L) {\n      const U = O[L], Z = (U.y1 - w) * k;\n      Z > 1e-6 && (U.y0 -= Z, U.y1 -= Z), w = U.y0 - a;\n    }\n  }\n  function $({ sourceLinks: O, targetLinks: w }) {\n    if (u === void 0) {\n      for (const { source: { sourceLinks: L } } of w)\n        L.sort(cp);\n      for (const { target: { targetLinks: L } } of O)\n        L.sort(lp);\n    }\n  }\n  function H(O) {\n    if (u === void 0)\n      for (const { sourceLinks: w, targetLinks: L } of O)\n        w.sort(cp), L.sort(lp);\n  }\n  function P(O, w) {\n    let L = O.y0 - (O.sourceLinks.length - 1) * a / 2;\n    for (const { target: k, width: U } of O.sourceLinks) {\n      if (k === w) break;\n      L += U + a;\n    }\n    for (const { source: k, width: U } of w.targetLinks) {\n      if (k === O) break;\n      L -= U;\n    }\n    return L;\n  }\n  function B(O, w) {\n    let L = w.y0 - (w.targetLinks.length - 1) * a / 2;\n    for (const { source: k, width: U } of w.targetLinks) {\n      if (k === O) break;\n      L += U + a;\n    }\n    for (const { target: k, width: U } of O.sourceLinks) {\n      if (k === w) break;\n      L -= U;\n    }\n    return L;\n  }\n  return f;\n}\nvar ac = Math.PI, oc = 2 * ac, Zn = 1e-6, Jk = oc - Zn;\nfunction lc() {\n  this._x0 = this._y0 = // start of current subpath\n  this._x1 = this._y1 = null, this._ = "";\n}\nfunction _v() {\n  return new lc();\n}\nlc.prototype = _v.prototype = {\n  constructor: lc,\n  moveTo: function(e, t) {\n    this._ += "M" + (this._x0 = this._x1 = +e) + "," + (this._y0 = this._y1 = +t);\n  },\n  closePath: function() {\n    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");\n  },\n  lineTo: function(e, t) {\n    this._ += "L" + (this._x1 = +e) + "," + (this._y1 = +t);\n  },\n  quadraticCurveTo: function(e, t, n, r) {\n    this._ += "Q" + +e + "," + +t + "," + (this._x1 = +n) + "," + (this._y1 = +r);\n  },\n  bezierCurveTo: function(e, t, n, r, i, s) {\n    this._ += "C" + +e + "," + +t + "," + +n + "," + +r + "," + (this._x1 = +i) + "," + (this._y1 = +s);\n  },\n  arcTo: function(e, t, n, r, i) {\n    e = +e, t = +t, n = +n, r = +r, i = +i;\n    var s = this._x1, a = this._y1, o = n - e, l = r - t, c = s - e, u = a - t, d = c * c + u * u;\n    if (i < 0) throw new Error("negative radius: " + i);\n    if (this._x1 === null)\n      this._ += "M" + (this._x1 = e) + "," + (this._y1 = t);\n    else if (d > Zn) if (!(Math.abs(u * o - l * c) > Zn) || !i)\n      this._ += "L" + (this._x1 = e) + "," + (this._y1 = t);\n    else {\n      var h = n - s, p = r - a, f = o * o + l * l, g = h * h + p * p, m = Math.sqrt(f), v = Math.sqrt(d), x = i * Math.tan((ac - Math.acos((f + d - g) / (2 * m * v))) / 2), _ = x / v, E = x / m;\n      Math.abs(_ - 1) > Zn && (this._ += "L" + (e + _ * c) + "," + (t + _ * u)), this._ += "A" + i + "," + i + ",0,0," + +(u * h > c * p) + "," + (this._x1 = e + E * o) + "," + (this._y1 = t + E * l);\n    }\n  },\n  arc: function(e, t, n, r, i, s) {\n    e = +e, t = +t, n = +n, s = !!s;\n    var a = n * Math.cos(r), o = n * Math.sin(r), l = e + a, c = t + o, u = 1 ^ s, d = s ? r - i : i - r;\n    if (n < 0) throw new Error("negative radius: " + n);\n    this._x1 === null ? this._ += "M" + l + "," + c : (Math.abs(this._x1 - l) > Zn || Math.abs(this._y1 - c) > Zn) && (this._ += "L" + l + "," + c), n && (d < 0 && (d = d % oc + oc), d > Jk ? this._ += "A" + n + "," + n + ",0,1," + u + "," + (e - a) + "," + (t - o) + "A" + n + "," + n + ",0,1," + u + "," + (this._x1 = l) + "," + (this._y1 = c) : d > Zn && (this._ += "A" + n + "," + n + ",0," + +(d >= ac) + "," + u + "," + (this._x1 = e + n * Math.cos(i)) + "," + (this._y1 = t + n * Math.sin(i))));\n  },\n  rect: function(e, t, n, r) {\n    this._ += "M" + (this._x0 = this._x1 = +e) + "," + (this._y0 = this._y1 = +t) + "h" + +n + "v" + +r + "h" + -n + "Z";\n  },\n  toString: function() {\n    return this._;\n  }\n};\nfunction dp(e) {\n  return function() {\n    return e;\n  };\n}\nfunction tD(e) {\n  return e[0];\n}\nfunction eD(e) {\n  return e[1];\n}\nvar nD = Array.prototype.slice;\nfunction rD(e) {\n  return e.source;\n}\nfunction iD(e) {\n  return e.target;\n}\nfunction sD(e) {\n  var t = rD, n = iD, r = tD, i = eD, s = null;\n  function a() {\n    var o, l = nD.call(arguments), c = t.apply(this, l), u = n.apply(this, l);\n    if (s || (s = o = _v()), e(s, +r.apply(this, (l[0] = c, l)), +i.apply(this, l), +r.apply(this, (l[0] = u, l)), +i.apply(this, l)), o) return s = null, o + "" || null;\n  }\n  return a.source = function(o) {\n    return arguments.length ? (t = o, a) : t;\n  }, a.target = function(o) {\n    return arguments.length ? (n = o, a) : n;\n  }, a.x = function(o) {\n    return arguments.length ? (r = typeof o == "function" ? o : dp(+o), a) : r;\n  }, a.y = function(o) {\n    return arguments.length ? (i = typeof o == "function" ? o : dp(+o), a) : i;\n  }, a.context = function(o) {\n    return arguments.length ? (s = o ?? null, a) : s;\n  }, a;\n}\nfunction aD(e, t, n, r, i) {\n  e.moveTo(t, n), e.bezierCurveTo(t = (t + r) / 2, n, t, i, r, i);\n}\nfunction oD() {\n  return sD(aD);\n}\nfunction lD(e) {\n  return [e.source.x1, e.y0];\n}\nfunction cD(e) {\n  return [e.target.x0, e.y1];\n}\nfunction uD() {\n  return oD().source(lD).target(cD);\n}\nclass hD extends mt {\n  constructor() {\n    super(...arguments), this.type = "alluvial", this.renderType = rt.SVG, this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999);\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(t = !0) {\n    const n = this.getComponentContainer({ ariaLabel: "alluvial graphs", withinChartClip: !0 });\n    n.html("");\n    const { width: r, height: i } = N.getSVGElementSize(n, {\n      useAttrs: !0\n    });\n    if (r < 1 || i < 1)\n      return;\n    const s = this.model.getOptions(), a = this.model.getDisplayData(), o = y(\n      this.getOptions(),\n      "color",\n      "gradient",\n      "enabled"\n    );\n    let l = Pe.minNodePadding;\n    s.alluvial.nodePadding > Pe.minNodePadding && (l = s.alluvial.nodePadding);\n    const c = y(s, "alluvial", "nodeAlignment");\n    let u = bv;\n    c === jt.LEFT ? u = qk : c === jt.RIGHT && (u = Yk);\n    const d = Qk().nodeId((x) => x.name).nodeWidth(Pe.nodeWidth).nodePadding(l).nodeAlign(u).extent([\n      [2, 30],\n      [r - 2, i]\n    ]);\n    this.graph = d({\n      nodes: s.alluvial.nodes.map((x) => Object.assign({}, x)),\n      links: a.map((x) => Object.assign({}, x))\n    }), this.graph.nodes = this.graph.nodes.filter((x) => x.value !== 0);\n    const h = {};\n    this.graph.nodes.forEach((x) => {\n      const _ = x.x0;\n      x.category && (h[_] = x == null ? void 0 : x.category);\n    }), n.append("g").classed("header-arrows", !0).selectAll("g").data(Object.keys(h)).join("g").attr("transform", (x) => `translate(${x}, 0)`).append("text").attr(\n      "id",\n      (x, _) => this.services.domUtils.generateElementIDString(`alluvial-category-${_}`)\n    ).style("font-size", "14px").text((x) => h[x] ? h[x] : "").attr("y", 20).attr("x", (x, _) => {\n      const E = this.services.domUtils.generateElementIDString(\n        `alluvial-category-${_}`\n      ), { width: b } = N.getSVGElementSize(I(`text#${E}`), {\n        useBBox: !0\n      });\n      let S = 0;\n      return x + S >= b && (S = -b + 4), S;\n    });\n    const p = n.append("g").attr("fill", "none").selectAll("g").data(this.graph.links);\n    if (p.exit().remove(), o) {\n      const x = y(this.getOptions(), "color", "scale");\n      x && p.enter().append("linearGradient").attr("id", (_) => `${this.gradient_id}-link-${_.index}`).attr("gradientUnits", "userSpaceOnUse").call(\n        (_) => _.append("stop").attr("offset", "0%").attr("stop-color", (E) => x[E.source.name])\n      ).call(\n        (_) => _.append("stop").attr("offset", "100%").attr("stop-color", (E) => x[E.target.name])\n      ), p.exit().remove();\n    }\n    p.enter().append("path").classed("link", !0).attr("d", uD()).attr(\n      "id",\n      (x) => this.services.domUtils.generateElementIDString(`alluvial-line-${x.index}`)\n    ).attr("class", (x) => s.alluvial.monochrome ? this.model.getColorClassName({\n      classNameTypes: [it.STROKE],\n      dataGroupName: 0,\n      originalClassName: "link"\n    }) : this.model.getColorClassName({\n      classNameTypes: [it.STROKE],\n      dataGroupName: x.source.index,\n      originalClassName: "link"\n    })).style("stroke", (x) => o ? `url(#${this.gradient_id}-link-${x.index})` : this.model.getFillColor(x.source.name, null, {\n      ...x,\n      source: x.source.name,\n      target: x.target.name\n    })).attr("stroke-width", (x) => Math.max(1, x.width)).style("stroke-opacity", Pe.opacity.default).attr(\n      "aria-label",\n      (x) => `${x.source.name}  ${x.target.name} (${x.value}${s.alluvial.units ? " " + s.alluvial.units : ""})`\n    );\n    const f = n.append("g").selectAll("g").data(this.graph.nodes).enter().append("g").attr(\n      "id",\n      (x) => this.services.domUtils.generateElementIDString(`alluvial-node-${x.index}`)\n    ).classed("node-group", !0).attr("transform", (x) => `translate(${x.x0}, ${x.y0})`);\n    f.append("rect").classed("node", !0).attr("height", (x) => x.y1 - x.y0).attr("width", (x) => x.x1 - x.x0).attr("fill", "black");\n    const g = f.append("g").attr(\n      "id",\n      (x) => this.services.domUtils.generateElementIDString(`alluvial-node-title-${x.index}`)\n    ), { code: m, number: v } = y(s, "locale");\n    g.append("text").attr(\n      "id",\n      (x) => this.services.domUtils.generateElementIDString(`alluvial-node-text-${x.index}`)\n    ).attr("class", "node-text").style("font-size", "12px").attr("text-anchor", "start").attr("fill", "white").attr("x", 4).attr("dy", 13).text((x) => `${x.name} (${v(x.value, m)})`).attr("aria-label", (x) => `${x.name} (${x.value})`), g.append("rect").classed("node-text-bg", !0).attr("width", (x, _) => {\n      const E = this.services.domUtils.generateElementIDString(\n        `alluvial-node-text-${_}`\n      ), { width: b } = N.getSVGElementSize(I(`text#${E}`), {\n        useBBox: !0\n      });\n      return b + 8;\n    }).attr("height", 18).attr("stroke-width", 2).lower(), g.attr("transform", (x, _) => {\n      const E = this.services.domUtils.generateElementIDString(\n        `alluvial-node-text-${_}`\n      ), { width: b } = N.getSVGElementSize(I(`text#${E}`), {\n        useBBox: !0\n      }), S = (x.y1 - x.y0) / 2 - 9;\n      let M = x.x1 - x.x0;\n      return x.x1 >= b ? M = M - (b + 16) : M += 4, `translate(${M}, ${S})`;\n    }), this.addLineEventListener(), this.addNodeEventListener();\n  }\n  addLineEventListener() {\n    const t = this.getOptions(), n = this, { number: r, code: i } = y(this.getOptions(), "locale"), s = ba((a, o = "mouseover") => {\n      const l = n.parent.selectAll("path.link").transition().call(\n        (c) => n.services.transitions.setupTransition({\n          transition: c,\n          name: "alluvial-links-mouse-highlight"\n        })\n      );\n      o === "mouseout" ? (I(a).lower(), l.style("stroke-opacity", Pe.opacity.default)) : l.style("stroke-opacity", function() {\n        return a === this ? (I(this).raise(), Pe.opacity.selected) : Pe.opacity.unfocus;\n      });\n    }, 33);\n    this.parent.selectAll("path.link").on("mouseover", function(a, o) {\n      const l = I(this);\n      s(this, "mouseover"), l.classed("link-hovered", !0);\n      const c = getComputedStyle(this).getPropertyValue("stroke");\n      n.services.events.dispatchEvent(T.Alluvial.LINE_MOUSEOVER, {\n        event: a,\n        element: l,\n        datum: o\n      }), n.services.events.dispatchEvent(T.Tooltip.SHOW, {\n        event: a,\n        hoveredElement: l,\n        items: [\n          {\n            label: o.target.name,\n            value: (r(o.value, i) ? `${r(o.value, i)}` : "-") + (t.alluvial.units ? ` ${t.alluvial.units}` : ""),\n            color: c,\n            labelIcon: n.getRightArrowIcon()\n          }\n        ]\n      });\n    }).on("mousemove", function(a, o) {\n      n.services.events.dispatchEvent(T.Alluvial.LINE_MOUSEMOVE, {\n        event: a,\n        element: I(this),\n        datum: o\n      }), n.services.events.dispatchEvent(T.Tooltip.MOVE, {\n        event: a\n      });\n    }).on("click", function(a, o) {\n      n.services.events.dispatchEvent(T.Alluvial.LINE_CLICK, {\n        event: a,\n        element: I(this),\n        datum: o\n      });\n    }).on("mouseout", function(a, o) {\n      const l = I(this);\n      s(this, "mouseout"), l.classed("link-hovered", !1), n.services.events.dispatchEvent(T.Alluvial.LINE_MOUSEOUT, {\n        event: a,\n        element: l,\n        datum: o\n      }), n.services.events.dispatchEvent(T.Tooltip.HIDE, {\n        event: a,\n        hoveredElement: l\n      });\n    });\n  }\n  addNodeEventListener() {\n    const t = this, n = ba((r = [], i = "mouseover") => {\n      if (i === "mouseout" || r.length === 0) {\n        t.parent.selectAll("path.link").classed("link-hovered", !1).data(this.graph.links, (s) => s.index).order().style("stroke-opacity", Pe.opacity.default);\n        return;\n      }\n      t.parent.selectAll("path.link").transition().call(\n        (s) => this.services.transitions.setupTransition({\n          transition: s,\n          name: "alluvial-link-mouse-highlight"\n        })\n      ).style("stroke-opacity", function(s) {\n        return r.some((a) => a === s.index) ? (I(this).classed("link-hovered", !0).raise(), Pe.opacity.selected) : Pe.opacity.unfocus;\n      });\n    }, 66);\n    t.parent.selectAll(".node-group").on("mouseover", function(r, i) {\n      const s = I(this), a = [];\n      if (t.traverse({ link: "sourceLinks", node: "target" }, i, a), t.traverse({ link: "targetLinks", node: "source" }, i, a), a.length) {\n        const o = Mi(s.attr("transform"));\n        if (s.attr("transform", `translate(${o.x - 2}, ${o.y})`), s.classed("node-hovered", !0).selectAll("rect.node").attr("width", 8), i.x0 - 2 === 0) {\n          const c = t.services.domUtils.generateElementIDString(\n            `alluvial-node-title-${i.index}`\n          ), u = t.parent.select(`g#${c}`), d = Mi(u.attr("transform"));\n          u.attr("transform", `translate(${d.x + 4},${d.y})`);\n        }\n        const l = t.services.domUtils.generateElementIDString(\n          `alluvial-node-text-${i.index}`\n        );\n        t.parent.select(`text#${l}`).style("font-weight", "bold"), n(a, "mouseover"), t.services.events.dispatchEvent(T.Alluvial.NODE_MOUSEOVER, {\n          event: r,\n          element: s,\n          datum: i\n        });\n      }\n    }).on("mousemove", function(r, i) {\n      t.services.events.dispatchEvent(T.Alluvial.NODE_MOUSEMOVE, {\n        event: r,\n        element: I(this),\n        datum: i\n      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {\n        event: r\n      });\n    }).on("click", function(r, i) {\n      t.services.events.dispatchEvent(T.Alluvial.NODE_CLICK, {\n        event: r,\n        element: I(this),\n        datum: i\n      });\n    }).on("mouseout", function(r, i) {\n      const s = I(this), a = Mi(s.attr("transform"));\n      if (s.classed("node-hovered", !1).attr("transform", `translate(${a.x + 2}, ${a.y})`).select("rect.node").attr("width", Pe.nodeWidth), i.x0 - 2 === 0) {\n        const l = t.services.domUtils.generateElementIDString(\n          `alluvial-node-title-${i.index}`\n        ), c = t.parent.select(`g#${l}`), u = Mi(c.attr("transform"));\n        c.attr("transform", `translate(${u.x - 4},${u.y})`);\n      }\n      const o = t.services.domUtils.generateElementIDString(\n        `alluvial-node-text-${i.index}`\n      );\n      t.parent.select(`text#${o}`).style("font-weight", "normal"), n([], "mouseout"), t.services.events.dispatchEvent(T.Alluvial.NODE_MOUSEOUT, {\n        event: r,\n        element: s,\n        datum: i\n      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {\n        hoveredElement: s\n      });\n    });\n  }\n  // Traverse graph and get all connected links to node\n  traverse(t, n, r = []) {\n    n[t.link].map((i) => (r.push(i.index), i[t.node])).forEach((i) => this.traverse(t, i, r));\n  }\n  getRightArrowIcon() {\n    return `\n\t\t<svg xmlns="http://www.w3.org/2000/svg" class="arrow-right" width="32" height="32" viewBox="0 0 32 32">\n\t\t\t<polygon points="18 6 16.57 7.393 24.15 15 4 15 4 17 24.15 17 16.57 24.573 18 26 28 16 18 6"/>\n\t\t\t<rect width="32" height="32"/>\n\t\t</svg>`;\n  }\n  // Remove event listeners\n  destroy() {\n    this.parent.selectAll("path.line,.node-group").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);\n  }\n}\nclass Oe extends mt {\n  constructor() {\n    super(...arguments), this.type = "grid", this.renderType = rt.SVG;\n  }\n  render(t = !0) {\n    const n = y(this.getOptions(), "grid", "x", "enabled"), r = y(this.getOptions(), "grid", "y", "enabled");\n    this.drawBackdrop(n, r), !(!n && !r) && (n && (N.appendOrSelect(this.backdrop, "g.x.grid"), this.drawXGrid(t)), r && (N.appendOrSelect(this.backdrop, "g.y.grid"), this.drawYGrid(t)));\n  }\n  drawXGrid(t) {\n    const n = this.parent, r = this.backdrop.attr("height"), i = this.services.cartesianScales.getMainXScale(), s = Jc(i).tickSizeInner(-r).tickSizeOuter(0);\n    if (y(this.getOptions(), "grid", "x", "alignWithAxisTicks")) {\n      const o = this.services.cartesianScales.getDomainAxisPosition(), l = y(this.getOptions(), "axes", o, "ticks", "values");\n      l && s.tickValues(l);\n    } else {\n      const o = y(this.getOptions(), "grid", "x", "numberOfTicks");\n      s.ticks(o);\n    }\n    const a = n.select(".x.grid").attr("transform", `translate(${-this.backdrop.attr("x")}, ${r})`);\n    t ? a.transition().call(\n      (o) => this.services.transitions.setupTransition({\n        transition: o,\n        name: "grid-update",\n        animate: t\n      })\n    ).call(s) : a.call(s), this.cleanGrid(a);\n  }\n  drawYGrid(t) {\n    const n = this.parent, r = this.backdrop.attr("width"), i = this.services.cartesianScales.getMainYScale(), s = Lg(i).tickSizeInner(-r).tickSizeOuter(0);\n    if (y(this.getOptions(), "grid", "y", "alignWithAxisTicks")) {\n      const o = this.services.cartesianScales.getRangeAxisPosition(), l = y(this.getOptions(), "axes", o, "ticks", "values");\n      l && s.tickValues(l);\n    } else {\n      const o = y(this.getOptions(), "grid", "y", "numberOfTicks");\n      s.ticks(o);\n    }\n    const a = n.select(".y.grid").attr("transform", `translate(0, ${-this.backdrop.attr("y")})`);\n    t ? a.transition().call(\n      (o) => this.services.transitions.setupTransition({\n        transition: o,\n        name: "grid-update",\n        animate: t\n      })\n    ).call(s) : a.call(s), this.cleanGrid(a);\n  }\n  /**\n   * Returns the threshold for the gridline tooltips based on the mouse location.\n   * Calculated based on the mouse position between the two closest gridlines or edges of chart.\n   */\n  getGridlineThreshold(t) {\n    const n = this.parent, r = n.selectAll(".x.grid .tick").nodes().sort((u, d) => Number(fn(u).tx) - Number(fn(d).tx));\n    let i = -1;\n    if (!r.length)\n      return;\n    r.forEach((u) => {\n      t[0] >= +fn(u).tx && i++;\n    });\n    const s = i + 1 < r.length ? i + 1 : r.length, a = r[i], o = r[s];\n    let l;\n    if (!a)\n      l = +fn(o).tx;\n    else if (o)\n      l = +fn(o).tx - +fn(a).tx;\n    else {\n      const u = n.select("rect.chart-grid-backdrop").node();\n      l = N.getSVGElementSize(u).width - +fn(a).tx;\n    }\n    const { threshold: c } = this.getOptions().tooltip.gridline;\n    return l * c;\n  }\n  /**\n   * Returns the active gridlines based on the gridline threshold and mouse position.\n   * @param position mouse positon\n   */\n  getActiveGridline(t) {\n    const n = y(this.getOptions, "tooltip", "gridline", "threshold"), r = n || this.getGridlineThreshold(t);\n    return this.parent.selectAll(".x.grid .tick").filter(function() {\n      const i = fn(this), s = {\n        min: Number(i.tx) - r,\n        max: Number(i.tx) + r\n      };\n      return s.min <= t[0] && t[0] <= s.max;\n    });\n  }\n  drawBackdrop(t, n) {\n    const r = this.parent, i = this.services.cartesianScales.getMainXScale(), s = this.services.cartesianScales.getMainYScale(), [a, o] = i.range(), [l, c] = s.range();\n    this.backdrop = N.appendOrSelect(r, "svg.chart-grid-backdrop").attr(\n      "role",\n      "presentation"\n    );\n    const u = N.appendOrSelect(\n      this.backdrop,\n      t || n ? "rect.chart-grid-backdrop.stroked" : "rect.chart-grid-backdrop"\n    );\n    this.backdrop.merge(u).attr("x", a).attr("y", c).attr("width", Math.abs(o - a)).attr("height", Math.abs(l - c)).lower(), u.attr("width", "100%").attr("height", "100%");\n  }\n  cleanGrid(t) {\n    t.selectAll("text").remove(), t.select(".domain").remove();\n  }\n}\nclass Ev extends mt {\n  constructor() {\n    super(...arguments), this.type = "area", this.renderType = rt.SVG, this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999), this.handleLegendOnHover = (t) => {\n      const { hoveredElement: n } = t.detail;\n      this.parent.selectAll("path.area").transition("legend-hover-area").call(\n        (r) => this.services.transitions.setupTransition({\n          transition: r,\n          name: "legend-hover-area"\n        })\n      ).attr("opacity", (r) => r.name !== n.datum().name ? yn.opacity.unselected : yn.opacity.selected);\n    }, this.handleLegendMouseOut = () => {\n      this.parent.selectAll("path.area").transition("legend-mouseout-area").call(\n        (t) => this.services.transitions.setupTransition({\n          transition: t,\n          name: "legend-mouseout-area"\n        })\n      ).attr("opacity", yn.opacity.selected);\n    };\n  }\n  init() {\n    const t = this.services.events;\n    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n  render(t = !0) {\n    const n = this.getComponentContainer({ ariaLabel: "area graphs", withinChartClip: !0 }), r = this.getOptions();\n    let i = [0, 0];\n    const { cartesianScales: s } = this.services, a = s.getOrientation(), o = au().curve(this.services.curves.getD3Curve()).defined((b) => {\n      const S = s.getRangeIdentifier();\n      return b[S] != null;\n    }), l = this.model.getGroupedData(this.configs.groups), c = y(r, "bounds"), u = c && l && l.length === 1;\n    !u && c && console.warn(\n      `Bounds can only be shown when having 1 single datagroup, you\'ve supplied ${l.length}`\n    );\n    let d = 0;\n    const h = (b, S) => {\n      y(r, "axes", b, "includeZero") === !1 && S[0] > 0 && S[1] > 0 && (d = S[0]);\n    }, p = (b) => u ? s.getBoundedScaledValues(b)[0] : s.getRangeValue(d), f = (b) => u ? s.getBoundedScaledValues(b)[1] : s.getRangeValue(b);\n    a === Ft.VERTICAL ? (i = s.getMainYScale().domain(), h(s.getMainYAxisPosition(), i), o.x((b) => s.getDomainValue(b)).y0((b) => p(b)).y1((b) => f(b))) : (i = s.getMainXScale().domain(), h(s.getMainXAxisPosition(), i), o.x0((b) => p(b)).x1((b) => f(b)).y((b) => s.getDomainValue(b)));\n    const g = y(r, "color", "gradient", "enabled"), m = l && l.length === 1 && g;\n    l.length > 1 && g && console.error("Gradients can only be enabled when having 1 single dataset");\n    const v = n.selectAll("path.area").data(l, (b) => b.name), x = I(this.services.domUtils.getMainContainer());\n    if (v.exit().attr("opacity", 0).remove(), !l.length)\n      return;\n    if (m) {\n      const b = x.select(\n        `path.${this.model.getColorClassName({\n          classNameTypes: [it.STROKE],\n          dataGroupName: l[0].name\n        })}`\n      ).node();\n      let S;\n      if (b)\n        S = getComputedStyle(b, null).getPropertyValue(\n          "stroke"\n        );\n      else {\n        const M = y(this.model.getOptions(), "color", "scale");\n        if (M !== null) {\n          const D = Object.keys(M);\n          S = M[D[0]];\n        }\n      }\n      Nl.appendOrUpdateLinearGradient({\n        svg: this.parent,\n        id: this.services.domUtils.generateElementIDString(\n          `${l[0].name.replace(" ", "")}_${this.gradient_id}`\n        ),\n        x1: "0%",\n        x2: "0%",\n        y1: "0%",\n        y2: "100%",\n        stops: Nl.getStops(i, S)\n      });\n    } else\n      this.parent.selectAll("defs linearGradient").empty() || this.parent.selectAll("defs linearGradient").each(function() {\n        this.parentNode.remove();\n      });\n    const _ = this, E = v.enter().append("path");\n    m ? E.merge(v).style(\n      "fill",\n      (b) => `url(#${this.services.domUtils.generateElementIDString(\n        `${b.name.replace(" ", "")}_${this.gradient_id}`\n      )})`\n    ).attr("class", "area").attr(\n      "class",\n      (b) => this.model.getColorClassName({\n        classNameTypes: [it.FILL],\n        dataGroupName: b.name,\n        originalClassName: "area"\n      })\n    ).attr("d", (b) => {\n      const { data: S } = b;\n      return o(S);\n    }) : (E.attr("opacity", 0).merge(v).attr("class", "area").attr(\n      "class",\n      (b) => this.model.getColorClassName({\n        classNameTypes: [it.FILL, it.STROKE],\n        dataGroupName: b.name,\n        originalClassName: "area"\n      })\n    ).style("fill", (b) => _.model.getFillColor(b.name, null, b.data)).transition().call(\n      (b) => this.services.transitions.setupTransition({\n        transition: b,\n        name: "area-update-enter",\n        animate: t\n      })\n    ).attr("opacity", u ? 1 : yn.opacity.selected).attr("d", (b) => {\n      const { data: S } = b;\n      return o(S);\n    }), u && E.attr("fill-opacity", yn.opacity.selected).style("stroke", (b) => _.model.getStrokeColor(b.name, null, b.data)).style("stroke-dasharray", "2, 2").attr("stroke-width", 0.7 + "px"));\n  }\n  destroy() {\n    const t = this.services.events;\n    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n}\nclass Fr extends mt {\n  constructor() {\n    super(...arguments), this.type = "line", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {\n      const { hoveredElement: n } = t.detail;\n      this.parent.selectAll("path.line").transition("legend-hover-line").call(\n        (r) => this.services.transitions.setupTransition({\n          transition: r,\n          name: "legend-hover-line"\n        })\n      ).attr("opacity", (r) => r.name !== n.datum().name ? vn.opacity.unselected : vn.opacity.selected);\n    }, this.handleLegendMouseOut = () => {\n      this.parent.selectAll("path.line").transition("legend-mouseout-line").call(\n        (t) => this.services.transitions.setupTransition({\n          transition: t,\n          name: "legend-mouseout-line"\n        })\n      ).attr("opacity", vn.opacity.selected);\n    };\n  }\n  init() {\n    const { events: t } = this.services;\n    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n  render(t = !0) {\n    const n = this.getComponentContainer({ ariaLabel: "lines", withinChartClip: !0 }), { cartesianScales: r, curves: i } = this.services, s = (p) => r.getDomainValue(p), a = (p) => r.getRangeValue(p), [o, l] = En(\n      s,\n      a,\n      r.getOrientation()\n    ), c = this.getOptions(), u = xs().x(o).y(l).curve(i.getD3Curve()).defined((p) => {\n      const f = r.getRangeIdentifier(p);\n      return p[f] != null;\n    });\n    let d = [];\n    if (this.configs.stacked) {\n      const p = Object.keys(c.axes).some((g) => c.axes[g].percentage), { groupMapsTo: f } = c.data;\n      d = this.model.getStackedData({\n        groups: this.configs.groups,\n        percentage: p\n      }).map((g) => {\n        const m = this.services.cartesianScales.getDomainIdentifier(g), v = this.services.cartesianScales.getRangeIdentifier(g);\n        return {\n          name: y(g, 0, f),\n          data: g.map((x) => ({\n            [m]: x.data.sharedStackKey,\n            [f]: x[f],\n            [v]: x[1]\n          })),\n          hidden: !NC(g, (x) => x[0] !== x[1])\n        };\n      });\n    } else\n      d = this.model.getGroupedData(this.configs.groups);\n    const h = n.selectAll("path.line").data(d, (p) => p.name);\n    h.exit().attr("opacity", 0).remove(), h.enter().append("path").classed("line", !0).attr("opacity", 0).merge(h).data(d, (p) => p.name).attr(\n      "class",\n      (p) => this.model.getColorClassName({\n        classNameTypes: [it.STROKE],\n        dataGroupName: p.name,\n        originalClassName: "line"\n      })\n    ).style("stroke", (p) => this.model.getStrokeColor(p.name, null, p.data)).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "line").attr("aria-label", (p) => {\n      const { data: f } = p;\n      return f.map((g) => {\n        const m = this.services.cartesianScales.getRangeIdentifier(g);\n        return g[m];\n      }).join(",");\n    }).transition().call(\n      (p) => this.services.transitions.setupTransition({\n        transition: p,\n        name: "line-update-enter",\n        animate: t\n      })\n    ).attr("opacity", (p) => p.hidden ? 0 : 1).attr("d", (p) => {\n      const { data: f } = p;\n      return u(f);\n    });\n  }\n  destroy() {\n    const t = this.services.events;\n    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n}\nconst pp = 5;\nfunction dD(e, t) {\n  return e > t - pp && e < t + pp;\n}\nclass Vn extends mt {\n  constructor() {\n    super(...arguments), this.type = "ruler", this.renderType = rt.SVG, this.isXGridEnabled = y(this.getOptions(), "grid", "x", "enabled"), this.isYGridEnabled = y(this.getOptions(), "grid", "y", "enabled"), this.isEventListenerAdded = !1;\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(t = !1) {\n    const n = y(this.getOptions(), "ruler", "enabled");\n    this.drawBackdrop(), n && !this.isEventListenerAdded ? this.addBackdropEventListeners() : !n && this.isEventListenerAdded && this.removeBackdropEventListeners();\n  }\n  removeBackdropEventListeners() {\n    this.isEventListenerAdded = !1, this.backdrop.on("mousemove mouseover mouseout", null);\n  }\n  formatTooltipData(t) {\n    return t;\n  }\n  showRuler(t, [n, r]) {\n    const i = this.parent, s = this.services.cartesianScales.getOrientation(), a = this.model.getDisplayData(), o = this.services.cartesianScales.getRangeScale(), [l, c] = o.range(), u = s === Ft.HORIZONTAL ? r : n, d = N.appendOrSelect(i, "g.ruler").attr("aria-label", "ruler"), h = N.appendOrSelect(d, "line.ruler-line"), p = i.selectAll("[role=graphics-symbol]"), f = a.map((m) => ({\n      domainValue: this.services.cartesianScales.getDomainValue(m),\n      originalData: m\n    })).filter((m) => dD(m.domainValue, u));\n    if (this.pointsWithinLine && f.length === this.pointsWithinLine.length && f.map((m) => m.domainValue).join() === this.pointsWithinLine.map((m) => m.domainValue).join())\n      return this.pointsWithinLine = f, this.services.events.dispatchEvent(T.Tooltip.MOVE, {\n        mousePosition: [n, r]\n      });\n    this.pointsWithinLine = f;\n    const g = this.pointsWithinLine.reduce((m, v) => {\n      if (m.length === 0)\n        return m.push(v), m;\n      const x = m[0].domainValue, _ = Math.abs(u - v.domainValue), E = Math.abs(u - x);\n      return _ > E || (_ < E ? m = [v] : m.push(v)), m;\n    }, []);\n    if (g.length > 0) {\n      const m = g.map((E) => E.originalData).filter((E) => {\n        const b = this.services.cartesianScales.getRangeIdentifier(E);\n        return E[b] != null;\n      }), v = g.map(\n        (E) => E.domainValue\n      ), x = p.filter((E) => {\n        const b = this.services.cartesianScales.getDomainValue(E);\n        return v.includes(b);\n      });\n      this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !Cg(this.elementsToHighlight, x) && this.hideRuler(), x.dispatch("mouseover"), this.elementsToHighlight = x, this.services.events.dispatchEvent(T.Tooltip.SHOW, {\n        event: t,\n        mousePosition: [n, r],\n        hoveredElement: h,\n        data: this.formatTooltipData(m)\n      }), d.attr("opacity", 1);\n      const _ = g[0];\n      s === "horizontal" ? h.attr("x1", c).attr("x2", l).attr("y1", _.domainValue).attr("y2", _.domainValue) : h.attr("y1", c).attr("y2", l).attr("x1", _.domainValue).attr("x2", _.domainValue);\n    } else\n      this.hideRuler();\n  }\n  hideRuler() {\n    const t = this.parent, n = N.appendOrSelect(t, "g.ruler");\n    t.selectAll("[role=graphics-symbol]").dispatch("mouseout"), this.services.events.dispatchEvent(T.Tooltip.HIDE), n.attr("opacity", 0);\n  }\n  /**\n   * Adds the listener on the X grid to trigger multiple point tooltips along the x axis.\n   */\n  addBackdropEventListeners() {\n    this.isEventListenerAdded = !0;\n    const t = this, n = this.services.domUtils.getHolder(), r = this.model.getDisplayData();\n    let i = function(s) {\n      const a = rr(s, t.parent.node());\n      t.showRuler(s, a);\n    };\n    if (r.length > 100) {\n      const s = r.length % 50 * 12.5;\n      i = iw(\n        function(a) {\n          const { mousePosition: o } = this;\n          t.showRuler(a, o);\n        },\n        s,\n        n\n      );\n    }\n    this.backdrop.on("mousemove mouseover", i).on("mouseout", this.hideRuler.bind(this));\n  }\n  drawBackdrop() {\n    const t = this.parent;\n    this.backdrop = N.appendOrSelect(t, "svg.chart-grid-backdrop");\n  }\n}\nlet nn = class extends mt {\n  constructor() {\n    super(...arguments), this.type = "scatter", this.renderType = rt.SVG, this.handleChartHolderOnHover = () => {\n      if (!this.parent) throw new Error("Parent not defined");\n      this.parent.selectAll("circle.dot").transition("chart-holder-hover-scatter").call(\n        (t) => {\n          var n;\n          return (n = this.services.transitions) == null ? void 0 : n.setupTransition({\n            transition: t,\n            name: "chart-holder-hover-scatter"\n          });\n        }\n      ).attr("opacity", 1);\n    }, this.handleChartHolderOnMouseOut = () => {\n      if (!this.parent) throw new Error("Parent not defined");\n      this.parent.selectAll("circle.dot").transition("chart-holder-mouseout-scatter").call(\n        (t) => {\n          var n;\n          return (n = this.services.transitions) == null ? void 0 : n.setupTransition({\n            transition: t,\n            name: "chart-holder-mouseout-scatter"\n          });\n        }\n      ).attr("opacity", 0);\n    }, this.handleLegendOnHover = (t) => {\n      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;\n      if (!this.parent) throw new Error("Parent not defined");\n      this.parent.selectAll("circle.dot").transition("legend-hover-scatter").call(\n        (i) => {\n          var s;\n          return (s = this.services.transitions) == null ? void 0 : s.setupTransition({\n            transition: i,\n            name: "legend-hover-scatter"\n          });\n        }\n      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);\n    }, this.handleLegendMouseOut = () => {\n      if (!this.parent) throw new Error("Parent not defined");\n      this.parent.selectAll("circle.dot").transition("legend-mouseout-scatter").call(\n        (t) => {\n          var n;\n          return (n = this.services.transitions) == null ? void 0 : n.setupTransition({\n            transition: t,\n            name: "legend-mouseout-scatter"\n          });\n        }\n      ).attr("opacity", 1);\n    };\n  }\n  init() {\n    const { events: t } = this.services;\n    if (!t) throw new Error("Services events are undefined.");\n    t.addEventListener(\n      T.Legend.ITEM_HOVER,\n      this.handleLegendOnHover\n    ), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n    const { fadeInOnChartHolderMouseover: n } = this.configs;\n    n && (t.addEventListener(T.Chart.MOUSEOVER, this.handleChartHolderOnHover), t.addEventListener(T.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut));\n  }\n  filterBasedOnZoomDomain(t) {\n    const { cartesianScales: n } = this.services;\n    if (!n) throw new Error("Services cartesianScales are undefined.");\n    const r = n.getDomainIdentifier(t), i = this.model.get("zoomDomain");\n    return i !== void 0 ? t.filter(\n      (s) => s[r].getTime() >= i[0].getTime() && s[r].getTime() <= i[1].getTime()\n    ) : t;\n  }\n  getScatterData() {\n    const t = this.getOptions(), { stacked: n } = this.configs;\n    let r;\n    if (n) {\n      const i = Object.keys(t.axes).some((s) => t.axes[s].percentage);\n      r = this.model.getStackedData({\n        groups: this.configs.groups,\n        percentage: i\n      });\n    } else {\n      const { cartesianScales: i } = this.services;\n      if (!i) throw new Error("Services cartesianScales are undefined.");\n      r = this.model.getDisplayData(this.configs.groups).filter((s) => {\n        const a = i.getRangeIdentifier(s);\n        return s[a] !== void 0 && s[a] !== null;\n      });\n    }\n    return this.filterBasedOnZoomDomain(r);\n  }\n  render(t) {\n    if (!(y(this.getOptions(), "points", "enabled") || y(this.getOptions(), "bubble", "enabled")))\n      return;\n    const n = this.getComponentContainer({ ariaLabel: "scatter points", withinChartClip: !0 }), r = this.getOptions(), { groupMapsTo: i } = r.data, { cartesianScales: s } = this.services;\n    if (!s) throw new Error("Services cartesianScales are undefined.");\n    const a = s.getDomainIdentifier(), o = n.selectAll("circle.dot").data(\n      this.getScatterData(),\n      (c) => `${c[i]}-${c[a]}`\n    );\n    o.exit().attr("opacity", 0).remove();\n    const l = o.enter().append("circle").classed("dot", !0).attr("opacity", 0).merge(o);\n    this.styleCircles(l, t), this.addEventListeners();\n  }\n  // A value is an anomaly if is above all defined domain and range thresholds\n  isDatapointThresholdAnomaly(t) {\n    const { handleThresholds: n } = this.configs;\n    if (!n)\n      return !1;\n    const { cartesianScales: r } = this.services;\n    if (!r) throw new Error("Cartesian scales service is undefined");\n    const i = r.getOrientation(), [s, a] = En(\n      r.getHighestDomainThreshold(),\n      r.getHighestRangeThreshold(),\n      i\n    ), [o, l] = En(\n      (d) => r.getDomainValue(d),\n      (d) => r.getRangeValue(d),\n      i\n    ), c = o(t), u = l(t);\n    return a && s ? u <= a.scaleValue && c >= s.scaleValue : a ? u <= a.scaleValue : s ? c >= s.scaleValue : !1;\n  }\n  styleCircles(t, n) {\n    const r = this.getOptions(), { filled: i, fillOpacity: s } = r.points, { cartesianScales: a } = this.services;\n    if (!a) throw new Error("Cartesian scales service is undefined");\n    const { groupMapsTo: o } = r.data, l = (p) => a.getDomainValue(p), c = (p) => a.getRangeValue(p), [u, d] = En(\n      l,\n      c,\n      a.getOrientation()\n    ), { fadeInOnChartHolderMouseover: h } = this.configs;\n    t.raise().classed("dot", !0).attr("class", (p) => {\n      const f = a.getDomainIdentifier(p), g = this.model.getIsFilled(p[o], p[f], p, i) ? [it.FILL, it.STROKE] : [it.STROKE];\n      return this.model.getColorClassName({\n        classNameTypes: g,\n        dataGroupName: p[o],\n        originalClassName: "dot"\n      }) || "";\n    }).classed("threshold-anomaly", (p) => this.isDatapointThresholdAnomaly(p)).classed("filled", (p) => {\n      const f = a.getDomainIdentifier(p);\n      return this.model.getIsFilled(p[o], p[f], p, i);\n    }).classed("unfilled", (p) => {\n      const f = a.getDomainIdentifier(p);\n      return !this.model.getIsFilled(p[o], p[f], p, i);\n    }).transition().call(\n      (p) => {\n        var f;\n        return (f = this.services.transitions) == null ? void 0 : f.setupTransition({\n          transition: p,\n          name: "scatter-update-enter",\n          animate: n\n        });\n      }\n    ).attr("cx", u).attr("cy", d).attr("r", r.points.radius).style("fill", (p) => {\n      const f = a.getDomainIdentifier(p);\n      if (this.model.getIsFilled(p[o], p[f], p, i))\n        return this.model.getFillColor(p[o], p[f], p);\n    }).style("stroke", (p) => {\n      const f = a.getDomainIdentifier(p);\n      return this.model.getStrokeColor(p[o], p[f], p);\n    }).attr("fill-opacity", i ? s : 1).attr("opacity", h ? 0 : 1).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "point").attr("aria-label", (p) => {\n      const f = a.getRangeIdentifier(p);\n      return p[f];\n    }), this.addEventListeners();\n  }\n  // Extended in bubble graphs\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getTooltipAdditionalItems(t) {\n    return null;\n  }\n  addEventListeners() {\n    const t = this, { groupMapsTo: n } = t.getOptions().data;\n    if (!this.parent) throw new Error("Parent not defined");\n    this.parent.selectAll("circle").on("mouseover", function(r, i) {\n      var s, a;\n      const o = I(this);\n      o.classed("hovered", !0).attr(\n        "class",\n        (l) => t.model.getColorClassName({\n          classNameTypes: [it.FILL],\n          dataGroupName: l[n],\n          originalClassName: o.attr("class")\n        })\n      ).style("fill", (l) => {\n        var c;\n        const u = (c = t.services.cartesianScales) == null ? void 0 : c.getDomainIdentifier(l);\n        return t.model.getFillColor(l[n], l[u], l);\n      }).classed("unfilled", !1), (s = t.services.events) == null || s.dispatchEvent(T.Tooltip.SHOW, {\n        event: r,\n        hoveredElement: o,\n        data: [i],\n        additionalItems: t.getTooltipAdditionalItems(i)\n      }), (a = t.services.events) == null || a.dispatchEvent(T.Scatter.SCATTER_MOUSEOVER, {\n        event: r,\n        element: o,\n        datum: i\n      });\n    }).on("mousemove", function(r, i) {\n      var s, a;\n      const o = I(this);\n      (s = t.services.events) == null || s.dispatchEvent(T.Scatter.SCATTER_MOUSEMOVE, {\n        event: r,\n        element: o,\n        datum: i\n      }), (a = t.services.events) == null || a.dispatchEvent(T.Tooltip.MOVE, {\n        event: r\n      });\n    }).on("click", function(r, i) {\n      var s;\n      (s = t.services.events) == null || s.dispatchEvent(T.Scatter.SCATTER_CLICK, {\n        event: r,\n        element: I(this),\n        datum: i\n      });\n    }).on("mouseout", function(r, i) {\n      var s, a, o;\n      const l = I(this);\n      if (l.classed("hovered", !1), !t.configs.filled) {\n        const { filled: c } = t.getOptions().points, u = (s = t.services.cartesianScales) == null ? void 0 : s.getDomainIdentifier(i), d = t.model.getIsFilled(\n          i[n],\n          i[u],\n          i,\n          c\n        );\n        l.classed("unfilled", !d).style("fill", (h) => d || c ? t.model.getFillColor(h[n], h[u], h) : null);\n      }\n      (a = t.services.events) == null || a.dispatchEvent(T.Scatter.SCATTER_MOUSEOUT, {\n        event: r,\n        element: l,\n        datum: i\n      }), (o = t.services.events) == null || o.dispatchEvent(T.Tooltip.HIDE, {\n        hoveredElement: l\n      });\n    });\n  }\n  destroy() {\n    var t;\n    (t = this.parent) == null || t.selectAll("circle").on("mousemove", null).on("mouseout", null);\n    const { events: n } = this.services;\n    if (!n) throw new Error("Services events undefined");\n    n.removeEventListener(\n      T.Legend.ITEM_HOVER,\n      this.handleLegendOnHover\n    ), n.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), n.removeEventListener(T.Chart.MOUSEOVER, this.handleChartHolderOnHover), n.removeEventListener(T.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut);\n  }\n};\nclass Ov extends mt {\n  constructor(t, n, r) {\n    super(t, n, r), this.type = "axes", this.renderType = rt.SVG, this.truncation = {\n      [G.LEFT]: !1,\n      [G.RIGHT]: !1,\n      [G.TOP]: !1,\n      [G.BOTTOM]: !1\n    }, r && (this.configs = r), this.margins = this.configs.margins;\n  }\n  render(t = !0) {\n    const { position: n } = this.configs, r = this.getOptions(), i = y(r, "axes", n, "visible"), s = this.getComponentContainer({\n      ariaLabel: "axes"\n    }), { width: a, height: o } = N.getSVGElementSize(s, {\n      useAttrs: !0\n    }), l = N.appendOrSelect(s, `g.axis.${n}`);\n    let c, u;\n    if (n === G.BOTTOM || n === G.TOP ? (c = this.configs.axes[G.LEFT] ? this.margins.left : 0, u = this.configs.axes[G.RIGHT] ? a - this.margins.right : a) : (c = o - this.margins.bottom, u = this.margins.top), !this.services.cartesianScales) throw new Error("Services cartesianScales undefined");\n    const d = this.services.cartesianScales.getScaleByPosition(n);\n    this.scaleType === et.LABELS || this.scaleType === et.LABELS_RATIO ? d.rangeRound([c, u]) : d.range([c, u]);\n    let h;\n    switch (n) {\n      case G.LEFT:\n        h = Lg;\n        break;\n      case G.BOTTOM:\n        h = Jc;\n        break;\n      case G.RIGHT:\n        h = jC;\n        break;\n      case G.TOP:\n        h = FC;\n        break;\n    }\n    l.attr("aria-label", `${n} axis`);\n    const p = !l.select("g.ticks").empty();\n    let f = N.appendOrSelect(l, "g.ticks");\n    p || (f.attr("role", `${ht.GRAPHICS_OBJECT} ${ht.GROUP}`), f.attr("aria-label", `${n} ticks`));\n    const g = N.appendOrSelect(l, "g.ticks.invisible").style("opacity", "0").style("pointer-events", "none").attr("aria-hidden", !0).attr("aria-label", `invisible ${n} ticks`), m = y(r, "axes", n), v = this.scaleType === et.TIME || m.scaleType === et.TIME, x = n === G.LEFT || n === G.RIGHT, _ = this.model.get("zoomDomain");\n    if (_ && v && !x && d.domain(_), !i) {\n      f.attr("aria-hidden", !0);\n      return;\n    }\n    const E = y(m, "scaleType"), b = y(r, "data", "loading"), S = y(m, "ticks", "number"), M = y(m, "ticks", "values"), D = y(m, "truncation", "type"), A = y(m, "truncation", "threshold"), R = y(m, "truncation", "numCharacter"), $ = S !== null, H = y(r, "timeScale"), P = N.appendOrSelect(g, "g.tick"), B = N.appendOrSelect(P, "text").text("0"), O = N.getSVGElementSize(B.node(), {\n      useBBox: !0\n    }).height;\n    P.remove();\n    const w = this.scaleType || m.scaleType || et.LINEAR, L = h(d).tickSizeOuter(0);\n    if (d.ticks) {\n      let q;\n      if ($ ? q = S : (q = Pn.ticks.number, x && (q = this.getNumberOfFittingTicks(\n        o,\n        O,\n        Pn.ticks.verticalSpaceRatio\n      ))), d.ticks().length === 1 && d.ticks()[0] === 0 && (q = 0), L.ticks(q), v)\n        if (!d.ticks(q).length)\n          L.tickValues([]);\n        else {\n          const tt = y(r, "timeScale", "addSpaceOnEdges"), lt = y(r, "axes", n, "domain"), z = d.copy();\n          tt && !lt && z.nice(q);\n          const W = z.ticks(q);\n          tt && W.length > 2 && !lt && (W.splice(W.length - 1, 1), W.splice(0, 1)), L.tickValues(W);\n        }\n    }\n    let k;\n    const U = y(m, "ticks", "formatter"), { code: Z, number: j } = y(r, "locale");\n    if (v) {\n      const q = Dl(\n        L.tickValues(),\n        y(r, "timeScale", "timeInterval")\n      );\n      U === null ? k = (tt, lt) => kl(tt, lt, L.tickValues(), q, H, r.locale) : k = (tt, lt) => {\n        const z = kl(\n          tt,\n          lt,\n          L.tickValues(),\n          q,\n          H,\n          r.locale\n        );\n        return U(tt, lt, z);\n      };\n    } else\n      U === null ? w === et.LINEAR && (k = (q) => j(q, Z)) : k = U;\n    L.tickFormat(k);\n    const [F, Y] = this.services.cartesianScales.getScaleByPosition(n).domain();\n    let ot;\n    if (M) {\n      if (v)\n        M.forEach((q, tt) => {\n          q.getTime === void 0 && (M[tt] = new Date(q));\n        }), ot = M.filter((q) => {\n          const tt = q.getTime();\n          return tt >= new Date(F).getTime() && tt <= new Date(Y).getTime();\n        });\n      else if (E === et.LABELS) {\n        const q = this.services.cartesianScales.getScaleByPosition(n).domain();\n        ot = M.filter((tt) => q.includes(tt));\n      } else\n        ot = M.filter(\n          (q) => q >= F && q <= Y\n        );\n      L.tickValues(ot);\n    }\n    switch (n) {\n      case G.LEFT:\n        f.attr("transform", `translate(${this.margins.left}, 0)`);\n        break;\n      case G.BOTTOM:\n        f.attr("transform", `translate(0, ${o - this.margins.bottom})`);\n        break;\n      case G.RIGHT:\n        f.attr("transform", `translate(${a - this.margins.right}, 0)`);\n        break;\n      case G.TOP:\n        f.attr("transform", `translate(0, ${this.margins.top})`);\n        break;\n    }\n    const Q = this.model.isDataEmpty();\n    if (m.title) {\n      const q = N.appendOrSelect(l, "text.axis-title").html(\n        Q || b ? "" : en(m.title)\n      ), tt = y(m, "titleOrientation");\n      let lt;\n      switch (n) {\n        case G.LEFT:\n          tt === fl.RIGHT ? q.attr("transform", "rotate(90)").attr("y", 0).attr("x", d.range()[0] / 2).attr("dy", "-0.5em").style("text-anchor", "middle") : q.attr("transform", "rotate(-90)").attr("y", 0).attr("x", -(d.range()[0] / 2)).attr("dy", "0.75em").style("text-anchor", "middle");\n          break;\n        case G.BOTTOM:\n          q.attr(\n            "transform",\n            `translate(${this.margins.left / 2 + d.range()[1] / 2}, ${o + 4})`\n          ).style("text-anchor", "middle");\n          break;\n        case G.RIGHT:\n          tt === fl.LEFT ? q.attr("transform", "rotate(-90)").attr("y", a).attr("x", -(d.range()[0] / 2)).style("text-anchor", "middle") : q.attr("transform", "rotate(90)").attr("y", -a).attr("x", d.range()[0] / 2).attr("dy", "0.75em").style("text-anchor", "middle");\n          break;\n        case G.TOP:\n          lt = N.getSVGElementSize(q, {\n            useBBox: !0\n          }).height, q.attr(\n            "transform",\n            `translate(${this.margins.left / 2 + d.range()[1] / 2}, ${lt / 2})`\n          ).style("text-anchor", "middle");\n          break;\n      }\n    }\n    if (v) {\n      const q = Dl(\n        L.tickValues(),\n        y(r, "timeScale", "timeInterval")\n      ), tt = H.showDayName, lt = f;\n      t && (f = f.transition().call(\n        (z) => this.services.transitions.setupTransition({\n          transition: z,\n          name: "axis-update",\n          animate: t\n        })\n      )), f = f.call(L), lt.selectAll(".tick").data(L.tickValues(), d).order().select("text").attr(\n        "class",\n        (z, W) => Gm(z, W, L.tickValues(), q, tt) ? "tick-label--primary" : "tick-label"\n      );\n    } else\n      !t || !p ? f = f.call(L) : f = f.transition().call(\n        (q) => this.services.transitions.setupTransition({\n          transition: q,\n          name: "axis-update",\n          animate: t\n        })\n      ).call(L);\n    if (g.call(L), n === G.BOTTOM || n === G.TOP) {\n      let q = !1;\n      const tt = y(m, "ticks", "rotation");\n      if (tt === Ws.ALWAYS)\n        q = !0;\n      else if (tt === Ws.NEVER)\n        q = !1;\n      else if (!tt || tt === Ws.AUTO)\n        if (d.step)\n          q = g.selectAll("g.tick text").nodes().some(\n            (lt) => N.getSVGElementSize(lt, {\n              useBBox: !0\n            }).width >= d.step()\n          );\n        else {\n          q = !1;\n          const lt = g.append("text").text("A"), z = N.getSVGElementSize(lt.node(), {\n            useBBox: !0\n          }).width;\n          let W;\n          g.selectAll("g.tick").each(function() {\n            const X = I(this), V = parseFloat(y(fn(this), "tx"));\n            V !== null && W + X.text().length * z * 0.8 >= V && (q = !0), W = V;\n          }), lt.remove();\n        }\n      q ? ($ || (L.ticks(\n        this.getNumberOfFittingTicks(a, O, Pn.ticks.horizontalSpaceRatio)\n      ), g.call(L), f.call(L)), l.selectAll("g.ticks g.tick text").attr("transform", "rotate(-45)").attr("text-anchor", n === G.TOP ? "start" : "end")) : l.selectAll("g.ticks g.tick text").attr("transform", null).attr("text-anchor", null);\n    }\n    if (b ? l.attr("opacity", 0) : l.attr("opacity", 1), f.selectAll("g.tick").attr("aria-label", (q) => q), g.selectAll("g.tick").attr("aria-label", (q) => q), D !== Ve.NONE && E === et.LABELS && !M) {\n      const q = this.services.cartesianScales.getScaleDomain(n);\n      if (q.length > 0) {\n        const tt = s.select(`g.axis.${n} g.ticks g.tick`).html();\n        l.selectAll("g.ticks g.tick").html(tt);\n        const lt = this;\n        l.selectAll("g.tick text").data(q).text(function(z) {\n          return z.length > A ? (lt.truncation[n] = !0, es(z, D, R)) : z;\n        }), this.getInvisibleAxisRef().selectAll("g.tick text").data(q).text(function(z) {\n          return z.length > A ? es(z, D, R) : z;\n        }), l.selectAll("g.ticks").html(this.getInvisibleAxisRef().html()), l.selectAll("g.tick text").data(q);\n      }\n    }\n    this.addEventListeners();\n  }\n  addEventListeners() {\n    const t = this.getComponentContainer(), { position: n } = this.configs, r = N.appendOrSelect(t, `g.axis.${n}`), i = this.getOptions(), s = y(i, "axes", n), a = y(s, "scaleType"), o = y(s, "truncation", "threshold"), l = this;\n    r.selectAll("g.tick text").on("mouseover", function(c, u) {\n      l.services.events.dispatchEvent(T.Axis.LABEL_MOUSEOVER, {\n        event: c,\n        element: I(this),\n        datum: u\n      }), a === et.LABELS && u.length > o && l.services.events.dispatchEvent(T.Tooltip.SHOW, {\n        event: c,\n        hoveredElement: I(this),\n        content: u\n      });\n    }).on("mousemove", function(c, u) {\n      l.services.events.dispatchEvent(T.Axis.LABEL_MOUSEMOVE, {\n        event: c,\n        element: I(this),\n        datum: u\n      }), a === et.LABELS && u.length > o && l.services.events.dispatchEvent(T.Tooltip.MOVE, {\n        event: c\n      });\n    }).on("click", function(c, u) {\n      l.services.events.dispatchEvent(T.Axis.LABEL_CLICK, {\n        event: c,\n        element: I(this),\n        datum: u\n      });\n    }).on("mouseout", function(c, u) {\n      l.services.events.dispatchEvent(T.Axis.LABEL_MOUSEOUT, {\n        event: c,\n        element: I(this),\n        datum: u\n      }), a === et.LABELS && l.services.events.dispatchEvent(T.Tooltip.HIDE);\n    });\n  }\n  getInvisibleAxisRef() {\n    const { position: t } = this.configs;\n    return this.getComponentContainer().select(`g.axis.${t} g.ticks.invisible`);\n  }\n  getTitleRef() {\n    const { position: t } = this.configs;\n    return this.getComponentContainer().select(`g.axis.${t} text.axis-title`);\n  }\n  getNumberOfFittingTicks(t, n, r) {\n    const i = Math.floor(t / (n * r));\n    return Mg(i, 2, Pn.ticks.number);\n  }\n  destroy() {\n    const t = this.getComponentContainer(), { position: n } = this.configs;\n    N.appendOrSelect(t, `g.axis.${n}`).selectAll("g.tick text").on("mouseover", null).on("mousemove", null).on("mouseout", null);\n  }\n}\nclass pD extends Ov {\n  constructor(t, n, r) {\n    super(t, n, r);\n  }\n  render(t = !0) {\n    super.render(t), super.destroy();\n    const n = this.configs.position, r = this.getComponentContainer({\n      ariaLabel: "axes"\n    }), i = N.appendOrSelect(r, `g.axis.${n}`), s = this;\n    i.selectAll("g.tick").each(function(a, o) {\n      const l = I(this);\n      l.classed("tick-hover", !0).attr("tabindex", o === 0 ? 0 : -1);\n      const c = l.select("text"), { width: u, height: d } = N.getSVGElementSize(c, {\n        useBBox: !0\n      }), h = N.appendOrSelect(l, "rect.axis-holder");\n      let p = 0, f = 0;\n      switch (n) {\n        case G.LEFT:\n          p = -u + Number(c.attr("x")), f = -(d / 2);\n          break;\n        case G.RIGHT:\n          p = Math.abs(Number(c.attr("x"))), f = -(d / 2);\n          break;\n        case G.TOP:\n          p = -(u / 2), f = -d + Number(c.attr("y")) / 2, s.truncation[n] && (p = 0, h.attr("transform", "rotate(-45)"));\n          break;\n        case G.BOTTOM:\n          p = -(u / 2), f = d / 2 - 2, s.truncation[n] && (p = -u, h.attr("transform", "rotate(-45)"));\n          break;\n      }\n      h.attr("x", p - Pn.hover.rectanglePadding).attr("y", f).attr("width", u + Pn.hover.rectanglePadding * 2).attr("height", d).lower();\n    }), this.addEventListeners();\n  }\n  addEventListeners() {\n    const t = this.getComponentContainer(), { position: n } = this.configs, r = N.appendOrSelect(t, `g.axis.${n}`), i = this.getOptions(), s = y(i, "axes", n), a = y(s, "scaleType"), o = y(s, "truncation", "threshold"), l = this;\n    r.selectAll("g.tick.tick-hover").on("mouseover", function(c) {\n      const u = I(this).select("text"), d = u.datum();\n      l.services.events.dispatchEvent(T.Axis.LABEL_MOUSEOVER, {\n        event: c,\n        element: u,\n        datum: d\n      }), a === et.LABELS && d.length > o && l.services.events.dispatchEvent(T.Tooltip.SHOW, {\n        event: c,\n        element: u,\n        datum: d\n      });\n    }).on("mousemove", function(c) {\n      const u = I(this).select("text"), d = u.datum();\n      l.services.events.dispatchEvent(T.Axis.LABEL_MOUSEMOVE, {\n        event: c,\n        element: u,\n        datum: d\n      }), l.services.events.dispatchEvent(T.Tooltip.MOVE, {\n        event: c\n      });\n    }).on("click", function(c) {\n      l.services.events.dispatchEvent(T.Axis.LABEL_CLICK, {\n        event: c,\n        element: I(this).select("text"),\n        datum: I(this).select("text").datum()\n      });\n    }).on("mouseout", function(c) {\n      l.services.events.dispatchEvent(T.Axis.LABEL_MOUSEOUT, {\n        event: c,\n        element: I(this).select("text"),\n        datum: I(this).select("text").datum()\n      }), a === et.LABELS && l.services.events.dispatchEvent(T.Tooltip.HIDE);\n    }).on("focus", function(c) {\n      const u = { clientX: 0, clientY: 0 };\n      if (c.target) {\n        c.target.focus();\n        const d = c.target.getBoundingClientRect();\n        u.clientX = d.x, u.clientY = d.y;\n      }\n      l.services.events.dispatchEvent(T.Axis.LABEL_FOCUS, {\n        event: { ...c, ...u },\n        element: I(this),\n        datum: I(this).select("text").datum()\n      });\n    }).on("blur", function(c) {\n      l.services.events.dispatchEvent(T.Axis.LABEL_BLUR, {\n        event: c,\n        element: I(this),\n        datum: I(this).select("text").datum()\n      });\n    }).on("keydown", function(c) {\n      c.key && c.key === "Escape" && (l.services.events.dispatchEvent(T.Tooltip.HIDE), l.services.events.dispatchEvent(T.Axis.LABEL_BLUR, {\n        event: c,\n        element: I(this),\n        datum: I(this).select("text").datum()\n      })), n === G.LEFT || n === G.RIGHT ? c.key && c.key === "ArrowUp" ? l.goNext(this, c) : c.key && c.key === "ArrowDown" && l.goPrevious(this, c) : c.key && c.key === "ArrowLeft" ? l.goPrevious(this, c) : c.key && c.key === "ArrowRight" && l.goNext(this, c);\n    });\n  }\n  // Focus on the next HTML element sibling\n  goNext(t, n) {\n    t.nextElementSibling && t.nextElementSibling.tagName !== "path" && t.nextElementSibling.dispatchEvent(new Event("focus")), n.preventDefault();\n  }\n  // Focus on the previous HTML element sibling\n  goPrevious(t, n) {\n    t.previousElementSibling && t.previousElementSibling.tagName !== "path" && t.previousElementSibling.dispatchEvent(new Event("focus")), n.preventDefault();\n  }\n  destroy() {\n    const t = this.getComponentContainer(), { position: n } = this.configs;\n    N.appendOrSelect(t, `g.axis.${n}`).selectAll("g.tick.tick-hover").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("focus", null).on("blur", null);\n  }\n}\nclass fe extends mt {\n  constructor() {\n    super(...arguments), this.type = "2D-axes", this.renderType = rt.SVG, this.children = {}, this.thresholds = [], this.margins = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n  }\n  render(t = !1) {\n    const n = {}, r = Object.keys(G), i = y(this.getOptions(), "axes");\n    r.forEach((a) => {\n      i[G[a]] && (n[G[a]] = !0);\n    }), this.configs.axes = n, r.forEach((a) => {\n      const o = G[a];\n      if (this.configs.axes[o] && !this.children[o]) {\n        const l = {\n          position: o,\n          axes: this.configs.axes,\n          margins: this.margins\n        }, c = this.model.axisFlavor === Ga.DEFAULT ? new Ov(this.model, this.services, l) : new pD(this.model, this.services, l);\n        c.setModel(this.model), c.setServices(this.services), c.setParent(this.parent), this.children[o] = c;\n      }\n    }), Object.keys(this.children).forEach((a) => {\n      this.children[a].render(t);\n    });\n    const s = {};\n    Object.keys(this.children).forEach((a) => {\n      const o = this.children[a], l = o.configs.position, c = o.getInvisibleAxisRef(), { width: u, height: d } = N.getSVGElementSize(c, { useBBox: !0 });\n      let h;\n      switch (o.getTitleRef().empty() ? h = 0 : (h = N.getSVGElementSize(o.getTitleRef(), {\n        useBBox: !0\n      }).height, (l === G.LEFT || l === G.RIGHT) && (h += 5)), l) {\n        case G.TOP:\n          s.top = d + h;\n          break;\n        case G.BOTTOM:\n          s.bottom = d + h;\n          break;\n        case G.LEFT:\n          s.left = u + h;\n          break;\n        case G.RIGHT:\n          s.right = u + h;\n          break;\n      }\n    }), this.services.events.dispatchEvent(T.Axis.RENDER_COMPLETE), Object.keys(s).some(\n      (a) => this.margins[a] !== s[a]\n    ) && (this.margins = Object.assign(this.margins, s), this.model.set({ axesMargins: this.margins }, { skipUpdate: !0 }), this.services.events.dispatchEvent(T.ZoomBar.UPDATE), Object.keys(this.children).forEach((a) => {\n      const o = this.children[a];\n      o.margins = this.margins;\n    }), this.render(!0));\n  }\n}\nclass ce extends mt {\n  constructor() {\n    super(...arguments), this.type = "skeleton";\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(t = !0) {\n    const n = y(this.getOptions(), "data", "loading");\n    n ? this.renderSkeleton(n) : this.removeSkeleton();\n  }\n  renderSkeleton(t) {\n    if (this.configs.skeleton === zt.GRID)\n      this.renderGridSkeleton(t);\n    else if (this.configs.skeleton === zt.VERT_OR_HORIZ)\n      this.renderVertOrHorizSkeleton(t);\n    else if (this.configs.skeleton === zt.PIE)\n      this.renderPieSkeleton(t);\n    else if (this.configs.skeleton === zt.DONUT)\n      this.renderDonutSkeleton(t);\n    else\n      throw new Error(`"${this.configs.skeleton}" is not a valid Skeleton type.`);\n  }\n  renderGridSkeleton(t) {\n    this.setScales(), this.drawBackdrop(t), this.drawXGrid(t), this.drawYGrid(t), t && this.setShimmerEffect("shimmer-lines");\n  }\n  renderVertOrHorizSkeleton(t) {\n    const n = this.services.cartesianScales.getOrientation();\n    this.setScales(), this.drawBackdrop(t), n === Ft.VERTICAL && this.drawYGrid(t), n === Ft.HORIZONTAL && this.drawXGrid(t), this.setShimmerEffect("shimmer-lines");\n  }\n  renderPieSkeleton(t) {\n    const n = this.computeOuterRadius();\n    this.drawRing(n, 0, t), t && this.setShimmerEffect("shimmer-areas");\n  }\n  renderDonutSkeleton(t) {\n    const n = this.computeOuterRadius(), r = this.computeInnerRadius();\n    this.drawRing(n, r, t), t && this.setShimmerEffect("shimmer-areas");\n  }\n  setScales() {\n    const t = this.services.cartesianScales.getMainXScale().range(), n = this.services.cartesianScales.getMainYScale().range();\n    this.xScale = Fe().domain([0, 1]).range(t), this.yScale = Fe().domain([0, 1]).range(n);\n  }\n  drawBackdrop(t) {\n    const n = this.parent, { width: r, height: i } = N.getSVGElementSize(n, {\n      useAttrs: !0\n    });\n    this.backdrop = N.appendOrSelect(n, "svg.chart-skeleton.DAII").attr("role", "presentation").attr("width", r).attr("height", i);\n    const s = N.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop");\n    s.attr("width", "100%").attr("height", "100%");\n    const [a] = this.xScale.range(), [, o] = this.yScale.range();\n    this.backdrop.merge(s).attr("x", a).attr("y", o), s.classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(\n      "stroke",\n      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null\n    );\n  }\n  drawXGrid(t) {\n    const n = +this.backdrop.attr("width"), r = y(this.getOptions(), "grid", "x", "numberOfTicks"), i = this.xScale.ticks(r).map((o) => o * n), s = N.appendOrSelect(this.backdrop, "g.x.skeleton"), a = s.selectAll("line").data(i);\n    a.enter().append("line").merge(a).attr("x1", (o) => o).attr("x2", (o) => o).attr("y1", 0).attr("y2", "100%"), s.selectAll("line").classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(\n      "stroke",\n      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null\n    );\n  }\n  drawYGrid(t) {\n    const n = +this.backdrop.attr("height"), r = this.backdrop.attr("width"), i = y(this.getOptions(), "grid", "y", "numberOfTicks"), s = this.xScale.ticks(i).map((l) => l * n), a = N.appendOrSelect(this.backdrop, "g.y.skeleton"), o = a.selectAll("line").data(s);\n    o.enter().append("line").merge(o).attr("x1", 0).attr("x2", r).attr("y1", (l) => l).attr("y2", (l) => l), a.selectAll("line").classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(\n      "stroke",\n      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null\n    );\n  }\n  drawRing(t, n, r = !0) {\n    const i = this.parent, { width: s, height: a } = N.getSVGElementSize(i, {\n      useAttrs: !0\n    }), o = N.appendOrSelect(i, "svg.chart-skeleton").attr("width", s).attr("height", a).attr("role", "presentation"), l = n === 0 ? "pie" : "donut", c = y(this.getOptions(), l, "alignment");\n    N.appendOrSelect(o, "rect.chart-skeleton-area-container").attr("width", s).attr("height", a).attr("fill", "none");\n    const u = as().innerRadius(n).outerRadius(t).startAngle(0).endAngle(Math.PI * 2), d = t + Math.abs(Mt.radiusOffset), h = t + (Math.min(s, a) - t * 2) / 2, p = N.appendOrSelect(o, "path").attr("class", "skeleton-area-shape").attr("transform", `translate(${d}, ${h})`).attr("d", u).classed("shimmer-effect-areas", r).classed("empty-state-areas", !r).style(\n      "fill",\n      r ? `url(#${this.services.domUtils.generateElementIDString("shimmer-areas")})` : null\n    );\n    let f = t + Mt.xOffset;\n    c === jt.CENTER ? f = s / 2 : c === jt.RIGHT && (f = s - t - Mt.xOffset);\n    const g = t + Mt.yOffset;\n    p.attr("transform", `translate(${f}, ${g})`);\n  }\n  // same logic in pie\n  computeOuterRadius() {\n    const { width: t, height: n } = N.getSVGElementSize(this.parent, {\n      useAttrs: !0\n    });\n    return Math.min(t, n) / 2 + Mt.radiusOffset;\n  }\n  // same logic in donut\n  computeInnerRadius() {\n    return this.computeOuterRadius() * (3 / 4);\n  }\n  setShimmerEffect(t) {\n    const n = "stop-bg-shimmer", r = "stop-shimmer", i = this.parent.select(".chart-skeleton"), { width: s } = N.getSVGElementSize(this.parent, {\n      useAttrs: !0\n    }), a = 0, o = s, l = N.appendOrSelect(i, "defs").lower(), c = N.appendOrSelect(l, "linearGradient").attr("id", this.services.domUtils.generateElementIDString(t)).attr("class", t).attr("x1", a - 3 * 0.2 * s).attr("x2", o).attr("y1", 0).attr("y2", 0).attr("gradientUnits", "userSpaceOnUse").attr("gradientTransform", "translate(0, 0)"), u = `\n\t\t\t<stop class="${n}" offset="${a}"></stop>\n\t\t\t<stop class="${r}" offset="${a + 0.2}"></stop>\n\t\t\t<stop class="${n}" offset="${a + 2 * 0.2}"></stop>\n\t\t`;\n    c.html(u), d();\n    function d() {\n      c.attr("gradientTransform", `translate(${a - 3 * 0.2 * s}, 0)`).transition().duration(2e3).delay(1e3).ease(XC).attr("gradientTransform", `translate(${o + 3 * 0.2 * s}, 0)`).on("end", d);\n    }\n  }\n  removeSkeleton() {\n    this.parent.select(".chart-skeleton").remove();\n  }\n}\nclass fD extends mt {\n  constructor() {\n    super(...arguments), this.type = "boxplot", this.renderType = rt.SVG;\n  }\n  render(t) {\n    const n = this.getComponentContainer({ ariaLabel: "box plots", withinChartClip: !0 }), r = this.getOptions(), { groupMapsTo: i } = r.data, s = this.model.getDataGroupNames(), a = this.services.cartesianScales.getMainXScale(), o = this.services.cartesianScales.getMainYScale(), [l, c] = a.range(), [u, d] = o.range(), h = c - l, p = u - d;\n    if (h === 0)\n      return;\n    const { cartesianScales: f } = this.services, g = f.getOrientation(), m = g === Ft.VERTICAL, [v, x] = En(\n      ($) => this.services.cartesianScales.getDomainValue($),\n      ($) => this.services.cartesianScales.getRangeValue($),\n      g\n    ), _ = Math.floor((m ? h : p) / s.length), E = Math.min(_ / 2, 16), b = this.model.getBoxplotData(), S = n.selectAll(".box-group").data(b);\n    S.exit().remove();\n    const M = S.enter().append("g").attr("class", "box-group"), D = S.merge(M);\n    M.append("path").merge(S.select("path.vertical-line.start")).attr(\n      "class",\n      () => this.model.getColorClassName({\n        classNameTypes: [it.STROKE],\n        originalClassName: "vertical-line start"\n      })\n    ).attr("stroke-width", Te.strokeWidth.default).attr("fill", "none").transition().call(\n      ($) => this.services.transitions.setupTransition({\n        transition: $,\n        name: "boxplot-update-verticalstartline",\n        animate: t\n      })\n    ).attr("d", ($) => {\n      const H = f.getDomainValue($[i]), P = H, B = f.getRangeValue($.whiskers.min), O = f.getRangeValue($.quartiles.q_25);\n      return ae({ x0: H, x1: P, y0: B, y1: O }, g);\n    }), M.append("path").merge(S.select("path.vertical-line.end")).attr(\n      "class",\n      () => this.model.getColorClassName({\n        classNameTypes: [it.STROKE],\n        originalClassName: "vertical-line end"\n      })\n    ).attr("stroke-width", Te.strokeWidth.default).attr("fill", "none").transition().call(\n      ($) => this.services.transitions.setupTransition({\n        transition: $,\n        name: "boxplot-update-verticalendline",\n        animate: t\n      })\n    ).attr("d", ($) => {\n      const H = f.getDomainValue($[i]), P = H, B = f.getRangeValue($.whiskers.max), O = f.getRangeValue($.quartiles.q_75);\n      return ae({ x0: H, x1: P, y0: B, y1: O }, g);\n    }), M.append("path").merge(S.select("path.box")).attr(\n      "class",\n      () => this.model.getColorClassName({\n        classNameTypes: [it.FILL, it.STROKE],\n        originalClassName: "box"\n      })\n    ).attr("fill-opacity", Te.box.opacity.default).attr("stroke-width", Te.strokeWidth.default).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "box").attr("aria-label", ($) => $[i]).transition().call(\n      ($) => this.services.transitions.setupTransition({\n        transition: $,\n        name: "boxplot-update-quartiles",\n        animate: t\n      })\n    ).attr("d", ($) => {\n      const H = f.getDomainValue($[i]) - E / 2, P = H + E, B = f.getRangeValue(\n        Math[m ? "max" : "min"]($.quartiles.q_75, $.quartiles.q_25)\n      ), O = B + Math.abs(\n        f.getRangeValue($.quartiles.q_75) - f.getRangeValue($.quartiles.q_25)\n      );\n      return ae({ x0: H, x1: P, y0: B, y1: O }, g);\n    }), M.append("path").merge(S.select("path.highlight-area")).attr("class", "highlight-area").attr("opacity", 0).attr("d", ($) => {\n      const H = f.getDomainValue($[i]) - E / 2, P = H + E, B = f.getRangeValue($.whiskers.min), O = f.getRangeValue($.whiskers.max);\n      return ae({ x0: H, x1: P, y0: B, y1: O }, g);\n    }), M.append("path").merge(S.select("path.whisker.start")).attr(\n      "class",\n      () => this.model.getColorClassName({\n        classNameTypes: [it.STROKE],\n        originalClassName: "whisker start"\n      })\n    ).attr("stroke-width", Te.strokeWidth.thicker).attr("fill", "none").transition().call(\n      ($) => this.services.transitions.setupTransition({\n        transition: $,\n        name: "boxplot-update-startingwhisker",\n        animate: t\n      })\n    ).attr("d", ($) => {\n      const H = f.getDomainValue($[i]) - E / 4, P = H + E / 2, B = f.getRangeValue($.whiskers.min), O = f.getRangeValue($.whiskers.min);\n      return ae({ x0: H, x1: P, y0: B, y1: O }, g);\n    }), M.append("path").merge(S.select("path.median")).attr("fill", "none").attr(\n      "class",\n      () => this.model.getColorClassName({\n        classNameTypes: [it.STROKE],\n        originalClassName: "median"\n      })\n    ).attr("stroke-width", 2).transition().call(\n      ($) => this.services.transitions.setupTransition({\n        transition: $,\n        name: "boxplot-update-median",\n        animate: t\n      })\n    ).attr("d", ($) => {\n      const H = f.getDomainValue($[i]) - E / 2, P = H + E, B = f.getRangeValue($.quartiles.q_50);\n      return ae({ x0: H, x1: P, y0: B, y1: B }, g);\n    }), M.append("path").merge(S.select("path.whisker.end")).attr(\n      "class",\n      () => this.model.getColorClassName({\n        classNameTypes: [it.STROKE],\n        originalClassName: "whisker end"\n      })\n    ).attr("stroke-width", Te.strokeWidth.thicker).attr("fill", "none").transition().call(\n      ($) => this.services.transitions.setupTransition({\n        transition: $,\n        name: "boxplot-update-endingwhisker",\n        animate: t\n      })\n    ).attr("d", ($) => {\n      const H = f.getDomainValue($[i]) - E / 4, P = H + E / 2, B = f.getRangeValue($.whiskers.max), O = f.getRangeValue($.whiskers.max);\n      return ae({ x0: H, x1: P, y0: B, y1: O }, g);\n    });\n    const A = D.selectAll("circle.outlier").data(\n      ($) => $.outliers.map((H) => ({\n        min: $.whiskers.min,\n        max: $.whiskers.max,\n        [i]: $[i],\n        value: H\n      }))\n    );\n    A.exit().remove();\n    const R = A.enter().append("circle");\n    A.merge(R).attr("r", Te.circle.radius).attr(\n      "class",\n      () => this.model.getColorClassName({\n        classNameTypes: [it.FILL, it.STROKE],\n        originalClassName: "outlier"\n      })\n    ).attr("fill-opacity", Te.circle.opacity.default).attr("cx", v).transition().call(\n      ($) => this.services.transitions.setupTransition({\n        transition: $,\n        name: "boxplot-update-circles",\n        animate: t\n      })\n    ).attr("cy", x), this.addBoxEventListeners(), this.addCircleEventListeners();\n  }\n  addBoxEventListeners() {\n    const t = this, n = this.getOptions(), { groupMapsTo: r } = n.data;\n    this.parent.selectAll("path.highlight-area").on("mouseover", function(i, s) {\n      const a = I(this);\n      I(this.parentNode).select("path.box").classed("hovered", !0).attr("fill-opacity", Te.box.opacity.hovered), t.services.events.dispatchEvent(T.Tooltip.SHOW, {\n        event: i,\n        hoveredElement: a,\n        items: [\n          {\n            label: y(n, "locale", "translations", "group") || y(n, "tooltip", "groupLabel") || "Group",\n            value: s[r],\n            class: t.model.getColorClassName({\n              classNameTypes: [it.TOOLTIP]\n            })\n          },\n          {\n            label: "Minimum",\n            value: s.whiskers.min\n          },\n          {\n            label: "Q1",\n            value: s.quartiles.q_25\n          },\n          {\n            label: "Median",\n            value: s.quartiles.q_50\n          },\n          {\n            label: "Q3",\n            value: s.quartiles.q_75\n          },\n          {\n            label: "Maximum",\n            value: s.whiskers.max\n          },\n          {\n            label: "IQR",\n            value: s.quartiles.q_75 - s.quartiles.q_25\n          }\n        ]\n      }), t.services.events.dispatchEvent(T.Boxplot.BOX_MOUSEOVER, {\n        event: i,\n        element: a,\n        datum: s\n      });\n    }).on("mousemove", function(i, s) {\n      const a = I(this);\n      t.services.events.dispatchEvent(T.Boxplot.BOX_MOUSEMOVE, {\n        event: i,\n        element: a,\n        datum: s\n      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {\n        event: i\n      });\n    }).on("click", function(i, s) {\n      t.services.events.dispatchEvent(T.Boxplot.BOX_CLICK, {\n        event: i,\n        element: I(this),\n        datum: s\n      });\n    }).on("mouseout", function(i, s) {\n      const a = I(this);\n      I(this.parentNode).select("path.box").classed("hovered", !1).attr("fill-opacity", Te.box.opacity.default), t.services.events.dispatchEvent(T.Boxplot.BOX_MOUSEOUT, {\n        event: i,\n        element: a,\n        datum: s\n      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {\n        hoveredElement: a\n      });\n    });\n  }\n  addCircleEventListeners() {\n    const t = this, n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.services.cartesianScales.getRangeIdentifier();\n    this.parent.selectAll("circle").on("mouseover", function(s, a) {\n      const o = I(this);\n      o.classed("hovered", !0).attr("fill-opacity", Te.circle.opacity.hovered).classed("unfilled", !1), t.services.events.dispatchEvent(T.Tooltip.SHOW, {\n        event: s,\n        hoveredElement: o,\n        items: [\n          {\n            label: y(n, "locale", "translations", "group") || y(n, "tooltip", "groupLabel") || "Group",\n            value: a[r],\n            class: t.model.getColorClassName({\n              classNameTypes: [it.TOOLTIP]\n            })\n          },\n          {\n            label: "Outlier",\n            value: a[i]\n          }\n        ]\n      }), t.services.events.dispatchEvent(T.Boxplot.OUTLIER_MOUSEOVER, {\n        event: s,\n        element: o,\n        datum: a\n      });\n    }).on("mousemove", function(s, a) {\n      const o = I(this);\n      t.services.events.dispatchEvent(T.Boxplot.OUTLIER_MOUSEMOVE, {\n        event: s,\n        element: o,\n        datum: a\n      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {\n        event: s\n      });\n    }).on("click", function(s, a) {\n      t.services.events.dispatchEvent(T.Boxplot.OUTLIER_CLICK, {\n        event: s,\n        element: I(this),\n        datum: a\n      });\n    }).on("mouseout", function(s, a) {\n      const o = I(this);\n      o.classed("hovered", !1).attr("fill-opacity", Te.circle.opacity.default), t.services.events.dispatchEvent(T.Boxplot.OUTLIER_MOUSEOUT, {\n        event: s,\n        element: o,\n        datum: a\n      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {\n        hoveredElement: o\n      });\n    });\n  }\n}\nclass si extends mt {\n  constructor() {\n    super(...arguments), this.type = "zero-line", this.renderType = rt.SVG;\n  }\n  render(t) {\n    const n = this.services.cartesianScales.getRangeAxisPosition({\n      groups: this.configs.groups\n    }), r = this.services.cartesianScales.getScaleByPosition(n), [i, s] = r.domain(), a = i > 0 && s < 0 || i < 0 && s > 0, o = this.getComponentContainer({\n      isPresentational: !0\n    });\n    if (!a) {\n      o.selectAll("line.domain").remove();\n      return;\n    }\n    const [l, c] = this.services.cartesianScales.getDomainScale().range();\n    let u = +r(0) + 0.5;\n    u || (u = r.range()[0]);\n    const d = Pm(\n      {\n        x0: l,\n        x1: c,\n        y0: u,\n        y1: u\n      },\n      this.services.cartesianScales.getOrientation()\n    );\n    N.appendOrSelect(o, "line.domain").transition().call(\n      (h) => this.services.transitions.setupTransition({\n        transition: h,\n        name: "zero-line-update",\n        animate: t\n      })\n    ).attr("y1", d.y0).attr("y2", d.y1).attr("x1", d.x0).attr("x2", d.x1);\n  }\n}\nclass mD extends nn {\n  constructor() {\n    super(...arguments), this.type = "bubble", this.renderType = rt.SVG;\n  }\n  getRadiusScale(t) {\n    const n = this.getOptions(), { radiusMapsTo: r } = n.bubble, i = t.data(), s = i.map((c) => c[r]).filter((c) => c), a = N.getHTMLElementSize(this.services.domUtils.getMainContainer()), o = s.length > 0, l = o ? ze(s) : [1, 1];\n    return Fe().domain(l).range(o ? n.bubble.radiusRange(a, i) : [4, 4]);\n  }\n  styleCircles(t, n) {\n    const r = this.getOptions(), { radiusMapsTo: i } = r.bubble, s = this.getRadiusScale(t), { groupMapsTo: a } = r.data, { cartesianScales: o } = this.services, l = (h) => o.getDomainValue(h), c = (h) => o.getRangeValue(h), [u, d] = En(\n      l,\n      c,\n      o.getOrientation()\n    );\n    t.raise().classed("dot", !0).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-label", (h) => {\n      const p = o.getRangeIdentifier(h);\n      return h[p];\n    }).transition().call(\n      (h) => this.services.transitions.setupTransition({\n        transition: h,\n        name: "bubble-update-enter",\n        animate: n\n      })\n    ).attr("cx", u).attr("cy", d).attr("r", (h) => s(h[i] || 1)).attr(\n      "class",\n      (h) => this.model.getColorClassName({\n        classNameTypes: [it.FILL, it.STROKE],\n        dataGroupName: h[a],\n        originalClassName: "dot"\n      })\n    ).style("fill", (h) => {\n      const p = this.services.cartesianScales.getDomainIdentifier(h);\n      return this.model.getFillColor(h[a], h[p], h);\n    }).style("stroke", (h) => {\n      const p = this.services.cartesianScales.getDomainIdentifier(h);\n      return this.model.getStrokeColor(h[a], h[p], h);\n    }).attr("fill-opacity", r.bubble.fillOpacity).attr("opacity", 1);\n  }\n  getTooltipAdditionalItems(t) {\n    const n = y(this.getOptions(), "bubble");\n    return [\n      {\n        label: y(n, "radiusLabel"),\n        value: t[y(n, "radiusMapsTo")]\n      }\n    ];\n  }\n}\nclass gD extends mt {\n  constructor() {\n    super(...arguments), this.type = "bullet", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {\n      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;\n      this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(\n        (i) => this.services.transitions.setupTransition({\n          transition: i,\n          name: "legend-hover-simple-bar"\n        })\n      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);\n    }, this.handleLegendMouseOut = () => {\n      this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(\n        (t) => this.services.transitions.setupTransition({\n          transition: t,\n          name: "legend-mouseout-simple-bar"\n        })\n      ).attr("opacity", 1);\n    };\n  }\n  init() {\n    const t = this.services.events;\n    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n  render(t) {\n    const n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.getComponentContainer({ ariaLabel: "bullet graphs", withinChartClip: !0 }), s = this.model.getDisplayData(this.configs.groups), a = this.services.cartesianScales.getRangeScale(), o = this.services.cartesianScales.getRangeIdentifier(), [l, c] = a.range(), [, u] = a.domain(), d = () => {\n      const g = [];\n      s.forEach((v) => {\n        v.ranges ? v.ranges.forEach((x, _) => {\n          x != null && x < u && g.push({\n            datum: v,\n            value: x,\n            order: _ + 1\n          });\n        }) : g.push({\n          datum: v,\n          order: 1\n        });\n      });\n      const m = N.appendOrSelect(i, "g.range-boxes").selectAll("path.range-box").data(g, (v) => `${v[r]}-${v.order}`);\n      m.exit().attr("opacity", 0).remove(), m.enter().append("path").attr("opacity", 0).merge(m).attr("class", (v) => `range-box order-${v.order}`).transition().call(\n        (v) => this.services.transitions.setupTransition({\n          transition: v,\n          name: "bullet-range-box-update-enter",\n          animate: t\n        })\n      ).attr("d", (v) => {\n        let x, _, E, b;\n        return v.order === 1 ? (x = this.services.cartesianScales.getDomainValue(v.datum) - 16 / 2, _ = x + 16, E = c - 2, b = l + 1) : (x = this.services.cartesianScales.getDomainValue(v.datum) - 16 / 2, _ = x + 16, E = this.services.cartesianScales.getRangeValue(v.value), b = c), ae(\n          { x0: x, x1: _, y0: E, y1: b },\n          this.services.cartesianScales.getOrientation()\n        );\n      }).attr("opacity", 1);\n    }, h = () => {\n      const g = N.appendOrSelect(i, "g.bars").selectAll("path.bar").data(s, (m) => m[r]);\n      g.exit().attr("opacity", 0).remove(), g.enter().append("path").attr("opacity", 0).merge(g).classed("bar", !0).transition().call(\n        (m) => this.services.transitions.setupTransition({\n          transition: m,\n          name: "bullet-bar-update-enter",\n          animate: t\n        })\n      ).attr(\n        "class",\n        (m) => this.model.getColorClassName({\n          classNameTypes: [it.FILL],\n          dataGroupName: m[r],\n          originalClassName: "bar"\n        })\n      ).style("fill", (m) => {\n        const v = this.services.cartesianScales.getDomainIdentifier(m);\n        return this.model.getFillColor(m[r], m[v], m);\n      }).attr("d", (m) => {\n        const v = this.services.cartesianScales.getDomainValue(m) - 4, x = v + 8, _ = this.services.cartesianScales.getRangeValue(0) + 1, E = this.services.cartesianScales.getRangeValue(m);\n        return ae(\n          { x0: v, x1: x, y0: _, y1: E },\n          this.services.cartesianScales.getOrientation()\n        );\n      }).attr("opacity", 1).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (m) => m.value);\n    }, p = () => {\n      const g = N.appendOrSelect(i, "g.markers").selectAll("path.marker").data(\n        s.filter((m) => y(m, "marker") !== null),\n        (m) => m[r]\n      );\n      g.exit().attr("opacity", 0).remove(), g.enter().append("path").attr("opacity", 0).merge(g).classed("marker", !0).transition().call(\n        (m) => this.services.transitions.setupTransition({\n          transition: m,\n          name: "bullet-marker-update-enter",\n          animate: t\n        })\n      ).attr("d", (m) => {\n        const v = this.services.cartesianScales.getDomainValue(m) - 12, x = v + 24, _ = this.services.cartesianScales.getRangeValue(m.marker);\n        return ae(\n          { x0: v, x1: x, y0: _, y1: _ },\n          this.services.cartesianScales.getOrientation()\n        );\n      }).attr("opacity", 1);\n    }, f = () => {\n      let g = [];\n      s.filter((v) => y(v, "marker") !== null).forEach((v) => {\n        const x = v.marker, _ = v[o];\n        g = g.concat([\n          { datum: v, value: x * 0.25, barValue: _ },\n          { datum: v, value: x * 0.5, barValue: _ },\n          { datum: v, value: x * 0.75, barValue: _ }\n        ]);\n      });\n      const m = N.appendOrSelect(i, "g.quartiles").selectAll("path.quartile").data(g, (v) => v[r]);\n      m.exit().attr("opacity", 0).remove(), m.enter().append("path").attr("opacity", 0).merge(m).attr("class", (v) => `quartile ${v.value <= v.barValue ? "over-bar" : ""}`).transition().call(\n        (v) => this.services.transitions.setupTransition({\n          transition: v,\n          name: "bullet-quartile-update-enter",\n          animate: t\n        })\n      ).attr("d", ({ datum: v, value: x }) => {\n        let _ = 4;\n        v.ranges && v.ranges.indexOf(x) !== -1 && (_ = 8);\n        const E = this.services.cartesianScales.getDomainValue(v) - _ / 2, b = E + _, S = this.services.cartesianScales.getRangeValue(x);\n        return ae(\n          { x0: E, x1: b, y0: S, y1: S },\n          this.services.cartesianScales.getOrientation()\n        );\n      }).attr("opacity", 1);\n    };\n    d(), h(), p(), f(), this.addEventListeners();\n  }\n  addEventListeners() {\n    const t = this, n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.services.cartesianScales.getRangeIdentifier(), { code: s, number: a } = y(n, "locale");\n    this.parent.selectAll("path.bar").on("mouseover", function(o, l) {\n      const c = I(this);\n      c.classed("hovered", !0), t.services.events.dispatchEvent(T.Bar.BAR_MOUSEOVER, {\n        event: o,\n        element: c,\n        datum: l\n      });\n      const u = y(n, "bullet", "performanceAreaTitles"), d = t.model.getMatchingRangeIndexForDatapoint(l);\n      t.services.events.dispatchEvent(T.Tooltip.SHOW, {\n        event: o,\n        hoveredElement: c,\n        items: [\n          {\n            label: y(n, "locale", "translations", "group") || y(n, "tooltip", "groupLabel") || "Group",\n            value: l[r],\n            class: t.model.getColorClassName({\n              classNameTypes: [it.TOOLTIP],\n              dataGroupName: l[r]\n            })\n          },\n          {\n            label: "Value",\n            value: l[i]\n          },\n          {\n            label: "Target",\n            value: l.marker\n          },\n          {\n            label: "Percentage",\n            value: `${a(Math.floor(l[i] / l.marker * 100), s)}%`\n          },\n          {\n            label: "Performance",\n            value: u[d]\n          }\n        ]\n      });\n    }).on("mousemove", function(o, l) {\n      t.services.events.dispatchEvent(T.Bar.BAR_MOUSEMOVE, {\n        event: o,\n        element: I(this),\n        datum: l\n      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {\n        event: o\n      });\n    }).on("click", function(o, l) {\n      t.services.events.dispatchEvent(T.Bar.BAR_CLICK, {\n        event: o,\n        element: I(this),\n        datum: l\n      });\n    }).on("mouseout", function(o, l) {\n      const c = I(this);\n      c.classed("hovered", !1), t.services.events.dispatchEvent(T.Bar.BAR_MOUSEOUT, {\n        event: o,\n        element: c,\n        datum: l\n      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {\n        hoveredElement: c\n      });\n    });\n  }\n  destroy() {\n    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);\n    const t = this.services.events;\n    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n}\nfunction vD(e) {\n  return e;\n}\nfunction yD(e) {\n  if (e == null) return vD;\n  var t, n, r = e.scale[0], i = e.scale[1], s = e.translate[0], a = e.translate[1];\n  return function(o, l) {\n    l || (t = n = 0);\n    var c = 2, u = o.length, d = new Array(u);\n    for (d[0] = (t += o[0]) * r + s, d[1] = (n += o[1]) * i + a; c < u; ) d[c] = o[c], ++c;\n    return d;\n  };\n}\nfunction xD(e, t) {\n  for (var n, r = e.length, i = r - t; i < --r; ) n = e[i], e[i++] = e[r], e[r] = n;\n}\nfunction bD(e, t) {\n  return typeof t == "string" && (t = e.objects[t]), t.type === "GeometryCollection" ? { type: "FeatureCollection", features: t.geometries.map(function(n) {\n    return fp(e, n);\n  }) } : fp(e, t);\n}\nfunction fp(e, t) {\n  var n = t.id, r = t.bbox, i = t.properties == null ? {} : t.properties, s = uu(e, t);\n  return n == null && r == null ? { type: "Feature", properties: i, geometry: s } : r == null ? { type: "Feature", id: n, properties: i, geometry: s } : { type: "Feature", id: n, bbox: r, properties: i, geometry: s };\n}\nfunction uu(e, t) {\n  var n = yD(e.transform), r = e.arcs;\n  function i(u, d) {\n    d.length && d.pop();\n    for (var h = r[u < 0 ? ~u : u], p = 0, f = h.length; p < f; ++p)\n      d.push(n(h[p], p));\n    u < 0 && xD(d, f);\n  }\n  function s(u) {\n    return n(u);\n  }\n  function a(u) {\n    for (var d = [], h = 0, p = u.length; h < p; ++h) i(u[h], d);\n    return d.length < 2 && d.push(d[0]), d;\n  }\n  function o(u) {\n    for (var d = a(u); d.length < 4; ) d.push(d[0]);\n    return d;\n  }\n  function l(u) {\n    return u.map(o);\n  }\n  function c(u) {\n    var d = u.type, h;\n    switch (d) {\n      case "GeometryCollection":\n        return { type: d, geometries: u.geometries.map(c) };\n      case "Point":\n        h = s(u.coordinates);\n        break;\n      case "MultiPoint":\n        h = u.coordinates.map(s);\n        break;\n      case "LineString":\n        h = a(u.arcs);\n        break;\n      case "MultiLineString":\n        h = u.arcs.map(a);\n        break;\n      case "Polygon":\n        h = l(u.arcs);\n        break;\n      case "MultiPolygon":\n        h = u.arcs.map(l);\n        break;\n      default:\n        return null;\n    }\n    return { type: d, coordinates: h };\n  }\n  return c(t);\n}\nfunction _D(e, t) {\n  var n = {}, r = {}, i = {}, s = [], a = -1;\n  t.forEach(function(c, u) {\n    var d = e.arcs[c < 0 ? ~c : c], h;\n    d.length < 3 && !d[1][0] && !d[1][1] && (h = t[++a], t[a] = c, t[u] = h);\n  }), t.forEach(function(c) {\n    var u = o(c), d = u[0], h = u[1], p, f;\n    if (p = i[d])\n      if (delete i[p.end], p.push(c), p.end = h, f = r[h]) {\n        delete r[f.start];\n        var g = f === p ? p : p.concat(f);\n        r[g.start = p.start] = i[g.end = f.end] = g;\n      } else\n        r[p.start] = i[p.end] = p;\n    else if (p = r[h])\n      if (delete r[p.start], p.unshift(c), p.start = d, f = i[d]) {\n        delete i[f.end];\n        var m = f === p ? p : f.concat(p);\n        r[m.start = f.start] = i[m.end = p.end] = m;\n      } else\n        r[p.start] = i[p.end] = p;\n    else\n      p = [c], r[p.start = d] = i[p.end = h] = p;\n  });\n  function o(c) {\n    var u = e.arcs[c < 0 ? ~c : c], d = u[0], h;\n    return e.transform ? (h = [0, 0], u.forEach(function(p) {\n      h[0] += p[0], h[1] += p[1];\n    })) : h = u[u.length - 1], c < 0 ? [h, d] : [d, h];\n  }\n  function l(c, u) {\n    for (var d in c) {\n      var h = c[d];\n      delete u[h.start], delete h.start, delete h.end, h.forEach(function(p) {\n        n[p < 0 ? ~p : p] = 1;\n      }), s.push(h);\n    }\n  }\n  return l(i, r), l(r, i), t.forEach(function(c) {\n    n[c < 0 ? ~c : c] || s.push([c]);\n  }), s;\n}\nfunction ED(e) {\n  for (var t = -1, n = e.length, r, i = e[n - 1], s = 0; ++t < n; ) r = i, i = e[t], s += r[0] * i[1] - r[1] * i[0];\n  return Math.abs(s);\n}\nfunction OD(e) {\n  return uu(e, SD.apply(this, arguments));\n}\nfunction SD(e, t) {\n  var n = {}, r = [], i = [];\n  t.forEach(s);\n  function s(l) {\n    switch (l.type) {\n      case "GeometryCollection":\n        l.geometries.forEach(s);\n        break;\n      case "Polygon":\n        a(l.arcs);\n        break;\n      case "MultiPolygon":\n        l.arcs.forEach(a);\n        break;\n    }\n  }\n  function a(l) {\n    l.forEach(function(c) {\n      c.forEach(function(u) {\n        (n[u = u < 0 ? ~u : u] || (n[u] = [])).push(l);\n      });\n    }), r.push(l);\n  }\n  function o(l) {\n    return ED(uu(e, { type: "Polygon", arcs: [l] }).coordinates[0]);\n  }\n  return r.forEach(function(l) {\n    if (!l._) {\n      var c = [], u = [l];\n      for (l._ = 1, i.push(c); l = u.pop(); )\n        c.push(l), l.forEach(function(d) {\n          d.forEach(function(h) {\n            n[h < 0 ? ~h : h].forEach(function(p) {\n              p._ || (p._ = 1, u.push(p));\n            });\n          });\n        });\n    }\n  }), r.forEach(function(l) {\n    delete l._;\n  }), {\n    type: "MultiPolygon",\n    arcs: i.map(function(l) {\n      var c = [], u;\n      if (l.forEach(function(g) {\n        g.forEach(function(m) {\n          m.forEach(function(v) {\n            n[v < 0 ? ~v : v].length < 2 && c.push(v);\n          });\n        });\n      }), c = _D(e, c), (u = c.length) > 1)\n        for (var d = 1, h = o(c[0]), p, f; d < u; ++d)\n          (p = o(c[d])) > h && (f = c[0], c[0] = c[d], c[d] = f, h = p);\n      return c;\n    }).filter(function(l) {\n      return l.length > 0;\n    })\n  };\n}\nclass TD extends Vn {\n  constructor() {\n    super(...arguments), this.type = "ruler-binned", this.renderType = rt.SVG;\n  }\n  showRuler(t, [n, r]) {\n    const i = this.parent, s = this.model.getOptions(), { cartesianScales: a } = this.services, o = a.getOrientation(), l = a.getRangeScale(), [c, u] = l.range(), d = a.getDomainScale(), h = d.invert(\n      o === Ft.VERTICAL ? n : r\n    ), p = N.appendOrSelect(i, "g.ruler").attr("aria-label", "ruler"), f = N.appendOrSelect(p, "line.ruler-line"), g = i.selectAll("[role=graphics-symbol]").filter((m) => {\n      if (parseFloat(gt(m, "data.x0")) <= h && parseFloat(gt(m, "data.x1")) >= h)\n        return !0;\n    });\n    if (g.size() > 0) {\n      this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !Cg(this.elementsToHighlight, g) && this.hideRuler(), g.dispatch("mouseover"), this.elementsToHighlight = g;\n      const m = I(g.nodes()[0]).datum(), v = parseFloat(gt(m, "data.x0")), x = parseFloat(gt(m, "data.x1")), _ = this.model.getActiveDataGroupNames(), E = _.reverse().map((b) => ({\n        label: b,\n        value: gt(m, `data.${b}`),\n        class: this.model.getColorClassName({\n          classNameTypes: [it.TOOLTIP],\n          dataGroupName: b\n        })\n      })).filter((b) => b.value !== 0);\n      if (E.length > 0) {\n        this.services.events.dispatchEvent(T.Tooltip.SHOW, {\n          event: t,\n          mousePosition: [n, r],\n          hoveredElement: f,\n          items: [\n            {\n              label: gt(s, "bins.rangeLabel") || "Range",\n              value: `${v}  ${x}`\n            },\n            ...E,\n            ...y(s, "tooltip", "showTotal") === !0 ? [\n              {\n                label: gt(s, "locale.translations.total") || gt(s, "tooltip.totalLabel") || "Total",\n                value: _.reduce(\n                  (S, M) => S + parseFloat(gt(m, `data.${M}`)),\n                  0\n                )\n              }\n            ] : []\n          ]\n        }), p.attr("opacity", 1);\n        const b = d((v + x) / 2);\n        o === "horizontal" ? f.attr("x1", u).attr("x2", c).attr("y1", b).attr("y2", b) : f.attr("y1", u).attr("y2", c).attr("x1", b).attr("x2", b);\n      } else\n        this.hideRuler();\n    } else\n      this.hideRuler();\n  }\n}\nclass Ua extends Vn {\n  formatTooltipData(t) {\n    return t.reverse();\n  }\n}\nconst wD = (e, t) => {\n  const n = e.x, r = e.y, i = t.x, s = t.y, a = Rg();\n  return a.moveTo(n, r), a.lineTo(i, s), a.toString();\n}, $D = {\n  d: "M7 0v8L0 4z"\n}, MD = {\n  d: "M0 0v8l7-4z"\n}, CD = {\n  d: "M5.32 9.513a4.75 4.75 0 100-9.5 4.75 4.75 0 000 9.5z"\n}, AD = {\n  d: "M5.03517654-1e-7l4.99999996 5-4.99999996 5-5-5L2.4517844 2.58339204z"\n}, LD = {\n  d: "M0 .44974747h8v8H0v-3.6830331z"\n}, kD = {\n  d: "M0 0h1.5v8H0z"\n};\nclass Sv extends lu {\n  constructor(t, n, r) {\n    super(t, n, r), this.type = "color-legend", this.renderType = rt.SVG, this.gradient_id = `gradient-id-${Math.floor(Math.random() * 99999999999)}`, this.handleAxisCompleteEvent = () => {\n      const i = this.getComponentContainer(), { width: s } = N.getSVGElementSize(i, {\n        useAttrs: !0\n      }), a = y(this.getOptions(), "data", "loading");\n      if (s > It.color.barWidth && !a) {\n        const o = y(this.getOptions(), "heatmap", "colorLegend", "title"), { cartesianScales: l } = this.services, c = l.getMainXScale().range();\n        if (c[0] > 1 && (i.select("g.legend").attr("transform", `translate(${c[0]}, 0)`), o)) {\n          const { width: u } = N.getSVGElementSize(\n            i.select("g.legend-title").select("text"),\n            { useBBox: !0 }\n          ), d = c[0] - u - 9;\n          d > 1 ? i.select("g.legend-title").attr("transform", `translate(${d}, 0)`) : (i.select("g.legend").attr("transform", `translate(${c[0]}, 16)`), i.select("g.legend-title").attr("transform", `translate(${c[0]}, 0)`));\n        }\n      } else\n        i.select("g.legend-title").attr("transform", "translate(0, 0)");\n    }, this.chartType = r.chartType;\n  }\n  init() {\n    this.chartType === "heatmap" && this.services.events.addEventListener(T.Axis.RENDER_COMPLETE, this.handleAxisCompleteEvent);\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(t = !1) {\n    const n = this.getOptions(), r = this.getComponentContainer({\n      ariaLabel: "legend"\n    }), { width: i } = N.getSVGElementSize(r, {\n      useAttrs: !0\n    }), s = y(n, "color", "gradient", "colors"), a = y(n, this.chartType, "colorLegend", "type");\n    let o = y(n, "color", "pairing", "option");\n    const l = y(n, "heatmap", "colorLegend", "title");\n    if (y(this.getOptions(), "data", "loading")) {\n      r.html("");\n      return;\n    }\n    const c = !Be(s), u = zm(this.model.getDisplayData()), d = !(i <= It.color.barWidth), h = d ? It.color.barWidth : i, p = N.appendOrSelect(r, "g.legend"), f = N.appendOrSelect(p, "g.legend-axis");\n    if (l) {\n      const A = N.appendOrSelect(r, "g.legend-title");\n      N.appendOrSelect(A, "text").text(l).attr("dy", "0.7em"), p.attr("transform", "translate(0, 16)");\n    }\n    const g = u[0] < 0 && u[1] > 0 ? "diverge" : "mono";\n    (o < 1 && o > 4 && g === "mono" || o < 1 && o > 2 && g === "diverge") && (o = 1);\n    let m = [];\n    const v = g === "diverge" ? 17 : 11;\n    if (c)\n      m = s;\n    else\n      for (let A = 1; A < v + 1; A++)\n        m.push(\n          a === qs.LINEAR ? `stop-color-${g}-${o}-${A}` : `fill-${g}-${o}-${A}`\n        );\n    const x = xe(u[0], u[1]), _ = YC(x, 3), E = Fe().domain(u).range([0, h]), b = Jc(E).tickSize(0).tickValues(_), { code: S, number: M } = y(n, "locale");\n    b.tickFormat((A) => M(A, S));\n    let D;\n    switch (a) {\n      case qs.LINEAR:\n        this.drawLinear(m, p, h);\n        break;\n      case qs.QUANTIZE:\n        D = this.drawQuantize(\n          m,\n          g,\n          c,\n          p,\n          h\n        ), E.range([D, h]);\n        break;\n      default:\n        throw Error("Entered color legend type is not supported.");\n    }\n    f.attr("transform", `translate(0,${It.color.axisYTranslation})`).call(b), f.select(".domain").remove(), f.select("g.tick:last-of-type text").style("text-anchor", d ? "middle" : "end"), f.select("g.tick:first-of-type text").style(\n      "text-anchor",\n      d && this.chartType !== "choropleth" ? "middle" : "start"\n    );\n  }\n  // Renders gradient legend\n  drawLinear(t, n, r) {\n    const i = 100 / (t.length - 1);\n    N.appendOrSelect(n, "linearGradient").attr("id", `${this.gradient_id}-legend`).selectAll("stop").data(t).enter().append("stop").attr("offset", (s, a) => `${a * i}%`).attr("class", (s, a) => t[a]).attr("stop-color", (s) => s), N.appendOrSelect(n, "rect").attr("width", r).attr("height", It.color.barHeight).style("fill", `url(#${this.gradient_id}-legend)`);\n  }\n  /**\n   * Renders quantized legend\n   * @returns number (range start)\n   */\n  drawQuantize(t, n, r, i, s) {\n    !r && n === "diverge" && t.splice(t.length / 2, 1);\n    const a = gs().domain(t).range([0, s]);\n    return N.appendOrSelect(i, "g.quantized-rect").selectAll("rect").data(a.domain()).join("rect").attr("x", (o) => a(o)).attr("y", 0).attr("width", Math.max(0, a.bandwidth() - 1)).attr("height", It.color.barHeight).attr("class", (o) => o).attr("fill", (o) => o), (!r && n) === "mono" ? a.bandwidth() - 1 : 0;\n  }\n  destroy() {\n    this.chartType === "heatmap" && this.services.events.removeEventListener(T.Axis.RENDER_COMPLETE, this.handleAxisCompleteEvent);\n  }\n}\nclass DD extends bs {\n  constructor() {\n    super(...arguments), this.type = "meter-title", this.renderType = rt.SVG;\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(t = !1) {\n    const n = y(this.model.getDisplayData(), 0), r = this.getOptions(), i = this.getComponentContainer({\n      ariaLabel: "meter title"\n    }), { groupMapsTo: s } = r.data, a = r.locale.translations.meter.title;\n    if (y(r, "meter", "proportional"))\n      this.displayTotal(), this.displayBreakdownTitle();\n    else {\n      const c = i.selectAll("text.meter-title").data(a ? [a] : [n[s]]);\n      c.enter().append("text").classed("meter-title", !0).merge(c).attr("x", 0).attr("y", "1em").text((u) => u), c.exit().remove(), this.appendPercentage();\n    }\n    this.displayStatus();\n    const o = this.getMaxTitleWidth(), l = N.appendOrSelect(i, "text.meter-title");\n    o > 0 && l.node().getComputedTextLength() > o && this.truncateTitle(l, o);\n  }\n  displayBreakdownTitle() {\n    const t = this.getComponentContainer(), n = this.getOptions(), r = this.model.getMaximumDomain(\n      this.model.getDisplayData()\n    ), i = y(n, "meter", "proportional", "total"), s = y(n, "meter", "proportional", "unit") ? y(n, "meter", "proportional", "unit") : "";\n    let a;\n    if (r === i)\n      a = null;\n    else {\n      const u = i !== null ? i - r : r, d = y(n, "meter", "proportional", "breakdownFormatter"), { code: h, number: p } = y(n, "locale");\n      a = d !== null ? d({\n        datasetsTotal: r,\n        total: i\n      }) : `${p(r, h)} ${s} used (${p(u, h)} ${s} available)`;\n    }\n    const o = t.selectAll("text.proportional-meter-title").data([a]);\n    o.enter().append("text").classed("proportional-meter-title", !0).merge(o).attr("x", 0).attr("y", "1em").text((u) => u), o.exit().remove();\n    const l = this.getMaxTitleWidth(), c = N.appendOrSelect(t, "text.proportional-meter-title");\n    l > 0 && c.node().getComputedTextLength() > l && this.truncateTitle(c, l);\n  }\n  // show the total for prop meter\n  displayTotal() {\n    const t = this.getComponentContainer(), n = this.getOptions(), r = y(n, "meter", "proportional", "total"), i = r ? y(n, "meter", "proportional", "total") : this.model.getMaximumDomain(this.model.getDisplayData()), s = y(n, "meter", "proportional", "unit") ? y(n, "meter", "proportional", "unit") : "", a = y(n, "meter", "proportional", "totalFormatter"), { code: o, number: l } = y(n, "locale"), c = a !== null ? a(i) : `${l(r, o)} ${s} total`, u = N.getHTMLElementSize(this.parent.node()).width, d = t.selectAll("text.proportional-meter-total").data([c]);\n    d.enter().append("text").classed("proportional-meter-total", !0).merge(d).attr(\n      "x",\n      this.model.getStatus() && typeof u != "string" ? u - Zt.total.paddingRight : u\n    ).attr("y", "1em").attr("text-anchor", "end").text((h) => h), d.exit().remove();\n  }\n  /**\n   * Appends the corresponding status based on the value and the peak.\n   */\n  displayStatus() {\n    const t = this, n = this.getComponentContainer(), r = N.getHTMLElementSize(this.parent.node()).width || 0, i = this.model.getStatus(), s = Zt.status.indicatorSize / 2, a = N.appendOrSelect(n, "g.status-indicator").attr("class", i !== null ? `status-indicator status--${i}` : "").attr("transform", `translate(${r - s}, 0)`), o = i ? [i] : [], l = a.selectAll("circle.status").data(o);\n    l.enter().append("circle").merge(l).attr("class", "status").attr("r", s).attr("cx", 0).attr("cy", 8);\n    const c = a.selectAll("path.innerFill").data(o);\n    c.enter().append("path").merge(c).attr("d", t.getStatusIconPathString(i)).attr("transform", `translate(-${s}, 0)`).attr("class", "innerFill"), c.exit().remove(), l.exit().remove();\n  }\n  /**\n   * Appends the associated percentage to the end of the title\n   */\n  appendPercentage() {\n    const t = y(this.model.getDisplayData(), 0, "value"), { code: n, number: r } = y(this.getOptions(), "locale"), i = this.getComponentContainer(), s = N.appendOrSelect(i, "text.meter-title"), a = y(this.getOptions(), "meter", "statusBar", "percentageIndicator", "enabled") === !0 ? [t] : [], o = i.selectAll("text.percent-value").data(a), l = Zt.statusBar.paddingRight;\n    o.enter().append("text").classed("percent-value", !0).merge(o).text((c) => `${c != null ? r(c, n) : 0}%`).attr("x", +s.attr("x") + s.node().getComputedTextLength() + l).attr("y", s.attr("y")), o.exit().remove();\n  }\n  /**\n   * Uses the parent class truncate logic\n   * @param title d3 selection of title element that will be truncated\n   * @param maxWidth the max width the title can take\n   */\n  truncateTitle(t, n) {\n    super.truncateTitle(t, n);\n    const r = N.appendOrSelect(this.parent, "tspan"), i = Zt.statusBar.paddingRight, s = Math.ceil(r.node().getComputedTextLength());\n    N.appendOrSelect(this.parent, "text.percent-value").attr(\n      "x",\n      +t.attr("x") + t.node().getComputedTextLength() + s + i\n    );\n  }\n  // computes the maximum space a title can take\n  getMaxTitleWidth() {\n    const t = y(this.getOptions(), "meter", "proportional"), n = N.getHTMLElementSize(this.parent.node()).width;\n    if (t !== null) {\n      const r = N.appendOrSelect(this.parent, "text.proportional-meter-total").node(), i = N.getSVGElementSize(r, {\n        useBBox: !0\n      }).width;\n      return n - i - Zt.total.paddingLeft;\n    } else {\n      const r = N.appendOrSelect(this.parent, "text.percent-value"), i = Zt.statusBar.paddingRight, s = r.node().getComputedTextLength(), a = N.appendOrSelect(this.parent, "g.status-indicator").node(), o = N.getSVGElementSize(a, { useBBox: !0 }).width + Zt.status.paddingLeft;\n      return n - s - i - o;\n    }\n  }\n  /**\n   * Get the associated status icon for the data\n   * @param status the active status for the meter chart\n   */\n  getStatusIconPathString(t) {\n    switch (t) {\n      case js.SUCCESS:\n        return "M6.875 11.3125 3.75 8.1875 4.74375 7.25 6.875 9.34375 11.50625 4.75 12.5 5.7375 Z";\n      case js.DANGER:\n        return "M10.7 11.5 4.5 5.3 5.3 4.5 11.5 10.7 Z";\n      case js.WARNING:\n        return "M7.9375,11.125 C7.41973305,11.125 7,11.544733 7,12.0625 C7,12.580267 7.41973305,13 7.9375,13 C8.45526695,13 8.875,12.580267 8.875,12.0625 C8.875,11.544733 8.45526695,11.125 7.9375,11.125 M7.3125, 3 8.5625, 3 8.5625, 9.875 7.3125, 9.875, 7.3125, 3 Z";\n    }\n  }\n}\nclass hu extends mt {\n  // Gets the correct width for bars based on options & configurations\n  getBarWidth() {\n    const t = this.getOptions();\n    if (t.bars.width)\n      return t.bars.width;\n    const n = this.model.getDisplayData().length, r = this.services.cartesianScales.getMainXScale(), i = N.getSVGElementSize(this.parent, {\n      useAttrs: !0\n    }).width;\n    if (!r.step) {\n      const s = y(t, "bars", "spacingFactor");\n      return Math.min(t.bars.maxWidth, i * s / n);\n    }\n    return Math.min(t.bars.maxWidth, r.step() / 2);\n  }\n  isOutsideZoomedDomain(t, n) {\n    if (this.model.getDisplayData().length <= 1)\n      return !1;\n    const r = this.model.get("zoomDomain");\n    if (r !== void 0) {\n      const i = this.services.cartesianScales.getDomainScale();\n      return t < i(r[0]) || n > i(r[1]);\n    }\n    return !1;\n  }\n}\nclass RD extends mt {\n  constructor() {\n    super(...arguments), this.type = "circle-pack", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {\n      const { hoveredElement: n } = t.detail;\n      this.parent.selectAll("circle.node").transition("legend-hover-circlepack").call(\n        (r) => this.services.transitions.setupTransition({\n          transition: r,\n          name: "legend-hover-circlepack"\n        })\n      ).attr("opacity", (r) => r.data.dataGroupName === n.datum().name ? 1 : Cr.circles.fillOpacity);\n    }, this.handleLegendMouseOut = () => {\n      this.parent.selectAll("circle.node").transition("legend-mouseout-circlepack").call(\n        (t) => this.services.transitions.setupTransition({\n          transition: t,\n          name: "legend-mouseout-circlepack"\n        })\n      ).attr("opacity", 1);\n    };\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(t = !0) {\n    const n = this.getComponentContainer({\n      ariaLabel: "circle packs",\n      withinChartClip: !0\n    }), { width: r, height: i } = N.getSVGElementSize(this.parent, {\n      useAttrs: !0\n    });\n    if (r < 1 || i < 1)\n      return;\n    let s = this.model.getDisplayData();\n    const a = this.model.hasParentNode(), o = this.model.getHierarchyLevel(), l = this.getOptions(), c = y(l, "canvasZoom", "enabled");\n    a && y(s, 0, "children") && (s = y(s, 0, "children"));\n    const u = ys({ children: s }).sum((f) => f.value).sort((f, g) => g.value - f.value), d = VL().size([r, i]).padding((f) => f.depth >= 1 ? Cr.padding.children + 3 : Cr.padding.mainGroup + 3)(u).descendants().splice(1).filter((f) => f.depth <= o), h = n.selectAll("circle.node").data(d);\n    h.exit().attr("width", 0).attr("height", 0).remove();\n    const p = h.enter().append("circle").classed("node", !0);\n    p.merge(h).attr("class", (f) => {\n      const g = c && o === 3 ? this.getZoomClass(f) : "";\n      return this.model.getColorClassName({\n        classNameTypes: [it.FILL, it.STROKE],\n        dataGroupName: f.data.dataGroupName,\n        originalClassName: f.children ? `node ${g}` : `node node-leaf ${g}`\n      });\n    }).style("fill", (f) => this.model.getFillColor(f.data.dataGroupName, null, f.data)).style("stroke", (f) => this.model.getFillColor(f.data.dataGroupName, null, f.data)).attr("cx", (f) => f.x).attr("cy", (f) => f.y).transition("circlepack-leaf-update-enter").call(\n      (f) => this.services.transitions.setupTransition({\n        transition: f,\n        name: "circlepack-leaf-update-enter"\n      })\n    ).attr("r", (f) => f.r).attr("opacity", 1).attr("fill-opacity", Cr.circles.fillOpacity), c === !0 && this.focal && (this.services.canvasZoom.zoomIn(this.focal, p, Nr), this.setBackgroundListeners()), a || this.addLegendListeners(), this.addEventListeners();\n  }\n  // turn off the highlight class on children circles\n  unhighlightChildren(t) {\n    const n = t.map((r) => r.data);\n    this.parent.selectAll("circle.node").filter((r) => n.some((i) => i === r.data) && r.depth > 1).style("stroke", (r) => this.model.getFillColor(r.data.dataGroupName, null, r.data));\n  }\n  // highlight the children circles with a stroke\n  highlightChildren(t) {\n    const n = t.map((r) => r.data);\n    this.parent.selectAll("circle.node").filter((r) => n.some((i) => i === r.data) && r.depth > 1).style("stroke", Cr.circles.hover.stroke);\n  }\n  getZoomClass(t) {\n    return this.model.getHierarchyLevel() === 3 && this.focal && (t.data === this.focal.data || this.focal.children.some((n) => n.data === t.data)) ? "focal" : "non-focal";\n  }\n  addLegendListeners() {\n    const { events: t } = this.services;\n    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n  removeBackgroundListeners() {\n    I(this.services.domUtils.getMainContainer()).on("click", () => null);\n  }\n  setBackgroundListeners() {\n    const t = I(this.services.domUtils.getMainContainer()), n = this, r = this.parent.selectAll("circle.node");\n    t.on("click", () => {\n      n.focal = null, n.model.updateHierarchyLevel(2), t.classed("zoomed-in", !1), n.services.canvasZoom.zoomOut(r, Nr);\n    });\n  }\n  // Zoom icon to be appended to the label in the tooltip\n  getZoomIcon() {\n    return `\n\t\t<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10">\n\t\t\t<polygon points="5.93 3.71 4.45 3.71 4.45 2.23 3.71 2.23 3.71 3.71 2.23 3.71 2.23 4.45 3.71 4.45 3.71 5.93 4.45 5.93 4.45 4.45 5.93 4.45 5.93 3.71"/>\n\t\t\t<path d="M7.2,6.67a4,4,0,0,0,1-2.59A4.08,4.08,0,1,0,4.07,8.15h0a4,4,0,0,0,2.59-1L9.48,10,10,9.48Zm-3.12.77A3.34,3.34,0,1,1,7.41,4.08,3.34,3.34,0,0,1,4.08,7.44Z"/>\n\t\t</svg>`;\n  }\n  // add event listeners for tooltip on the circles\n  addEventListeners() {\n    const t = this;\n    this.parent.selectAll("circle.node").on("mouseover", function(n, r) {\n      const i = I(this);\n      i.classed("hovered", !0);\n      const s = t.model.getHierarchyLevel(), a = s > 2 && !i.classed("focal"), o = y(t.model.getOptions(), "canvasZoom", "enabled");\n      let l = !1;\n      if (!a) {\n        let c = [], u = [], d = null;\n        if (r.children) {\n          r.depth > 1 && o && (l = !0, i.classed("clickable", !0)), c = r.children.map((f) => {\n            if (f !== null)\n              return typeof f.data.value == "number" ? {\n                label: f.data.name,\n                value: f.data.value\n              } : {\n                label: f.data.name,\n                labelIcon: o && s <= 2 ? t.getZoomIcon() : null,\n                value: f.value\n              };\n          });\n          const p = t.model.getOptions();\n          u = [\n            {\n              label: gt(p, "locale.translations.total") || gt(p, "tooltip.totalLabel") || "Total",\n              value: r.value,\n              bold: !0\n            }\n          ], t.highlightChildren(r.children);\n        } else\n          d = r.value;\n        const h = getComputedStyle(this, null).getPropertyValue("fill");\n        t.services.events.dispatchEvent(T.Tooltip.SHOW, {\n          event: n,\n          hoveredElement: i,\n          items: [\n            {\n              color: h,\n              label: r.data.name,\n              labelIcon: l && o && s <= 2 ? t.getZoomIcon() : null,\n              value: d\n            },\n            ...c,\n            ...u\n          ]\n        });\n      }\n      t.services.events.dispatchEvent(T.CirclePack.CIRCLE_MOUSEOVER, {\n        event: n,\n        element: i,\n        datum: r\n      });\n    }).on("mousemove", function(n, r) {\n      const i = I(this);\n      t.services.events.dispatchEvent(T.CirclePack.CIRCLE_MOUSEMOVE, {\n        event: n,\n        element: i,\n        datum: r\n      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {\n        event: n\n      });\n    }).on("mouseout", function(n, r) {\n      const i = I(this);\n      i.classed("hovered", !1), r.children && t.unhighlightChildren(r.children), t.services.events.dispatchEvent(T.CirclePack.CIRCLE_MOUSEOUT, {\n        event: n,\n        element: i,\n        datum: r\n      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {\n        hoveredElement: i\n      });\n    }).on("click", function(n, r) {\n      const i = I(this), s = i.classed("non-focal"), a = y(t.model.getOptions(), "canvasZoom", "enabled");\n      if (a && t.model.getHierarchyLevel() > 2) {\n        const o = t.parent.selectAll("circle.node");\n        I(t.services.domUtils.getMainContainer()).classed("zoomed-in", !1), t.focal = null, t.model.updateHierarchyLevel(2), t.services.canvasZoom.zoomOut(o, Nr);\n      } else if (r.depth === 2 && r.children && !s && a) {\n        const o = t.parent.selectAll("circle.node");\n        I(t.services.domUtils.getMainContainer()).classed("zoomed-in", !0), t.focal = r, t.model.updateHierarchyLevel(3), t.services.canvasZoom.zoomIn(r, o, Nr), n.stopPropagation();\n      }\n      t.services.events.dispatchEvent(T.CirclePack.CIRCLE_CLICK, {\n        event: n,\n        element: i,\n        datum: r\n      });\n    });\n  }\n  destroy() {\n    this.parent.selectAll("circle.node").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);\n    const t = this.services.events;\n    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), this.removeBackgroundListeners();\n  }\n}\nfunction ID(e, t) {\n  const n = fs(this._current, e);\n  return (r) => (this._current = n(r), t(this._current));\n}\nclass Tv extends mt {\n  constructor() {\n    super(...arguments), this.type = "pie", this.renderType = rt.SVG, this.isRendering = !1, this.handleLegendOnHover = (t) => {\n      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;\n      this.parent.selectAll("path.slice").transition("legend-hover-bar").call(\n        (i) => this.services.transitions.setupTransition({\n          transition: i,\n          name: "legend-hover-bar"\n        })\n      ).attr(\n        "opacity",\n        (i) => i.data[r] !== n.datum().name ? 0.3 : 1\n      );\n    }, this.handleLegendMouseOut = () => {\n      this.parent.selectAll("path.slice").transition("legend-mouseout-bar").call(\n        (t) => this.services.transitions.setupTransition({\n          transition: t,\n          name: "legend-mouseout-bar"\n        })\n      ).attr("opacity", 1);\n    };\n  }\n  init() {\n    const t = this.services.events;\n    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n  getInnerRadius() {\n    return Mt.innerRadius;\n  }\n  render(t = !0) {\n    const n = this, r = this.getComponentContainer({\n      ariaLabel: "pie graph"\n    }), i = this.getOptions(), { groupMapsTo: s } = i.data, { valueMapsTo: a } = i.pie;\n    this.isRendering = !0;\n    const o = this.model.getDisplayData().filter((A) => A[a] > 0), l = this.computeRadius();\n    this.arc = as().innerRadius(this.getInnerRadius()).outerRadius(l), this.hoverArc = as().innerRadius(this.getInnerRadius()).outerRadius(l + Mt.hoverArc.outerRadiusOffset);\n    const c = ck().value((A) => A[a]).sort(y(i, "pie", "sortFunction")).padAngle(Mt.padAngle)(o), u = N.appendOrSelect(r, "g.slices").attr("role", ht.GROUP).attr("data-name", "slices").selectAll("path.slice").data(c, (A) => A.data[s]);\n    u.exit().attr("opacity", 0).remove(), u.enter().append("path").classed("slice", !0).attr("opacity", 0).merge(u).attr(\n      "class",\n      (A) => this.model.getColorClassName({\n        classNameTypes: [it.FILL],\n        dataGroupName: A.data[s],\n        originalClassName: "slice"\n      })\n    ).style("fill", (A) => n.model.getFillColor(A.data[s], null, A.data)).attr("d", this.arc).transition().call(\n      (A) => this.services.transitions.setupTransition({\n        transition: A,\n        name: "pie_slice_enter_update",\n        animate: t\n      })\n    ).attr("opacity", 1).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "slice").attr(\n      "aria-label",\n      (A) => `${A[a]}, ${Lo(A.data[a], o, a) + "%"}`\n    ).attrTween("d", function(A) {\n      return ID.bind(this)(A, n.arc);\n    }).on("end", () => {\n      n.isRendering = !1;\n    });\n    const { code: d, number: h } = y(i, "locale"), p = i.pie.labels.enabled, f = p ? c.filter((A) => A.data[a] > 0) : [], g = N.appendOrSelect(r, "g.labels").attr("role", ht.GROUP).attr("data-name", "labels").selectAll("text.pie-label").data(f, (A) => A.data[s]);\n    g.exit().attr("opacity", 0).remove();\n    const m = g.enter().append("text").classed("pie-label", !0), v = [];\n    m.merge(g).style("text-anchor", "middle").text((A) => i.pie.labels.formatter ? i.pie.labels.formatter({\n      ...A,\n      percentageValue: Lo(\n        A.data[a],\n        o,\n        a,\n        !0\n      )\n    }) : h(\n      Lo(A.data[a], o, a),\n      d\n    ) + "%").datum(function(A) {\n      const R = l + 7, $ = (A.endAngle - A.startAngle) / 2 + A.startAngle, H = $ / Math.PI * 180, P = this.getComputedTextLength();\n      return A.textOffsetX = P / 2, A.textOffsetY = H > 90 && H < 270 ? 10 : 0, A.xPosition = (A.textOffsetX + R) * Math.sin($), A.yPosition = (A.textOffsetY + R) * -Math.cos($), A;\n    }).attr("transform", function(A, R) {\n      const $ = f.length, H = (A.endAngle - A.startAngle) * (180 / Math.PI);\n      if (R >= $ - 2 && H < Mt.callout.minSliceDegree) {\n        let P, B;\n        return A.index === $ - 1 ? (P = A.xPosition + Mt.callout.offsetX + Mt.callout.textMargin + A.textOffsetX, B = A.yPosition - Mt.callout.offsetY, A.direction = Fs.RIGHT, v.push(A)) : (P = A.xPosition - Mt.callout.offsetX - A.textOffsetX - Mt.callout.textMargin, B = A.yPosition - Mt.callout.offsetY, A.direction = Fs.LEFT, v.push(A)), `translate(${P}, ${B})`;\n      }\n      return `translate(${A.xPosition}, ${A.yPosition})`;\n    }), this.renderCallouts(v);\n    const x = y(i, "donut") ? "donut" : "pie", _ = y(i, x, "alignment"), { width: E } = N.getSVGElementSize(this.getParent(), {\n      useAttrs: !0\n    }), b = p ? Mt.xOffset : 0, S = p ? Mt.yOffset : 0;\n    let M = l + b;\n    _ === jt.CENTER ? M = E / 2 : _ === jt.RIGHT && (M = E - l - Mt.xOffset);\n    let D = l + S;\n    v.length > 0 && (D += Mt.yOffsetCallout), r.attr("x", M + 7).attr("y", D), this.addEventListeners();\n  }\n  renderCallouts(t) {\n    const n = N.appendOrSelect(this.getComponentContainer(), "g.callouts").attr("role", ht.GROUP).attr("data-name", "callouts"), r = n.selectAll("g.callout").data(t);\n    r.exit().remove();\n    const i = r.enter().append("g").classed("callout", !0).attr("role", ht.GROUP).attr("aria-roledescription", "label callout");\n    i.merge(r).datum(function(s) {\n      const { xPosition: a, yPosition: o, direction: l } = s;\n      return l === Fs.RIGHT ? (s.startPos = {\n        x: a,\n        y: o + s.textOffsetY\n      }, s.endPos = {\n        x: a + Mt.callout.offsetX,\n        y: o - Mt.callout.offsetY + s.textOffsetY\n      }, s.intersectPointX = s.endPos.x - Mt.callout.horizontalLineLength) : (s.startPos = {\n        x: a,\n        y: o + s.textOffsetY\n      }, s.endPos = {\n        x: a - Mt.callout.offsetX,\n        y: o - Mt.callout.offsetY + s.textOffsetY\n      }, s.intersectPointX = s.endPos.x + Mt.callout.horizontalLineLength), s;\n    }), i.append("line").classed("vertical-line", !0).merge(n.selectAll("line.vertical-line")).datum(function() {\n      return I(this.parentNode).datum();\n    }).style("stroke-width", "1px").attr("x1", (s) => s.startPos.x).attr("y1", (s) => s.startPos.y).attr("x2", (s) => s.intersectPointX).attr("y2", (s) => s.endPos.y), i.append("line").classed("horizontal-line", !0).merge(n.selectAll("line.horizontal-line")).datum(function() {\n      return I(this.parentNode).datum();\n    }).style("stroke-width", "1px").attr("x1", (s) => s.intersectPointX).attr("y1", (s) => s.endPos.y).attr("x2", (s) => s.endPos.x).attr("y2", (s) => s.endPos.y);\n  }\n  addEventListeners() {\n    const t = this;\n    this.parent.selectAll("path.slice").on("mouseover", function(n, r) {\n      const i = I(this);\n      t.isRendering || i.classed("hovered", !0).transition("pie_slice_mouseover").call(\n        (o) => t.services.transitions.setupTransition({\n          transition: o,\n          name: "pie_slice_mouseover"\n        })\n      ).attr("d", t.hoverArc), t.services.events.dispatchEvent(T.Pie.SLICE_MOUSEOVER, {\n        event: n,\n        element: I(this),\n        datum: r\n      });\n      const { groupMapsTo: s } = t.getOptions().data, { valueMapsTo: a } = t.getOptions().pie;\n      t.services.events.dispatchEvent(T.Tooltip.SHOW, {\n        event: n,\n        hoveredElement: i,\n        items: [\n          {\n            label: r.data[s],\n            value: r.data[a]\n          }\n        ]\n      });\n    }).on("mousemove", function(n, r) {\n      const i = I(this);\n      t.services.events.dispatchEvent(T.Pie.SLICE_MOUSEMOVE, {\n        event: n,\n        element: i,\n        datum: r\n      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {\n        event: n\n      });\n    }).on("click", function(n, r) {\n      t.services.events.dispatchEvent(T.Pie.SLICE_CLICK, {\n        event: n,\n        element: I(this),\n        datum: r\n      });\n    }).on("mouseout", function(n, r) {\n      const i = I(this);\n      AC(() => {\n        t.isRendering || i.classed("hovered", !1).transition("pie_slice_mouseout").call(\n          (s) => t.services.transitions.setupTransition({\n            transition: s,\n            name: "pie_slice_mouseout"\n          })\n        ).attr("d", t.arc);\n      }, 100), t.services.events.dispatchEvent(T.Pie.SLICE_MOUSEOUT, {\n        event: n,\n        element: i,\n        datum: r\n      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {\n        hoveredElement: i\n      });\n    });\n  }\n  // Helper functions\n  computeRadius() {\n    const { width: t, height: n } = N.getSVGElementSize(this.parent, {\n      useAttrs: !0\n    }), r = this.getOptions(), i = Math.min(t, n) / 2;\n    return r.pie.labels.enabled ? i + Mt.radiusOffset : i;\n  }\n}\nclass ND extends Tv {\n  constructor() {\n    super(...arguments), this.type = "donut", this.renderType = rt.SVG;\n  }\n  render(t = !0) {\n    super.render(t);\n    const n = this;\n    if (this.model.isDataEmpty()) {\n      this.getComponentContainer({\n        ariaLabel: "donut graph"\n      }).select("g.center").remove();\n      return;\n    }\n    const r = N.appendOrSelect(\n      this.getComponentContainer({\n        ariaLabel: "donut graph"\n      }),\n      "g.center"\n    ), i = this.getOptions(), s = this.computeRadius(), a = y(i, "donut", "center", "label");\n    N.appendOrSelect(r, "text.donut-figure").attr("text-anchor", "middle").style("dominant-baseline", () => a === null || a === "" ? "central" : "initial").style("font-size", () => i.donut.center.numberFontSize(s)).transition().call(\n      (o) => this.services.transitions.setupTransition({\n        transition: o,\n        name: "donut-figure-enter-update",\n        animate: t\n      })\n    ).tween("text", function() {\n      return n.centerNumberTween(I(this));\n    }), a !== null && a !== "" && N.appendOrSelect(r, "text.donut-title").attr("text-anchor", "middle").style("font-size", () => i.donut.center.titleFontSize(s)).attr("y", i.donut.center.titleYPosition(s)).text(a);\n  }\n  getInnerRadius() {\n    return this.computeRadius() * (3 / 4);\n  }\n  centerNumberTween(t) {\n    const n = this.getOptions();\n    let r = y(n, "donut", "center", "number");\n    r === null && (r = this.model.getDisplayData().reduce((o, l) => o + l[n.pie.valueMapsTo], 0));\n    const i = parseInt(t.text().replace(/[, ]+/g, ""), 10) || 0;\n    let s;\n    i % 1 === 0 && r % 1 === 0 ? s = hm : s = xe;\n    const a = s(i, r);\n    return (o) => {\n      const { numberFormatter: l } = n.donut.center;\n      if (l)\n        t.text(l(a(o)));\n      else {\n        const { code: c, number: u } = y(n, "locale");\n        t.text(u(Math.floor(a(o)), c));\n      }\n    };\n  }\n}\nconst mp = "4,10 8,6 12,10", gp = "12,6 8,10 4,6";\nclass PD extends mt {\n  constructor() {\n    super(...arguments), this.type = "gauge", this.renderType = rt.SVG;\n  }\n  getValue() {\n    var t;\n    return ((t = this.model.getData().find((n) => n.group === "value")) == null ? void 0 : t.value) ?? null;\n  }\n  getValueRatio() {\n    return Mg(this.getValue(), 0, 100) / 100;\n  }\n  getDelta() {\n    var t;\n    return ((t = this.model.getData().find((n) => n.group === "delta")) == null ? void 0 : t.value) ?? null;\n  }\n  getArcRatio() {\n    const t = this.getOptions();\n    return y(t, "gauge", "type") === Rr.FULL ? 1 : 0.5;\n  }\n  getArcSize() {\n    return this.getArcRatio() * Math.PI * 2;\n  }\n  getStartAngle() {\n    const t = this.getArcSize();\n    return t === 2 * Math.PI ? 0 : -t / 2;\n  }\n  // use provided arrow direction or default to using the delta\n  getArrow(t) {\n    const n = this.getOptions();\n    switch (y(n, "gauge", "deltaArrow", "direction")) {\n      case pl.UP:\n        return mp;\n      case pl.DOWN:\n        return gp;\n      default:\n        return t > 0 ? mp : gp;\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(t = !0) {\n    const n = this.getComponentContainer({\n      ariaLabel: "gauge graph"\n    }).attr("width", "100%").attr("height", "100%"), r = this.getOptions(), i = this.getValue(), s = this.getValueRatio(), a = this.getArcSize(), o = this.getStartAngle(), l = s * a, c = o + l, u = o + a, d = this.computeRadius(), h = this.getInnerRadius();\n    this.backgroundArc = as().innerRadius(h).outerRadius(d).startAngle(c).endAngle(u), this.arc = as().innerRadius(h).outerRadius(d).startAngle(o).endAngle(c), N.appendOrSelect(n, "path.arc-background").attr("d", this.backgroundArc);\n    const p = n.selectAll("path.arc-foreground").data([i]);\n    p.enter().append("path").merge(p).attr(\n      "class",\n      this.model.getColorClassName({\n        classNameTypes: [it.FILL],\n        dataGroupName: "value",\n        originalClassName: "arc-foreground"\n      })\n    ).style("fill", () => y(this.getOptions(), "color", "scale", "value")).attr("d", this.arc).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", (v) => v), this.drawValueNumber(), this.drawDelta(), p.exit().remove();\n    const f = y(r, "gauge", "alignment"), { width: g } = N.getSVGElementSize(this.getParent(), {\n      useAttrs: !0\n    });\n    let m = d;\n    f === jt.CENTER ? m = g / 2 : f === jt.RIGHT && (m = g - d), n.attr("x", m).attr("y", d), this.addEventListeners();\n  }\n  /**\n   * draws the value number associated with the Gauge component in the center\n   */\n  drawValueNumber() {\n    const t = this.getComponentContainer(), n = this.getOptions(), r = y(n, "gauge", "type"), i = this.getValue(), s = this.getDelta(), a = this.computeRadius(), o = y(n, "gauge", "valueFontSize"), l = y(n, "gauge", "deltaFontSize"), c = y(n, "gauge", "numberSpacing"), u = y(n, "gauge", "showPercentageSymbol");\n    let d = 0;\n    r === Rr.FULL && !s ? d = l(a) : r === Rr.SEMI && s && (d = -(l(a) + c));\n    const h = N.appendOrSelect(t, "g.gauge-numbers").attr(\n      "transform",\n      `translate(0, ${d})`\n    ), p = o(a), f = N.appendOrSelect(h, "g.gauge-value-number"), { code: g, number: m } = y(n, "locale"), v = y(n, "gauge", "numberFormatter"), x = f.selectAll("text.gauge-value-number").data([i]);\n    x.enter().append("text").attr("class", "gauge-value-number").merge(x).style("font-size", `${p}px`).attr("text-anchor", "middle").text((A) => {\n      let R;\n      return A != null ? R = Number(A.toFixed(2)) % 1 !== 0 ? A.toFixed(2) : A.toFixed() : R = 0, v ? v(R) : m(Number(R), g);\n    });\n    const { width: _ } = N.getSVGElementSize(\n      N.appendOrSelect(t, "text.gauge-value-number"),\n      { useBBox: !0 }\n    ), E = p / 2, b = u ? "%" : "", S = N.appendOrSelect(f, "text.gauge-value-symbol").style("font-size", `${E}px`).attr("x", _ / 2).text(b), { width: M, height: D } = N.getSVGElementSize(S, {\n      useBBox: !0\n    });\n    S.attr("y", `-${D / 2}px`), f.attr("transform", `translate(-${M / 2}, 0)`);\n  }\n  /**\n   * adds the delta number for the gauge\n   */\n  drawDelta() {\n    const t = this, n = this.getComponentContainer(), r = this.getOptions(), i = this.getDelta(), { code: s, number: a } = y(r, "locale");\n    if (i) {\n      const o = this.computeRadius(), l = i ? y(r, "gauge", "deltaFontSize") : () => 0, c = i ? y(r, "gauge", "numberFormatter") : () => null, u = y(r, "gauge", "deltaArrow", "size"), d = y(r, "gauge", "numberSpacing"), h = y(r, "gauge", "showPercentageSymbol"), p = N.appendOrSelect(n, "g.gauge-numbers"), f = N.appendOrSelect(p, "g.gauge-delta").attr(\n        "transform",\n        `translate(0, ${l(o) + d})`\n      ), g = N.appendOrSelect(f, "text.gauge-delta-number"), m = h ? "%" : "";\n      g.data(i === null ? [] : [i]), g.enter().append("text").classed("gauge-delta-number", !0).merge(g).attr("text-anchor", "middle").style("font-size", `${l(o)}px`).text((E) => {\n        let b;\n        return E != null ? b = Number(E.toFixed(2)) % 1 !== 0 ? E.toFixed(2) : E.toFixed() : b = 0, c ? `${c(b)}${m}` : `${a(Number(b), s)}${m}`;\n      });\n      const { width: v } = N.getSVGElementSize(\n        N.appendOrSelect(n, ".gauge-delta-number"),\n        { useBBox: !0 }\n      ), x = y(r, "gauge", "deltaArrow", "enabled"), _ = f.selectAll("svg.gauge-delta-arrow").data(i !== null && x ? [i] : []);\n      _.enter().append("svg").merge(_).attr("class", "gauge-delta-arrow").attr("x", -u(o) - v / 2).attr("y", -u(o) / 2 - l(o) * 0.35).attr("width", u(o)).attr("height", u(o)).attr("viewBox", "0 0 16 16").each(function() {\n        const E = I(this);\n        N.appendOrSelect(E, "rect.gauge-delta-arrow-backdrop").attr("width", "16").attr("height", "16").attr("fill", "none");\n        const b = y(r, "gauge", "status");\n        N.appendOrSelect(E, "polygon.gauge-delta-arrow").attr("class", b !== null ? `gauge-delta-arrow status--${b}` : "").attr("points", t.getArrow(i));\n      }), _.exit().remove(), g.exit().remove();\n    } else {\n      const o = n.select("g.gauge-delta");\n      o.empty() || o.remove();\n    }\n  }\n  getInnerRadius() {\n    const t = this.computeRadius(), n = y(this.getOptions(), "gauge", "arcWidth");\n    return t - n;\n  }\n  addEventListeners() {\n    const t = this;\n    this.parent.selectAll("path.arc-foreground").on("mouseover", function(n, r) {\n      t.services.events.dispatchEvent(T.Gauge.ARC_MOUSEOVER, {\n        event: n,\n        element: I(this),\n        datum: r\n      });\n    }).on("mousemove", function(n, r) {\n      const i = I(this);\n      t.services.events.dispatchEvent(T.Gauge.ARC_MOUSEMOVE, {\n        event: n,\n        element: i,\n        datum: r\n      });\n    }).on("click", function(n, r) {\n      t.services.events.dispatchEvent(T.Gauge.ARC_CLICK, {\n        event: n,\n        element: I(this),\n        datum: r\n      });\n    }).on("mouseout", function(n, r) {\n      const i = I(this);\n      t.services.events.dispatchEvent(T.Gauge.ARC_MOUSEOUT, {\n        event: n,\n        element: i,\n        datum: r\n      });\n    });\n  }\n  // Helper functions\n  computeRadius() {\n    const t = this.getOptions(), n = y(t, "gauge", "type"), { width: r, height: i } = N.getSVGElementSize(this.parent, {\n      useAttrs: !0\n    });\n    return n === Rr.SEMI ? Math.min(r / 2, i) : Math.min(r / 2, i / 2);\n  }\n}\nclass wv extends hu {\n  constructor() {\n    super(...arguments), this.type = "grouped-bar", this.renderType = rt.SVG, this.padding = 5, this.defaultStepFactor = 70, this.handleLegendOnHover = (t) => {\n      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;\n      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(\n        (i) => this.services.transitions.setupTransition({\n          transition: i,\n          name: "legend-hover-bar"\n        })\n      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);\n    }, this.handleLegendMouseOut = () => {\n      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(\n        (t) => this.services.transitions.setupTransition({\n          transition: t,\n          name: "legend-mouseout-bar"\n        })\n      ).attr("opacity", 1);\n    };\n  }\n  init() {\n    const t = this.services.events;\n    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n  render(t) {\n    const n = this.model.getDisplayData(this.configs.groups), r = this.getOptions(), { groupMapsTo: i } = r.data;\n    this.setGroupScale();\n    const s = this.getComponentContainer({ ariaLabel: "grouped bar graphs", withinChartClip: !0 }), a = Zi(\n      n.map((u) => {\n        const d = this.services.cartesianScales.getDomainIdentifier(u);\n        return u[d] && typeof u[d].toString == "function" ? u[d].toString() : u[d];\n      })\n    ), o = s.selectAll("g.bars").data(a, (u) => u);\n    o.exit().attr("opacity", 0).remove();\n    const l = o.enter().append("g").classed("bars", !0).attr("role", ht.GROUP).attr("data-name", "bars").merge(o);\n    l.transition().call(\n      (u) => this.services.transitions.setupTransition({\n        transition: u,\n        name: "bar-group-update-enter",\n        animate: t\n      })\n    ).attr("transform", (u) => {\n      const d = this.services.cartesianScales.getDomainValue(u) - this.getGroupWidth() / 2;\n      return this.services.cartesianScales.getOrientation() === Ft.VERTICAL ? `translate(${d}, 0)` : `translate(0, ${d})`;\n    });\n    const c = l.selectAll("path.bar").data(\n      (u) => this.getDataCorrespondingToLabel(u),\n      (u) => u[i]\n    );\n    c.exit().attr("opacity", 0).remove(), c.enter().append("path").attr("opacity", 0).merge(c).classed("bar", !0).transition().call(\n      (u) => this.services.transitions.setupTransition({\n        transition: u,\n        name: "bar-update-enter",\n        animate: t\n      })\n    ).attr(\n      "class",\n      (u) => this.model.getColorClassName({\n        classNameTypes: [it.FILL],\n        dataGroupName: u[i],\n        originalClassName: "bar"\n      })\n    ).style("fill", (u) => {\n      const d = this.services.cartesianScales.getDomainIdentifier(u);\n      return this.model.getFillColor(u[i], u[d], u);\n    }).attr("d", (u) => {\n      const d = this.groupScale(u[i]), h = this.getBarWidth(), p = d, f = d + h, g = this.services.cartesianScales.getRangeAxisPosition({ datum: u }), m = this.services.cartesianScales.getDomainLowerBound(g), v = this.services.cartesianScales.getValueThroughAxisPosition(g, m), x = this.services.cartesianScales.getRangeValue(u), _ = this.services.cartesianScales.getDomainValue(u) - h / 2, E = _ + h;\n      if (!this.isOutsideZoomedDomain(_, E))\n        return ae(\n          { x0: p, x1: f, y0: v, y1: x },\n          this.services.cartesianScales.getOrientation()\n        );\n    }).attr("opacity", 1).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (u) => u.value), this.addEventListeners();\n  }\n  addEventListeners() {\n    const t = this;\n    this.parent.selectAll("path.bar").on("mouseover", function(n, r) {\n      const i = I(this);\n      i.classed("hovered", !0), t.services.events.dispatchEvent(T.Bar.BAR_MOUSEOVER, {\n        event: n,\n        element: i,\n        datum: r\n      }), t.services.events.dispatchEvent(T.Tooltip.SHOW, {\n        event: n,\n        hoveredElement: i,\n        data: [r]\n      });\n    }).on("mousemove", function(n, r) {\n      const i = I(this);\n      t.services.events.dispatchEvent(T.Bar.BAR_MOUSEMOVE, {\n        event: n,\n        element: i,\n        datum: r\n      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {\n        event: n\n      });\n    }).on("click", function(n, r) {\n      t.services.events.dispatchEvent(T.Bar.BAR_CLICK, {\n        event: n,\n        element: I(this),\n        datum: r\n      });\n    }).on("mouseout", function(n, r) {\n      const i = I(this);\n      i.classed("hovered", !1), t.services.events.dispatchEvent(T.Bar.BAR_MOUSEOUT, {\n        event: n,\n        element: i,\n        datum: r\n      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {\n        hoveredElement: i\n      });\n    });\n  }\n  destroy() {\n    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);\n    const t = this.services.events;\n    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n  getDataCorrespondingToLabel(t) {\n    return this.model.getDisplayData(this.configs.groups).filter((n) => {\n      const r = this.services.cartesianScales.getDomainIdentifier(n);\n      return n[r].toString() === t;\n    });\n  }\n  getGroupWidth() {\n    const t = this.model.getGroupedData(this.configs.groups), n = this.getTotalGroupPadding();\n    return this.getBarWidth() * t.length + n;\n  }\n  getDomainScaleStep() {\n    const t = this.services.cartesianScales.getDomainScale(), n = this.model.getGroupedData(this.configs.groups);\n    let r = this.defaultStepFactor;\n    if (typeof t.step == "function")\n      r = t.step();\n    else if (n.length > 0) {\n      const i = n.find((s) => {\n        var a;\n        return ((a = s.data) == null ? void 0 : a.length) > 1;\n      });\n      if (i) {\n        const s = this.services.cartesianScales.getDomainIdentifier(i.data[0]);\n        r = Math.abs(\n          t(i.data[1][s]) - t(i.data[0][s])\n        );\n      }\n    }\n    return r;\n  }\n  getTotalGroupPadding() {\n    const t = this.model.getGroupedData(this.configs.groups);\n    return t.length === 1 ? 0 : Math.min(5, 5 * (this.getDomainScaleStep() / this.defaultStepFactor)) * (t.length - 1);\n  }\n  // Gets the correct width for bars based on options & configurations\n  getBarWidth() {\n    const t = this.getOptions(), n = y(t, "bars", "width"), r = y(t, "bars", "maxWidth");\n    if (n !== null && (r === null || n <= r))\n      return n;\n    const i = this.model.getGroupedData(this.configs.groups).length, s = this.getTotalGroupPadding();\n    return Math.min(\n      r,\n      (this.getDomainScaleStep() - s) / i\n    );\n  }\n  setGroupScale() {\n    const t = this.model.getActiveDataGroupNames(this.configs.groups);\n    this.groupScale = gs().domain(t).rangeRound([0, this.getGroupWidth()]);\n  }\n}\nclass UD extends mt {\n  constructor() {\n    super(...arguments), this.type = "heatmap", this.renderType = rt.SVG, this.matrix = {}, this.xBandwidth = 0, this.yBandwidth = 0, this.translationUnits = {\n      x: 0,\n      y: 0\n    }, this.handleAxisOnHover = (t) => {\n      const { detail: n } = t, { datum: r } = n, i = this.model.getUniqueRanges(), s = this.model.getUniqueDomain(), a = this.services.cartesianScales.getDomainLabel(), o = this.services.cartesianScales.getRangeLabel(), l = this.services.cartesianScales.getMainXScale(), c = this.services.cartesianScales.getMainYScale();\n      let u = "", d = null, h = null, p = null;\n      this.matrix[r] !== void 0 ? (u = a, i.forEach((f) => {\n        if (typeof this.matrix[r][f].value == "number") {\n          const g = this.matrix[r][f].value;\n          if (d === null) {\n            d = g, h = g, p = g;\n            return;\n          }\n          d += g, h = g < h ? g : h, p = g > p ? g : p;\n        }\n      })) : (u = o, s.forEach((f) => {\n        if (typeof this.matrix[f][r].value == "number") {\n          const g = this.matrix[f][r].value;\n          if (d === null) {\n            d = g, h = g, p = g;\n            return;\n          }\n          d += g, h = g < h ? g : h, p = g > p ? g : p;\n        }\n      })), l(r) !== void 0 ? this.parent.select("g.multi-cell.column-highlight").classed("highlighter-hidden", !1).attr("transform", `translate(${l(r)}, ${Bn(c.range())})`) : c(r) !== void 0 && this.parent.select("g.multi-cell.row-highlight").classed("highlighter-hidden", !1).attr("transform", `translate(${Bn(l.range())},${c(r)})`), this.services.events.dispatchEvent(T.Tooltip.SHOW, {\n        event: n.event,\n        hoveredElement: I(t.detail.element),\n        items: [\n          {\n            label: u,\n            value: r,\n            bold: !0\n          },\n          {\n            label: "Min",\n            value: h !== null ? h : "-"\n          },\n          {\n            label: "Max",\n            value: p !== null ? p : "-"\n          },\n          {\n            label: "Average",\n            value: d !== null ? d / s.length : "-"\n          }\n        ]\n      });\n    }, this.handleAxisMouseOut = (t) => {\n      this.parent.selectAll("g.multi-cell").classed("highlighter-hidden", !0), this.services.events.dispatchEvent(T.Tooltip.HIDE, {\n        event: t\n      });\n    };\n  }\n  init() {\n    const t = this.services.events;\n    t.addEventListener(T.Axis.LABEL_MOUSEOVER, this.handleAxisOnHover), t.addEventListener(T.Axis.LABEL_MOUSEOUT, this.handleAxisMouseOut), t.addEventListener(T.Axis.LABEL_FOCUS, this.handleAxisOnHover), t.addEventListener(T.Axis.LABEL_BLUR, this.handleAxisMouseOut);\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(t = !0) {\n    const n = this.getComponentContainer({ ariaLabel: "heatmap", withinChartClip: !0 });\n    n.lower();\n    const { cartesianScales: r } = this.services;\n    if (this.matrix = this.model.getMatrix(), n.html(""), y(this.getOptions(), "data", "loading"))\n      return;\n    const i = r.getMainXScale(), s = r.getMainYScale(), a = r.getDomainIdentifier(), o = r.getRangeIdentifier(), l = this.model.getUniqueDomain(), c = this.model.getUniqueRanges(), u = this.model.getMatrixAsArray(), d = i.range(), h = s.range();\n    this.xBandwidth = Math.abs((d[1] - d[0]) / l.length), this.yBandwidth = Math.abs((h[1] - h[0]) / c.length);\n    const p = this.services.domUtils.generateElementIDString("heatmap-pattern-stripes");\n    n.append("defs").append("pattern").attr("id", p).attr("width", 3).attr("height", 3).attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").append("rect").classed("pattern-fill", !0).attr("width", 0.5).attr("height", 8);\n    const f = n.selectAll().data(u).enter().append("g").attr("class", (g) => `heat-${g.index}`).classed("cell", !0).attr(\n      "transform",\n      (g) => `translate(${i(g[a])}, ${s(g[o])})`\n    ).append("rect").attr(\n      "class",\n      (g) => this.model.getColorClassName({\n        value: g.value,\n        originalClassName: `heat-${g.index}`\n      })\n    ).classed("heat", !0).classed("null-state", (g) => g.index === -1 || g.value === null).attr("width", this.xBandwidth).attr("height", this.yBandwidth).style("fill", (g) => {\n      const m = this.services.cartesianScales.getDomainIdentifier(g);\n      return g.index === -1 || g.value === null ? `url(#${p})` : this.model.getFillColor(Number(g.value), g[m], g);\n    }).attr("aria-label", (g) => g.value);\n    this.createOuterBox("g.cell-highlight", this.xBandwidth, this.yBandwidth), this.createOuterBox(\n      "g.multi-cell.column-highlight",\n      this.xBandwidth,\n      Math.abs(h[1] - h[0])\n    ), this.createOuterBox(\n      "g.multi-cell.row-highlight",\n      Math.abs(d[1] - d[0]),\n      this.yBandwidth\n    ), this.determineDividerStatus() && (f.style("stroke-width", "1px"), this.parent.select("g.cell-highlight").classed("cell-2", !0)), this.addEventListener();\n  }\n  /**\n   * Generates a box using lines to create a hover effect\n   * The lines have drop shadow in their respective direction\n   * @param parentTag - tag name\n   * @param xBandwidth - X length\n   * @param yBandwidth - y length\n   */\n  createOuterBox(t, n, r) {\n    const i = N.appendOrSelect(this.parent, t).classed("shadows", !0).classed("highlighter-hidden", !0);\n    N.appendOrSelect(i, "line.top").attr("x1", -1).attr("x2", n + 1), N.appendOrSelect(i, "line.left").attr("x1", 0).attr("y1", -1).attr("x2", 0).attr("y2", r + 1), N.appendOrSelect(i, "line.down").attr("x1", -1).attr("x2", n + 1).attr("y1", r).attr("y2", r), N.appendOrSelect(i, "line.right").attr("x1", n).attr("x2", n).attr("y1", -1).attr("y2", r + 1);\n  }\n  determineDividerStatus() {\n    const t = y(this.getOptions(), "heatmap", "divider", "state");\n    return t !== Pi.OFF && (t === Pi.AUTO && Dh.minCellDividerDimension <= this.xBandwidth && Dh.minCellDividerDimension <= this.yBandwidth || t === Pi.ON);\n  }\n  addEventListener() {\n    const t = this, { cartesianScales: n } = this.services, r = this.getOptions(), i = gt(r, "locale.translations.total") || gt(r, "tooltip.totalLabel") || "Total", s = n.getDomainIdentifier(), a = n.getRangeIdentifier(), o = n.getDomainLabel(), l = n.getRangeLabel();\n    this.parent.selectAll("g.cell").on("mouseover", function(c, u) {\n      const d = I(this), h = d.select("rect.heat");\n      if (!h.classed("null-state")) {\n        const p = Mi(d.attr("transform"));\n        t.parent.select("g.cell-highlight").attr(\n          "transform",\n          `translate(${p.x + t.translationUnits.x}, ${p.y + t.translationUnits.y})`\n        ).classed("highlighter-hidden", !1), t.services.events.dispatchEvent(T.Heatmap.HEATMAP_MOUSEOVER, {\n          event: c,\n          element: h,\n          datum: u\n        }), t.services.events.dispatchEvent(T.Tooltip.SHOW, {\n          event: c,\n          items: [\n            {\n              label: o,\n              value: u[s]\n            },\n            {\n              label: l,\n              value: u[a]\n            },\n            {\n              label: i,\n              value: u.value,\n              color: h.style("fill")\n            }\n          ]\n        });\n      }\n    }).on("mousemove", function(c, u) {\n      t.services.events.dispatchEvent(T.Heatmap.HEATMAP_MOUSEMOVE, {\n        event: c,\n        element: I(this),\n        datum: u\n      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {\n        event: c\n      });\n    }).on("click", function(c, u) {\n      t.services.events.dispatchEvent(T.Heatmap.HEATMAP_CLICK, {\n        event: c,\n        element: I(this),\n        datum: u\n      });\n    }).on("mouseout", function(c, u) {\n      const d = I(this).select("rect.heat"), h = d.classed("null-state");\n      t.parent.select("g.cell-highlight").classed("highlighter-hidden", !0), h || (t.services.events.dispatchEvent(T.Heatmap.HEATMAP_MOUSEOUT, {\n        event: c,\n        element: d,\n        datum: u\n      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {\n        event: c,\n        hoveredElement: d\n      }));\n    });\n  }\n  // Remove event listeners\n  destroy() {\n    this.parent.selectAll("rect.heat").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);\n    const t = this.services.events;\n    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleAxisOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleAxisMouseOut);\n  }\n}\nclass BD extends mt {\n  constructor() {\n    super(...arguments), this.type = "histogram", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {\n      const { hoveredElement: n } = t.detail, r = this.getOptions(), { groupMapsTo: i } = r.data;\n      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(\n        (s) => this.services.transitions.setupTransition({\n          transition: s,\n          name: "legend-hover-bar"\n        })\n      ).attr("opacity", (s) => s[i] !== n.datum().name ? 0.3 : 1);\n    }, this.handleLegendMouseOut = () => {\n      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(\n        (t) => this.services.transitions.setupTransition({\n          transition: t,\n          name: "legend-mouseout-bar"\n        })\n      ).attr("opacity", 1);\n    };\n  }\n  init() {\n    const t = this.services.events;\n    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n  render(t) {\n    const n = this.getComponentContainer({\n      ariaLabel: "histogram bars"\n    }), r = this.model.getOptions(), { groupIdentifier: i } = r, { groupMapsTo: s } = r.data, a = this.model.getBinnedStackedData(), o = this.services.cartesianScales.getMainXScale(), l = n.selectAll("g.bars").data(a, (u) => gt(u, `0.${s}`));\n    l.exit().attr("opacity", 0).remove(), l.enter().append("g").classed("bars", !0).attr("role", ht.GROUP);\n    const c = n.selectAll("g.bars").selectAll("path.bar").data((u) => u);\n    c.exit().remove(), c.enter().append("path").merge(c).classed("bar", !0).attr(i, (u, d) => d).transition().call(\n      (u) => this.services.transitions.setupTransition({\n        transition: u,\n        name: "histogram-bar-update-enter",\n        animate: t\n      })\n    ).attr(\n      "class",\n      (u) => this.model.getColorClassName({\n        classNameTypes: [it.FILL],\n        dataGroupName: u[s],\n        originalClassName: "bar"\n      })\n    ).style("fill", (u) => this.model.getFillColor(u[s], null, u)).attr("d", (u) => {\n      const d = gt(u, "data");\n      if (!d)\n        return;\n      const h = o(d.x1) - o(d.x0) - 1, p = this.services.cartesianScales.getDomainValue(d.x0), f = p + h, g = this.services.cartesianScales.getRangeValue(u[0]);\n      let m = this.services.cartesianScales.getRangeValue(u[1]);\n      return Math.abs(m - g) > 0 && Math.abs(m - g) > r.bars.dividerSize && (this.services.cartesianScales.getOrientation() === Ft.VERTICAL ? m += 1 : m -= 1), ae(\n        { x0: p, x1: f, y0: g, y1: m },\n        this.services.cartesianScales.getOrientation()\n      );\n    }).attr("opacity", 1).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (u) => y(u, "data", u[s])), this.addEventListeners();\n  }\n  addEventListeners() {\n    const t = this.model.getOptions(), { groupMapsTo: n } = t.data, { code: r, number: i } = y(t, "locale"), s = this;\n    this.parent.selectAll("path.bar").on("mouseover", function(a, o) {\n      const l = I(this);\n      l.classed("hovered", !0);\n      const c = i(parseFloat(gt(o, "data.x0")), r), u = i(parseFloat(gt(o, "data.x1")), r), d = s.services.cartesianScales.getRangeAxisPosition(), h = s.services.cartesianScales.getScaleLabel(d);\n      s.services.events.dispatchEvent(T.Tooltip.SHOW, {\n        event: a,\n        hoveredElement: l,\n        items: [\n          {\n            label: gt(t, "bins.rangeLabel") || "Range",\n            value: `${c}  ${u}`\n          },\n          {\n            label: t.tooltip.groupLabel || "Group",\n            value: o[n],\n            class: s.model.getColorClassName({\n              classNameTypes: [it.TOOLTIP],\n              dataGroupName: o[n]\n            })\n          },\n          {\n            label: h,\n            value: gt(o, `data.${o[n]}`)\n          }\n        ]\n      });\n    }).on("mousemove", function(a) {\n      s.services.events.dispatchEvent(T.Tooltip.MOVE, {\n        event: a\n      });\n    }).on("mouseout", function() {\n      I(this).classed("hovered", !1), s.services.events.dispatchEvent(T.Tooltip.HIDE);\n    });\n  }\n  destroy() {\n    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);\n    const t = this.services.events;\n    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n}\nclass HD extends nn {\n  constructor() {\n    super(...arguments), this.type = "lollipop", this.renderType = rt.SVG, this.handleScatterOnHover = (t) => {\n      const n = t.detail, r = this.getOptions(), { groupMapsTo: i } = r.data;\n      this.parent.selectAll("line.line").attr("stroke-width", (s) => s[i] !== n.datum[i] ? vn.weight.unselected : vn.weight.selected);\n    }, this.handleScatterOnMouseOut = () => {\n      this.parent.selectAll("line.line").attr("stroke-width", vn.weight.unselected);\n    }, this.handleLegendOnHover = (t) => {\n      const { hoveredElement: n } = t.detail, r = this.getOptions(), { groupMapsTo: i } = r.data;\n      this.parent.selectAll("line.line").transition("legend-hover-line").call(\n        (s) => this.services.transitions.setupTransition({\n          transition: s,\n          name: "legend-hover-line"\n        })\n      ).attr("opacity", (s) => s[i] !== n.datum().name ? vn.opacity.unselected : vn.opacity.selected);\n    }, this.handleLegendMouseOut = () => {\n      this.parent.selectAll("line.line").transition("legend-mouseout-line").call(\n        (t) => this.services.transitions.setupTransition({\n          transition: t,\n          name: "legend-mouseout-line"\n        })\n      ).attr("opacity", vn.opacity.selected);\n    };\n  }\n  init() {\n    const { events: t } = this.services;\n    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n  render(t) {\n    const n = this.getComponentContainer({ ariaLabel: "lines", withinChartClip: !0 }), r = this.model.getOptions(), { groupMapsTo: i } = r.data, { cartesianScales: s } = this.services, a = s.getMainXScale(), o = s.getMainYScale(), l = s.getDomainIdentifier(), c = (m) => s.getDomainValue(m), u = (m) => s.getRangeValue(m), d = s.getOrientation(), [h, p] = En(\n      c,\n      u,\n      d\n    ), f = n.selectAll("line.line").data(\n      this.getScatterData(),\n      (m) => `${m[i]}-${m[l]}`\n    );\n    f.exit().attr("opacity", 0).remove();\n    const g = f.enter().append("line").attr("opacity", 0).merge(f).classed("line", !0).attr(\n      "class",\n      (m) => this.model.getColorClassName({\n        classNameTypes: [it.STROKE],\n        dataGroupName: m[i],\n        originalClassName: "line"\n      })\n    ).transition().call(\n      (m) => this.services.transitions.setupTransition({\n        transition: m,\n        name: "lollipop-line-update-enter",\n        animate: t\n      })\n    ).style("stroke", (m) => this.model.getFillColor(m[i], m[l], m)).attr("opacity", 1);\n    d === Ft.HORIZONTAL ? g.attr("y1", p).attr("y2", p).attr("x1", a.range()[0]).attr("x2", (m) => h(m) - r.points.radius) : g.attr("x1", h).attr("x2", h).attr("y1", o.range()[0]).attr("y2", (m) => p(m) + r.points.radius), this.addScatterPointEventListeners();\n  }\n  // listen for when individual datapoints are hovered\n  addScatterPointEventListeners() {\n    this.services.events.addEventListener(\n      T.Scatter.SCATTER_MOUSEOVER,\n      this.handleScatterOnHover\n    ), this.services.events.addEventListener(\n      T.Scatter.SCATTER_MOUSEOUT,\n      this.handleScatterOnMouseOut\n    );\n  }\n  destroy() {\n    const t = this.services.events;\n    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), t.removeEventListener(T.Scatter.SCATTER_MOUSEOVER, this.handleScatterOnHover), t.removeEventListener(\n      T.Scatter.SCATTER_MOUSEOUT,\n      this.handleScatterOnMouseOut\n    );\n  }\n}\nclass VD extends mt {\n  constructor() {\n    super(...arguments), this.type = "meter", this.renderType = rt.SVG;\n  }\n  getStackedBounds(t, n) {\n    let r = 0;\n    return t.map((i, s) => s !== 0 ? (r += n(i.value), {\n      ...i,\n      width: Math.abs(n(i.value) - Zt.dividerWidth),\n      x: r - n(i.value)\n    }) : (r = n(i.value), {\n      ...i,\n      width: Math.abs(n(i.value) - Zt.dividerWidth),\n      x: 0\n    }));\n  }\n  render(t = !0) {\n    const n = this, r = this.getComponentContainer({\n      ariaLabel: "meter lines"\n    }), i = this.getOptions(), s = y(i, "meter", "proportional"), a = this.model.getDisplayData(), o = this.model.getStatus(), { width: l } = N.getSVGElementSize(r, {\n      useAttrs: !0\n    }), { groupMapsTo: c } = i.data;\n    let u;\n    y(i, "meter", "proportional") === null ? u = 100 : u = y(i, "meter", "proportional", "total") || this.model.getMaximumDomain(this.model.getDisplayData());\n    const d = Fe().domain([0, u]).range([0, l]), h = this.getStackedBounds(a, d), p = y(i, "meter", "height");\n    N.appendOrSelect(r, "rect.container").attr("x", 0).attr("y", 0).attr("width", l).attr(\n      "height",\n      p || (s ? Zt.height.proportional : Zt.height.default)\n    ), N.appendOrSelect(r, "line.rangeIndicator").attr("x1", l).attr("x2", l).attr("y1", 0).attr(\n      "y2",\n      p || (s ? Zt.height.proportional : Zt.height.default)\n    );\n    const f = r.selectAll("rect.value").data(h), g = o != null && !n.model.isUserProvidedColorScaleValid() && !s ? `value status--${o}` : "value";\n    f.enter().append("rect").classed("value", !0).merge(f).attr("x", (_) => _.x).attr("y", 0).attr("height", () => p || (s ? Zt.height.proportional : Zt.height.default)).attr(\n      "class",\n      (_) => this.model.getColorClassName({\n        classNameTypes: [it.FILL],\n        dataGroupName: _[c],\n        originalClassName: g\n      })\n    ).transition().call(\n      (_) => this.services.transitions.setupTransition({\n        transition: _,\n        name: "meter-bar-update",\n        animate: t\n      })\n    ).attr("width", (_) => _.value > u ? d(u) : Math.max(_.width, 2)).style("fill", (_) => n.model.getFillColor(_[c], null, _)).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", (_) => _.value), f.exit().remove();\n    const m = y(i, "meter", "peak");\n    let v = m;\n    m !== null && (m > u ? v = u : m < 0 && (v = 0));\n    const x = r.selectAll("line.peak").data(v == null ? [] : [v]);\n    x.enter().append("line").classed("peak", !0).merge(x).attr("y1", 0).attr("y2", () => p || (s ? Zt.height.proportional : Zt.height.default)).transition().call(\n      (_) => this.services.transitions.setupTransition({\n        transition: _,\n        name: "peak-line-update",\n        animate: t\n      })\n    ).attr("x1", (_) => d(_)).attr("x2", (_) => d(_)).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "peak").attr("aria-label", (_) => _), x.exit().remove(), this.services.domUtils.setSVGMaxHeight(), this.addEventListeners();\n  }\n  // add event listeners for tooltips on proportional meter bars\n  addEventListeners() {\n    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this, i = y(t, "meter", "proportional");\n    this.parent.selectAll("rect.value").on("mouseover", function(s, a) {\n      const o = I(this);\n      r.services.events.dispatchEvent(T.Meter.METER_MOUSEOVER, {\n        event: s,\n        element: o,\n        datum: a\n      }), i && (o.classed("hovered", !0), r.services.events.dispatchEvent(T.Tooltip.SHOW, {\n        event: s,\n        hoveredElement: o,\n        items: [\n          {\n            label: a[n],\n            value: a.value\n          }\n        ]\n      }));\n    }).on("mousemove", function(s, a) {\n      const o = I(this);\n      r.services.events.dispatchEvent(T.Meter.METER_MOUSEMOVE, {\n        event: s,\n        element: o,\n        datum: a\n      }), i && r.services.events.dispatchEvent(T.Tooltip.MOVE, {\n        event: s\n      });\n    }).on("click", function(s, a) {\n      r.services.events.dispatchEvent(T.Meter.METER_CLICK, {\n        event: s,\n        element: I(this),\n        datum: a\n      });\n    }).on("mouseout", function(s, a) {\n      const o = I(this);\n      r.services.events.dispatchEvent(T.Meter.METER_MOUSEOUT, {\n        event: s,\n        element: o,\n        datum: a\n      }), i && (o.classed("hovered", !1), r.services.events.dispatchEvent(T.Tooltip.HIDE, {\n        hoveredElement: o\n      }));\n    });\n  }\n  destroy() {\n    this.parent.selectAll("rect.value").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);\n  }\n}\nclass GD extends mt {\n  constructor() {\n    super(...arguments), this.type = "radar", this.renderType = rt.SVG, this.getLabelDimensions = (t) => {\n      const n = N.appendOrSelect(this.getComponentContainer(), "g.tmp-tick"), r = N.appendOrSelect(n, "text").text(t), { width: i, height: s } = N.getSVGElementSize(r.node(), { useBBox: !0 });\n      return n.remove(), { width: i, height: s };\n    }, this.normalizeFlatData = (t) => {\n      const n = this.getOptions(), { angle: r, value: i } = y(n, "radar", "axes"), s = y(n, "data", "groupMapsTo"), a = RC(\n        this.uniqueKeys.map((o) => this.uniqueGroups.map((l) => ({\n          [r]: o,\n          [s]: l,\n          [i]: null\n        })))\n      );\n      return at(a, t);\n    }, this.normalizeGroupedData = (t) => {\n      const n = this.getOptions(), { angle: r, value: i } = y(n, "radar", "axes"), s = y(n, "data", "groupMapsTo");\n      return t.map(({ name: a, data: o }) => {\n        const l = this.uniqueKeys.map((c) => ({\n          [s]: a,\n          [r]: c,\n          [i]: null\n        }));\n        return { name: a, data: at(l, o) };\n      });\n    }, this.handleLegendOnHover = (t) => {\n      const { hoveredElement: n } = t.detail;\n      this.parent.selectAll("g.blobs path").transition("legend-hover-blob").call(\n        (r) => this.services.transitions.setupTransition({\n          transition: r,\n          name: "legend-hover-blob"\n        })\n      ).style("fill-opacity", (r) => r.name !== n.datum().name ? Wn.opacity.unselected : Wn.opacity.selected).style("stroke-opacity", (r) => r.name !== n.datum().name ? Wn.opacity.unselected : 1);\n    }, this.handleLegendMouseOut = () => {\n      this.parent.selectAll("g.blobs path").transition("legend-mouseout-blob").call(\n        (t) => this.services.transitions.setupTransition({\n          transition: t,\n          name: "legend-mouseout-blob"\n        })\n      ).style("fill-opacity", Wn.opacity.selected).style("stroke-opacity", 1);\n    };\n  }\n  init() {\n    const { events: t } = this.services;\n    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n  render(t = !0) {\n    const n = this.getComponentContainer({\n      ariaLabel: "radar graph"\n    }), { width: r, height: i } = N.getSVGElementSize(n, {\n      useAttrs: !0\n    }), s = this.model.getData(), a = this.model.getGroupedData(), o = this.getOptions(), l = y(o, "data", "groupMapsTo"), c = y(o, "radar", "axes", "value"), { angle: u, value: d } = y(o, "radar", "axes"), { xLabelPadding: h, yLabelPadding: p, yTicksNumber: f, minRange: g, xAxisRectHeight: m } = Wn;\n    this.uniqueKeys = Array.from(new Set(s.map((O) => O[u]))), this.uniqueGroups = Array.from(new Set(s.map((O) => O[l]))), this.fullDataNormalized = this.normalizeFlatData(s), this.groupedDataNormalized = this.normalizeGroupedData(a);\n    const v = 2 * (this.getLabelDimensions(this.uniqueKeys[0]).height + p), x = (Math.min(r, i) - v) / 2;\n    if (x <= 0)\n      return;\n    const _ = gs().domain(this.fullDataNormalized.map((O) => O[u])).range([0, 2 * Math.PI].map((O) => O - Math.PI / 2)), E = Bn(this.fullDataNormalized.map((O) => O[d])), b = Fe().domain([\n      E >= 0 ? 0 : E,\n      nr(this.fullDataNormalized.map((O) => O[d]))\n    ]).range([g, x]).nice(f), S = b.ticks(f), M = (O, w, L) => this.model.getFillColor(O, w, L), D = dk().angle((O) => _(O[u]) + Math.PI / 2).radius((O) => b(O[d])).curve(ig), A = this.uniqueKeys.map((O) => {\n      const w = this.getLabelDimensions(O).width, L = U2(\n        _(O),\n        x\n      );\n      return w + L;\n    }), R = {\n      x: nr(A) + h,\n      y: i / 2\n    }, $ = N.appendOrSelect(n, "g.y-axes").attr("role", ht.GROUP).selectAll("path").data(S, (O) => O), H = (O) => this.uniqueKeys.map((w) => ({ [u]: w, [d]: O }));\n    $.join(\n      (O) => O.append("path").attr("opacity", 0).attr("transform", `translate(${R.x}, ${R.y})`).attr("fill", "none").call(\n        (w) => w.transition().call(\n          (L) => this.services.transitions.setupTransition({\n            transition: L,\n            name: "radar_y_axes_enter",\n            animate: t\n          })\n        ).attr("opacity", 1).attr("d", (L) => D(H(L)))\n      ),\n      (O) => O.call(\n        (w) => w.transition().call(\n          (L) => this.services.transitions.setupTransition({\n            transition: L,\n            name: "radar_y_axes_update",\n            animate: t\n          })\n        ).attr("opacity", 1).attr("transform", `translate(${R.x}, ${R.y})`).attr("d", (L) => D(H(L)))\n      ),\n      (O) => O.call(\n        (w) => w.transition().call(\n          (L) => this.services.transitions.setupTransition({\n            transition: L,\n            name: "radar_y_axes_exit",\n            animate: t\n          })\n        ).attr("d", (L) => D(H(L))).attr("opacity", 0).remove()\n      )\n    ), N.appendOrSelect(n, "g.x-axes").attr("role", ht.GROUP).selectAll("line").data(this.uniqueKeys, (O) => O).join(\n      (O) => O.append("line").attr("opacity", 0).attr("class", (w) => `x-axis-${Tr(w)}`).attr("stroke-dasharray", "0").attr("x1", (w) => Ut(_(w), 0, R).x).attr("y1", (w) => Ut(_(w), 0, R).y).attr("x2", (w) => Ut(_(w), 0, R).x).attr("y2", (w) => Ut(_(w), 0, R).y).call(\n        (w) => w.transition().call(\n          (L) => this.services.transitions.setupTransition({\n            transition: L,\n            name: "radar_x_axes_enter",\n            animate: t\n          })\n        ).attr("opacity", 1).attr("x1", (L) => Ut(_(L), b.range()[0], R).x).attr("y1", (L) => Ut(_(L), b.range()[0], R).y).attr("x2", (L) => Ut(_(L), b.range()[1], R).x).attr("y2", (L) => Ut(_(L), b.range()[1], R).y)\n      ),\n      (O) => O.call(\n        (w) => w.transition().call(\n          (L) => this.services.transitions.setupTransition({\n            transition: L,\n            name: "radar_x_axes_update",\n            animate: t\n          })\n        ).attr("opacity", 1).attr("x1", (L) => Ut(_(L), b.range()[0], R).x).attr("y1", (L) => Ut(_(L), b.range()[0], R).y).attr("x2", (L) => Ut(_(L), b.range()[1], R).x).attr("y2", (L) => Ut(_(L), b.range()[1], R).y)\n      ),\n      (O) => O.call(\n        (w) => w.transition().call(\n          (L) => this.services.transitions.setupTransition({\n            transition: L,\n            name: "radar_x_axes_exit",\n            animate: t\n          })\n        ).attr("opacity", 0).remove()\n      )\n    ), N.appendOrSelect(n, "g.x-labels").attr("role", ht.GROUP).selectAll("text").data(this.uniqueKeys).join(\n      (O) => O.append("text").text((w) => w).attr("opacity", 0).attr(\n        "x",\n        (w) => Ut(_(w), b.range()[1] + h, R).x\n      ).attr(\n        "y",\n        (w) => Ut(_(w), b.range()[1] + h, R).y\n      ).style("text-anchor", (w) => pd(_(w)).textAnchor).style(\n        "dominant-baseline",\n        (w) => pd(_(w)).dominantBaseline\n      ).call(\n        (w) => w.transition().call(\n          (L) => this.services.transitions.setupTransition({\n            transition: L,\n            name: "radar_x_labels_enter",\n            animate: t\n          })\n        ).attr("opacity", 1)\n      ),\n      (O) => O.call(\n        (w) => w.transition().call(\n          (L) => this.services.transitions.setupTransition({\n            transition: L,\n            name: "radar_x_labels_update",\n            animate: t\n          })\n        ).attr("opacity", 1).attr(\n          "x",\n          (L) => Ut(_(L), b.range()[1] + h, R).x\n        ).attr(\n          "y",\n          (L) => Ut(_(L), b.range()[1] + h, R).y\n        ).end().finally(() => {\n          const L = y(o, "radar", "alignment"), k = this.getAlignmentXOffset(L, n, this.getParent());\n          n.attr("x", k);\n        })\n      ),\n      (O) => O.call(\n        (w) => w.transition().call(\n          (L) => this.services.transitions.setupTransition({\n            transition: L,\n            name: "radar_x_labels_exit",\n            animate: t\n          })\n        ).attr("opacity", 0).remove()\n      )\n    ), N.appendOrSelect(n, "g.blobs").attr("role", ht.GROUP).selectAll("path").data(this.groupedDataNormalized, (O) => O.name).join(\n      (O) => O.append("path").attr(\n        "class",\n        (w) => this.model.getColorClassName({\n          classNameTypes: [it.FILL, it.STROKE],\n          dataGroupName: w.name,\n          originalClassName: "blob"\n        })\n      ).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-label", (w) => w.name).attr("opacity", 0).attr(\n        "transform",\n        t ? () => `translate(${R.x}, ${R.y}) scale(${1 + Math.random() * 0.35})` : `translate(${R.x}, ${R.y})`\n      ).style("fill", (w) => M(w.name, null, w.data)).style("fill-opacity", Wn.opacity.selected).style("stroke", (w) => M(w.name, null, w.data)).call((w) => {\n        const L = w.transition().call(\n          (k) => this.services.transitions.setupTransition({\n            transition: k,\n            name: "radar_blobs_enter",\n            animate: t\n          })\n        );\n        t && L.delay(() => Math.random() * 30).attr("transform", `translate(${R.x}, ${R.y})`), L.attr("opacity", 1).attr("d", (k) => D(k.data));\n      }),\n      (O) => (O.attr(\n        "class",\n        (w) => this.model.getColorClassName({\n          classNameTypes: [it.FILL, it.STROKE],\n          dataGroupName: w.name,\n          originalClassName: "blob"\n        })\n      ).style("fill", (w) => M(w.name, null, w.data)).style("stroke", (w) => M(w.name, null, w.data)), O.call(\n        (w) => w.transition().call(\n          (L) => this.services.transitions.setupTransition({\n            transition: L,\n            name: "radar_blobs_update",\n            animate: t\n          })\n        ).attr("opacity", 1).attr("transform", `translate(${R.x}, ${R.y})`).attr("d", (L) => D(L.data))\n      ), O),\n      (O) => O.call((w) => {\n        const L = w.transition().call(\n          (k) => this.services.transitions.setupTransition({\n            transition: k,\n            name: "radar_blobs_exit",\n            animate: t\n          })\n        );\n        t && L.delay(() => Math.random() * 30).attr(\n          "transform",\n          () => `translate(${R.x}, ${R.y}) scale(${1 + Math.random() * 0.35})`\n        ), L.attr("opacity", 0).remove();\n      })\n    ), N.appendOrSelect(n, "g.dots").attr("role", ht.GROUP).selectAll("circle").data(this.fullDataNormalized.filter((O) => y(O, d) !== null)).join(\n      (O) => O.append("circle").attr("role", ht.GRAPHICS_SYMBOL).attr("aria-label", (w) => w[c]),\n      (O) => O,\n      (O) => O.remove()\n    ).attr(\n      "class",\n      (O) => this.model.getColorClassName({\n        classNameTypes: [it.FILL],\n        dataGroupName: O[l],\n        originalClassName: Tr(O[u])\n      })\n    ).attr("cx", (O) => Ut(_(O[u]), b(O[d]), R).x).attr("cy", (O) => Ut(_(O[u]), b(O[d]), R).y).attr("r", 0).attr("opacity", 0).style("fill", (O) => M(O[l])), N.appendOrSelect(n, "g.x-axes-rect").attr("role", ht.GROUP).selectAll("rect").data(this.uniqueKeys).join(\n      (O) => O.append("rect"),\n      (O) => O,\n      (O) => O.remove()\n    ).attr("x", R.x).attr("y", R.y - m / 2).attr("width", b.range()[1]).attr("height", m).style("fill", "red").style("fill-opacity", 0).attr("transform", (O) => `rotate(${pg(_(O))}, ${R.x}, ${R.y})`);\n    const { code: P, number: B } = y(o, "locale");\n    N.appendOrSelect(n, "g.y-labels").attr("role", ht.GROUP).selectAll("text").data(ze(S)).join(\n      (O) => O.append("text").attr("opacity", 0).text((w) => B(w, P)).attr(\n        "x",\n        (w) => Ut(-Math.PI / 2, b(w), R).x + p\n      ).attr("y", (w) => Ut(-Math.PI / 2, b(w), R).y).style("text-anchor", "start").style("dominant-baseline", "middle").call(\n        (w) => w.transition().call(\n          (L) => this.services.transitions.setupTransition({\n            transition: L,\n            name: "radar_y_labels_enter",\n            animate: t\n          })\n        ).attr("opacity", 1)\n      ),\n      (O) => O.call(\n        (w) => w.transition().call(\n          (L) => this.services.transitions.setupTransition({\n            transition: L,\n            name: "radar_y_labels_update",\n            animate: t\n          })\n        ).text((L) => L).attr("opacity", 1).attr(\n          "x",\n          (L) => Ut(-Math.PI / 2, b(L), R).x + p\n        ).attr("y", (L) => Ut(-Math.PI / 2, b(L), R).y)\n      ),\n      (O) => O.call(\n        (w) => w.transition().call(\n          (L) => this.services.transitions.setupTransition({\n            transition: L,\n            name: "radar_y_labels_exit",\n            animate: t\n          })\n        ).attr("opacity", 0).remove()\n      )\n    ), this.addEventListeners();\n  }\n  getAlignmentXOffset(t, n, r) {\n    const i = N.getSVGElementSize(n, {\n      useBBox: !0\n    }), { width: s } = N.getSVGElementSize(r, {\n      useAttrs: !0\n    });\n    let a = 0;\n    return t === jt.CENTER ? a = Math.floor((s - i.width) / 2) : t === jt.RIGHT && (a = s - i.width), a;\n  }\n  destroy() {\n    this.parent.selectAll(".x-axes-rect > rect").on("mouseover", null).on("mousemove", null).on("mouseout", null);\n    const t = this.services.events;\n    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n  addEventListeners() {\n    const t = this, {\n      axes: { angle: n }\n    } = y(this.getOptions(), "radar");\n    this.parent.selectAll(".x-axes-rect > rect").on("mouseover", function(r, i) {\n      const s = I(this);\n      t.services.events.dispatchEvent(T.Radar.X_AXIS_MOUSEOVER, {\n        event: r,\n        element: s,\n        datum: i\n      });\n      const a = t.parent.select(`.x-axes .x-axis-${Tr(i)}`), o = t.parent.selectAll(`.dots circle.${Tr(i)}`), l = t.model.getActiveDataGroupNames(), c = t.getOptions(), { groupMapsTo: u } = c.data, d = y(c, "radar", "axes", "value");\n      a.classed("hovered", !0).attr("stroke-dasharray", "4 4"), o.classed("hovered", !0).attr(\n        "opacity",\n        (p) => l.indexOf(p[u]) !== -1 ? 1 : 0\n      ).attr("r", Wn.dotsRadius);\n      const h = t.fullDataNormalized.filter(\n        (p) => p[n] === i && l.indexOf(p[u]) !== -1\n      );\n      t.services.events.dispatchEvent(T.Tooltip.SHOW, {\n        event: r,\n        hoveredElement: s,\n        items: h.filter((p) => typeof p[d] == "number").map((p) => ({\n          label: p[u],\n          value: p[d],\n          color: t.model.getFillColor(p[u], null, p),\n          class: t.model.getColorClassName({\n            classNameTypes: [it.TOOLTIP],\n            dataGroupName: p[u]\n          })\n        }))\n      });\n    }).on("mousemove", function(r, i) {\n      const s = I(this);\n      t.services.events.dispatchEvent(T.Radar.X_AXIS_MOUSEMOVE, {\n        event: r,\n        element: s,\n        datum: i\n      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {\n        event: r\n      });\n    }).on("click", function(r, i) {\n      t.services.events.dispatchEvent(T.Radar.X_AXIS_CLICK, {\n        event: r,\n        element: I(this),\n        datum: i\n      });\n    }).on("mouseout", function(r, i) {\n      const s = I(this), a = t.parent.select(`.x-axes .x-axis-${Tr(i)}`), o = t.parent.selectAll(`.dots circle.${Tr(i)}`);\n      a.classed("hovered", !1).attr("stroke-dasharray", "0"), o.classed("hovered", !1).attr("opacity", 0).attr("r", 0), t.services.events.dispatchEvent(T.Radar.X_AXIS_MOUSEOUT, {\n        event: r,\n        element: s,\n        datum: i\n      }), t.services.events.dispatchEvent(T.Tooltip.HIDE);\n    });\n  }\n}\nclass $v extends hu {\n  constructor() {\n    super(...arguments), this.type = "simple-bar", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {\n      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;\n      this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(\n        (i) => this.services.transitions.setupTransition({\n          transition: i,\n          name: "legend-hover-simple-bar"\n        })\n      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);\n    }, this.handleLegendMouseOut = () => {\n      this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(\n        (t) => this.services.transitions.setupTransition({\n          transition: t,\n          name: "legend-mouseout-simple-bar"\n        })\n      ).attr("opacity", 1);\n    };\n  }\n  init() {\n    const t = this.services.events;\n    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n  render(t) {\n    const n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.getComponentContainer({\n      ariaLabel: "bar graphs",\n      withinChartClip: !0\n    }), s = this.model.getDisplayData(this.configs.groups), a = this.services.cartesianScales.getOrientation(), o = i.selectAll("path.bar").data(s, (l) => l[r]);\n    o.exit().attr("opacity", 0).remove(), o.enter().append("path").attr("opacity", 0).merge(o).classed("bar", !0).attr("width", this.getBarWidth.bind(this)).transition().call(\n      (l) => this.services.transitions.setupTransition({\n        transition: l,\n        name: "bar-update-enter",\n        animate: t\n      })\n    ).attr(\n      "class",\n      (l) => this.model.getColorClassName({\n        classNameTypes: [it.FILL],\n        dataGroupName: l[r],\n        originalClassName: "bar"\n      })\n    ).style("fill", (l) => {\n      const c = this.services.cartesianScales.getDomainIdentifier(l);\n      return this.model.getFillColor(l[r], l[c], l);\n    }).attr("d", (l) => {\n      const c = this.services.cartesianScales.getRangeIdentifier(), u = this.getBarWidth(), d = l[c], h = this.services.cartesianScales.getDomainValue(l) - u / 2, p = h + u;\n      let f, g;\n      if (Array.isArray(d) && d.length === 2)\n        f = this.services.cartesianScales.getRangeValue(d[0]), g = this.services.cartesianScales.getRangeValue(d[1]);\n      else {\n        const v = this.services.cartesianScales.getRangeScale().domain()[0];\n        f = this.services.cartesianScales.getRangeValue(Math.max(0, v)), g = this.services.cartesianScales.getRangeValue(l);\n      }\n      const m = Math.abs(g - f);\n      if (m !== 0 && m < 2 && (d > 0 && a === Ft.VERTICAL || d < 0 && a === Ft.HORIZONTAL ? g = f - 2 : g = f + 2), !this.isOutsideZoomedDomain(h, p))\n        return ae({ x0: h, x1: p, y0: f, y1: g }, a);\n    }).attr("opacity", 1).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (l) => l.value), this.addEventListeners();\n  }\n  addEventListeners() {\n    const t = this;\n    this.parent.selectAll("path.bar").on("mouseover", function(n, r) {\n      const i = I(this);\n      i.classed("hovered", !0), t.services.events.dispatchEvent(T.Bar.BAR_MOUSEOVER, {\n        event: n,\n        element: i,\n        datum: r\n      }), t.services.events.dispatchEvent(T.Tooltip.SHOW, {\n        event: n,\n        hoveredElement: i,\n        data: [r]\n      });\n    }).on("mousemove", function(n, r) {\n      t.services.events.dispatchEvent(T.Bar.BAR_MOUSEMOVE, {\n        event: n,\n        element: I(this),\n        datum: r\n      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {\n        event: n\n      });\n    }).on("click", function(n, r) {\n      t.services.events.dispatchEvent(T.Bar.BAR_CLICK, {\n        event: n,\n        element: I(this),\n        datum: r\n      });\n    }).on("mouseout", function(n, r) {\n      const i = I(this);\n      i.classed("hovered", !1), t.services.events.dispatchEvent(T.Bar.BAR_MOUSEOUT, {\n        event: n,\n        element: i,\n        datum: r\n      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {\n        hoveredElement: i\n      });\n    });\n  }\n  destroy() {\n    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);\n    const t = this.services.events;\n    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n}\nclass zD extends ce {\n  constructor() {\n    super(...arguments), this.type = "skeleton-lines";\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(t = !0) {\n    const n = y(this.getOptions(), "data", "loading"), r = !y(this.getOptions(), "grid", "x", "enabled") && !y(this.getOptions(), "grid", "y", "enabled") && !y(this.getOptions(), "axes", "bottom", "visible") && !y(this.getOptions(), "axes", "left", "visible");\n    n && !r ? super.renderGridSkeleton(n) : n && r ? this.renderSparklineSkeleton(n) : this.removeSkeleton();\n  }\n  renderSparklineSkeleton(t) {\n    this.setScales(), this.drawBackdrop(t), this.drawSparkline(t), this.updateBackdropStyle(), t && this.setShimmerEffect("shimmer-lines");\n  }\n  drawSparkline(t) {\n    const n = this.backdrop.attr("width"), r = [100], i = N.appendOrSelect(this.backdrop, "g.y.skeleton"), s = i.selectAll("line").data(r);\n    s.enter().append("line").merge(s).attr("x1", 0).attr("x2", n).attr("y1", (a) => a).attr("y2", (a) => a), i.selectAll("line").classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(\n      "stroke",\n      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null\n    );\n  }\n  updateBackdropStyle() {\n    const t = this.parent;\n    this.backdrop = N.appendOrSelect(t, "svg.chart-skeleton.DAII").attr(\n      "role",\n      "presentation"\n    ), N.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop").classed("shimmer-effect-lines", !1).classed("shimmer-effect-sparkline", !0).style("stroke", null);\n  }\n}\nclass Mv extends mt {\n  constructor() {\n    super(...arguments), this.type = "area-stacked", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {\n      const { hoveredElement: n } = t.detail, r = this.getOptions(), { groupMapsTo: i } = r.data;\n      this.parent.selectAll("path.area").transition("legend-hover-area").call(\n        (s) => this.services.transitions.setupTransition({\n          transition: s,\n          name: "legend-hover-area"\n        })\n      ).attr("opacity", (s) => y(s, 0, i) !== n.datum().name ? yn.opacity.unselected : yn.opacity.selected);\n    }, this.handleLegendMouseOut = () => {\n      this.parent.selectAll("path.area").transition("legend-mouseout-area").call(\n        (t) => this.services.transitions.setupTransition({\n          transition: t,\n          name: "legend-mouseout-area"\n        })\n      ).attr("opacity", yn.opacity.selected);\n    };\n  }\n  init() {\n    const t = this.services.events;\n    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n  render(t = !0) {\n    const n = this.getComponentContainer({\n      ariaLabel: "stacked area graphs",\n      withinChartClip: !0\n    }), r = this, i = this.getOptions(), { groupMapsTo: s } = i.data, a = Object.keys(i.axes).some((p) => i.axes[p].percentage), o = this.model.getStackedData({\n      percentage: a,\n      groups: this.configs.groups\n    }), l = y(o, 0, 0), c = this.services.cartesianScales.getDomainAxisPosition({ datum: l }), u = this.services.cartesianScales.getRangeAxisPosition({ datum: l }), d = this.services.cartesianScales.getScaleByPosition(u), h = n.selectAll("path.area").data(o, (p) => y(p, 0, s));\n    this.areaGenerator = au().x(\n      (p) => this.services.cartesianScales.getValueThroughAxisPosition(\n        c,\n        p.data.sharedStackKey\n      )\n    ).y0((p) => d(p[0])).y1((p) => d(p[1])).curve(this.services.curves.getD3Curve()), h.exit().attr("opacity", 0).remove(), h.enter().append("path").attr("opacity", 0).merge(h).data(o, (p) => y(p, 0, s)).attr("class", "area").attr(\n      "class",\n      (p) => this.model.getColorClassName({\n        classNameTypes: [it.FILL],\n        dataGroupName: y(p, 0, s),\n        originalClassName: "area"\n      })\n    ).style("fill", (p) => r.model.getFillColor(y(p, 0, s), null, p)).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "area").attr("aria-label", (p) => y(p, 0, s)).transition().call(\n      (p) => this.services.transitions.setupTransition({\n        transition: p,\n        name: "area-update-enter",\n        animate: t\n      })\n    ).attr("opacity", yn.opacity.selected).attr("d", this.areaGenerator);\n  }\n}\nclass Cv extends hu {\n  constructor() {\n    super(...arguments), this.type = "stacked-bar", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {\n      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.model.getOptions().data;\n      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(\n        (i) => this.services.transitions.setupTransition({\n          transition: i,\n          name: "legend-hover-bar"\n        })\n      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);\n    }, this.handleLegendMouseOut = () => {\n      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(\n        (t) => this.services.transitions.setupTransition({\n          transition: t,\n          name: "legend-mouseout-bar"\n        })\n      ).attr("opacity", 1);\n    };\n  }\n  init() {\n    const t = this.services.events;\n    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n  render(t) {\n    const n = this.getComponentContainer({ ariaLabel: "stacked bar graphs", withinChartClip: !0 }), r = this.getOptions(), { groupMapsTo: i } = r.data, s = this.model.getStackedData({\n      groups: this.configs.groups,\n      divergent: !0\n    }), a = this.model.getActiveDataGroupNames(), o = n.selectAll("g.bars").data(s, (c) => y(c, 0, i));\n    o.exit().attr("opacity", 0).remove(), o.enter().append("g").classed("bars", !0).attr("role", ht.GROUP).attr("data-name", "bars");\n    const l = n.selectAll("g.bars").selectAll("path.bar").data(\n      (c) => c,\n      (c) => c.data.sharedStackKey\n    );\n    l.exit().remove(), l.enter().append("path").merge(l).classed("bar", !0).transition().call(\n      (c) => this.services.transitions.setupTransition({\n        transition: c,\n        name: "bar-update-enter",\n        animate: t\n      })\n    ).attr(\n      "class",\n      (c) => this.model.getColorClassName({\n        classNameTypes: [it.FILL],\n        dataGroupName: c[i],\n        originalClassName: "bar"\n      })\n    ).style(\n      "fill",\n      (c) => this.model.getFillColor(c[i], c.data.sharedStackKey, c.data)\n    ).attr("d", (c) => {\n      const u = c.data.sharedStackKey, d = this.getBarWidth(), h = this.services.cartesianScales.getDomainValue(u) - d / 2, p = h + d, f = this.services.cartesianScales.getRangeValue(c[0]);\n      let g = this.services.cartesianScales.getRangeValue(c[1]);\n      if (!this.isOutsideZoomedDomain(h, p)) {\n        if (Math.abs(g - f) > 0 && Math.abs(g - f) > r.bars.dividerSize) {\n          const m = c[0] < 0 && c[1] <= 0;\n          m && a.length > 1 ? this.services.cartesianScales.getOrientation() === Ft.VERTICAL ? g += c[1] === 0 ? 2 : 1 : g -= 1 : m || (this.services.cartesianScales.getOrientation() === Ft.VERTICAL ? g += 1 : g -= 1);\n        }\n        return ae(\n          { x0: h, x1: p, y0: f, y1: g },\n          this.services.cartesianScales.getOrientation()\n        );\n      }\n    }).attr("opacity", 1).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (c) => c[1] - c[0]), this.addEventListeners();\n  }\n  addEventListeners() {\n    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this;\n    this.parent.selectAll("path.bar").on("mouseover", function(i, s) {\n      const a = I(this);\n      a.classed("hovered", !0), r.services.events.dispatchEvent(T.Bar.BAR_MOUSEOVER, {\n        event: i,\n        element: a,\n        datum: s\n      });\n      let o = r.model.getDisplayData(r.configs.groups).find((l) => {\n        const c = r.services.cartesianScales.getDomainIdentifier(l), u = r.services.cartesianScales.getRangeIdentifier(l);\n        return l[u] === s.data[s[n]] && l[c].toString() === s.data.sharedStackKey && l[n] === s[n];\n      });\n      if (o === void 0) {\n        const l = r.services.cartesianScales.getDomainIdentifier(), c = r.services.cartesianScales.getRangeIdentifier();\n        o = {\n          [l]: s.data.sharedStackKey,\n          [c]: s.data[s[n]],\n          [n]: s[n]\n        };\n      }\n      r.services.events.dispatchEvent(T.Tooltip.SHOW, {\n        event: i,\n        hoveredElement: a,\n        data: [o]\n      });\n    }).on("mousemove", function(i, s) {\n      const a = I(this);\n      r.services.events.dispatchEvent(T.Bar.BAR_MOUSEMOVE, {\n        event: i,\n        element: a,\n        datum: s\n      }), r.services.events.dispatchEvent(T.Tooltip.MOVE, {\n        event: i\n      });\n    }).on("click", function(i, s) {\n      r.services.events.dispatchEvent(T.Bar.BAR_CLICK, {\n        event: i,\n        element: I(this),\n        datum: s\n      });\n    }).on("mouseout", function(i, s) {\n      const a = I(this);\n      a.classed("hovered", !1), r.services.events.dispatchEvent(T.Bar.BAR_MOUSEOUT, {\n        event: i,\n        element: a,\n        datum: s\n      }), r.services.events.dispatchEvent(T.Tooltip.HIDE, {\n        hoveredElement: a\n      });\n    });\n  }\n  getBarWidth() {\n    const t = this.getOptions();\n    if (y(t, "bars", "width"))\n      return t.bars.width;\n    const n = this.services.cartesianScales.getMainXScale(), r = N.getSVGElementSize(this.parent, {\n      useAttrs: !0\n    }).width, i = this.model.getStackKeys().length, s = y(t, "bars", "spacingFactor");\n    return n.step ? Math.min(t.bars.maxWidth, n.step() / 2) : Math.min(t.bars.maxWidth, r * s / i);\n  }\n  destroy() {\n    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);\n    const t = this.services.events;\n    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n}\nclass Av extends nn {\n  constructor() {\n    super(...arguments), this.type = "scatter-stacked", this.renderType = rt.SVG;\n  }\n  render(t) {\n    if (!y(this.getOptions(), "points", "enabled"))\n      return;\n    const n = this.getComponentContainer({ ariaLabel: "scatter points", withinChartClip: !0 }), r = this.getOptions(), { groupMapsTo: i } = r.data, s = Object.keys(r.axes).some((u) => r.axes[u].percentage), a = this.model.getStackedData({\n      groups: this.configs.groups,\n      percentage: s\n    }), o = n.selectAll("g.dots").data(a, (u) => y(u, 0, i));\n    o.exit().attr("opacity", 0).remove();\n    const l = o.enter().append("g").classed("dots", !0).attr("role", ht.GROUP).merge(o).selectAll("circle.dot").data((u) => u);\n    l.exit().attr("opacity", 0).remove();\n    const c = l.enter().append("circle").classed("dot", !0).attr("opacity", 0).merge(l).datum((u) => {\n      const d = u[i], h = this.services.cartesianScales.getDomainIdentifier(u), p = this.services.cartesianScales.getRangeIdentifier(u);\n      return {\n        [i]: d,\n        [h]: u.data.sharedStackKey,\n        [p]: u[1]\n      };\n    });\n    this.styleCircles(c, t), this.addEventListeners();\n  }\n  getTooltipData(t, n) {\n    const r = this.getOptions(), { groupMapsTo: i } = r.data, s = Object.keys(r.axes).some((l) => r.axes[l].percentage), a = this.model.getStackedData({\n      groups: this.configs.groups,\n      percentage: s\n    }), o = [];\n    return a.forEach((l, c) => {\n      l.forEach((u, d) => {\n        const h = u[i], p = u.data.sharedStackKey;\n        let f = u.data[h];\n        const g = u[1], m = this.services.cartesianScales.getDomainIdentifier(u), v = this.services.cartesianScales.getRangeIdentifier(u);\n        f != null && t === this.services.cartesianScales.getDomainValue(p) && n === this.services.cartesianScales.getRangeValue(g) && (s && (f = this.model.getStackedData({\n          groups: this.configs.groups\n        })[c][d].data[h]), f !== null && o.push({\n          [i]: h,\n          [m]: p,\n          [v]: f\n        }));\n      });\n    }), this.model.getDisplayData(this.configs.groups).filter((l) => {\n      const c = this.services.cartesianScales.getDomainIdentifier(l), u = this.services.cartesianScales.getRangeIdentifier(l);\n      return o.find((d) => d[i] == l[i] && d[c] == l[c] && d[u] == l[u]) !== void 0;\n    });\n  }\n}\nconst Si = 6;\nclass FD extends mt {\n  constructor() {\n    super(...arguments), this.type = "tree", this.renderType = rt.SVG;\n  }\n  getLongestLabel(t) {\n    let n = "";\n    return t.forEach((r) => {\n      const i = r.children ? this.getLongestLabel(r.children) : "";\n      (i.length > n.length || r.name.length > n.length) && (n = i.length > r.name.length ? i : r.name);\n    }), n;\n  }\n  getMockLabelWidth(t, n) {\n    const r = t.append("text").attr("dy", "0.31em").attr("x", 0).attr("text-anchor", "end").text(n), { width: i } = N.getSVGElementSize(r.node(), {\n      useBBox: !0\n    });\n    return r.remove(), i;\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(t = !0) {\n    const n = this.getComponentContainer({\n      ariaLabel: "tree diagram"\n    });\n    n.html("");\n    const { width: r, height: i } = N.getSVGElementSize(this.parent, {\n      useAttrs: !0\n    });\n    if (r < 1 || i < 1)\n      return;\n    const s = this.model.getOptions(), a = this.model.getDisplayData(), o = y(s, "tree", "rootTitle") || "Tree", l = this.getMockLabelWidth(n, o), c = this.getLongestLabel(a), u = this.getMockLabelWidth(n, c), d = {\n      left: l > 0 ? l + Si : 30 - Si\n    }, h = ys({\n      name: o,\n      children: a\n    }), p = 10, f = r / 6, g = (S) => {\n      const M = h.descendants().reverse(), D = h.links();\n      let A = h, R = h;\n      h.eachBefore((k) => {\n        k.x < A.x && (A = k), k.x > R.x && (R = k);\n      });\n      const $ = R.x - A.x, H = n.transition().call(\n        (k) => this.services.transitions.setupTransition({\n          transition: k,\n          name: "tree-update-viewbox",\n          animate: !0\n        })\n      ).attr("viewBox", [-d.left, A.x, r, $].join(" ")), P = b.selectAll("g").data(M, (k) => k.id), B = this, O = P.enter().append("g").attr("transform", () => `translate(${S.y0},${S.x0})`).attr(\n        "class",\n        (k) => k.depth !== 0 && k.children && k.children.length > 0 ? "clickable" : null\n      ).on("mouseover", function(k, U) {\n        B.services.events.dispatchEvent(T.Tree.NODE_MOUSEOVER, {\n          event: k,\n          element: I(this),\n          datum: U\n        });\n      }).on("click", function(k, U) {\n        U.depth !== 0 && (U.children = U.children ? null : U._children, g(U)), B.services.events.dispatchEvent(T.Tree.NODE_CLICK, {\n          event: k,\n          element: I(this),\n          datum: U\n        });\n      }).on("mouseout", function(k, U) {\n        B.services.events.dispatchEvent(T.Tree.NODE_MOUSEOUT, {\n          event: k,\n          element: I(this),\n          datum: U\n        });\n      });\n      O.append("circle").attr("r", 2.5).attr("class", (k) => k._children ? "parent" : "child").attr("stroke-width", 10), O.append("text").attr("dy", "0.31em").attr("x", (k) => k._children ? -6 : Si).attr("text-anchor", (k) => k._children ? "end" : "start").text((k) => k.data.name).clone(!0).attr("class", "text-stroke").lower(), P.merge(O).transition(H).attr("transform", (k) => `translate(${k.y},${k.x})`).attr("fill-opacity", 1).attr("stroke-opacity", 1), P.exit().transition(H).remove().attr("transform", () => `translate(${S.y},${S.x})`).attr("fill-opacity", 0).attr("stroke-opacity", 0);\n      const w = E.selectAll("path").data(D, (k) => k.target.id), L = w.enter().append("path").attr("d", () => {\n        const k = { x: S.x0, y: S.y0 };\n        return _({ source: k, target: k });\n      });\n      w.merge(L).transition(H).attr("d", _), w.exit().transition(H).remove().attr("d", () => {\n        const k = { x: S.x, y: S.y };\n        return _({ source: k, target: k });\n      }), h.eachBefore((k) => {\n        k.x0 = k.x, k.y0 = k.y;\n      });\n    }, m = h.descendants(), v = m[m.length - 1].depth, x = y(s, "tree", "type") === pc.DENDROGRAM ? lL().size([\n      i,\n      r - u - v * Si - l\n    ]) : XL().nodeSize([p, f]).size([\n      i,\n      r - u - v * Si - l\n    ]), _ = yk().x((S) => S.y).y((S) => S.x);\n    h.x0 = f / 2, h.y0 = 0, h.descendants().forEach((S, M) => {\n      S.id = M, S._children = S.children;\n    }), x(h), n.attr("viewBox", [-d.left, -0, r, p]).style("user-select", "none");\n    const E = n.append("g").attr("class", "links"), b = n.append("g").attr("class", "nodes");\n    g(h);\n  }\n}\nvar jD = "#000000", WD = "#ffffff", qD = "#fcf4d6", YD = "#fddc69", XD = "#f1c21b", ZD = "#d2a106", KD = "#b28600", QD = "#8e6a00", JD = "#684e00", tR = "#483700", eR = "#302400", nR = "#1c1500", rR = {\n  10: qD,\n  20: YD,\n  30: XD,\n  40: ZD,\n  50: KD,\n  60: QD,\n  70: JD,\n  80: tR,\n  90: eR,\n  100: nR\n}, iR = "#fff2e8", sR = "#ffd9be", aR = "#ffb784", oR = "#ff832b", lR = "#eb6200", cR = "#ba4e00", uR = "#8a3800", hR = "#5e2900", dR = "#3e1a00", pR = "#231000", fR = {\n  10: iR,\n  20: sR,\n  30: aR,\n  40: oR,\n  50: lR,\n  60: cR,\n  70: uR,\n  80: hR,\n  90: dR,\n  100: pR\n}, mR = "#fff1f1", gR = "#ffd7d9", vR = "#ffb3b8", yR = "#ff8389", xR = "#fa4d56", bR = "#da1e28", _R = "#a2191f", ER = "#750e13", OR = "#520408", SR = "#2d0709", TR = {\n  10: mR,\n  20: gR,\n  30: vR,\n  40: yR,\n  50: xR,\n  60: bR,\n  70: _R,\n  80: ER,\n  90: OR,\n  100: SR\n}, wR = "#fff0f7", $R = "#ffd6e8", MR = "#ffafd2", CR = "#ff7eb6", AR = "#ee5396", LR = "#d02670", kR = "#9f1853", DR = "#740937", RR = "#510224", IR = "#2a0a18", NR = {\n  10: wR,\n  20: $R,\n  30: MR,\n  40: CR,\n  50: AR,\n  60: LR,\n  70: kR,\n  80: DR,\n  90: RR,\n  100: IR\n}, PR = "#f6f2ff", UR = "#e8daff", BR = "#d4bbff", HR = "#be95ff", VR = "#a56eff", GR = "#8a3ffc", zR = "#6929c4", FR = "#491d8b", jR = "#31135e", WR = "#1c0f30", qR = {\n  10: PR,\n  20: UR,\n  30: BR,\n  40: HR,\n  50: VR,\n  60: GR,\n  70: zR,\n  80: FR,\n  90: jR,\n  100: WR\n}, YR = "#edf5ff", XR = "#d0e2ff", ZR = "#a6c8ff", KR = "#78a9ff", QR = "#4589ff", JR = "#0f62fe", tI = "#0043ce", eI = "#002d9c", nI = "#001d6c", rI = "#001141", iI = {\n  10: YR,\n  20: XR,\n  30: ZR,\n  40: KR,\n  50: QR,\n  60: JR,\n  70: tI,\n  80: eI,\n  90: nI,\n  100: rI\n}, sI = "#e5f6ff", aI = "#bae6ff", oI = "#82cfff", lI = "#33b1ff", cI = "#1192e8", uI = "#0072c3", hI = "#00539a", dI = "#003a6d", pI = "#012749", fI = "#061727", mI = {\n  10: sI,\n  20: aI,\n  30: oI,\n  40: lI,\n  50: cI,\n  60: uI,\n  70: hI,\n  80: dI,\n  90: pI,\n  100: fI\n}, gI = "#d9fbfb", vI = "#9ef0f0", yI = "#3ddbd9", xI = "#08bdba", bI = "#009d9a", _I = "#007d79", EI = "#005d5d", OI = "#004144", SI = "#022b30", TI = "#081a1c", wI = {\n  10: gI,\n  20: vI,\n  30: yI,\n  40: xI,\n  50: bI,\n  60: _I,\n  70: EI,\n  80: OI,\n  90: SI,\n  100: TI\n}, $I = "#defbe6", MI = "#a7f0ba", CI = "#6fdc8c", AI = "#42be65", LI = "#24a148", kI = "#198038", DI = "#0e6027", RI = "#044317", II = "#022d0d", NI = "#071908", PI = {\n  10: $I,\n  20: MI,\n  30: CI,\n  40: AI,\n  50: LI,\n  60: kI,\n  70: DI,\n  80: RI,\n  90: II,\n  100: NI\n}, UI = "#f2f4f8", BI = "#dde1e6", HI = "#c1c7cd", VI = "#a2a9b0", GI = "#878d96", zI = "#697077", FI = "#4d5358", jI = "#343a3f", WI = "#21272a", qI = "#121619", YI = {\n  10: UI,\n  20: BI,\n  30: HI,\n  40: VI,\n  50: GI,\n  60: zI,\n  70: FI,\n  80: jI,\n  90: WI,\n  100: qI\n}, XI = "#f4f4f4", ZI = "#e0e0e0", KI = "#c6c6c6", QI = "#a8a8a8", JI = "#8d8d8d", tN = "#6f6f6f", eN = "#525252", nN = "#393939", rN = "#262626", iN = "#161616", sN = {\n  10: XI,\n  20: ZI,\n  30: KI,\n  40: QI,\n  50: JI,\n  60: tN,\n  70: eN,\n  80: nN,\n  90: rN,\n  100: iN\n}, aN = "#f7f3f2", oN = "#e5e0df", lN = "#cac5c4", cN = "#ada8a8", uN = "#8f8b8b", hN = "#726e6e", dN = "#565151", pN = "#3c3838", fN = "#272525", mN = "#171414", gN = {\n  10: aN,\n  20: oN,\n  30: lN,\n  40: cN,\n  50: uN,\n  60: hN,\n  70: dN,\n  80: pN,\n  90: fN,\n  100: mN\n}, vp = {\n  black: {\n    100: jD\n  },\n  blue: iI,\n  coolGray: YI,\n  cyan: mI,\n  gray: sN,\n  green: PI,\n  magenta: NR,\n  orange: fR,\n  purple: qR,\n  red: TR,\n  teal: wI,\n  warmGray: gN,\n  white: {\n    0: WD\n  },\n  yellow: rR\n};\nconst vN = (e) => {\n  if (!e)\n    return null;\n  for (const t of Object.keys(vp)) {\n    const n = vp[t];\n    for (const r of Object.keys(n))\n      if (n[+r] === e)\n        return r;\n  }\n  return null;\n}, yp = function(e) {\n  const t = I(this.parentNode).select("rect.leaf"), n = e.backgroundColor ?? getComputedStyle(t.node(), null).getPropertyValue("fill"), r = Tn(n);\n  let i;\n  if (r && (i = vN(r ? r.hex() : null)), i == null) {\n    const s = lm(r).l;\n    i = Math.abs(s * 100 - 100);\n  }\n  return i > 50 ? "white" : "black";\n};\nlet yN = 0;\nclass xN extends mt {\n  constructor() {\n    super(...arguments), this.type = "treemap", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {\n      const { hoveredElement: n } = t.detail;\n      this.parent.selectAll("g[data-name=\'leaf\']").transition("legend-hover-treemap").call(\n        (r) => this.services.transitions.setupTransition({\n          transition: r,\n          name: "legend-hover-treemap"\n        })\n      ).attr(\n        "opacity",\n        (r) => r.parent.data.name === n.datum().name ? 1 : 0.3\n      );\n    }, this.handleLegendMouseOut = () => {\n      this.parent.selectAll("g[data-name=\'leaf\']").transition("legend-mouseout-treemap").call(\n        (t) => this.services.transitions.setupTransition({\n          transition: t,\n          name: "legend-mouseout-treemap"\n        })\n      ).attr("opacity", 1);\n    };\n  }\n  init() {\n    const { events: t } = this.services;\n    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n  render(t = !0) {\n    const n = this.getComponentContainer({\n      ariaLabel: "treemap"\n    });\n    this.model.getData();\n    const r = this.model.getDisplayData(), i = this.model.getOptions(), s = y(window, "location"), { width: a, height: o } = N.getSVGElementSize(n, {\n      useAttrs: !0\n    }), l = ys({\n      name: i.title || "Treemap",\n      children: r\n    }).sum((p) => p.value).sort((p, f) => f.value - p.value), c = tk().size([a, o]).paddingInner(1).paddingOuter(0).round(!0)(\n      l\n    ), u = n.selectAll("g[data-name=\'leaf\']").data(c.leaves(), (p) => p.data.name);\n    u.exit().attr("opacity", 0).remove();\n    const d = u.enter().append("g").attr("data-name", "leaf").attr("data-uid", () => yN++).merge(u);\n    d.attr("data-name", "leaf").transition().call(\n      (p) => this.services.transitions.setupTransition({\n        transition: p,\n        name: "treemap-group-update",\n        animate: t\n      })\n    ).attr("transform", (p) => `translate(${p.x0},${p.y0})`);\n    const h = d.selectAll("rect.leaf").data((p) => [p]);\n    h.exit().attr("width", 0).attr("height", 0).remove(), h.enter().append("rect").classed("leaf", !0).merge(h).attr("width", 0).attr("height", 0).attr("id", function() {\n      const p = I(this.parentNode).attr("data-uid");\n      return `${i.style.prefix}-leaf-${p}`;\n    }).attr("class", (p) => {\n      for (; p.depth > 1; ) p = p.parent;\n      return this.model.getColorClassName({\n        classNameTypes: [it.FILL],\n        dataGroupName: p.data.name,\n        originalClassName: "leaf"\n      });\n    }).transition().call(\n      (p) => this.services.transitions.setupTransition({\n        transition: p,\n        name: "treemap-leaf-update-enter",\n        animate: t\n      })\n    ).attr("width", (p) => p.x1 - p.x0).attr("height", (p) => p.y1 - p.y0).style("fill", (p) => {\n      for (; p.depth > 1; ) p = p.parent;\n      return this.model.getFillColor(p.data.name, null, p.data);\n    }), d.selectAll("clipPath").data(\n      (p) => p.data.showLabel !== !0 ? [] : [1],\n      (p) => p\n    ).join(\n      (p) => p.append("clipPath").attr("id", function() {\n        const f = I(this.parentNode).attr("data-uid");\n        return `${i.style.prefix}-clip-${f}`;\n      }).append("use").attr("xlink:href", function() {\n        const f = I(this.parentNode.parentNode).attr("data-uid"), g = `${i.style.prefix}-leaf-${f}`;\n        return new URL(`#${g}`, s) + "";\n      }),\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      (p) => null,\n      (p) => p.remove()\n    ), d.selectAll("text").data(\n      (p) => {\n        if (p.data.showLabel !== !0)\n          return [];\n        let f = p;\n        for (; f.depth > 1; ) f = f.parent;\n        return [\n          {\n            text: p.data.name,\n            backgroundColor: this.model.getFillColor(f.data.name)\n          }\n        ];\n      },\n      (p) => p\n    ).join(\n      (p) => {\n        const f = p.append("text").text((g) => g.text).style("fill", yp).attr("x", 7).attr("y", 18);\n        return s && f.attr("clip-path", function() {\n          const g = I(this.parentNode).attr("data-uid"), m = `${i.style.prefix}-clip-${g}`;\n          return `url(${new URL(`#${m}`, s) + ""})`;\n        }), f;\n      },\n      (p) => p.text((f) => f.text).style("fill", yp),\n      (p) => p.remove()\n    ), this.addEventListeners();\n  }\n  addEventListeners() {\n    const t = this;\n    this.parent.selectAll("rect.leaf").on("mouseover", function(n, r) {\n      const i = I(this);\n      let s = getComputedStyle(this, null).getPropertyValue("fill"), a = r;\n      for (; a.depth > 1; ) a = a.parent;\n      i.transition("graph_element_mouseover_fill_update").call(\n        (o) => t.services.transitions.setupTransition({\n          transition: o,\n          name: "graph_element_mouseover_fill_update"\n        })\n      ).style("fill", (o) => {\n        const l = t.model.getFillColor(o.parent.data.name, null, o.data);\n        return l && (s = l), Tn(s).darker(0.7).toString();\n      }), t.services.events.dispatchEvent(T.Tooltip.SHOW, {\n        event: n,\n        hoveredElement: i,\n        items: [\n          {\n            color: s,\n            label: a.data.name,\n            bold: !0\n          },\n          {\n            label: r.data.name,\n            value: r.data.value\n          }\n        ]\n      }), t.services.events.dispatchEvent(T.Treemap.LEAF_MOUSEOVER, {\n        event: n,\n        element: i,\n        datum: r\n      });\n    }).on("mousemove", function(n, r) {\n      const i = I(this);\n      t.services.events.dispatchEvent(T.Treemap.LEAF_MOUSEMOVE, {\n        event: n,\n        element: i,\n        datum: r\n      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {\n        event: n\n      });\n    }).on("click", function(n, r) {\n      t.services.events.dispatchEvent(T.Treemap.LEAF_CLICK, {\n        event: n,\n        element: I(this),\n        datum: r\n      });\n    }).on("mouseout", function(n, r) {\n      const i = I(this);\n      i.classed("hovered", !1);\n      let s = r;\n      for (; s.depth > 1; ) s = s.parent;\n      i.transition().call(\n        (a) => t.services.transitions.setupTransition({\n          transition: a,\n          name: "graph_element_mouseout_fill_update"\n        })\n      ).style("fill", (a) => t.model.getFillColor(a.parent.data.name, null, a.data)), t.services.events.dispatchEvent(T.Treemap.LEAF_MOUSEOUT, {\n        event: n,\n        element: i,\n        datum: r\n      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {\n        hoveredElement: i\n      });\n    });\n  }\n}\nfunction bN(e) {\n  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;\n}\nfunction _N(e) {\n  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;\n  var t = e.default;\n  if (typeof t == "function") {\n    var n = function r() {\n      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);\n    };\n    n.prototype = t.prototype;\n  } else n = {};\n  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {\n    var i = Object.getOwnPropertyDescriptor(e, r);\n    Object.defineProperty(n, r, i.get ? i : {\n      enumerable: !0,\n      get: function() {\n        return e[r];\n      }\n    });\n  }), n;\n}\nvar EN = { value: function() {\n} };\nfunction Lv() {\n  for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {\n    if (!(r = arguments[e] + "") || r in n || /[\\s.]/.test(r)) throw new Error("illegal type: " + r);\n    n[r] = [];\n  }\n  return new sa(n);\n}\nfunction sa(e) {\n  this._ = e;\n}\nfunction ON(e, t) {\n  return e.trim().split(/^|\\s+/).map(function(n) {\n    var r = "", i = n.indexOf(".");\n    if (i >= 0 && (r = n.slice(i + 1), n = n.slice(0, i)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);\n    return { type: n, name: r };\n  });\n}\nsa.prototype = Lv.prototype = {\n  constructor: sa,\n  on: function(e, t) {\n    var n = this._, r = ON(e + "", n), i, s = -1, a = r.length;\n    if (arguments.length < 2) {\n      for (; ++s < a; ) if ((i = (e = r[s]).type) && (i = SN(n[i], e.name))) return i;\n      return;\n    }\n    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);\n    for (; ++s < a; )\n      if (i = (e = r[s]).type) n[i] = xp(n[i], e.name, t);\n      else if (t == null) for (i in n) n[i] = xp(n[i], e.name, null);\n    return this;\n  },\n  copy: function() {\n    var e = {}, t = this._;\n    for (var n in t) e[n] = t[n].slice();\n    return new sa(e);\n  },\n  call: function(e, t) {\n    if ((i = arguments.length - 2) > 0) for (var n = new Array(i), r = 0, i, s; r < i; ++r) n[r] = arguments[r + 2];\n    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);\n    for (s = this._[e], r = 0, i = s.length; r < i; ++r) s[r].value.apply(t, n);\n  },\n  apply: function(e, t, n) {\n    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);\n    for (var r = this._[e], i = 0, s = r.length; i < s; ++i) r[i].value.apply(t, n);\n  }\n};\nfunction SN(e, t) {\n  for (var n = 0, r = e.length, i; n < r; ++n)\n    if ((i = e[n]).name === t)\n      return i.value;\n}\nfunction xp(e, t, n) {\n  for (var r = 0, i = e.length; r < i; ++r)\n    if (e[r].name === t) {\n      e[r] = EN, e = e.slice(0, r).concat(e.slice(r + 1));\n      break;\n    }\n  return n != null && e.push({ name: t, value: n }), e;\n}\nconst TN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  dispatch: Lv\n}, Symbol.toStringTag, { value: "Module" })), wN = /* @__PURE__ */ _N(TN);\nvar ul, bp;\nfunction $N() {\n  if (bp) return ul;\n  bp = 1;\n  const e = wN.dispatch, t = Math.PI / 180, n = {\n    archimedean: g,\n    rectangular: m\n  }, r = 64, i = 2048;\n  ul = function() {\n    var E = [256, 256], b = s, S = a, M = l, D = o, A = o, R = c, $ = u, H = g, P = [], B = 1 / 0, O = e("word", "end"), w = null, L = Math.random, k = {}, U = x;\n    k.canvas = function(F) {\n      return arguments.length ? (U = _(F), k) : U;\n    }, k.start = function() {\n      var F = Z(U()), Y = v((E[0] >> 5) * E[1]), ot = null, Q = P.length, q = -1, tt = [], lt = P.map(function(W, X) {\n        return W.text = b.call(this, W, X), W.font = S.call(this, W, X), W.style = D.call(this, W, X), W.weight = A.call(this, W, X), W.rotate = R.call(this, W, X), W.size = ~~M.call(this, W, X), W.padding = $.call(this, W, X), W;\n      }).sort(function(W, X) {\n        return X.size - W.size;\n      });\n      return w && clearInterval(w), w = setInterval(z, 0), z(), k;\n      function z() {\n        for (var W = Date.now(); Date.now() - W < B && ++q < Q && w; ) {\n          var X = lt[q];\n          X.x = E[0] * (L() + 0.5) >> 1, X.y = E[1] * (L() + 0.5) >> 1, d(F, X, lt, q), X.hasText && j(Y, X, ot) && (tt.push(X), O.call("word", k, X), ot ? p(ot, X) : ot = [{ x: X.x + X.x0, y: X.y + X.y0 }, { x: X.x + X.x1, y: X.y + X.y1 }], X.x -= E[0] >> 1, X.y -= E[1] >> 1);\n        }\n        q >= Q && (k.stop(), O.call("end", k, tt, ot));\n      }\n    }, k.stop = function() {\n      w && (clearInterval(w), w = null);\n      for (const F of P)\n        delete F.sprite;\n      return k;\n    };\n    function Z(F) {\n      const Y = F.getContext("2d", { willReadFrequently: !0 });\n      F.width = F.height = 1;\n      const ot = Math.sqrt(Y.getImageData(0, 0, 1, 1).data.length >> 2);\n      return F.width = (r << 5) / ot, F.height = i / ot, Y.fillStyle = Y.strokeStyle = "red", { context: Y, ratio: ot };\n    }\n    function j(F, Y, ot) {\n      E[0], E[1];\n      for (var Q = Y.x, q = Y.y, tt = Math.sqrt(E[0] * E[0] + E[1] * E[1]), lt = H(E), z = L() < 0.5 ? 1 : -1, W = -z, X, V, ut; (X = lt(W += z)) && (V = ~~X[0], ut = ~~X[1], !(Math.min(Math.abs(V), Math.abs(ut)) >= tt)); )\n        if (Y.x = Q + V, Y.y = q + ut, !(Y.x + Y.x0 < 0 || Y.y + Y.y0 < 0 || Y.x + Y.x1 > E[0] || Y.y + Y.y1 > E[1]) && (!ot || f(Y, ot)) && !h(Y, F, E[0])) {\n          for (var st = Y.sprite, Dt = Y.width >> 5, Nt = E[0] >> 5, nt = Y.x - (Dt << 4), yt = nt & 127, Se = 32 - yt, ge = Y.y1 - Y.y0, oi = (Y.y + Y.y0) * Nt + (nt >> 5), li, Fn = 0; Fn < ge; Fn++) {\n            li = 0;\n            for (var Ie = 0; Ie <= Dt; Ie++)\n              F[oi + Ie] |= li << Se | (Ie < Dt ? (li = st[Fn * Dt + Ie]) >>> yt : 0);\n            oi += Nt;\n          }\n          return !0;\n        }\n      return !1;\n    }\n    return k.timeInterval = function(F) {\n      return arguments.length ? (B = F ?? 1 / 0, k) : B;\n    }, k.words = function(F) {\n      return arguments.length ? (P = F, k) : P;\n    }, k.size = function(F) {\n      return arguments.length ? (E = [+F[0], +F[1]], k) : E;\n    }, k.font = function(F) {\n      return arguments.length ? (S = _(F), k) : S;\n    }, k.fontStyle = function(F) {\n      return arguments.length ? (D = _(F), k) : D;\n    }, k.fontWeight = function(F) {\n      return arguments.length ? (A = _(F), k) : A;\n    }, k.rotate = function(F) {\n      return arguments.length ? (R = _(F), k) : R;\n    }, k.text = function(F) {\n      return arguments.length ? (b = _(F), k) : b;\n    }, k.spiral = function(F) {\n      return arguments.length ? (H = n[F] || F, k) : H;\n    }, k.fontSize = function(F) {\n      return arguments.length ? (M = _(F), k) : M;\n    }, k.padding = function(F) {\n      return arguments.length ? ($ = _(F), k) : $;\n    }, k.random = function(F) {\n      return arguments.length ? (L = F, k) : L;\n    }, k.on = function() {\n      var F = O.on.apply(O, arguments);\n      return F === O ? k : F;\n    }, k;\n  };\n  function s(E) {\n    return E.text;\n  }\n  function a() {\n    return "serif";\n  }\n  function o() {\n    return "normal";\n  }\n  function l(E) {\n    return Math.sqrt(E.value);\n  }\n  function c() {\n    return (~~(random() * 6) - 3) * 30;\n  }\n  function u() {\n    return 1;\n  }\n  function d(E, b, S, M) {\n    if (!b.sprite) {\n      var D = E.context, A = E.ratio;\n      D.clearRect(0, 0, (r << 5) / A, i / A);\n      var R = 0, $ = 0, H = 0, P = S.length;\n      for (--M; ++M < P; ) {\n        b = S[M], D.save(), D.font = b.style + " " + b.weight + " " + ~~((b.size + 1) / A) + "px " + b.font;\n        const X = D.measureText(b.text), V = -Math.floor(X.width / 2);\n        let ut = (X.width + 1) * A, st = b.size << 1;\n        if (b.rotate) {\n          var B = Math.sin(b.rotate * t), O = Math.cos(b.rotate * t), w = ut * O, L = ut * B, k = st * O, U = st * B;\n          ut = Math.max(Math.abs(w + U), Math.abs(w - U)) + 31 >> 5 << 5, st = ~~Math.max(Math.abs(L + k), Math.abs(L - k));\n        } else\n          ut = ut + 31 >> 5 << 5;\n        if (st > H && (H = st), R + ut >= r << 5 && (R = 0, $ += H, H = 0), $ + st >= i) break;\n        D.translate((R + (ut >> 1)) / A, ($ + (st >> 1)) / A), b.rotate && D.rotate(b.rotate * t), D.fillText(b.text, V, 0), b.padding && (D.lineWidth = 2 * b.padding, D.strokeText(b.text, V, 0)), D.restore(), b.width = ut, b.height = st, b.xoff = R, b.yoff = $, b.x1 = ut >> 1, b.y1 = st >> 1, b.x0 = -b.x1, b.y0 = -b.y1, b.hasText = !0, R += ut;\n      }\n      for (var Z = D.getImageData(0, 0, (r << 5) / A, i / A).data, j = []; --M >= 0; )\n        if (b = S[M], !!b.hasText) {\n          for (var F = b.width, Y = F >> 5, ot = b.y1 - b.y0, Q = 0; Q < ot * Y; Q++) j[Q] = 0;\n          if (R = b.xoff, R == null) return;\n          $ = b.yoff;\n          for (var q = 0, tt = -1, lt = 0; lt < ot; lt++) {\n            for (var Q = 0; Q < F; Q++) {\n              var z = Y * lt + (Q >> 5), W = Z[($ + lt) * (r << 5) + (R + Q) << 2] ? 1 << 31 - Q % 32 : 0;\n              j[z] |= W, q |= W;\n            }\n            q ? tt = lt : (b.y0++, ot--, lt--, $++);\n          }\n          b.y1 = b.y0 + tt, b.sprite = j.slice(0, (b.y1 - b.y0) * Y);\n        }\n    }\n  }\n  function h(E, b, S) {\n    S >>= 5;\n    for (var M = E.sprite, D = E.width >> 5, A = E.x - (D << 4), R = A & 127, $ = 32 - R, H = E.y1 - E.y0, P = (E.y + E.y0) * S + (A >> 5), B, O = 0; O < H; O++) {\n      B = 0;\n      for (var w = 0; w <= D; w++)\n        if ((B << $ | (w < D ? (B = M[O * D + w]) >>> R : 0)) & b[P + w]) return !0;\n      P += S;\n    }\n    return !1;\n  }\n  function p(E, b) {\n    var S = E[0], M = E[1];\n    b.x + b.x0 < S.x && (S.x = b.x + b.x0), b.y + b.y0 < S.y && (S.y = b.y + b.y0), b.x + b.x1 > M.x && (M.x = b.x + b.x1), b.y + b.y1 > M.y && (M.y = b.y + b.y1);\n  }\n  function f(E, b) {\n    return E.x + E.x1 > b[0].x && E.x + E.x0 < b[1].x && E.y + E.y1 > b[0].y && E.y + E.y0 < b[1].y;\n  }\n  function g(E) {\n    var b = E[0] / E[1];\n    return function(S) {\n      return [b * (S *= 0.1) * Math.cos(S), S * Math.sin(S)];\n    };\n  }\n  function m(E) {\n    var b = 4, S = b * E[0] / E[1], M = 0, D = 0;\n    return function(A) {\n      var R = A < 0 ? -1 : 1;\n      switch (Math.sqrt(1 + 4 * R * A) - R & 3) {\n        case 0:\n          M += S;\n          break;\n        case 1:\n          D += b;\n          break;\n        case 2:\n          M -= S;\n          break;\n        default:\n          D -= b;\n          break;\n      }\n      return [M, D];\n    };\n  }\n  function v(E) {\n    for (var b = [], S = -1; ++S < E; ) b[S] = 0;\n    return b;\n  }\n  function x() {\n    return document.createElement("canvas");\n  }\n  function _(E) {\n    return typeof E == "function" ? E : function() {\n      return E;\n    };\n  }\n  return ul;\n}\nvar MN = $N();\nconst CN = /* @__PURE__ */ bN(MN);\nclass AN extends mt {\n  constructor() {\n    super(...arguments), this.type = "wordcloud", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {\n      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;\n      this.parent.selectAll("text.word").transition("legend-hover-wordcloud").call(\n        (i) => this.services.transitions.setupTransition({\n          transition: i,\n          name: "legend-hover-wordcloud"\n        })\n      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);\n    }, this.handleLegendMouseOut = () => {\n      this.parent.selectAll("text.word").transition("legend-mouseout-wordcloud").call(\n        (t) => this.services.transitions.setupTransition({\n          transition: t,\n          name: "legend-mouseout-wordcloud"\n        })\n      ).attr("opacity", 1);\n    };\n  }\n  init() {\n    const t = this.services.events;\n    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);\n  }\n  render(t = !0) {\n    const n = this, r = this.getComponentContainer({\n      ariaLabel: "word cloud"\n    }).attr("width", "100%").attr("height", "100%"), i = this.model.getDisplayData(), s = this.getFontSizeScale(i), a = this.getOptions(), { fontSizeMapsTo: o, wordMapsTo: l } = a.wordCloud, { groupMapsTo: c } = a.data, { width: u, height: d } = N.getSVGElementSize(r, {\n      useAttrs: !0\n    });\n    if (u === 0 || d === 0)\n      return;\n    const h = CN().size([u, d]).words(\n      i.map(function(f) {\n        const g = f[o];\n        if (typeof f[o] != "number")\n          throw Error(\n            "Badly formatted WordCloud data. `value` should only be an integer or float"\n          );\n        return {\n          [c]: f[c],\n          text: f[l],\n          size: g,\n          value: g\n        };\n      })\n    ).padding(5).rotate(0).fontSize((f) => s(f.size)).on("end", p);\n    h.start();\n    function p(f) {\n      const g = N.appendOrSelect(r, "g.words");\n      g.attr("transform", `translate(${h.size()[0] / 2}, ${h.size()[1] / 2})`);\n      const m = g.selectAll("text").data(f, (v) => `${v[c]}-${v.text}`);\n      m.exit().attr("opacity", 0).remove(), m.enter().append("text").attr("opacity", 0).merge(m).style("font-size", (v) => `${v.size}px`).text(function(v) {\n        return v.text;\n      }).attr(\n        "class",\n        (v) => n.model.getColorClassName({\n          classNameTypes: [it.FILL],\n          dataGroupName: v[c],\n          originalClassName: `word ${v.size > 32 ? "light" : ""}`\n        })\n      ).style("fill", (v) => n.model.getFillColor(v[c], v.text, v)).attr("text-anchor", "middle").transition().call(\n        (v) => n.services.transitions.setupTransition({\n          transition: v,\n          name: "wordcloud-text-update-enter",\n          animate: t\n        })\n      ).attr("transform", (v) => `translate(${v.x}, ${v.y})`).attr("opacity", 1);\n    }\n    this.addEventListeners();\n  }\n  getFontSizeScale(t) {\n    const n = this.getOptions(), { fontSizeMapsTo: r } = n.wordCloud, i = t.map((l) => l[r]).filter((l) => l), s = N.getHTMLElementSize(this.services.domUtils.getMainContainer()), a = i.length > 0, o = a ? ze(i) : [1, 1];\n    return Fe().domain(o).range(a ? n.wordCloud.fontSizeRange(s, t) : [4, 4]);\n  }\n  addEventListeners() {\n    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this, i = ba((s) => {\n      const a = r.parent.selectAll("text.word").transition("wordcloud-word-mouse-highlight").call(\n        (o) => r.services.transitions.setupTransition({\n          transition: o,\n          name: "wordcloud-word-mouse-highlight"\n        })\n      );\n      s === null ? a.attr("opacity", 1) : a.attr("opacity", function() {\n        return s === this ? 1 : 0.3;\n      });\n    }, 6);\n    this.parent.selectAll("text.word").on("mouseover", function(s, a) {\n      const o = this;\n      i(o), r.services.events.dispatchEvent(T.WordCloud.WORD_MOUSEOVER, {\n        event: s,\n        element: I(this),\n        datum: a\n      }), r.services.events.dispatchEvent(T.Tooltip.SHOW, {\n        event: s,\n        hoveredElement: o,\n        items: [\n          {\n            label: t.tooltip.wordLabel,\n            value: a.text\n          },\n          {\n            label: t.tooltip.valueLabel,\n            value: a.value\n          },\n          {\n            label: gt(t, "locale.translations.group") || gt(t, "tooltip.groupLabel") || "Group",\n            value: a[n],\n            class: r.model.getColorClassName({\n              classNameTypes: [it.TOOLTIP],\n              dataGroupName: a[n]\n            })\n          }\n        ]\n      });\n    }).on("mousemove", function(s, a) {\n      const o = I(this);\n      r.services.events.dispatchEvent(T.WordCloud.WORD_MOUSEMOVE, {\n        element: o,\n        datum: a\n      }), r.services.events.dispatchEvent(T.Tooltip.MOVE, {\n        event: s\n      });\n    }).on("click", function(s, a) {\n      r.services.events.dispatchEvent(T.WordCloud.WORD_CLICK, {\n        event: s,\n        element: I(this),\n        datum: a\n      });\n    }).on("mouseout", function(s, a) {\n      const o = I(this);\n      i(null), r.services.events.dispatchEvent(T.WordCloud.WORD_MOUSEOUT, {\n        event: s,\n        element: o,\n        datum: a\n      }), r.services.events.dispatchEvent(T.Tooltip.HIDE, {\n        hoveredElement: o\n      });\n    });\n  }\n}\nclass LN extends mt {\n  constructor() {\n    super(...arguments), this.type = "geo", this.renderType = rt.SVG;\n  }\n  render() {\n    const t = this.getComponentContainer({ withinChartClip: !0 }), { width: n, height: r } = N.getSVGElementSize(t, {\n      useAttrs: !0\n    });\n    if (n < 1 || r < 1)\n      return;\n    const i = this.getProjection(), s = y(this.getOptions(), "geoData"), a = this.model.getCombinedData(), o = {}, l = {};\n    Object.keys(a).forEach((m) => {\n      typeof a[m].value == "number" ? o[m] = a[m] : l[m] = a[m];\n    });\n    const c = OD(s, Object.values(l)), u = bD(s, {\n      // We need to specify that we are converting geometry collections\n      type: "GeometryCollection",\n      geometries: Object.values(o)\n    }), d = i.fitSize([n, r], u), h = RA().projection(d);\n    N.appendOrSelect(t, "g.geo").selectAll("path").data(u.features).join("path").attr("d", h);\n    const p = this.services.domUtils.generateElementIDString("geo-pattern-stripes"), f = N.appendOrSelect(t, "defs");\n    N.appendOrSelect(f, "pattern").attr("id", p).attr("width", 5).attr("height", 10).attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").append("path").classed("pattern-fill", !0).attr(\n      "d",\n      xs()([\n        [0, 0],\n        [0, 10]\n      ])\n    );\n    const g = N.appendOrSelect(t, "g.missing-data");\n    N.appendOrSelect(g, "path").datum(c).attr("d", h).style("fill", `url(#${p})`);\n  }\n  /**\n   * Retrieves the D3 geographic projection based on the options provided.\n   *\n   * This method selects a geographic projection from the available D3 projections\n   * based on the `projection` property in the `thematic` options. If the projection\n   * is not supported or is missing, an error is thrown.\n   *\n   * @returns {d3.GeoProjection} - The D3 geographic projection corresponding to the selected option.\n   * @throws {Error} If the projection is not supported or is missing.\n   */\n  getProjection() {\n    let t = null;\n    switch (y(this.getOptions(), "thematic", "projection")) {\n      // Azimuthal Projections\n      case gn.geoEqualEarth:\n        t = JA();\n        break;\n      // Conic Projections\n      case gn.geoAlbers:\n        t = WA();\n        break;\n      case gn.geoConicEqualArea:\n        t = tv();\n        break;\n      case gn.geoConicEquidistant:\n        t = KA();\n        break;\n      // Cyndrical projections\n      case gn.geoEquirectangular:\n        t = XA();\n        break;\n      case gn.geoMercator:\n        t = qA();\n        break;\n      case gn.geoNaturalEarth1:\n        t = tL();\n        break;\n      default:\n        throw new Error("Projection is not supported.");\n    }\n    return t;\n  }\n}\nclass kN extends LN {\n  constructor() {\n    super(...arguments), this.type = "choropleth";\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(t = !0) {\n    super.render();\n    const n = this.model.getCombinedData(), r = this.getComponentContainer({ ariaLabel: "map", withinChartClip: !0 }), i = y(this.getOptions(), "color"), s = y(i, "gradient", "colors");\n    r.select("g.geo").selectAll("path").classed("border", !0).attr("class", (a) => this.model.getColorClassName({\n      value: n[a.properties.NAME].value,\n      originalClassName: "border"\n    })).attr("style", (a) => s ? `fill: ${this.model.getColorClassName({\n      value: n[a.properties.NAME].value\n    })}` : null), this.addCountryAreaEventListener();\n  }\n  addCountryAreaEventListener() {\n    const t = this, n = this.model.getCombinedData();\n    this.parent.selectAll("path.border").on("mouseover", function(r, i) {\n      const s = I(this);\n      t.services.events.dispatchEvent(Dr.CHOROPLETH_MOUSEOVER, {\n        event: r,\n        element: s,\n        datum: n[i.properties.NAME]\n      }), t.services.events.dispatchEvent(Ii.SHOW, {\n        event: r,\n        hoveredElement: s,\n        items: [\n          {\n            label: i.properties.NAME,\n            value: n[i.properties.NAME].value\n          }\n        ]\n      });\n    }).on("mousemove", function(r, i) {\n      t.services.events.dispatchEvent(Dr.CHOROPLETH_MOUSEMOVE, {\n        event: r,\n        element: I(this),\n        datum: n[i.properties.NAME]\n      }), t.services.events.dispatchEvent(Ii.MOVE, {\n        event: r\n      });\n    }).on("click", function(r, i) {\n      t.services.events.dispatchEvent(Dr.CHOROPLETH_CLICK, {\n        event: r,\n        element: I(this),\n        datum: n[i.properties.NAME]\n      });\n    }).on("mouseout", function(r, i) {\n      const s = I(this);\n      t.services.events.dispatchEvent(Dr.CHOROPLETH_MOUSEOUT, {\n        event: r,\n        element: s,\n        datum: n[i.properties.NAME]\n      }), t.services.events.dispatchEvent(Ii.HIDE, {\n        event: r,\n        hoveredElement: s\n      });\n    });\n  }\n}\nfunction du(e) {\n  var t = e == null ? 0 : e.length;\n  return t ? Ka(e, 1) : [];\n}\nfunction DN(e) {\n  return vf(xf(e, void 0, du), e + "");\n}\nfunction kv(e, t, n) {\n  var r = -1, i = e.length;\n  t < 0 && (t = -t > i ? 0 : i + t), n = n > i ? i : n, n < 0 && (n += i), i = t > n ? 0 : n - t >>> 0, t >>>= 0;\n  for (var s = Array(i); ++r < i; )\n    s[r] = e[r + t];\n  return s;\n}\nfunction RN(e, t) {\n  return t.length < 2 ? e : Oc(e, kv(t, 0, -1));\n}\nfunction IN(e, t) {\n  return t = Za(t, e), e = RN(e, t), e == null || delete e[hs(Wf(t))];\n}\nfunction NN(e) {\n  return $f(e) ? void 0 : e;\n}\nvar PN = 1, UN = 2, BN = 4, HN = DN(function(e, t) {\n  var n = {};\n  if (e == null)\n    return n;\n  var r = !1;\n  t = fc(t, function(s) {\n    return s = Za(s, e), r || (r = s.length > 1), s;\n  }), ri(e, Df(e), n), r && (n = Bi(n, PN | UN | BN, NN));\n  for (var i = t.length; i--; )\n    IN(n, t[i]);\n  return n;\n});\nfunction _p(e) {\n  return Math.log(e);\n}\nfunction Ep(e) {\n  return Math.exp(e);\n}\nfunction VN(e) {\n  return -Math.log(-e);\n}\nfunction GN(e) {\n  return -Math.exp(-e);\n}\nfunction zN(e) {\n  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;\n}\nfunction FN(e) {\n  return e === 10 ? zN : e === Math.E ? Math.exp : (t) => Math.pow(e, t);\n}\nfunction jN(e) {\n  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);\n}\nfunction Op(e) {\n  return (t, n) => -e(-t, n);\n}\nfunction WN(e) {\n  const t = e(_p, Ep), n = t.domain;\n  let r = 10, i, s;\n  function a() {\n    return i = jN(r), s = FN(r), n()[0] < 0 ? (i = Op(i), s = Op(s), e(VN, GN)) : e(_p, Ep), t;\n  }\n  return t.base = function(o) {\n    return arguments.length ? (r = +o, a()) : r;\n  }, t.domain = function(o) {\n    return arguments.length ? (n(o), a()) : n();\n  }, t.ticks = (o) => {\n    const l = n();\n    let c = l[0], u = l[l.length - 1];\n    const d = u < c;\n    d && ([c, u] = [u, c]);\n    let h = i(c), p = i(u), f, g;\n    const m = o == null ? 10 : +o;\n    let v = [];\n    if (!(r % 1) && p - h < m) {\n      if (h = Math.floor(h), p = Math.ceil(p), c > 0) {\n        for (; h <= p; ++h)\n          for (f = 1; f < r; ++f)\n            if (g = h < 0 ? f / s(-h) : f * s(h), !(g < c)) {\n              if (g > u) break;\n              v.push(g);\n            }\n      } else for (; h <= p; ++h)\n        for (f = r - 1; f >= 1; --f)\n          if (g = h > 0 ? f / s(-h) : f * s(h), !(g < c)) {\n            if (g > u) break;\n            v.push(g);\n          }\n      v.length * 2 < m && (v = ca(c, u, m));\n    } else\n      v = ca(h, p, Math.min(p - h, m)).map(s);\n    return d ? v.reverse() : v;\n  }, t.tickFormat = (o, l) => {\n    if (o == null && (o = 10), l == null && (l = r === 10 ? "s" : ","), typeof l != "function" && (!(r % 1) && (l = ts(l)).precision == null && (l.trim = !0), l = Hc(l)), o === 1 / 0) return l;\n    const c = Math.max(1, r * o / t.ticks().length);\n    return (u) => {\n      let d = u / s(Math.round(i(u)));\n      return d * r < r - 0.5 && (d *= r), d <= c ? l(u) : "";\n    };\n  }, t.nice = () => n(qm(n(), {\n    floor: (o) => s(Math.floor(i(o))),\n    ceil: (o) => s(Math.ceil(i(o)))\n  })), t;\n}\nfunction Dv() {\n  const e = WN(Tm()).domain([1, 10]);\n  return e.copy = () => Vc(e, Dv()).base(e.base()), ii.apply(e, arguments), e;\n}\nfunction Ba(e, t, n) {\n  e._context.bezierCurveTo(\n    (2 * e._x0 + e._x1) / 3,\n    (2 * e._y0 + e._y1) / 3,\n    (e._x0 + 2 * e._x1) / 3,\n    (e._y0 + 2 * e._y1) / 3,\n    (e._x0 + 4 * e._x1 + t) / 6,\n    (e._y0 + 4 * e._y1 + n) / 6\n  );\n}\nfunction go(e) {\n  this._context = e;\n}\ngo.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 3:\n        Ba(this, this._x1, this._y1);\n      // falls through\n      case 2:\n        this._context.lineTo(this._x1, this._y1);\n        break;\n    }\n    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;\n  },\n  point: function(e, t) {\n    switch (e = +e, t = +t, this._point) {\n      case 0:\n        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);\n      // falls through\n      default:\n        Ba(this, e, t);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;\n  }\n};\nfunction qN(e) {\n  return new go(e);\n}\nfunction Rv(e) {\n  this._context = e;\n}\nRv.prototype = {\n  areaStart: Hn,\n  areaEnd: Hn,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x2, this._y2), this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);\n        break;\n      }\n    }\n  },\n  point: function(e, t) {\n    switch (e = +e, t = +t, this._point) {\n      case 0:\n        this._point = 1, this._x2 = e, this._y2 = t;\n        break;\n      case 1:\n        this._point = 2, this._x3 = e, this._y3 = t;\n        break;\n      case 2:\n        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);\n        break;\n      default:\n        Ba(this, e, t);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;\n  }\n};\nfunction YN(e) {\n  return new Rv(e);\n}\nfunction Iv(e) {\n  this._context = e;\n}\nIv.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;\n  },\n  lineEnd: function() {\n    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;\n  },\n  point: function(e, t) {\n    switch (e = +e, t = +t, this._point) {\n      case 0:\n        this._point = 1;\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3;\n        var n = (this._x0 + 4 * this._x1 + e) / 6, r = (this._y0 + 4 * this._y1 + t) / 6;\n        this._line ? this._context.lineTo(n, r) : this._context.moveTo(n, r);\n        break;\n      case 3:\n        this._point = 4;\n      // falls through\n      default:\n        Ba(this, e, t);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;\n  }\n};\nfunction XN(e) {\n  return new Iv(e);\n}\nfunction Nv(e, t) {\n  this._basis = new go(e), this._beta = t;\n}\nNv.prototype = {\n  lineStart: function() {\n    this._x = [], this._y = [], this._basis.lineStart();\n  },\n  lineEnd: function() {\n    var e = this._x, t = this._y, n = e.length - 1;\n    if (n > 0)\n      for (var r = e[0], i = t[0], s = e[n] - r, a = t[n] - i, o = -1, l; ++o <= n; )\n        l = o / n, this._basis.point(\n          this._beta * e[o] + (1 - this._beta) * (r + l * s),\n          this._beta * t[o] + (1 - this._beta) * (i + l * a)\n        );\n    this._x = this._y = null, this._basis.lineEnd();\n  },\n  point: function(e, t) {\n    this._x.push(+e), this._y.push(+t);\n  }\n};\nconst ZN = function e(t) {\n  function n(r) {\n    return t === 1 ? new go(r) : new Nv(r, t);\n  }\n  return n.beta = function(r) {\n    return e(+r);\n  }, n;\n}(0.85);\nfunction Ha(e, t, n) {\n  e._context.bezierCurveTo(\n    e._x1 + e._k * (e._x2 - e._x0),\n    e._y1 + e._k * (e._y2 - e._y0),\n    e._x2 + e._k * (e._x1 - t),\n    e._y2 + e._k * (e._y1 - n),\n    e._x2,\n    e._y2\n  );\n}\nfunction pu(e, t) {\n  this._context = e, this._k = (1 - t) / 6;\n}\npu.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2:\n        this._context.lineTo(this._x2, this._y2);\n        break;\n      case 3:\n        Ha(this, this._x1, this._y1);\n        break;\n    }\n    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;\n  },\n  point: function(e, t) {\n    switch (e = +e, t = +t, this._point) {\n      case 0:\n        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);\n        break;\n      case 1:\n        this._point = 2, this._x1 = e, this._y1 = t;\n        break;\n      case 2:\n        this._point = 3;\n      // falls through\n      default:\n        Ha(this, e, t);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;\n  }\n};\nconst KN = function e(t) {\n  function n(r) {\n    return new pu(r, t);\n  }\n  return n.tension = function(r) {\n    return e(+r);\n  }, n;\n}(0);\nfunction fu(e, t) {\n  this._context = e, this._k = (1 - t) / 6;\n}\nfu.prototype = {\n  areaStart: Hn,\n  areaEnd: Hn,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3), this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3), this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(e, t) {\n    switch (e = +e, t = +t, this._point) {\n      case 0:\n        this._point = 1, this._x3 = e, this._y3 = t;\n        break;\n      case 1:\n        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);\n        break;\n      case 2:\n        this._point = 3, this._x5 = e, this._y5 = t;\n        break;\n      default:\n        Ha(this, e, t);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;\n  }\n};\nconst QN = function e(t) {\n  function n(r) {\n    return new fu(r, t);\n  }\n  return n.tension = function(r) {\n    return e(+r);\n  }, n;\n}(0);\nfunction mu(e, t) {\n  this._context = e, this._k = (1 - t) / 6;\n}\nmu.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;\n  },\n  lineEnd: function() {\n    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;\n  },\n  point: function(e, t) {\n    switch (e = +e, t = +t, this._point) {\n      case 0:\n        this._point = 1;\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);\n        break;\n      case 3:\n        this._point = 4;\n      // falls through\n      default:\n        Ha(this, e, t);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;\n  }\n};\nconst JN = function e(t) {\n  function n(r) {\n    return new mu(r, t);\n  }\n  return n.tension = function(r) {\n    return e(+r);\n  }, n;\n}(0);\nfunction gu(e, t, n) {\n  var r = e._x1, i = e._y1, s = e._x2, a = e._y2;\n  if (e._l01_a > ne) {\n    var o = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, l = 3 * e._l01_a * (e._l01_a + e._l12_a);\n    r = (r * o - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / l, i = (i * o - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / l;\n  }\n  if (e._l23_a > ne) {\n    var c = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, u = 3 * e._l23_a * (e._l23_a + e._l12_a);\n    s = (s * c + e._x1 * e._l23_2a - t * e._l12_2a) / u, a = (a * c + e._y1 * e._l23_2a - n * e._l12_2a) / u;\n  }\n  e._context.bezierCurveTo(r, i, s, a, e._x2, e._y2);\n}\nfunction Pv(e, t) {\n  this._context = e, this._alpha = t;\n}\nPv.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2:\n        this._context.lineTo(this._x2, this._y2);\n        break;\n      case 3:\n        this.point(this._x2, this._y2);\n        break;\n    }\n    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;\n  },\n  point: function(e, t) {\n    if (e = +e, t = +t, this._point) {\n      var n = this._x2 - e, r = this._y2 - t;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));\n    }\n    switch (this._point) {\n      case 0:\n        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3;\n      // falls through\n      default:\n        gu(this, e, t);\n        break;\n    }\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;\n  }\n};\nconst tP = function e(t) {\n  function n(r) {\n    return t ? new Pv(r, t) : new pu(r, 0);\n  }\n  return n.alpha = function(r) {\n    return e(+r);\n  }, n;\n}(0.5);\nfunction Uv(e, t) {\n  this._context = e, this._alpha = t;\n}\nUv.prototype = {\n  areaStart: Hn,\n  areaEnd: Hn,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3), this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3), this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(e, t) {\n    if (e = +e, t = +t, this._point) {\n      var n = this._x2 - e, r = this._y2 - t;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));\n    }\n    switch (this._point) {\n      case 0:\n        this._point = 1, this._x3 = e, this._y3 = t;\n        break;\n      case 1:\n        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);\n        break;\n      case 2:\n        this._point = 3, this._x5 = e, this._y5 = t;\n        break;\n      default:\n        gu(this, e, t);\n        break;\n    }\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;\n  }\n};\nconst eP = function e(t) {\n  function n(r) {\n    return t ? new Uv(r, t) : new fu(r, 0);\n  }\n  return n.alpha = function(r) {\n    return e(+r);\n  }, n;\n}(0.5);\nfunction Bv(e, t) {\n  this._context = e, this._alpha = t;\n}\nBv.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;\n  },\n  lineEnd: function() {\n    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;\n  },\n  point: function(e, t) {\n    if (e = +e, t = +t, this._point) {\n      var n = this._x2 - e, r = this._y2 - t;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));\n    }\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);\n        break;\n      case 3:\n        this._point = 4;\n      // falls through\n      default:\n        gu(this, e, t);\n        break;\n    }\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;\n  }\n};\nconst nP = function e(t) {\n  function n(r) {\n    return t ? new Bv(r, t) : new mu(r, 0);\n  }\n  return n.alpha = function(r) {\n    return e(+r);\n  }, n;\n}(0.5);\nfunction Sp(e) {\n  return e < 0 ? -1 : 1;\n}\nfunction Tp(e, t, n) {\n  var r = e._x1 - e._x0, i = t - e._x1, s = (e._y1 - e._y0) / (r || i < 0 && -0), a = (n - e._y1) / (i || r < 0 && -0), o = (s * i + a * r) / (r + i);\n  return (Sp(s) + Sp(a)) * Math.min(Math.abs(s), Math.abs(a), 0.5 * Math.abs(o)) || 0;\n}\nfunction wp(e, t) {\n  var n = e._x1 - e._x0;\n  return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t;\n}\nfunction hl(e, t, n) {\n  var r = e._x0, i = e._y0, s = e._x1, a = e._y1, o = (s - r) / 3;\n  e._context.bezierCurveTo(r + o, i + o * t, s - o, a - o * n, s, a);\n}\nfunction Va(e) {\n  this._context = e;\n}\nVa.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2:\n        this._context.lineTo(this._x1, this._y1);\n        break;\n      case 3:\n        hl(this, this._t0, wp(this, this._t0));\n        break;\n    }\n    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;\n  },\n  point: function(e, t) {\n    var n = NaN;\n    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {\n      switch (this._point) {\n        case 0:\n          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);\n          break;\n        case 1:\n          this._point = 2;\n          break;\n        case 2:\n          this._point = 3, hl(this, wp(this, n = Tp(this, e, t)), n);\n          break;\n        default:\n          hl(this, this._t0, n = Tp(this, e, t));\n          break;\n      }\n      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n;\n    }\n  }\n};\nfunction Hv(e) {\n  this._context = new Vv(e);\n}\n(Hv.prototype = Object.create(Va.prototype)).point = function(e, t) {\n  Va.prototype.point.call(this, t, e);\n};\nfunction Vv(e) {\n  this._context = e;\n}\nVv.prototype = {\n  moveTo: function(e, t) {\n    this._context.moveTo(t, e);\n  },\n  closePath: function() {\n    this._context.closePath();\n  },\n  lineTo: function(e, t) {\n    this._context.lineTo(t, e);\n  },\n  bezierCurveTo: function(e, t, n, r, i, s) {\n    this._context.bezierCurveTo(t, e, r, n, s, i);\n  }\n};\nfunction rP(e) {\n  return new Va(e);\n}\nfunction iP(e) {\n  return new Hv(e);\n}\nfunction Gv(e) {\n  this._context = e;\n}\nGv.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = [], this._y = [];\n  },\n  lineEnd: function() {\n    var e = this._x, t = this._y, n = e.length;\n    if (n)\n      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)\n        this._context.lineTo(e[1], t[1]);\n      else\n        for (var r = $p(e), i = $p(t), s = 0, a = 1; a < n; ++s, ++a)\n          this._context.bezierCurveTo(r[0][s], i[0][s], r[1][s], i[1][s], e[a], t[a]);\n    (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;\n  },\n  point: function(e, t) {\n    this._x.push(+e), this._y.push(+t);\n  }\n};\nfunction $p(e) {\n  var t, n = e.length - 1, r, i = new Array(n), s = new Array(n), a = new Array(n);\n  for (i[0] = 0, s[0] = 2, a[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t) i[t] = 1, s[t] = 4, a[t] = 4 * e[t] + 2 * e[t + 1];\n  for (i[n - 1] = 2, s[n - 1] = 7, a[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t) r = i[t] / s[t - 1], s[t] -= r, a[t] -= r * a[t - 1];\n  for (i[n - 1] = a[n - 1] / s[n - 1], t = n - 2; t >= 0; --t) i[t] = (a[t] - i[t + 1]) / s[t];\n  for (s[n - 1] = (e[n] + i[n - 1]) / 2, t = 0; t < n - 1; ++t) s[t] = 2 * e[t + 1] - i[t + 1];\n  return [i, s];\n}\nfunction sP(e) {\n  return new Gv(e);\n}\nfunction vo(e, t) {\n  this._context = e, this._t = t;\n}\nvo.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = this._y = NaN, this._point = 0;\n  },\n  lineEnd: function() {\n    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);\n  },\n  point: function(e, t) {\n    switch (e = +e, t = +t, this._point) {\n      case 0:\n        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);\n        break;\n      case 1:\n        this._point = 2;\n      // falls through\n      default: {\n        if (this._t <= 0)\n          this._context.lineTo(this._x, t), this._context.lineTo(e, t);\n        else {\n          var n = this._x * (1 - this._t) + e * this._t;\n          this._context.lineTo(n, this._y), this._context.lineTo(n, t);\n        }\n        break;\n      }\n    }\n    this._x = e, this._y = t;\n  }\n};\nfunction aP(e) {\n  return new vo(e, 0.5);\n}\nfunction oP(e) {\n  return new vo(e, 0);\n}\nfunction lP(e) {\n  return new vo(e, 1);\n}\nclass cP extends Dn {\n  /**\n   * focal:  object to zoom into\n   * canvasElements: all the elements to translate and zoom on the chart area\n   * zoomSettings: object containing duration, easing and zoomlevel for the zoom behaviours\n   *  */\n  zoomIn(t, n, r) {\n    let i, s, a;\n    const o = r || Nr;\n    t && (i = t.x, s = t.y, a = 2);\n    const { width: l, height: c } = N.getSVGElementSize(this.services.domUtils.getHolder(), {\n      useClientDimensions: !0\n    });\n    n.transition().duration(o.duration).ease(o.ease).attr(\n      "transform",\n      `translate(${l / 2}, ${c / 2}) scale(${a}) translate(${-i},${-s})`\n    ), this.services.events.dispatchEvent(T.CanvasZoom.CANVAS_ZOOM_IN, {\n      element: I(t)\n    });\n  }\n  zoomOut(t, n) {\n    const r = n || Nr;\n    t.transition().duration(r.duration).ease(r.ease).attr("transform", ""), this.services.events.dispatchEvent(T.CanvasZoom.CANVAS_ZOOM_OUT);\n  }\n}\nclass uP extends Dn {\n  init() {\n    this.documentFragment = document.createDocumentFragment();\n  }\n  addEventListener(t, n) {\n    this.documentFragment.addEventListener(t, n);\n  }\n  removeEventListener(t, n) {\n    this.documentFragment.removeEventListener(t, n);\n  }\n  dispatchEvent(t, n) {\n    let r;\n    n ? r = new CustomEvent(t, {\n      detail: n\n    }) : (r = document.createEvent("Event"), r.initEvent(t, !1, !0)), this.documentFragment.dispatchEvent(r);\n  }\n}\nclass hP extends Dn {\n  constructor(t, n) {\n    super(t, n);\n  }\n  downloadCSV(t, n) {\n    const r = document.createElement("a"), i = "text/csv;encoding:utf-8";\n    if (navigator.msSaveBlob)\n      navigator.msSaveBlob(\n        new Blob([t], {\n          type: i\n        }),\n        n\n      );\n    else if (URL && "download" in r) {\n      const s = URL.createObjectURL(\n        new Blob([t], {\n          type: i\n        })\n      );\n      r.href = s, r.setAttribute("download", n), document.body.appendChild(r), r.click(), document.body.removeChild(r), URL.revokeObjectURL(s);\n    } else\n      location.href = `data:application/octet-stream,${encodeURIComponent(t)}`;\n  }\n  downloadImage(t, n) {\n    const r = document.createElement("a");\n    r.download = n, r.href = t, document.body.appendChild(r), r.click(), document.body.removeChild(r);\n  }\n}\nclass dP extends Dn {\n  constructor() {\n    super(...arguments), this.pendingTransitions = {};\n  }\n  init() {\n    var t;\n    (t = this.services.events) == null || t.addEventListener(T.Model.UPDATE, () => {\n      this.pendingTransitions = {};\n    });\n  }\n  setupTransition({ transition: t, name: n, animate: r }) {\n    return this.pendingTransitions[t._id] = t, t.on("end interrupt cancel", () => {\n      delete this.pendingTransitions[t._id];\n    }), this.model.getOptions().animations === !1 || r === !1 ? t.duration(0) : t.duration(\n      y(Nh, n, "duration") || Nh.default.duration\n    );\n  }\n  getPendingTransitions() {\n    return this.pendingTransitions;\n  }\n}\nfunction Fi(e, t) {\n  const n = +Ht(e) - +Ht(t);\n  return n < 0 ? -1 : n > 0 ? 1 : n;\n}\nfunction pP(e, t, n) {\n  const [r, i] = ur(\n    void 0,\n    e,\n    t\n  );\n  return r.getFullYear() - i.getFullYear();\n}\nfunction fP(e, t, n) {\n  const [r, i] = ur(\n    void 0,\n    e,\n    t\n  ), s = Fi(r, i), a = Math.abs(pP(r, i));\n  r.setFullYear(1584), i.setFullYear(1584);\n  const o = Fi(r, i) === -s, l = s * (a - +o);\n  return l === 0 ? 0 : l;\n}\nfunction vu(e, t, n) {\n  const r = Ht(e, void 0);\n  if (isNaN(t)) return Le(e, NaN);\n  if (!t)\n    return r;\n  const i = r.getDate(), s = Le(e, r.getTime());\n  s.setMonth(r.getMonth() + t + 1, 0);\n  const a = s.getDate();\n  return i >= a ? s : (r.setFullYear(\n    s.getFullYear(),\n    s.getMonth(),\n    i\n  ), r);\n}\nfunction zv(e, t, n) {\n  return vu(e, t * 12);\n}\nfunction mP(e, t, n) {\n  return zv(e, -t);\n}\nfunction gP(e, t, n) {\n  const [r, i] = ur(\n    void 0,\n    e,\n    t\n  ), s = r.getFullYear() - i.getFullYear(), a = r.getMonth() - i.getMonth();\n  return s * 12 + a;\n}\nfunction vP(e, t) {\n  const n = Ht(e, void 0);\n  return n.setHours(23, 59, 59, 999), n;\n}\nfunction yP(e, t) {\n  const n = Ht(e, void 0), r = n.getMonth();\n  return n.setFullYear(n.getFullYear(), r + 1, 0), n.setHours(23, 59, 59, 999), n;\n}\nfunction xP(e, t) {\n  const n = Ht(e, void 0);\n  return +vP(n) == +yP(n);\n}\nfunction bP(e, t, n) {\n  const [r, i, s] = ur(\n    void 0,\n    e,\n    e,\n    t\n  ), a = Fi(i, s), o = Math.abs(\n    gP(i, s)\n  );\n  if (o < 1) return 0;\n  i.getMonth() === 1 && i.getDate() > 27 && i.setDate(30), i.setMonth(i.getMonth() - a * o);\n  let l = Fi(i, s) === -a;\n  xP(r) && o === 1 && Fi(r, s) === 1 && (l = !1);\n  const c = a * (o - +l);\n  return c === 0 ? 0 : c;\n}\nfunction _P(e, t, n) {\n  return vu(e, -t);\n}\nfunction EP(e, t, n) {\n  const [r, i] = ur(\n    void 0,\n    e,\n    t\n  ), s = Mp(r, i), a = Math.abs(\n    Um(r, i)\n  );\n  r.setDate(r.getDate() - s * a);\n  const o = +(Mp(r, i) === -s), l = s * (a - o);\n  return l === 0 ? 0 : l;\n}\nfunction Mp(e, t) {\n  const n = e.getFullYear() - t.getFullYear() || e.getMonth() - t.getMonth() || e.getDate() - t.getDate() || e.getHours() - t.getHours() || e.getMinutes() - t.getMinutes() || e.getSeconds() - t.getSeconds() || e.getMilliseconds() - t.getMilliseconds();\n  return n < 0 ? -1 : n > 0 ? 1 : n;\n}\nfunction Fv(e, t, n) {\n  const r = Ht(e, void 0);\n  return isNaN(t) ? Le(e, NaN) : (t && r.setDate(r.getDate() + t), r);\n}\nfunction OP(e, t, n) {\n  return Fv(e, -t);\n}\nfunction yu(e) {\n  return (t) => {\n    const n = (0, Math.trunc)(t);\n    return n === 0 ? 0 : n;\n  };\n}\nfunction SP(e, t, n) {\n  const [r, i] = ur(\n    void 0,\n    e,\n    t\n  ), s = (+r - +i) / hf;\n  return yu()(s);\n}\nfunction jv(e, t, n) {\n  return Le(e, +Ht(e) + t);\n}\nfunction Wv(e, t, n) {\n  return jv(e, t * hf);\n}\nfunction TP(e, t, n) {\n  return Wv(e, -t);\n}\nfunction qv(e, t) {\n  return +Ht(e) - +Ht(t);\n}\nfunction Cp(e, t, n) {\n  const r = qv(e, t) / uf;\n  return yu()(r);\n}\nfunction cc(e, t, n) {\n  const r = Ht(e, void 0);\n  return r.setTime(r.getTime() + t * uf), r;\n}\nfunction Ap(e, t, n) {\n  return cc(e, -t);\n}\nfunction Lp(e, t, n) {\n  const r = qv(e, t) / 1e3;\n  return yu()(r);\n}\nfunction uc(e, t, n) {\n  return jv(e, t * 1e3);\n}\nfunction kp(e, t, n) {\n  return uc(e, -t);\n}\nclass wP extends Dn {\n  constructor() {\n    super(...arguments), this.scaleTypes = {\n      top: null,\n      right: null,\n      bottom: null,\n      left: null\n    }, this.scales = {\n      // null or function\n      top: null,\n      right: null,\n      bottom: null,\n      left: null\n    };\n  }\n  getDomainAxisPosition({ datum: t = null } = {}) {\n    if (this.dualAxes && t) {\n      const n = this.model.getOptions(), { groupMapsTo: r } = n.data, i = y(n, "axes", this.secondaryDomainAxisPosition), s = t[r];\n      if (i != null && i.correspondingDatasets && i.correspondingDatasets.includes(s))\n        return this.secondaryDomainAxisPosition;\n    }\n    return this.domainAxisPosition;\n  }\n  getRangeAxisPosition({ datum: t = null, groups: n = null } = {}) {\n    if (this.dualAxes) {\n      const r = this.model.getOptions(), { groupMapsTo: i } = r.data, s = y(r, "axes", this.secondaryRangeAxisPosition);\n      let a;\n      if (t !== null ? a = t[i] : n && n.length > 0 && (a = n[0]), s != null && s.correspondingDatasets && s.correspondingDatasets.includes(a))\n        return this.secondaryRangeAxisPosition;\n    }\n    return this.rangeAxisPosition;\n  }\n  getAxisOptions(t) {\n    return y(this.model.getOptions(), "axes", t);\n  }\n  getDomainAxisOptions() {\n    const t = this.getDomainAxisPosition();\n    return this.getAxisOptions(t);\n  }\n  getRangeAxisOptions() {\n    const t = this.getRangeAxisPosition();\n    return this.getAxisOptions(t);\n  }\n  getScaleLabel(t) {\n    return this.getAxisOptions(t).title || (t === G.BOTTOM || t === G.TOP ? "x-value" : "y-value");\n  }\n  getDomainLabel() {\n    return this.getScaleLabel(this.getDomainAxisPosition());\n  }\n  getRangeLabel() {\n    return this.getScaleLabel(this.getRangeAxisPosition());\n  }\n  update() {\n    this.determineAxisDuality(), this.findDomainAndRangeAxes(), this.determineOrientation(), Object.keys(G).map(\n      (t) => G[t]\n    ).forEach((t) => {\n      this.scales[t] = this.createScale(t);\n    });\n  }\n  findDomainAndRangeAxes() {\n    const t = this.findVerticalAxesPositions(), n = this.findHorizontalAxesPositions(), r = this.findDomainAndRangeAxesPositions(\n      t,\n      n\n    );\n    this.domainAxisPosition = r.primaryDomainAxisPosition, this.rangeAxisPosition = r.primaryRangeAxisPosition, this.isDualAxes() && (this.secondaryDomainAxisPosition = r.secondaryDomainAxisPosition, this.secondaryRangeAxisPosition = r.secondaryRangeAxisPosition);\n  }\n  determineOrientation() {\n    (this.rangeAxisPosition === G.LEFT || this.rangeAxisPosition === G.RIGHT) && (this.domainAxisPosition === G.BOTTOM || this.domainAxisPosition === G.TOP) ? this.orientation = Ft.VERTICAL : this.orientation = Ft.HORIZONTAL;\n  }\n  isDualAxes() {\n    return this.dualAxes;\n  }\n  // if any of the axes objects have correspondingDatasets [] asserted we flag the chart as dual axes\n  // it does not count as dual axes if it just has another axis turned on but is not actually using it to map a dataset\n  determineAxisDuality() {\n    var t, n, r, i;\n    const s = this.model.getOptions(), a = y(s, "axes");\n    ((t = a[G.LEFT]) != null && t.correspondingDatasets && a[G.RIGHT] || (n = a[G.RIGHT]) != null && n.correspondingDatasets && a[G.LEFT] || (r = a[G.TOP]) != null && r.correspondingDatasets && a[G.BOTTOM] || (i = a[G.BOTTOM]) != null && i.correspondingDatasets && a[G.TOP]) && (this.dualAxes = !0);\n  }\n  getCustomDomainValuesByposition(t) {\n    const n = y(this.model.getOptions(), "axes", t, "domain");\n    if (n && !Array.isArray(n))\n      throw new Error(`Domain in ${t} axis is not a valid array`);\n    if (Array.isArray(n) && (this.scaleTypes[t] === et.LINEAR || this.scaleTypes[t] === et.TIME) && n.length !== 2)\n      throw new Error(\n        `There can only be 2 elements in domain for scale type: ${this.scaleTypes[t]}`\n      );\n    return n;\n  }\n  getOrientation() {\n    return this.orientation;\n  }\n  getScaleByPosition(t) {\n    return this.scales[t];\n  }\n  getScaleTypeByPosition(t) {\n    return this.scaleTypes[t];\n  }\n  getDomainAxisScaleType() {\n    const t = this.getDomainAxisPosition();\n    return this.getScaleTypeByPosition(t);\n  }\n  getRangeAxisScaleType() {\n    const t = this.getRangeAxisPosition();\n    return this.getScaleTypeByPosition(t);\n  }\n  getDomainScale() {\n    return this.scales[this.domainAxisPosition];\n  }\n  getRangeScale() {\n    return this.scales[this.rangeAxisPosition];\n  }\n  // Find the main x-axis out of the 2 x-axis on the chart (when 2D axis is used)\n  getMainXAxisPosition() {\n    const t = [G.BOTTOM, G.TOP];\n    return [this.domainAxisPosition, this.rangeAxisPosition].find(\n      (n) => t.indexOf(n) > -1\n    );\n  }\n  // Find the main y-axis out of the 2 y-axis on the chart (when 2D axis is used)\n  getMainYAxisPosition() {\n    const t = [G.LEFT, G.RIGHT];\n    return [this.domainAxisPosition, this.rangeAxisPosition].find(\n      (n) => t.indexOf(n) > -1\n    );\n  }\n  getMainXScale() {\n    return this.scales[this.getMainXAxisPosition()];\n  }\n  getMainYScale() {\n    return this.scales[this.getMainYAxisPosition()];\n  }\n  getValueFromScale(t, n, r, i) {\n    const s = this.model.getOptions(), a = y(s, "axes")[r], { mapsTo: o } = a, l = y(i, o) !== null ? i[o] : i;\n    let c;\n    switch (n) {\n      case et.LABELS:\n        c = t(l) + t.step() / 2;\n        break;\n      case et.TIME:\n        c = t(new Date(l));\n        break;\n      default:\n        c = t(l);\n    }\n    return c;\n  }\n  getBoundedScaledValues(t) {\n    const { bounds: n } = this.model.getOptions(), r = this.getRangeAxisPosition({ datum: t }), i = this.scales[r], s = this.model.getOptions(), a = y(s, "axes")[r], { mapsTo: o } = a, l = t[o] !== void 0 ? t[o] : t;\n    return [\n      i(\n        y(t, n.upperBoundMapsTo) !== null ? t[n.upperBoundMapsTo] : l\n      ),\n      i(\n        y(t, n.lowerBoundMapsTo) !== null ? t[n.lowerBoundMapsTo] : l\n      )\n    ];\n  }\n  getValueThroughAxisPosition(t, n) {\n    const r = this.scaleTypes[t], i = this.scales[t];\n    return this.getValueFromScale(i, r, t, n);\n  }\n  getDomainValue(t) {\n    const n = this.getDomainAxisPosition({ datum: t });\n    return this.getValueThroughAxisPosition(n, t);\n  }\n  getRangeValue(t) {\n    const n = this.getRangeAxisPosition({ datum: t });\n    return this.getValueThroughAxisPosition(n, t);\n  }\n  getMainXScaleType() {\n    return this.getScaleTypeByPosition(this.getMainXAxisPosition());\n  }\n  getMainYScaleType() {\n    return this.getScaleTypeByPosition(this.getMainYAxisPosition());\n  }\n  getDomainIdentifier(t) {\n    const n = this.model.getOptions();\n    return y(n, "axes", this.getDomainAxisPosition({ datum: t }), "mapsTo");\n  }\n  getRangeIdentifier(t) {\n    const n = this.model.getOptions();\n    return y(n, "axes", this.getRangeAxisPosition({ datum: t }), "mapsTo");\n  }\n  extendsDomain(t, n) {\n    const r = this.model.getOptions(), i = y(r, "axes", t);\n    if (i.scaleType === et.TIME) {\n      const s = y(r, "timeScale", "addSpaceOnEdges");\n      return $P(n, s);\n    } else\n      return MP(n, Pn.paddingRatio, i.scaleType);\n  }\n  findVerticalAxesPositions() {\n    const t = this.model.getOptions(), n = y(t, "axes"), r = this.isDualAxes();\n    return y(n, G.LEFT) === null && y(n, G.RIGHT) !== null || y(n, G.RIGHT, "main") === !0 || r && y(n, G.LEFT, "correspondingDatasets") ? {\n      primary: G.RIGHT,\n      secondary: G.LEFT\n    } : { primary: G.LEFT, secondary: G.RIGHT };\n  }\n  findHorizontalAxesPositions() {\n    const t = this.model.getOptions(), n = y(t, "axes"), r = this.isDualAxes();\n    return y(n, G.BOTTOM) === null && y(n, G.TOP) !== null || y(n, G.TOP, "main") === !0 || r && y(n, G.BOTTOM, "correspondingDatasets") ? {\n      primary: G.TOP,\n      secondary: G.BOTTOM\n    } : { primary: G.BOTTOM, secondary: G.TOP };\n  }\n  findDomainAndRangeAxesPositions(t, n) {\n    const r = this.model.getOptions(), i = y(r, "axes", t.primary), s = y(r, "axes", n.primary), a = i.scaleType || et.LINEAR, o = s.scaleType || et.LINEAR, l = {\n      primaryDomainAxisPosition: null,\n      secondaryDomainAxisPosition: null,\n      primaryRangeAxisPosition: null,\n      secondaryRangeAxisPosition: null\n    };\n    return l.primaryDomainAxisPosition = n.primary, l.primaryRangeAxisPosition = t.primary, l.secondaryDomainAxisPosition = n.secondary, l.secondaryRangeAxisPosition = t.secondary, (!(o === et.LABELS || o === et.TIME) && a === et.LABELS || a === et.TIME) && (l.primaryDomainAxisPosition = t.primary, l.primaryRangeAxisPosition = n.primary, l.secondaryDomainAxisPosition = t.secondary, l.secondaryRangeAxisPosition = n.secondary), l;\n  }\n  getScaleDomain(t) {\n    const n = this.model.getOptions(), r = y(n, "axes", t), i = y(n, "bounds"), { includeZero: s } = r, a = y(r, "scaleType") || et.LINEAR;\n    if (this.model.isDataEmpty())\n      return [];\n    if (r.binned) {\n      const { bins: v } = this.model.getBinConfigurations();\n      return [0, nr(v, (x) => x.length)];\n    } else if (r.limitDomainToBins) {\n      const { bins: v } = this.model.getBinConfigurations(), x = this.model.getStackKeys({ bins: v });\n      return [x[0].split(":")[0], x[x.length - 1].split(":")[1]];\n    }\n    const o = this.model.getDisplayData(), { extendLinearDomainBy: l, mapsTo: c, percentage: u, thresholds: d } = r, { reference: h, compareTo: p } = Pn.ratio;\n    if (r.domain)\n      return a === et.LABELS ? r.domain : (a === et.TIME && (r.domain = r.domain.map(\n        (v) => v.getTime === void 0 ? new Date(v) : v\n      )), this.extendsDomain(t, r.domain));\n    if (u)\n      return [0, 100];\n    if (r && a === et.LABELS)\n      return Zi(o.map((v) => v[c]));\n    let f, g;\n    const m = this.model.getDataGroupNames();\n    if (a === et.LABELS_RATIO)\n      return o.map((v) => `${v[h]}/${v[p]}`);\n    if (a === et.TIME)\n      g = o.map((v) => +new Date(v[c]));\n    else if (i && n.axes)\n      g = [], o.forEach((v) => {\n        g.push(v[c]), v[i.upperBoundMapsTo] && g.push(v[i.upperBoundMapsTo]), v[i.lowerBoundMapsTo] && g.push(v[i.lowerBoundMapsTo]);\n      });\n    else if (r.stacked === !0 && m && t === this.getRangeAxisPosition()) {\n      const { groupMapsTo: v } = n.data, x = this.model.getDataValuesGroupedByKeys({\n        groups: m\n      }), _ = o.filter(\n        (b) => !m.includes(b[v])\n      ), E = [];\n      x.forEach((b) => {\n        const { ...S } = b;\n        let M = 0, D = 0;\n        Object.values(HN(S, "sharedStackKey")).forEach((A) => {\n          isNaN(A) || (A < 0 ? D += A : M += A);\n        }), E.push([D, M]);\n      }), g = [\n        ...du(E),\n        ..._.map((b) => b[c])\n      ];\n    } else\n      g = [], o.forEach((v) => {\n        const x = v[c];\n        Array.isArray(x) && x.length === 2 ? (g.push(x[0]), g.push(x[1])) : (l && g.push(Math.max(v[c], v[l])), g.push(x));\n      });\n    return a !== et.TIME && a !== et.LOG && s && g.push(0), d && d.length > 0 && d.forEach((v) => {\n      const x = y(v, "value");\n      x !== null && g.push(x);\n    }), f = ze(g), f = this.extendsDomain(t, f), f;\n  }\n  createScale(t) {\n    const n = this.model.getOptions(), r = y(n, "axes", t);\n    if (!r)\n      return null;\n    const i = y(r, "scaleType") || et.LINEAR;\n    this.scaleTypes[t] = i;\n    let s;\n    return i === et.TIME ? s = eg() : i === et.LOG ? s = Dv().base(r.base || 10) : i === et.LABELS || i === et.LABELS_RATIO ? s = gs() : s = Fe(), s.domain(this.getScaleDomain(t)), s;\n  }\n  getDomainLowerBound(t) {\n    let n, r = 0;\n    return this.getOrientation() === Ft.VERTICAL ? n = this.getMainYScale().domain() : n = this.getMainXScale().domain(), y(this.model.getOptions(), "axes", t, "includeZero") === !1 && n[0] > 0 && n[1] > 0 && (r = n[0]), r;\n  }\n  getHighestDomainThreshold() {\n    const t = y(this.model.getOptions(), "axes"), n = this.getDomainAxisPosition(), { thresholds: r } = t[n];\n    if (!Array.isArray(r) || Array.isArray(r) && !r.length)\n      return null;\n    const i = this.getDomainScale(), s = r.sort((a, o) => o.value - a.value)[0];\n    return this.getScaleTypeByPosition(n) === et.TIME && (typeof s.value == "string" || s.value.getTime === void 0) && (s.value = new Date(s.value)), {\n      threshold: s,\n      scaleValue: i(s.value)\n    };\n  }\n  getHighestRangeThreshold() {\n    const t = y(this.model.getOptions(), "axes"), n = this.getRangeAxisPosition(), { thresholds: r } = t[n];\n    if (!Array.isArray(r) || Array.isArray(r) && !r.length)\n      return null;\n    const i = this.getRangeScale(), s = r.sort((a, o) => o.value - a.value)[0];\n    return {\n      threshold: s,\n      scaleValue: i(s.value)\n    };\n  }\n}\nfunction $P(e, t) {\n  const n = new Date(e[0]), r = new Date(e[1]);\n  return fP(r, n) > 1 ? [mP(n, t), zv(r, t)] : bP(r, n) > 1 ? [_P(n, t), vu(r, t)] : EP(r, n) > 1 ? [OP(n, t), Fv(r, t)] : SP(r, n) > 1 ? [TP(n, t), Wv(r, t)] : Cp(r, n) > 30 ? [\n    Ap(n, t * 30),\n    cc(r, t * 30)\n  ] : Cp(r, n) > 1 ? [Ap(n, t), cc(r, t)] : Lp(r, n) > 15 ? [\n    kp(n, t * 15),\n    uc(r, t * 15)\n  ] : Lp(r, n) > 1 ? [kp(n, t), uc(r, t)] : [n, r];\n}\nfunction MP([e, t], n, r) {\n  const i = (t - e) * n, s = t <= 0 && t + i > 0 ? 0 : t + i;\n  let a = e >= 0 && e - i < 0 ? 0 : e - i;\n  if (r === et.LOG && a <= 0) {\n    if (e <= 0)\n      throw Error("Data must have values greater than 0 if log scale type is used.");\n    a = e;\n  }\n  return [a, s];\n}\nclass CP extends Dn {\n  constructor() {\n    super(...arguments), this.curveTypes = {\n      curveLinear: oo,\n      curveLinearClosed: ig,\n      curveBasis: qN,\n      curveBasisClosed: YN,\n      curveBasisOpen: XN,\n      curveBundle: ZN,\n      curveCardinal: KN,\n      curveCardinalClosed: QN,\n      curveCardinalOpen: JN,\n      curveCatmullRom: tP,\n      curveCatmullRomClosed: eP,\n      curveCatmullRomOpen: nP,\n      curveMonotoneX: rP,\n      curveMonotoneY: iP,\n      curveNatural: sP,\n      curveStep: aP,\n      curveStepAfter: lP,\n      curveStepBefore: oP\n    };\n  }\n  getD3Curve() {\n    let t = "curveLinear";\n    const n = this.model.getOptions().curve;\n    if (n && (typeof n == "string" ? t = n : t = n.name), this.curveTypes[t]) {\n      let r = this.curveTypes[t];\n      return n && Object.keys(n).forEach((i) => {\n        r[i] && (r = r[i](n[i]));\n      }), r;\n    }\n    return console.warn(`The curve type \'${t}\' is invalid, using \'curveLinear\' instead`), this.curveTypes.curveLinear;\n  }\n}\nclass AP extends Dn {\n  isZoomBarEnabled() {\n    if (!this.services.cartesianScales || !y(this.model.getOptions(), "zoomBar", "top", "enabled"))\n      return !1;\n    this.services.cartesianScales.findDomainAndRangeAxes();\n    const t = this.services.cartesianScales.getMainXAxisPosition(), n = y(\n      this.model.getOptions(),\n      "axes",\n      t,\n      "scaleType"\n    );\n    return t === G.BOTTOM && n === et.TIME;\n  }\n  // get display data for zoom bar\n  // basically it\'s sum of value grouped by time\n  getZoomBarData() {\n    const t = this.model.getZoomBarData();\n    return t && t.length > 1 ? t : this.model.getDisplayData();\n  }\n  getDefaultZoomBarDomain(t) {\n    if (!this.services.zoom) throw new Error("Services zoom not defined");\n    const n = t || this.services.zoom.getZoomBarData(), { cartesianScales: r } = this.services;\n    if (!r) throw new Error("Services cartesianScales undefined");\n    const i = r.getMainXAxisPosition(), s = r.getDomainIdentifier(), a = y(this.model.getOptions(), "axes", i, "domain");\n    if (Array.isArray(a) && a.length === 2)\n      return a;\n    if (!i) throw new Error("Not defined: mainXAxisPosition");\n    return r.extendsDomain(\n      i,\n      ze(n, (o) => o[s])\n    );\n  }\n  handleDomainChange(t, n = { dispatchEvent: !0 }) {\n    var r;\n    this.model.set({ zoomDomain: t }, { animate: !1 }), n.dispatchEvent && ((r = this.services.events) == null || r.dispatchEvent(T.ZoomDomain.CHANGE, {\n      newDomain: t\n    }));\n  }\n  getZoomRatio() {\n    return y(this.model.getOptions(), "zoomBar", "zoomRatio");\n  }\n  // filter out data not inside zoom domain\n  // to get better range value for axis label\n  filterDataForRangeAxis(t, n) {\n    var r;\n    const i = this.model.get("zoomDomain"), s = Object.assign(\n      { stacked: !1 },\n      // default configs\n      n\n    ), a = y(this.model.getOptions(), "zoomBar", "updateRangeAxis");\n    if (this.isZoomBarEnabled() && a && i) {\n      const o = s.stacked ? "sharedStackKey" : (r = this.services.cartesianScales) == null ? void 0 : r.getDomainIdentifier(), l = t.filter(\n        (c) => new Date(c[o]) >= i[0] && new Date(c[o]) <= i[1]\n      );\n      if (l.length > 0)\n        return l;\n    }\n    return t;\n  }\n  zoomIn(t = this.getZoomRatio()) {\n    var n;\n    const r = this.model.get("zoomDomain"), i = ye.handleWidth, s = (n = this.services.cartesianScales) == null ? void 0 : n.getMainXScale().copy();\n    s.domain(this.getDefaultZoomBarDomain());\n    const a = s(r[0]), o = s(r[1]);\n    if (o - a < i + 1)\n      return;\n    const l = s.range(), c = o - a, u = Math.min((l[1] - l[0]) / 2 * (t / 2), c / 2);\n    let d = a + u, h = o - u;\n    d >= h && (d = a + c / 2 - i / 2, h = o - c / 2 + i / 2);\n    const p = [s.invert(d), s.invert(h)];\n    (r[0].valueOf() !== p[0].valueOf() || r[1].valueOf() !== p[1].valueOf()) && this.handleDomainChange(p);\n  }\n  zoomOut(t = this.getZoomRatio()) {\n    const n = this.model.get("zoomDomain");\n    if (!this.services.cartesianScales) throw new Error("Services cartesianScales undefined");\n    const r = this.services.cartesianScales.getMainXScale().copy();\n    r.domain(this.getDefaultZoomBarDomain());\n    const i = r(n[0]), s = r(n[1]), a = r.range(), o = (a[1] - a[0]) / 2 * (t / 2), l = Math.max(i - o, a[0]), c = Math.min(s + o, a[1]), u = [r.invert(l), r.invert(c)];\n    (n[0].valueOf() !== u[0].valueOf() || n[1].valueOf() !== u[1].valueOf()) && this.handleDomainChange(u);\n  }\n  resetZoomDomain() {\n    const t = this.model.get("zoomDomain"), n = this.getDefaultZoomBarDomain();\n    (t[0].valueOf() !== n[0].valueOf() || t[1].valueOf() !== n[1].valueOf()) && this.handleDomainChange(n);\n  }\n  // check if current zoom domain is already the min zoom domain\n  // when toolbar is rendered, we don\'t render chart yet\n  // don\'t depend on scale range\n  isMinZoomDomain() {\n    const t = this.model.get("zoomDomain"), n = this.getDefaultZoomBarDomain();\n    if (!t || !n)\n      return !1;\n    const r = t[1].valueOf() - t[0].valueOf(), i = n[1].valueOf() - n[0].valueOf(), s = y(this.model.getOptions(), "zoomBar", "minZoomRatio");\n    return r / i < s;\n  }\n  // check if current zoom domain is already the max zoom domain\n  isMaxZoomDomain() {\n    const t = this.model.get("zoomDomain"), n = this.getDefaultZoomBarDomain();\n    return !!(t && n && t[0].valueOf() === n[0].valueOf() && t[1].valueOf() === n[1].valueOf());\n  }\n  isEmptyState() {\n    return this.getZoomBarData().length === 0;\n  }\n  isZoomBarLoading(t) {\n    return y(this.model.getOptions(), "zoomBar", t, "loading");\n  }\n  isZoomBarLocked(t) {\n    return y(this.model.getOptions(), "zoomBar", t, "locked");\n  }\n}\nfunction LP(e, t, n) {\n  var r = e.length;\n  return n = n === void 0 ? r : n, kv(e, t, n);\n}\nvar kP = "\\\\ud800-\\\\udfff", DP = "\\\\u0300-\\\\u036f", RP = "\\\\ufe20-\\\\ufe2f", IP = "\\\\u20d0-\\\\u20ff", NP = DP + RP + IP, PP = "\\\\ufe0e\\\\ufe0f", UP = "\\\\u200d", BP = RegExp("[" + UP + kP + NP + PP + "]");\nfunction Yv(e) {\n  return BP.test(e);\n}\nfunction HP(e) {\n  return e.split("");\n}\nvar Xv = "\\\\ud800-\\\\udfff", VP = "\\\\u0300-\\\\u036f", GP = "\\\\ufe20-\\\\ufe2f", zP = "\\\\u20d0-\\\\u20ff", FP = VP + GP + zP, jP = "\\\\ufe0e\\\\ufe0f", WP = "[" + Xv + "]", hc = "[" + FP + "]", dc = "\\\\ud83c[\\\\udffb-\\\\udfff]", qP = "(?:" + hc + "|" + dc + ")", Zv = "[^" + Xv + "]", Kv = "(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}", Qv = "[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]", YP = "\\\\u200d", Jv = qP + "?", t0 = "[" + jP + "]?", XP = "(?:" + YP + "(?:" + [Zv, Kv, Qv].join("|") + ")" + t0 + Jv + ")*", ZP = t0 + Jv + XP, KP = "(?:" + [Zv + hc + "?", hc, Kv, Qv, WP].join("|") + ")", QP = RegExp(dc + "(?=" + dc + ")|" + KP + ZP, "g");\nfunction JP(e) {\n  return e.match(QP) || [];\n}\nfunction t3(e) {\n  return Yv(e) ? JP(e) : HP(e);\n}\nfunction e3(e) {\n  return function(t) {\n    t = us(t);\n    var n = Yv(t) ? t3(t) : void 0, r = n ? n[0] : t.charAt(0), i = n ? LP(n, 1).join("") : t.slice(1);\n    return r[e]() + i;\n  };\n}\nvar n3 = e3("toUpperCase");\nfunction r3(e) {\n  return n3(us(e).toLowerCase());\n}\nvar i3 = $g(function(e, t, n) {\n  return t = t.toLowerCase(), e + (n ? r3(t) : t);\n});\nclass Ye {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  constructor(t, n) {\n    this.components = [], this.services = {\n      canvasZoom: cP,\n      domUtils: N,\n      events: uP,\n      files: hP,\n      gradientUtils: Nl,\n      transitions: dP\n    }, this.model = new an(this.services);\n  }\n  // Contains the code that uses properties that are overridable by the super-class\n  init(t, n) {\n    this.model.set({ holder: t }, { skipUpdate: !0 }), Object.keys(this.services).forEach((r) => {\n      const i = this.services[r];\n      this.services[r] = new i(this.model, this.services);\n    }), this.services.events.addEventListener(T.Model.UPDATE, (r) => {\n      const i = !!y(r, "detail", "animate");\n      this.update(i);\n    }), this.model.setData(n.data), this.services.events.addEventListener(T.Chart.RESIZE, () => {\n      this.update(!1);\n    }), this.components = this.getComponents(), this.update();\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    return console.error("getComponents() method is not implemented"), [];\n  }\n  update(t = !0) {\n    if (!this.components)\n      return;\n    Object.keys(this.services).forEach((i) => {\n      this.services[i].update();\n    }), this.components.forEach((i) => i.render(t));\n    const n = this.services.transitions.getPendingTransitions(), r = Object.keys(n).map((i) => n[i].end().catch((s) => s));\n    Promise.all(r).then(\n      () => this.services.events.dispatchEvent(T.Chart.RENDER_FINISHED)\n    );\n  }\n  destroy() {\n    this.components.forEach((t) => t.destroy()), this.services.domUtils.getHolder().remove(), this.model.set({ destroyed: !0 }, { skipUpdate: !0 });\n  }\n  getChartComponents(t, n) {\n    const r = this.model.getOptions(), i = y(r, "toolbar", "enabled"), s = {\n      id: "legend",\n      components: [new lu(this.model, this.services)],\n      growth: ct.PREFERRED\n    }, a = y(r, "canvasZoom", "enabled");\n    a && a === !0 && t.push(new Vk(this.model, this.services));\n    const o = !!this.model.getOptions().title, l = {\n      id: "title",\n      components: [new bs(this.model, this.services)],\n      growth: ct.STRETCH\n    }, c = {\n      id: "toolbar",\n      components: [new po(this.model, this.services)],\n      growth: ct.PREFERRED\n    }, u = {\n      id: "header",\n      components: [\n        new be(\n          this.model,\n          this.services,\n          [\n            // always add title to keep layout correct\n            l,\n            ...i ? [c] : []\n          ],\n          {\n            direction: At.ROW,\n            alignItems: ni.CENTER\n          }\n        )\n      ],\n      growth: ct.PREFERRED\n    }, d = {\n      id: "graph-frame",\n      components: t,\n      growth: ct.STRETCH,\n      renderType: y(n, "graphFrameRenderType") || rt.SVG\n    }, h = y(n, "excludeLegend") !== !0 && r.legend.enabled !== !1;\n    let p = At.COLUMN;\n    if (h) {\n      const v = y(r, "legend", "position");\n      v === "left" ? (p = At.ROW, r.legend.orientation || (r.legend.orientation = ji.VERTICAL)) : v === "right" ? (p = At.ROW_REVERSE, r.legend.orientation || (r.legend.orientation = ji.VERTICAL)) : v === "bottom" && (p = At.COLUMN_REVERSE);\n    }\n    const f = {\n      id: "spacer",\n      components: [new An(this.model, this.services)],\n      growth: ct.PREFERRED\n    }, g = {\n      id: "full-frame",\n      components: [\n        new be(\n          this.model,\n          this.services,\n          [\n            ...h ? [s] : [],\n            ...h ? [f] : [],\n            d\n          ],\n          {\n            direction: p\n          }\n        )\n      ],\n      growth: ct.STRETCH\n    }, m = [];\n    if (o || i) {\n      m.push(u);\n      const v = {\n        id: "spacer",\n        components: [\n          new An(this.model, this.services, i ? { size: 15 } : void 0)\n        ],\n        growth: ct.PREFERRED\n      };\n      m.push(v);\n    }\n    return m.push(g), [\n      new cu(this.model, this.services),\n      new fo(this.model, this.services),\n      new be(this.model, this.services, m, {\n        direction: At.COLUMN\n      })\n    ];\n  }\n}\nclass me extends Ye {\n  constructor(t, n) {\n    super(t, n), this.services = Object.assign(this.services, {\n      cartesianScales: wP,\n      curves: CP,\n      zoom: AP\n    }), this.model = new mr(this.services);\n  }\n  getAxisChartComponents(t, n) {\n    const r = this.model.getOptions(), i = y(r, "zoomBar", G.TOP, "enabled"), s = y(r, "toolbar", "enabled");\n    this.services.cartesianScales.determineAxisDuality(), this.services.cartesianScales.findDomainAndRangeAxes(), this.services.cartesianScales.determineOrientation();\n    const a = this.services.cartesianScales.getMainXAxisPosition(), o = y(r, "axes", a, "scaleType"), l = i && a === G.BOTTOM && o === et.TIME, c = this.services.zoom.isZoomBarLocked(G.TOP), u = !!this.model.getOptions().title, d = {\n      id: "title",\n      components: [new bs(this.model, this.services)],\n      growth: ct.STRETCH\n    }, h = {\n      id: "toolbar",\n      components: [new po(this.model, this.services)],\n      growth: ct.PREFERRED\n    }, p = {\n      id: "header",\n      components: [\n        new be(\n          this.model,\n          this.services,\n          [\n            // always add title to keep layout correct\n            d,\n            ...s ? [h] : []\n          ],\n          {\n            direction: At.ROW,\n            alignItems: ni.CENTER\n          }\n        )\n      ],\n      growth: ct.PREFERRED\n    }, f = {\n      id: "legend",\n      components: [new lu(this.model, this.services)],\n      growth: ct.PREFERRED\n    };\n    l && !c && t.push(\n      new vv(this.model, this.services),\n      new Gk(this.model, this.services)\n    ), t.push(new Fk(this.model, this.services)), t.push(new jk(this.model, this.services));\n    const g = {\n      id: "graph-frame",\n      components: t,\n      growth: ct.STRETCH,\n      renderType: rt.SVG\n    }, m = y(n, "legend", "enabled") !== !1 && this.model.getOptions().legend.enabled !== !1;\n    let v = At.COLUMN;\n    if (m) {\n      const S = y(this.model.getOptions(), "legend", "position");\n      S === Ni.LEFT ? (v = At.ROW, this.model.getOptions().legend.orientation || (this.model.getOptions().legend.orientation = ji.VERTICAL)) : S === Ni.RIGHT ? (v = At.ROW_REVERSE, this.model.getOptions().legend.orientation || (this.model.getOptions().legend.orientation = ji.VERTICAL)) : S === Ni.BOTTOM && (v = At.COLUMN_REVERSE);\n    }\n    const x = {\n      id: "spacer",\n      components: [new An(this.model, this.services)],\n      growth: ct.PREFERRED\n    }, _ = {\n      id: "full-frame",\n      components: [\n        new be(\n          this.model,\n          this.services,\n          [\n            ...m ? [f] : [],\n            ...m ? [x] : [],\n            g\n          ],\n          {\n            direction: v\n          }\n        )\n      ],\n      growth: ct.STRETCH\n    }, E = {\n      id: "zoom-bar",\n      components: [new zk(this.model, this.services)],\n      growth: ct.PREFERRED,\n      renderType: rt.SVG\n    }, b = [];\n    if (u || s) {\n      b.push(p);\n      const S = {\n        id: "spacer",\n        components: [\n          new An(this.model, this.services, s ? { size: 15 } : void 0)\n        ],\n        growth: ct.PREFERRED\n      };\n      b.push(S);\n    }\n    return l && b.push(E), b.push(_), [\n      new xv(this.model, this.services),\n      new fo(this.model, this.services),\n      new be(this.model, this.services, b, {\n        direction: At.COLUMN\n      })\n    ];\n  }\n}\nclass s3 extends Ye {\n  constructor(t, n) {\n    super(t, n), this.model = new Qw(this.services), this.model.setOptions(Rt(wt.alluvialChart, n.options)), this.init(t, n);\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [new hD(this.model, this.services)];\n    return this.getChartComponents(t, {\n      excludeLegend: !0\n    });\n  }\n}\nclass a3 extends me {\n  constructor(t, n) {\n    super(t, n), this.model.setOptions(\n      Rt(Sn(wt.areaChart), n.options)\n    ), this.init(t, n);\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [\n      new fe(this.model, this.services),\n      new Oe(this.model, this.services),\n      new Vn(this.model, this.services),\n      new Fr(this.model, this.services),\n      new Ev(this.model, this.services),\n      new nn(this.model, this.services, {\n        fadeInOnChartHolderMouseover: !0,\n        handleThresholds: !0\n      }),\n      new ce(this.model, this.services, {\n        skeleton: zt.GRID\n      })\n    ];\n    return this.getAxisChartComponents(t);\n  }\n}\nclass o3 extends me {\n  constructor(t, n) {\n    super(t, n), this.model = new Jw(this.services), this.model.setOptions(Rt(wt.boxplotChart, n.options)), this.init(t, n);\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [\n      new fe(this.model, this.services),\n      new Oe(this.model, this.services),\n      new fD(this.model, this.services),\n      new si(this.model, this.services),\n      new ce(this.model, this.services, {\n        skeleton: zt.VERT_OR_HORIZ\n      })\n    ];\n    return this.getAxisChartComponents(t, {\n      legend: {\n        enabled: !1\n      }\n    });\n  }\n}\nclass l3 extends me {\n  constructor(t, n) {\n    super(t, n), this.model.setOptions(Rt(wt.bubbleChart, n.options)), this.init(t, n);\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [\n      new fe(this.model, this.services),\n      new Oe(this.model, this.services),\n      new Vn(this.model, this.services),\n      new mD(this.model, this.services),\n      new ce(this.model, this.services, {\n        skeleton: zt.GRID\n      })\n    ];\n    return this.getAxisChartComponents(t);\n  }\n}\nclass c3 extends me {\n  constructor(t, n) {\n    super(t, n), this.model = new t$(this.services), this.model.setOptions(Rt(wt.bulletChart, n.options)), this.init(t, n);\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [\n      new fe(this.model, this.services),\n      new Oe(this.model, this.services),\n      new gD(this.model, this.services),\n      new ce(this.model, this.services, {\n        skeleton: zt.GRID\n      })\n    ];\n    return this.getAxisChartComponents(t);\n  }\n}\nclass u3 extends Ye {\n  constructor(t, n) {\n    super(t, n), this.model = new e$(this.services), this.model.setOptions(\n      Rt(wt.choroplethChart, n.options)\n    ), this.init(t, n);\n  }\n  // Custom getChartComponents - Implements getChartComponents\n  // Removes zoombar support and additional `features` that are not supported in heatmap\n  getChartComponents(t, n) {\n    const r = this.model.getOptions(), i = y(r, "toolbar", "enabled"), s = !!this.model.getOptions().title, a = {\n      id: "title",\n      components: [new bs(this.model, this.services)],\n      growth: ct.STRETCH\n    }, o = {\n      id: "toolbar",\n      components: [new po(this.model, this.services)],\n      growth: ct.PREFERRED\n    }, l = {\n      id: "header",\n      components: [\n        new be(\n          this.model,\n          this.services,\n          [\n            // always add title to keep layout correct\n            a,\n            ...i ? [o] : []\n          ],\n          {\n            direction: At.ROW,\n            alignItems: ni.CENTER\n          }\n        )\n      ],\n      growth: ct.PREFERRED\n    }, c = {\n      id: "legend",\n      components: [\n        new Sv(this.model, this.services, {\n          chartType: "choropleth"\n        })\n      ],\n      growth: ct.PREFERRED,\n      renderType: rt.SVG\n    }, u = {\n      id: "graph-frame",\n      components: t,\n      growth: ct.STRETCH,\n      renderType: rt.SVG\n    }, d = y(n, "legend", "enabled") !== !1 && this.model.getOptions().legend.enabled !== !1 && this.model.getData().length > 0, h = At.COLUMN_REVERSE, p = {\n      id: "spacer",\n      components: [new An(this.model, this.services, { size: 15 })],\n      growth: ct.PREFERRED\n    }, f = {\n      id: "full-frame",\n      components: [\n        new be(\n          this.model,\n          this.services,\n          [\n            ...d ? [c] : [],\n            ...d ? [p] : [],\n            u\n          ],\n          {\n            direction: h\n          }\n        )\n      ],\n      growth: ct.STRETCH\n    }, g = [];\n    if (s || i) {\n      g.push(l);\n      const m = {\n        id: "spacer",\n        components: [\n          new An(this.model, this.services, i ? { size: 15 } : void 0)\n        ],\n        growth: ct.PREFERRED\n      };\n      g.push(m);\n    }\n    return g.push(f), [\n      new cu(this.model, this.services),\n      new fo(this.model, this.services),\n      new be(this.model, this.services, g, {\n        direction: At.COLUMN\n      })\n    ];\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [new kN(this.model, this.services)];\n    return this.getChartComponents(t);\n  }\n}\nclass h3 extends Ye {\n  constructor(t, n) {\n    super(t, n), this.model = new n$(this.services), this.model.setOptions(Rt(wt.circlePackChart, n.options)), this.init(t, n);\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [new RD(this.model, this.services)];\n    return this.getChartComponents(t);\n  }\n}\nconst Dp = {\n  [we.LINE]: [Fr, nn],\n  [we.SCATTER]: [nn],\n  [we.AREA]: [Ev, Fr, nn],\n  [we.STACKED_AREA]: [Mv, Fr, Av, Ua],\n  [we.SIMPLE_BAR]: [$v],\n  [we.GROUPED_BAR]: [wv, si],\n  [we.STACKED_BAR]: [Cv, Ua]\n};\nclass d3 extends me {\n  constructor(t, n) {\n    super(t, n);\n    const r = Rt(wt.comboChart, n.options);\n    n.options.comboChartTypes || (console.error("No comboChartTypes defined for the Combo Chart!"), r.comboChartTypes = [{ type: we.LINE, correspondingDatasets: [] }]), this.model.setOptions(r), this.init(t, n);\n  }\n  getGraphComponents() {\n    const { comboChartTypes: t } = this.model.getOptions();\n    let n = 0;\n    const r = t.map((i) => {\n      const s = i.type;\n      let a;\n      if (typeof i.type == "string") {\n        if (!Object.keys(Dp).includes(i.type))\n          return console.error(\n            `Invalid chart type "${i.type}" specified for combo chart. Please refer to the ComboChart tutorial for more guidance.`\n          ), null;\n        let o = !1;\n        const l = `${i3(i.type)}Chart`;\n        return a = at({}, wt[l], this.model.getOptions(), i.options), i.type === we.STACKED_AREA && (o = !0), Dp[i.type].map(\n          (c) => new c(this.model, this.services, {\n            groups: i.correspondingDatasets,\n            id: n++,\n            options: a,\n            stacked: o\n          })\n        );\n      } else\n        return a = at({}, this.model.getOptions(), i.options), new s(this.model, this.services, {\n          groups: i.correspondingDatasets,\n          id: n++,\n          options: a\n        });\n    }).filter((i) => i !== null);\n    return du(r);\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const { comboChartTypes: t } = this.model.getOptions(), n = t.some(\n      (i) => i.type === we.STACKED_BAR || i.type === we.STACKED_AREA\n    ), r = [\n      new fe(this.model, this.services),\n      new Oe(this.model, this.services),\n      new ce(this.model, this.services, {\n        skeleton: zt.GRID\n      }),\n      ...n ? [] : [new Vn(this.model, this.services)],\n      ...this.getGraphComponents()\n    ];\n    return this.getAxisChartComponents(r);\n  }\n}\nclass e0 extends Ye {\n  // TODO - Optimize the use of "extending"\n  constructor(t, n, r = !1) {\n    super(t, n), this.model = new r$(this.services), !r && (this.model.setOptions(Rt(wt.pieChart, n.options)), this.init(t, n));\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [\n      new Tv(this.model, this.services),\n      new ce(this.model, this.services, {\n        skeleton: zt.PIE\n      })\n    ];\n    return this.getChartComponents(t);\n  }\n}\nclass p3 extends e0 {\n  constructor(t, n) {\n    super(t, n, !0), this.model.setOptions(Rt(wt.donutChart, n.options)), this.init(t, n);\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [\n      new ND(this.model, this.services),\n      new ce(this.model, this.services, {\n        skeleton: zt.DONUT\n      })\n    ];\n    return this.getChartComponents(t);\n  }\n}\nclass f3 extends Ye {\n  constructor(t, n) {\n    super(t, n), this.model = new i$(this.services), this.model.setOptions(Rt(wt.gaugeChart, n.options)), this.init(t, n);\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [new PD(this.model, this.services)];\n    return this.getChartComponents(t);\n  }\n}\nclass m3 extends me {\n  constructor(t, n) {\n    super(t, n), this.model.setOptions(Rt(wt.groupedBarChart, n.options)), this.init(t, n);\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [\n      new fe(this.model, this.services),\n      new Oe(this.model, this.services),\n      new wv(this.model, this.services),\n      new si(this.model, this.services),\n      new ce(this.model, this.services, {\n        skeleton: zt.VERT_OR_HORIZ\n      })\n    ];\n    return this.getAxisChartComponents(t);\n  }\n}\nclass g3 extends me {\n  constructor(t, n) {\n    super(t, n), this.model = new s$(this.services), this.model.setOptions(\n      Rt(wt.heatmapChart, n.options)\n    ), this.init(t, n);\n  }\n  // Custom getChartComponents - Implements getChartComponents\n  // Removes zoombar support and additional `features` that are not supported in heatmap\n  getAxisChartComponents(t, n) {\n    const r = this.model.getOptions(), i = y(r, "toolbar", "enabled");\n    this.services.cartesianScales.determineAxisDuality(), this.services.cartesianScales.findDomainAndRangeAxes(), this.services.cartesianScales.determineOrientation();\n    const s = !!this.model.getOptions().title, a = {\n      id: "title",\n      components: [new bs(this.model, this.services)],\n      growth: ct.STRETCH\n    }, o = {\n      id: "toolbar",\n      components: [new po(this.model, this.services)],\n      growth: ct.PREFERRED\n    }, l = {\n      id: "header",\n      components: [\n        new be(\n          this.model,\n          this.services,\n          [\n            // always add title to keep layout correct\n            a,\n            ...i ? [o] : []\n          ],\n          {\n            direction: At.ROW,\n            alignItems: ni.CENTER\n          }\n        )\n      ],\n      growth: ct.PREFERRED\n    }, c = {\n      id: "legend",\n      components: [\n        new Sv(this.model, this.services, {\n          chartType: "heatmap"\n        })\n      ],\n      growth: ct.PREFERRED,\n      renderType: rt.SVG\n    }, u = {\n      id: "graph-frame",\n      components: t,\n      growth: ct.STRETCH,\n      renderType: rt.SVG\n    }, d = y(n, "legend", "enabled") !== !1 && this.model.getOptions().legend.enabled !== !1 && this.model.getData().length > 0, h = At.COLUMN_REVERSE, p = {\n      id: "spacer",\n      components: [new An(this.model, this.services, { size: 15 })],\n      growth: ct.PREFERRED\n    }, f = {\n      id: "full-frame",\n      components: [\n        new be(\n          this.model,\n          this.services,\n          [\n            ...d ? [c] : [],\n            ...d ? [p] : [],\n            u\n          ],\n          {\n            direction: h\n          }\n        )\n      ],\n      growth: ct.STRETCH\n    }, g = [];\n    if (s || i) {\n      g.push(l);\n      const m = {\n        id: "spacer",\n        components: [\n          new An(this.model, this.services, i ? { size: 15 } : void 0)\n        ],\n        growth: ct.PREFERRED\n      };\n      g.push(m);\n    }\n    return g.push(f), [\n      new xv(this.model, this.services),\n      new fo(this.model, this.services),\n      new be(this.model, this.services, g, {\n        direction: At.COLUMN\n      })\n    ];\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [\n      new fe(this.model, this.services),\n      new UD(this.model, this.services)\n    ];\n    return this.getAxisChartComponents(t);\n  }\n}\nclass v3 extends me {\n  constructor(t, n) {\n    super(t, n), this.model = new a$(this.services), this.model.setOptions(Rt(wt.histogramChart, n.options)), this.init(t, n), this.update();\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [\n      new fe(this.model, this.services),\n      new Oe(this.model, this.services),\n      new TD(this.model, this.services),\n      new BD(this.model, this.services)\n    ];\n    return this.getAxisChartComponents(t);\n  }\n}\nclass y3 extends me {\n  constructor(t, n) {\n    super(t, n), this.model.setOptions(Rt(wt.lineChart, n.options)), this.init(t, n);\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [\n      new fe(this.model, this.services),\n      new Oe(this.model, this.services),\n      new Vn(this.model, this.services),\n      new Fr(this.model, this.services),\n      new nn(this.model, this.services, { handleThresholds: !0 }),\n      new zD(this.model, this.services),\n      new si(this.model, this.services)\n    ];\n    return this.getAxisChartComponents(t);\n  }\n}\nclass x3 extends me {\n  constructor(t, n) {\n    super(t, n), this.model.setOptions(Rt(wt.lollipopChart, n.options)), this.init(t, n);\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [\n      new fe(this.model, this.services),\n      new Oe(this.model, this.services),\n      new Vn(this.model, this.services),\n      new HD(this.model, this.services),\n      new nn(this.model, this.services),\n      new ce(this.model, this.services, {\n        skeleton: zt.GRID\n      })\n    ];\n    return this.getAxisChartComponents(t);\n  }\n}\nclass b3 extends Ye {\n  constructor(t, n) {\n    var r;\n    super(t, n), this.model = new o$(this.services);\n    const i = (r = n.options.meter) != null && r.proportional ? at(Sn(wt.proportionalMeterChart), n.options) : at(Sn(wt.meterChart), n.options);\n    this.model.setOptions(i), this.init(t, n);\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [\n      ...y(this.model.getOptions(), "meter", "showLabels") ? [\n        // Meter has a unique dataset title within the graph\n        {\n          id: "meter-title",\n          components: [new DD(this.model, this.services)],\n          growth: ct.STRETCH,\n          renderType: rt.SVG\n        },\n        // Create the title spacer\n        {\n          id: "spacer",\n          components: [\n            new An(this.model, this.services, {\n              size: 8\n            })\n          ],\n          growth: ct.STRETCH\n        }\n      ] : [],\n      // Specify what to render inside the graph only\n      {\n        id: "meter-graph",\n        components: [new VD(this.model, this.services)],\n        growth: ct.STRETCH,\n        renderType: rt.SVG\n      }\n    ], n = [\n      new be(this.model, this.services, t, {\n        direction: At.COLUMN\n      })\n    ];\n    return this.getChartComponents(n, {\n      graphFrameRenderType: rt.HTML\n    });\n  }\n}\nclass _3 extends Ye {\n  constructor(t, n) {\n    super(t, n), this.model = new l$(this.services), this.model.setOptions(Rt(wt.radarChart, n.options)), this.init(t, n);\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [new GD(this.model, this.services)];\n    return this.getChartComponents(t);\n  }\n}\nclass E3 extends me {\n  constructor(t, n) {\n    super(t, n), this.model.setOptions(Rt(wt.scatterChart, n.options)), this.init(t, n);\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [\n      new fe(this.model, this.services),\n      new Oe(this.model, this.services),\n      new Vn(this.model, this.services),\n      new nn(this.model, this.services),\n      new ce(this.model, this.services, {\n        skeleton: zt.GRID\n      })\n    ];\n    return this.getAxisChartComponents(t);\n  }\n}\nclass O3 extends Ye {\n  constructor(t, n) {\n    super(t, n), this.model = new c$(this.services), this.model.setOptions(Rt(wt.treeChart, n.options)), this.init(t, n);\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [new FD(this.model, this.services)];\n    return this.getChartComponents(t, {\n      excludeLegend: !0\n    });\n  }\n}\nclass S3 extends Ye {\n  constructor(t, n) {\n    super(t, n), this.model = new u$(this.services), this.model.setOptions(Rt(wt.treemapChart, n.options)), this.init(t, n);\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [new xN(this.model, this.services)];\n    return this.getChartComponents(t);\n  }\n}\nclass T3 extends me {\n  constructor(t, n) {\n    super(t, n), this.model.setOptions(Rt(wt.simpleBarChart, n.options)), this.init(t, n);\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [\n      new fe(this.model, this.services),\n      new Oe(this.model, this.services),\n      new $v(this.model, this.services),\n      new si(this.model, this.services),\n      new ce(this.model, this.services, {\n        skeleton: zt.VERT_OR_HORIZ\n      })\n    ];\n    return this.getAxisChartComponents(t);\n  }\n}\nclass w3 extends me {\n  constructor(t, n) {\n    super(t, n), this.model.setOptions(Rt(wt.stackedAreaChart, n.options)), this.init(t, n);\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [\n      new fe(this.model, this.services),\n      new Oe(this.model, this.services),\n      new Ua(this.model, this.services),\n      new Mv(this.model, this.services),\n      new Fr(this.model, this.services, { stacked: !0 }),\n      new Av(this.model, this.services, {\n        fadeInOnChartHolderMouseover: !0,\n        handleThresholds: !0,\n        stacked: !0\n      }),\n      new ce(this.model, this.services, {\n        skeleton: zt.GRID\n      })\n    ];\n    return this.getAxisChartComponents(t);\n  }\n}\nclass $3 extends me {\n  constructor(t, n) {\n    super(t, n), this.model.setOptions(Rt(wt.stackedBarChart, n.options)), this.init(t, n);\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [\n      new fe(this.model, this.services),\n      new Oe(this.model, this.services),\n      new Ua(this.model, this.services),\n      new Cv(this.model, this.services),\n      new ce(this.model, this.services, {\n        skeleton: zt.VERT_OR_HORIZ\n      }),\n      new si(this.model, this.services)\n    ];\n    return this.getAxisChartComponents(t);\n  }\n}\nclass M3 extends Ye {\n  constructor(t, n) {\n    super(t, n), this.model = new h$(this.services), this.model.setOptions(Rt(wt.wordCloudChart, n.options)), this.init(t, n);\n  }\n  /**\n   * Retrieves the components to be rendered inside the graph frame.\n   *\n   * @returns {Component[]} An array of components to be rendered.\n   */\n  getComponents() {\n    const t = [\n      new AN(this.model, this.services),\n      new ce(this.model, this.services, {\n        skeleton: zt.PIE\n      })\n    ];\n    return this.getChartComponents(t);\n  }\n}\nclass kt extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n  constructor() {\n    super(...arguments);\n    So(this, "chart");\n    So(this, "chartRef", react__WEBPACK_IMPORTED_MODULE_0__.createRef());\n  }\n  // TODO: add abstract keyword once React 16 support no longer needed then remove the next 3 comments\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  createChart(n, r, i) {\n    throw new Error("Method not implemented.");\n  }\n  componentDidMount() {\n    this.chartRef.current && !this.chart && (this.chart = this.createChart(this.chartRef.current, this.props.data, this.props.options));\n  }\n  componentDidUpdate(n) {\n    var r, i;\n    this.props.data !== n.data && ((r = this.chart) == null || r.model.setData(this.props.data)), this.props.options !== n.options && ((i = this.chart) == null || i.model.setOptions(this.props.options));\n  }\n  render() {\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { ref: this.chartRef, className: "chart-holder" });\n  }\n}\nclass Z3 extends (/* unused pure expression or super */ null && (kt)) {\n  createChart(t, n, r) {\n    return new s3(t, { data: n, options: r });\n  }\n}\nclass K3 extends (/* unused pure expression or super */ null && (kt)) {\n  createChart(t, n, r) {\n    return new a3(t, { data: n, options: r });\n  }\n}\nclass Q3 extends (/* unused pure expression or super */ null && (kt)) {\n  createChart(t, n, r) {\n    return new o3(t, { data: n, options: r });\n  }\n}\nclass J3 extends (/* unused pure expression or super */ null && (kt)) {\n  createChart(t, n, r) {\n    return new l3(t, { data: n, options: r });\n  }\n}\nclass tU extends (/* unused pure expression or super */ null && (kt)) {\n  createChart(t, n, r) {\n    return new c3(t, { data: n, options: r });\n  }\n}\nclass eU extends (/* unused pure expression or super */ null && (kt)) {\n  createChart(t, n, r) {\n    return new u3(t, { data: n, options: r });\n  }\n}\nclass nU extends (/* unused pure expression or super */ null && (kt)) {\n  createChart(t, n, r) {\n    return new h3(t, { data: n, options: r });\n  }\n}\nclass rU extends (/* unused pure expression or super */ null && (kt)) {\n  createChart(t, n, r) {\n    return new d3(t, { data: n, options: r });\n  }\n}\nclass iU extends (/* unused pure expression or super */ null && (kt)) {\n  createChart(t, n, r) {\n    return new p3(t, { data: n, options: r });\n  }\n}\nclass sU extends (/* unused pure expression or super */ null && (kt)) {\n  createChart(t, n, r) {\n    return new f3(t, { data: n, options: r });\n  }\n}\nclass aU extends (/* unused pure expression or super */ null && (kt)) {\n  createChart(t, n, r) {\n    return new m3(t, { data: n, options: r });\n  }\n}\nclass oU extends kt {\n  createChart(t, n, r) {\n    return new g3(t, { data: n, options: r });\n  }\n}\nclass lU extends (/* unused pure expression or super */ null && (kt)) {\n  createChart(t, n, r) {\n    return new v3(t, { data: n, options: r });\n  }\n}\nclass cU extends kt {\n  createChart(t, n, r) {\n    return new y3(t, { data: n, options: r });\n  }\n}\nclass uU extends (/* unused pure expression or super */ null && (kt)) {\n  createChart(t, n, r) {\n    return new x3(t, { data: n, options: r });\n  }\n}\nclass hU extends (/* unused pure expression or super */ null && (kt)) {\n  createChart(t, n, r) {\n    return new b3(t, { data: n, options: r });\n  }\n}\nclass dU extends kt {\n  createChart(t, n, r) {\n    return new e0(t, { data: n, options: r });\n  }\n}\nclass pU extends (/* unused pure expression or super */ null && (kt)) {\n  createChart(t, n, r) {\n    return new _3(t, { data: n, options: r });\n  }\n}\nclass fU extends (/* unused pure expression or super */ null && (kt)) {\n  createChart(t, n, r) {\n    return new E3(t, { data: n, options: r });\n  }\n}\nclass mU extends kt {\n  createChart(t, n, r) {\n    return new T3(t, { data: n, options: r });\n  }\n}\nclass gU extends (/* unused pure expression or super */ null && (kt)) {\n  createChart(t, n, r) {\n    return new w3(t, { data: n, options: r });\n  }\n}\nclass vU extends (/* unused pure expression or super */ null && (kt)) {\n  createChart(t, n, r) {\n    return new $3(t, { data: n, options: r });\n  }\n}\nclass yU extends (/* unused pure expression or super */ null && (kt)) {\n  createChart(t, n, r) {\n    return new O3(t, { data: n, options: r });\n  }\n}\nclass xU extends (/* unused pure expression or super */ null && (kt)) {\n  createChart(t, n, r) {\n    return new S3(t, { data: n, options: r });\n  }\n}\nclass bU extends (/* unused pure expression or super */ null && (kt)) {\n  createChart(t, n, r) {\n    return new M3(t, { data: n, options: r });\n  }\n}\nfunction C3(e) {\n  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;\n}\nvar dl = { exports: {} };\n/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/\nvar Rp;\nfunction A3() {\n  return Rp || (Rp = 1, function(e) {\n    (function() {\n      var t = {}.hasOwnProperty;\n      function n() {\n        for (var s = "", a = 0; a < arguments.length; a++) {\n          var o = arguments[a];\n          o && (s = i(s, r(o)));\n        }\n        return s;\n      }\n      function r(s) {\n        if (typeof s == "string" || typeof s == "number")\n          return s;\n        if (typeof s != "object")\n          return "";\n        if (Array.isArray(s))\n          return n.apply(null, s);\n        if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]"))\n          return s.toString();\n        var a = "";\n        for (var o in s)\n          t.call(s, o) && s[o] && (a = i(a, o));\n        return a;\n      }\n      function i(s, a) {\n        return a ? s ? s + " " + a : s + a : s;\n      }\n      e.exports ? (n.default = n, e.exports = n) : window.classNames = n;\n    })();\n  }(dl)), dl.exports;\n}\nvar L3 = A3();\nconst Gn = /* @__PURE__ */ (/* unused pure expression or super */ null && (C3(L3))), zn = "cds", _U = ({ tag: e = "div", className: t, children: n, color: r, href: i, position: s = "static", stacked: a, ...o }) => {\n  const l = i ? "a" : o.onClick ? "button" : e, c = `${zn}--cc--card-node`, u = Gn(c, {\n    [`${c}--stacked`]: a,\n    [`${c}--${l}`]: l,\n    [t]: t\n  });\n  return Ct.createElement(\n    l,\n    {\n      className: u,\n      style: { borderColor: r, position: s },\n      tabIndex: 0,\n      ...o\n    },\n    n\n  );\n}, EU = ({\n  children: e,\n  farsideColumn: t = !1,\n  ...n\n}) => {\n  const r = `${zn}--cc--card-node`, i = Gn(`${r}__column`, {\n    [`${r}__column--farside`]: t,\n    ...n.className ? { [n.className]: !0 } : {}\n  });\n  return Ct.createElement("div", { className: i, ...n }, e);\n}, OU = ({\n  children: e,\n  ...t\n}) => {\n  const n = `${zn}--cc--card-node`, r = Gn(`${n}__label`, {\n    ...t.className ? { [t.className]: !0 } : {}\n  });\n  return Ct.createElement("label", { className: r, ...t }, e);\n}, SU = ({\n  children: e,\n  ...t\n}) => {\n  const n = `${zn}--cc--card-node`, r = Gn(`${n}__subtitle`, {\n    ...t.className ? { [t.className]: !0 } : {}\n  });\n  return Ct.createElement("div", { className: r, ...t }, e);\n}, TU = ({\n  children: e,\n  ...t\n}) => {\n  const n = `${zn}--cc--card-node`, r = Gn(`${n}__title`, {\n    ...t.className ? { [t.className]: !0 } : {}\n  });\n  return Ct.createElement("div", { className: r, ...t }, e);\n}, wU = ({\n  color: e,\n  markerEnd: t,\n  markerStart: n,\n  path: r,\n  source: i,\n  target: s,\n  variant: a = null,\n  ...o\n}) => {\n  const l = `${zn}--cc--edge`, c = Gn(l, {\n    [`${l}--${a}`]: a,\n    ...o.className ? { [o.className]: !0 } : {}\n  });\n  let u = r;\n  if (!u && i && s && (u = wD(i, s)), !u) throw Error("Missing parameters for Edge component: path or source and target.");\n  return Ct.createElement(\n    "g",\n    { className: c, ...o },\n    Ct.createElement("path", { d: u, className: `${l}__container` }),\n    Ct.createElement("path", { d: u, className: `${l}__outer` }),\n    Ct.createElement("path", {\n      d: u,\n      className: `${l}__inner`,\n      markerEnd: `url(#${t})`,\n      markerStart: `url(#${n})`,\n      style: { stroke: e }\n    })\n  );\n}, ai = ({\n  color: e,\n  d: t,\n  id: n,\n  orient: r = "auto",\n  height: i,\n  width: s,\n  position: a = "end",\n  className: o,\n  refX: l,\n  refY: c,\n  ...u\n}) => {\n  const d = `${zn}--cc--marker`, h = Gn(d, o), p = a === "end" ? (s || 0) / 2 + 0.5 : 0.5, f = (i || 0) / 2;\n  return Ct.createElement(\n    "marker",\n    {\n      className: h,\n      markerHeight: i,\n      markerWidth: s,\n      orient: r,\n      id: n,\n      refX: l || p,\n      refY: c || f,\n      markerUnits: "userSpaceOnUse",\n      ...u\n    },\n    Ct.createElement("path", { d: t, style: { fill: e } })\n  );\n}, $U = (e) => Ct.createElement(ai, { d: $D.d, ...e }), MU = (e) => Ct.createElement(ai, { d: MD.d, ...e }), CU = (e) => Ct.createElement(ai, { d: CD.d, ...e }), AU = (e) => Ct.createElement(ai, { d: AD.d, ...e }), LU = (e) => Ct.createElement(ai, { d: LD.d, ...e }), kU = (e) => Ct.createElement(ai, { d: kD.d, ...e }), DU = ({\n  shape: e = "circle",\n  tag: t = "div",\n  title: n = "Title",\n  className: r,\n  subtitle: i,\n  description: s,\n  renderIcon: a,\n  href: o,\n  size: l = 48,\n  stacked: c,\n  position: u = "fixed",\n  bodyPosition: d = "absolute",\n  ...h\n}) => {\n  const p = o ? "a" : h.onClick ? "button" : t, f = `${zn}--cc--shape-node`, g = Gn(f, {\n    [`${f}--stacked`]: c,\n    [`${f}--${e}`]: e,\n    [`${f}--${p}`]: p,\n    [r]: r\n  }), m = n ? Ct.createElement("div", { className: `${f}__title` }, n) : null, v = i ? Ct.createElement("div", { className: `${f}__subtitle` }, i) : null, x = s ? Ct.createElement("div", { className: `${f}__description` }, s) : null;\n  return Ct.createElement(\n    p,\n    {\n      className: g,\n      style: { height: l, width: l, position: u },\n      tabIndex: 0,\n      ...h\n    },\n    Ct.createElement("div", { className: `${f}__icon` }, a),\n    Ct.createElement(\n      "div",\n      { className: `${f}__body`, style: { position: d } },\n      m,\n      v,\n      x\n    )\n  );\n};\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxXQUFXLE9BQU8sT0FBTyxNQUFNO0FBQy9CLFdBQVcsT0FBTyxPQUFPLE1BQU07QUFDL0IsYUFBYSxNQUFNLElBQUksTUFBTTtBQUM3QixZQUFZLE1BQU0sSUFBSSxNQUFNO0FBQzVCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxTQUFTO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUc7QUFDdEI7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsS0FBSztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsU0FBUztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLCtEQUErRDtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFtQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOExBQThMLElBQUksK0JBQStCLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxrQ0FBa0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLG1DQUFtQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLG1DQUFtQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLGtDQUFrQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsbUNBQW1DLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFDMWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsYUFBYSxXQUFXLEVBQUUsV0FBVyxFQUFFLFdBQVc7QUFDbEQ7QUFDQTtBQUNBLGFBQWEsV0FBVyxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsbURBQW1EO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCLEVBQUUsV0FBVyxJQUFJLFdBQVcsSUFBSSxXQUFXLEVBQUUscUJBQXFCLEVBQUUsR0FBRztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLE9BQU87QUFDakcsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNDQUFzQztBQUNwRDtBQUNBLG9DQUFvQyxHQUFHO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RCwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsd0hBQXdIO0FBQ25MO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsU0FBUztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDhEQUE4RCxTQUFTO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxRQUFRLHNCQUFzQjtBQUM5QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxRQUFRLHVCQUF1QjtBQUMvQixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxRQUFRLG1DQUFtQztBQUMzQyxRQUFRO0FBQ1I7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsbUNBQW1DO0FBQ3BEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUJBQWlCO0FBQ2pCLG1CQUFtQjtBQUNuQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQSxDQUFDLGFBQWE7QUFDZDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxhQUFhO0FBQ2Q7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLGFBQWE7QUFDZDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsYUFBYTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxhQUFhO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLFVBQVUsNkJBQTZCO0FBQ3ZDLGFBQWEsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7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Q0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHVCQUF1QixhQUFhO0FBQ3BDLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUIsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxXQUFXO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFNBQVM7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUIsb0RBQW9EO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0Q0FBNEM7QUFDdkQ7QUFDQSw0QkFBNEIsSUFBSSxFQUFFLEVBQUU7QUFDcEMsQ0FBQztBQUNEO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEVBQUU7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsMHlCQUEweUIsRUFBRTtBQUM1eUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhEQUE4RDtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFlBQVksNENBQTRDO0FBQ3hELG1CQUFtQiw0Q0FBNEM7QUFDL0QsY0FBYyw0Q0FBNEM7QUFDMUQsaUJBQWlCLDRDQUE0QztBQUM3RCxZQUFZLDRDQUE0QztBQUN4RCxTQUFTO0FBQ1QsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjLFNBQVMsZUFBZSxTQUFTLGdCQUFnQixTQUFTO0FBQ25GLFFBQVEsNEJBQTRCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxTQUFTO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxZQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEVBQUU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCLEdBQUcseUJBQXlCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYyxHQUFHLGNBQWM7QUFDbkQ7QUFDQTtBQUNBLG9CQUFvQixHQUFHLEdBQUcsR0FBRyxHQUFHLGNBQWMsR0FBRyxjQUFjO0FBQy9EO0FBQ0E7QUFDQSxvQkFBb0IsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLGNBQWMsR0FBRyxjQUFjO0FBQzNFO0FBQ0E7QUFDQSwyRkFBMkYsRUFBRTtBQUM3RjtBQUNBO0FBQ0Esc0JBQXNCLGFBQWEsR0FBRyxhQUFhO0FBQ25EO0FBQ0Esc0JBQXNCLGFBQWEsR0FBRyxhQUFhO0FBQ25EO0FBQ0E7QUFDQSw4Q0FBOEMsVUFBVSxHQUFHLFVBQVUsbUJBQW1CLEVBQUUsR0FBRyxFQUFFLE9BQU8saUJBQWlCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixFQUFFO0FBQ3RGO0FBQ0Esd0NBQXdDLEVBQUUsR0FBRyxFQUFFLG9GQUFvRixFQUFFLEdBQUcsRUFBRSw4REFBOEQsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLEdBQUcsTUFBTSxHQUFHLE1BQU0sR0FBRyxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUUsR0FBRyxhQUFhLEdBQUcsYUFBYSw4QkFBOEIsRUFBRSxHQUFHLEVBQUUsS0FBSyxXQUFXLEdBQUcsRUFBRSxHQUFHLCtCQUErQixHQUFHLCtCQUErQjtBQUMzWjtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QixHQUFHLHlCQUF5QixHQUFHLE9BQU8sR0FBRyxHQUFHLEdBQUcsR0FBRztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzREFBc0QsU0FBUztBQUMvRCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHNEQUFzRCxTQUFTO0FBQy9ELEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0RBQXNELFNBQVM7QUFDL0QsR0FBRztBQUNIO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0EsK0JBQStCO0FBQy9CLDhCQUE4QixLQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0EsOEZBQThGLE9BQU87QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxPQUFPO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQscUZBQXFGLE9BQU87QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEVBQUUsR0FBRyxFQUFFO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixFQUFFLEdBQUcsRUFBRTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsRUFBRSxHQUFHLEVBQUU7QUFDbkM7QUFDQSx5Q0FBeUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFHLFVBQVUsT0FBTyxHQUFHLEVBQUUsR0FBRyxHQUFHLFVBQVUsTUFBTTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsRUFBRTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsRUFBRTtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQscUtBQXFLO0FBQ2pPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsTUFBTSxJQUFJLEtBQUs7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsWUFBWSxRQUFRO0FBQzVCLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxVQUFVO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsT0FBTztBQUM1RDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxXQUFXO0FBQ3JFLDBFQUEwRSxPQUFPO0FBQ2pGLGtEQUFrRCxRQUFRO0FBQzFELGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CLE1BQU0sSUFBSSxNQUFNLFVBQVUsRUFBRSxjQUFjLEdBQUcsR0FBRyxHQUFHO0FBQ3RFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTix1REFBdUQsc0JBQXNCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0Isb0NBQW9DO0FBQ3hEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsV0FBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxXQUFXO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVEQUF1RCxVQUFVO0FBQ2pFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsV0FBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkhBQTJILDBDQUEwQztBQUNySztBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEMsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVEQUF1RCxVQUFVO0FBQ2pFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsV0FBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtB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LEtBQUs7QUFDTCwrQkFBK0IsZUFBZSxXQUFXO0FBQ3pEO0FBQ0EsQ0FBQyxxQ0FBcUMsZUFBZSxzQ0FBc0MsZUFBZSxzQ0FBc0MsZUFBZSxzQ0FBc0MsZUFBZSxzQ0FBc0MsZUFBZSxzQ0FBc0MsZUFBZTtBQUM5VDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx1REFBdUQsR0FBRztBQUMxRCxRQUFRLEVBQUU7QUFDVixRQUFRLEVBQUUsSUFBSSxFQUFFO0FBQ2hCLFFBQVEsRUFBRSxJQUFJLEVBQUU7QUFDaEI7QUFDQSxHQUFHLHFDQUFxQyxjQUFjLEVBQUUsVUFBVSwrQ0FBK0MsY0FBYyxFQUFFLGFBQWEsK0NBQStDLGNBQWMsRUFBRSxnQkFBZ0I7QUFDN047QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtDQUFrQztBQUNqRDtBQUNBO0FBQ0EsS0FBSztBQUNMLDhCQUE4QixjQUFjLEVBQUUsU0FBUztBQUN2RDtBQUNBO0FBQ0EsUUFBUSxjQUFjLEVBQUUsa0JBQWtCLGVBQWU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNkZFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AaWJtL2Fpb3BzLXVpLWV4dGVuc2lvbi10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY2FyYm9uL2NoYXJ0cy1yZWFjdC9kaXN0L2luZGV4Lm1qcz83M2Q5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB1MCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBoMCA9IChlLCB0LCBuKSA9PiB0IGluIGUgPyB1MChlLCB0LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiBuIH0pIDogZVt0XSA9IG47XG52YXIgU28gPSAoZSwgdCwgbikgPT4gaDAoZSwgdHlwZW9mIHQgIT0gXCJzeW1ib2xcIiA/IHQgKyBcIlwiIDogdCwgbik7XG5pbXBvcnQgQ3QgZnJvbSBcInJlYWN0XCI7XG52YXIgSXAgPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZS5SRU5ERVJfRklOSVNIRUQgPSBcInJlbmRlci1maW5pc2hlZFwiLCBlLlJFU0laRSA9IFwiY2hhcnQtcmVzaXplXCIsIGUuTU9VU0VPVkVSID0gXCJjaGFydC1tb3VzZW92ZXJcIiwgZS5NT1VTRU9VVCA9IFwiY2hhcnQtbW91c2VvdXRcIiwgZSkpKElwIHx8IHt9KSwgTnAgPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZS5TSE9XID0gXCJzaG93LW1vZGFsXCIsIGUuSElERSA9IFwiaGlkZS1tb2RhbFwiLCBlKSkoTnAgfHwge30pLCBQcCA9IC8qIEBfX1BVUkVfXyAqLyAoKGUpID0+IChlLlVQREFURSA9IFwibW9kZWwtdXBkYXRlXCIsIGUpKShQcCB8fCB7fSksIFVwID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuU0hPV19PVkVSRkxPV19NRU5VID0gXCJzaG93LXRvb2xiYXItb3ZlcmZsb3ctbWVudVwiLCBlLkhJREVfT1ZFUkZMT1dfTUVOVSA9IFwiaGlkZS10b29sYmFyLW92ZXJmbG93LW1lbnVcIiwgZS5CVVRUT05fQ0xJQ0sgPSBcInRvb2xiYXItYnV0dG9uLWNsaWNrXCIsIGUuU0hPV19UT09MVElQID0gXCJ0b29sYmFyLXNob3ctdG9vbHRpcFwiLCBlLkhJREVfVE9PTFRJUCA9IFwidG9vbGJhci1oaWRlLXRvb2x0aXBcIiwgZSkpKFVwIHx8IHt9KSwgQnAgPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZS5VUERBVEUgPSBcInpvb20tYmFyLXVwZGF0ZVwiLCBlLlNFTEVDVElPTl9TVEFSVCA9IFwiem9vbS1iYXItc2VsZWN0aW9uLXN0YXJ0XCIsIGUuU0VMRUNUSU9OX0lOX1BST0dSRVNTID0gXCJ6b29tLWJhci1zZWxlY3Rpb24taW4tcHJvZ3Jlc3NcIiwgZS5TRUxFQ1RJT05fRU5EID0gXCJ6b29tLWJhci1zZWxlY3Rpb24tZW5kXCIsIGUpKShCcCB8fCB7fSksIEhwID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuQ0hBTkdFID0gXCJ6b29tLWRvbWFpbi1jaGFuZ2VcIiwgZSkpKEhwIHx8IHt9KSwgVnAgPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZS5DQU5WQVNfWk9PTV9JTiA9IFwiY2FudmFzLXpvb20taW5cIiwgZS5DQU5WQVNfWk9PTV9PVVQgPSBcImNhbnZhcy16b29tLW91dFwiLCBlKSkoVnAgfHwge30pLCBHcCA9IC8qIEBfX1BVUkVfXyAqLyAoKGUpID0+IChlLkxBQkVMX01PVVNFT1ZFUiA9IFwiYXhpcy1sYWJlbC1tb3VzZW92ZXJcIiwgZS5MQUJFTF9NT1VTRU1PVkUgPSBcImF4aXMtbGFiZWwtbW91c2Vtb3ZlXCIsIGUuTEFCRUxfQ0xJQ0sgPSBcImF4aXMtbGFiZWwtY2xpY2tcIiwgZS5MQUJFTF9NT1VTRU9VVCA9IFwiYXhpcy1sYWJlbC1tb3VzZW91dFwiLCBlLkxBQkVMX0ZPQ1VTID0gXCJheGlzLWxhYmVsLWZvY3VzXCIsIGUuTEFCRUxfQkxVUiA9IFwiYXhpcy1sYWJlbC1ibHVyXCIsIGUuUkVOREVSX0NPTVBMRVRFID0gXCJheGlzLXJlbmRlci1jb21wbGV0ZVwiLCBlKSkoR3AgfHwge30pLCB6cCA9IC8qIEBfX1BVUkVfXyAqLyAoKGUpID0+IChlLlBPSU5UX01PVVNFT1ZFUiA9IFwic2NhdHRlci1tb3VzZW92ZXJcIiwgZS5QT0lOVF9NT1VTRU1PVkUgPSBcInNjYXR0ZXItbW91c2Vtb3ZlXCIsIGUuUE9JTlRfQ0xJQ0sgPSBcInNjYXR0ZXItY2xpY2tcIiwgZS5QT0lOVF9NT1VTRU9VVCA9IFwic2NhdHRlci1tb3VzZW91dFwiLCBlKSkoenAgfHwge30pLCBGcCA9IC8qIEBfX1BVUkVfXyAqLyAoKGUpID0+IChlLldPUkRfTU9VU0VPVkVSID0gXCJ3b3JkY2xvdWQtd29yZC1tb3VzZW92ZXJcIiwgZS5XT1JEX01PVVNFTU9WRSA9IFwid29yZGNsb3VkLXdvcmQtbW91c2Vtb3ZlXCIsIGUuV09SRF9DTElDSyA9IFwid29yZGNsb3VkLXdvcmQtY2xpY2tcIiwgZS5XT1JEX01PVVNFT1VUID0gXCJ3b3JkY2xvdWQtd29yZC1tb3VzZW91dFwiLCBlKSkoRnAgfHwge30pLCBqcCA9IC8qIEBfX1BVUkVfXyAqLyAoKGUpID0+IChlLlNMSUNFX01PVVNFT1ZFUiA9IFwicGllLXNsaWNlLW1vdXNlb3ZlclwiLCBlLlNMSUNFX01PVVNFTU9WRSA9IFwicGllLXNsaWNlLW1vdXNlbW92ZVwiLCBlLlNMSUNFX0NMSUNLID0gXCJwaWUtc2xpY2UtY2xpY2tcIiwgZS5TTElDRV9NT1VTRU9VVCA9IFwicGllLXNsaWNlLW1vdXNlb3V0XCIsIGUpKShqcCB8fCB7fSksIFdwID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuQVJDX01PVVNFT1ZFUiA9IFwiZ2F1Z2UtYXJjLW1vdXNlb3ZlclwiLCBlLkFSQ19NT1VTRU1PVkUgPSBcImdhdWdlLWFyYy1tb3VzZW1vdmVcIiwgZS5BUkNfQ0xJQ0sgPSBcImdhdWdlLWFyYy1jbGlja1wiLCBlLkFSQ19NT1VTRU9VVCA9IFwiZ2F1Z2UtYXJjLW1vdXNlb3V0XCIsIGUpKShXcCB8fCB7fSksIHFwID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuQkFSX01PVVNFT1ZFUiA9IFwiYmFyLW1vdXNlb3ZlclwiLCBlLkJBUl9NT1VTRU1PVkUgPSBcImJhci1tb3VzZW1vdmVcIiwgZS5CQVJfQ0xJQ0sgPSBcImJhci1jbGlja1wiLCBlLkJBUl9NT1VTRU9VVCA9IFwiYmFyLW1vdXNlb3V0XCIsIGUpKShxcCB8fCB7fSksIFlwID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuQk9YX01PVVNFT1ZFUiA9IFwiYm94LW1vdXNlb3ZlclwiLCBlLkJPWF9NT1VTRU1PVkUgPSBcImJveC1tb3VzZW1vdmVcIiwgZS5CT1hfQ0xJQ0sgPSBcImJveC1jbGlja1wiLCBlLkJPWF9NT1VTRU9VVCA9IFwiYm94LW1vdXNlb3V0XCIsIGUuT1VUTElFUl9NT1VTRU9WRVIgPSBcIm91dGxpZXItbW91c2VvdmVyXCIsIGUuT1VUTElFUl9NT1VTRU1PVkUgPSBcIm91dGxpZXItbW91c2Vtb3ZlXCIsIGUuT1VUTElFUl9DTElDSyA9IFwib3V0bGllci1jbGlja1wiLCBlLk9VVExJRVJfTU9VU0VPVVQgPSBcIm91dGxpZXItbW91c2VvdXRcIiwgZSkpKFlwIHx8IHt9KSwgWHAgPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZS5TQ0FUVEVSX01PVVNFT1ZFUiA9IFwic2NhdHRlci1tb3VzZW92ZXJcIiwgZS5TQ0FUVEVSX01PVVNFTU9WRSA9IFwic2NhdHRlci1tb3VzZW1vdmVcIiwgZS5TQ0FUVEVSX0NMSUNLID0gXCJzY2F0dGVyLWNsaWNrXCIsIGUuU0NBVFRFUl9NT1VTRU9VVCA9IFwic2NhdHRlci1tb3VzZW91dFwiLCBlKSkoWHAgfHwge30pLCBacCA9IC8qIEBfX1BVUkVfXyAqLyAoKGUpID0+IChlLlBPSU5UX01PVVNFT1ZFUiA9IFwic2NhdHRlci1tb3VzZW92ZXJcIiwgZS5QT0lOVF9NT1VTRU1PVkUgPSBcInNjYXR0ZXItbW91c2Vtb3ZlXCIsIGUuUE9JTlRfQ0xJQ0sgPSBcInNjYXR0ZXItY2xpY2tcIiwgZS5QT0lOVF9NT1VTRU9VVCA9IFwic2NhdHRlci1tb3VzZW91dFwiLCBlKSkoWnAgfHwge30pLCBLcCA9IC8qIEBfX1BVUkVfXyAqLyAoKGUpID0+IChlLlhfQVhJU19NT1VTRU9WRVIgPSBcInJhZGFyLXgtYXhpcy1tb3VzZW92ZXJcIiwgZS5YX0FYSVNfTU9VU0VNT1ZFID0gXCJyYWRhci14LWF4aXMtbW91c2Vtb3ZlXCIsIGUuWF9BWElTX0NMSUNLID0gXCJyYWRhci14LWF4aXMtY2xpY2tcIiwgZS5YX0FYSVNfTU9VU0VPVVQgPSBcInJhZGFyLXgtYXhpcy1tb3VzZW91dFwiLCBlKSkoS3AgfHwge30pLCBRcCA9IC8qIEBfX1BVUkVfXyAqLyAoKGUpID0+IChlLk5PREVfTU9VU0VPVkVSID0gXCJ0cmVlLW5vZGUtbW91c2VvdmVyXCIsIGUuTk9ERV9DTElDSyA9IFwidHJlZS1ub2RlLWNsaWNrXCIsIGUuTk9ERV9NT1VTRU9VVCA9IFwidHJlZS1ub2RlLW1vdXNlb3V0XCIsIGUpKShRcCB8fCB7fSksIEpwID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuTEVBRl9NT1VTRU9WRVIgPSBcImxlYWYtbW91c2VvdmVyXCIsIGUuTEVBRl9NT1VTRU1PVkUgPSBcImxlYWYtbW91c2Vtb3ZlXCIsIGUuTEVBRl9DTElDSyA9IFwibGVhZi1jbGlja1wiLCBlLkxFQUZfTU9VU0VPVVQgPSBcImxlYWYtbW91c2VvdXRcIiwgZSkpKEpwIHx8IHt9KSwgSWkgPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZS5TSE9XID0gXCJzaG93LXRvb2x0aXBcIiwgZS5NT1ZFID0gXCJtb3ZlLXRvb2x0aXBcIiwgZS5ISURFID0gXCJoaWRlLXRvb2x0aXBcIiwgZSkpKElpIHx8IHt9KSwgdGYgPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZS5TSE9XID0gXCJzaG93LXRocmVzaG9sZFwiLCBlLkhJREUgPSBcImhpZGUtdGhyZXNob2xkXCIsIGUpKSh0ZiB8fCB7fSksIGVmID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuSVRFTV9IT1ZFUiA9IFwibGVnZW5kLWl0ZW0tb25ob3ZlclwiLCBlLklURU1fQ0xJQ0sgPSBcImxlZ2VuZC1pdGVtLW9uY2xpY2tcIiwgZS5JVEVNX01PVVNFT1VUID0gXCJsZWdlbmQtaXRlbS1vbm1vdXNlb3V0XCIsIGUuSVRFTVNfVVBEQVRFID0gXCJsZWdlbmQtaXRlbXMtdXBkYXRlXCIsIGUpKShlZiB8fCB7fSksIG5mID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuQ0lSQ0xFX01PVVNFT1ZFUiA9IFwiY2lyY2xlLWxlYWYtbW91c2VvdmVyXCIsIGUuQ0lSQ0xFX0NMSUNLID0gXCJjaXJjbGUtbGVhZi1jbGlja1wiLCBlLkNJUkNMRV9NT1VTRU9VVCA9IFwiY2lyY2xlLWxlYWYtbW91c2VvdXRcIiwgZS5DSVJDTEVfTU9VU0VNT1ZFID0gXCJjaXJjbGUtbGVhZi1tb3VzZW1vdmVcIiwgZSkpKG5mIHx8IHt9KSwgcmYgPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZS5OT0RFX01PVVNFT1ZFUiA9IFwiYWxsdXZpYWwtbm9kZS1tb3VzZW92ZXJcIiwgZS5OT0RFX0NMSUNLID0gXCJhbGx1dmlhbC1ub2RlLWNsaWNrXCIsIGUuTk9ERV9NT1VTRU9VVCA9IFwiYWxsdXZpYWwtbm9kZS1tb3VzZW91dFwiLCBlLk5PREVfTU9VU0VNT1ZFID0gXCJhbGx1dmlhbC1ub2RlLW1vdXNlbW92ZVwiLCBlLkxJTkVfTU9VU0VPVkVSID0gXCJhbGx1dmlhbC1saW5lLW1vdXNlb3ZlclwiLCBlLkxJTkVfQ0xJQ0sgPSBcImFsbHV2aWFsLWxpbmUtY2xpY2tcIiwgZS5MSU5FX01PVVNFT1VUID0gXCJhbGx1dmlhbC1saW5lLW1vdXNlb3V0XCIsIGUuTElORV9NT1VTRU1PVkUgPSBcImFsbHV2aWFsLWxpbmUtbW91c2Vtb3ZlXCIsIGUpKShyZiB8fCB7fSksIHNmID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuTUVURVJfTU9VU0VPVkVSID0gXCJtZXRlci1tb3VzZW92ZXJcIiwgZS5NRVRFUl9DTElDSyA9IFwibWV0ZXItY2xpY2tcIiwgZS5NRVRFUl9NT1VTRU9VVCA9IFwibWV0ZXItbW91c2VvdXRcIiwgZS5NRVRFUl9NT1VTRU1PVkUgPSBcIm1ldGVyLW1vdXNlbW92ZVwiLCBlKSkoc2YgfHwge30pLCBhZiA9IC8qIEBfX1BVUkVfXyAqLyAoKGUpID0+IChlLkhFQVRNQVBfTU9VU0VPVkVSID0gXCJoZWF0bWFwLW1vdXNlb3ZlclwiLCBlLkhFQVRNQVBfQ0xJQ0sgPSBcImhlYXRtYXAtY2xpY2tcIiwgZS5IRUFUTUFQX01PVVNFT1VUID0gXCJoZWF0bWFwLW1vdXNlb3V0XCIsIGUuSEVBVE1BUF9NT1VTRU1PVkUgPSBcImhldG1hcC1tb3VzZW1vdmVcIiwgZSkpKGFmIHx8IHt9KSwgRHIgPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZS5DSE9ST1BMRVRIX01PVVNFT1ZFUiA9IFwiY2hvcm9wbGV0aC1tb3VzZW92ZXJcIiwgZS5DSE9ST1BMRVRIX0NMSUNLID0gXCJjaG9yb3BsZXRoLWNsaWNrXCIsIGUuQ0hPUk9QTEVUSF9NT1VTRU9VVCA9IFwiY2hvcm9wbGV0aC1tb3VzZW91dFwiLCBlLkNIT1JPUExFVEhfTU9VU0VNT1ZFID0gXCJjaG9yb3BsZXRoLW1vdXNlbW92ZVwiLCBlKSkoRHIgfHwge30pO1xuY29uc3QgZDAgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBBbGx1dmlhbDogcmYsXG4gIEFyZWE6IHpwLFxuICBBeGlzOiBHcCxcbiAgQmFyOiBxcCxcbiAgQm94cGxvdDogWXAsXG4gIENhbnZhc1pvb206IFZwLFxuICBDaGFydDogSXAsXG4gIENob3JvcGxldGg6IERyLFxuICBDaXJjbGVQYWNrOiBuZixcbiAgR2F1Z2U6IFdwLFxuICBIZWF0bWFwOiBhZixcbiAgTGVnZW5kOiBlZixcbiAgTGluZTogWnAsXG4gIE1ldGVyOiBzZixcbiAgTW9kYWw6IE5wLFxuICBNb2RlbDogUHAsXG4gIFBpZToganAsXG4gIFJhZGFyOiBLcCxcbiAgU2NhdHRlcjogWHAsXG4gIFRocmVzaG9sZDogdGYsXG4gIFRvb2xiYXI6IFVwLFxuICBUb29sdGlwOiBJaSxcbiAgVHJlZTogUXAsXG4gIFRyZWVtYXA6IEpwLFxuICBXb3JkQ2xvdWQ6IEZwLFxuICBab29tQmFyOiBCcCxcbiAgWm9vbURvbWFpbjogSHBcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIFQgPSBkMDtcbnZhciBydCA9IC8qIEBfX1BVUkVfXyAqLyAoKGUpID0+IChlLkhUTUwgPSBcImh0bWxcIiwgZS5TVkcgPSBcInN2Z1wiLCBlKSkocnQgfHwge30pLCBvZiA9IC8qIEBfX1BVUkVfXyAqLyAoKGUpID0+IChlLldISVRFID0gXCJ3aGl0ZVwiLCBlLkcxMDAgPSBcImcxMDBcIiwgZS5HOTAgPSBcImc5MFwiLCBlLkcxMCA9IFwiZzEwXCIsIGUpKShvZiB8fCB7fSksIGl0ID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuQkFDS0dST1VORCA9IFwiYmFja2dyb3VuZFwiLCBlLkZJTEwgPSBcImZpbGxcIiwgZS5TVFJPS0UgPSBcInN0cm9rZVwiLCBlLlRPT0xUSVAgPSBcInRvb2x0aXBcIiwgZSkpKGl0IHx8IHt9KSwgRyA9IC8qIEBfX1BVUkVfXyAqLyAoKGUpID0+IChlLkxFRlQgPSBcImxlZnRcIiwgZS5SSUdIVCA9IFwicmlnaHRcIiwgZS5UT1AgPSBcInRvcFwiLCBlLkJPVFRPTSA9IFwiYm90dG9tXCIsIGUpKShHIHx8IHt9KSwgS2UgPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZS5HUkFQSF9WSUVXID0gXCJncmFwaF92aWV3XCIsIGUuU0xJREVSX1ZJRVcgPSBcInNsaWRlcl92aWV3XCIsIGUpKShLZSB8fCB7fSksIFZlID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuRU5EX0xJTkUgPSBcImVuZF9saW5lXCIsIGUuTUlEX0xJTkUgPSBcIm1pZF9saW5lXCIsIGUuRlJPTlRfTElORSA9IFwiZnJvbnRfbGluZVwiLCBlLk5PTkUgPSBcIm5vbmVcIiwgZSkpKFZlIHx8IHt9KSwgRnQgPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZS5WRVJUSUNBTCA9IFwidmVydGljYWxcIiwgZS5IT1JJWk9OVEFMID0gXCJob3Jpem9udGFsXCIsIGUpKShGdCB8fCB7fSksIGV0ID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuVElNRSA9IFwidGltZVwiLCBlLkxJTkVBUiA9IFwibGluZWFyXCIsIGUuTE9HID0gXCJsb2dcIiwgZS5MQUJFTFMgPSBcImxhYmVsc1wiLCBlLkxBQkVMU19SQVRJTyA9IFwibGFiZWxzLXJhdGlvXCIsIGUpKShldCB8fCB7fSksIE5pID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuUklHSFQgPSBcInJpZ2h0XCIsIGUuTEVGVCA9IFwibGVmdFwiLCBlLlRPUCA9IFwidG9wXCIsIGUuQk9UVE9NID0gXCJib3R0b21cIiwgZSkpKE5pIHx8IHt9KSwganQgPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZS5MRUZUID0gXCJsZWZ0XCIsIGUuQ0VOVEVSID0gXCJjZW50ZXJcIiwgZS5SSUdIVCA9IFwicmlnaHRcIiwgZSkpKGp0IHx8IHt9KSwgamkgPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZS5IT1JJWk9OVEFMID0gXCJob3Jpem9udGFsXCIsIGUuVkVSVElDQUwgPSBcInZlcnRpY2FsXCIsIGUpKShqaSB8fCB7fSksIHBjID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuVFJFRSA9IFwidHJlZVwiLCBlLkRFTkRST0dSQU0gPSBcImRlbmRyb2dyYW1cIiwgZSkpKHBjIHx8IHt9KSwgQXQgPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZS5ST1cgPSBcInJvd1wiLCBlLkNPTFVNTiA9IFwiY29sdW1uXCIsIGUuUk9XX1JFVkVSU0UgPSBcInJvdy1yZXZlcnNlXCIsIGUuQ09MVU1OX1JFVkVSU0UgPSBcImNvbHVtbi1yZXZlcnNlXCIsIGUpKShBdCB8fCB7fSksIGN0ID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuRklYRUQgPSBcImZpeGVkXCIsIGUuUFJFRkVSUkVEID0gXCJwcmVmZXJyZWRcIiwgZS5TVFJFVENIID0gXCJzdHJldGNoXCIsIGUpKShjdCB8fCB7fSksIG5pID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuQ0VOVEVSID0gXCJjZW50ZXJcIiwgZSkpKG5pIHx8IHt9KSwgRnMgPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZS5MRUZUID0gXCJsZWZ0XCIsIGUuUklHSFQgPSBcInJpZ2h0XCIsIGUpKShGcyB8fCB7fSksIHp0ID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuR1JJRCA9IFwiZ3JpZFwiLCBlLlZFUlRfT1JfSE9SSVogPSBcInZlcnRPckhvcml6XCIsIGUuUElFID0gXCJwaWVcIiwgZS5ET05VVCA9IFwiZG9udXRcIiwgZSkpKHp0IHx8IHt9KSwgZG4gPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZS5TVEFSVCA9IFwic3RhcnRcIiwgZS5NSURETEUgPSBcIm1pZGRsZVwiLCBlLkVORCA9IFwiZW5kXCIsIGUpKShkbiB8fCB7fSksIHBuID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuQkFTRUxJTkUgPSBcImJhc2VsaW5lXCIsIGUuTUlERExFID0gXCJtaWRkbGVcIiwgZS5IQU5HSU5HID0gXCJoYW5naW5nXCIsIGUpKShwbiB8fCB7fSksIFJyID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuU0VNSSA9IFwic2VtaVwiLCBlLkZVTEwgPSBcImZ1bGxcIiwgZSkpKFJyIHx8IHt9KSwgcGwgPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZS5VUCA9IFwidXBcIiwgZS5ET1dOID0gXCJkb3duXCIsIGUpKShwbCB8fCB7fSksIGpzID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuU1VDQ0VTUyA9IFwic3VjY2Vzc1wiLCBlLldBUk5JTkcgPSBcIndhcm5pbmdcIiwgZS5EQU5HRVIgPSBcImRhbmdlclwiLCBlKSkoanMgfHwge30pLCBXcyA9IC8qIEBfX1BVUkVfXyAqLyAoKGUpID0+IChlLkFMV0FZUyA9IFwiYWx3YXlzXCIsIGUuQVVUTyA9IFwiYXV0b1wiLCBlLk5FVkVSID0gXCJuZXZlclwiLCBlKSkoV3MgfHwge30pLCB3ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKGUpID0+IChlLlNDQVRURVIgPSBcInNjYXR0ZXJcIiwgZS5MSU5FID0gXCJsaW5lXCIsIGUuU0lNUExFX0JBUiA9IFwic2ltcGxlLWJhclwiLCBlLlNUQUNLRURfQkFSID0gXCJzdGFja2VkLWJhclwiLCBlLkdST1VQRURfQkFSID0gXCJncm91cGVkLWJhclwiLCBlLkFSRUEgPSBcImFyZWFcIiwgZS5TVEFDS0VEX0FSRUEgPSBcInN0YWNrZWQtYXJlYVwiLCBlKSkod2UgfHwge30pLCBfdCA9IC8qIEBfX1BVUkVfXyAqLyAoKGUpID0+IChlLkVYUE9SVF9DU1YgPSBcIkV4cG9ydCBhcyBDU1ZcIiwgZS5FWFBPUlRfUE5HID0gXCJFeHBvcnQgYXMgUE5HXCIsIGUuRVhQT1JUX0pQRyA9IFwiRXhwb3J0IGFzIEpQR1wiLCBlLlpPT01fSU4gPSBcIlpvb20gaW5cIiwgZS5aT09NX09VVCA9IFwiWm9vbSBvdXRcIiwgZS5SRVNFVF9aT09NID0gXCJSZXNldCB6b29tXCIsIGUuTUFLRV9GVUxMU0NSRUVOID0gXCJNYWtlIGZ1bGxzY3JlZW5cIiwgZS5FWElUX0ZVTExTQ1JFRU4gPSBcIkV4aXQgZnVsbHNjcmVlblwiLCBlLlNIT1dfQVNfREFUQVRBQkxFID0gXCJTaG93IGFzIGRhdGEtdGFibGVcIiwgZS5DVVNUT00gPSBcIkN1c3RvbVwiLCBlKSkoX3QgfHwge30pLCBmbCA9IC8qIEBfX1BVUkVfXyAqLyAoKGUpID0+IChlLkxFRlQgPSBcImxlZnRcIiwgZS5SSUdIVCA9IFwicmlnaHRcIiwgZSkpKGZsIHx8IHt9KSwgR3QgPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZS5DSEVDS0JPWCA9IFwiY2hlY2tib3hcIiwgZS5SQURJVVMgPSBcInJhZGl1c1wiLCBlLkFSRUEgPSBcImFyZWFcIiwgZS5TSVpFID0gXCJzaXplXCIsIGUuTElORSA9IFwibGluZVwiLCBlLlFVQVJUSUxFID0gXCJxdWFydGlsZVwiLCBlLlpPT00gPSBcInpvb21cIiwgZSkpKEd0IHx8IHt9KSwgcXMgPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZS5MSU5FQVIgPSBcImxpbmVhclwiLCBlLlFVQU5USVpFID0gXCJxdWFudGl6ZVwiLCBlKSkocXMgfHwge30pLCBQaSA9IC8qIEBfX1BVUkVfXyAqLyAoKGUpID0+IChlLk9OID0gXCJvblwiLCBlLkFVVE8gPSBcImF1dG9cIiwgZS5PRkYgPSBcIm9mZlwiLCBlKSkoUGkgfHwge30pLCBHYSA9IC8qIEBfX1BVUkVfXyAqLyAoKGUpID0+IChlLkRFRkFVTFQgPSBcImRlZmF1bHRcIiwgZS5IT1ZFUkFCTEUgPSBcImhvdmVyYWJsZVwiLCBlKSkoR2EgfHwge30pLCBnbiA9IC8qIEBfX1BVUkVfXyAqLyAoKGUpID0+IChlLmdlb0VxdWFsRWFydGggPSBcImdlb0VxdWFsRWFydGhcIiwgZS5nZW9BbGJlcnMgPSBcImdlb0FsYmVyc1wiLCBlLmdlb0NvbmljRXF1YWxBcmVhID0gXCJnZW9Db25pY0VxdWFsQXJlYVwiLCBlLmdlb0NvbmljRXF1aWRpc3RhbnQgPSBcImdlb0NvbmljRXF1aWRpc3RhbnRcIiwgZS5nZW9FcXVpcmVjdGFuZ3VsYXIgPSBcImdlb0VxdWlyZWN0YW5ndWxhclwiLCBlLmdlb01lcmNhdG9yID0gXCJnZW9NZXJjYXRvclwiLCBlLmdlb05hdHVyYWxFYXJ0aDEgPSBcImdlb05hdHVyYWxFYXJ0aDFcIiwgZSkpKGduIHx8IHt9KSwgbGYgPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZVtcIjE1c2Vjb25kc1wiXSA9IFwiMTVzZWNvbmRzXCIsIGUubWludXRlID0gXCJtaW51dGVcIiwgZVtcIjMwbWludXRlc1wiXSA9IFwiMzBtaW51dGVzXCIsIGUuaG91cmx5ID0gXCJob3VybHlcIiwgZS5kYWlseSA9IFwiZGFpbHlcIiwgZS53ZWVrbHkgPSBcIndlZWtseVwiLCBlLm1vbnRobHkgPSBcIm1vbnRobHlcIiwgZS5xdWFydGVybHkgPSBcInF1YXJ0ZXJseVwiLCBlLnllYXJseSA9IFwieWVhcmx5XCIsIGUpKShsZiB8fCB7fSk7XG5mdW5jdGlvbiBUbyhlKSB7XG4gIHJldHVybiAodCA9IHt9KSA9PiB7XG4gICAgY29uc3QgbiA9IHQud2lkdGggPyBTdHJpbmcodC53aWR0aCkgOiBlLmRlZmF1bHRXaWR0aDtcbiAgICByZXR1cm4gZS5mb3JtYXRzW25dIHx8IGUuZm9ybWF0c1tlLmRlZmF1bHRXaWR0aF07XG4gIH07XG59XG5mdW5jdGlvbiB1aShlKSB7XG4gIHJldHVybiAodCwgbikgPT4ge1xuICAgIGNvbnN0IHIgPSBuICE9IG51bGwgJiYgbi5jb250ZXh0ID8gU3RyaW5nKG4uY29udGV4dCkgOiBcInN0YW5kYWxvbmVcIjtcbiAgICBsZXQgaTtcbiAgICBpZiAociA9PT0gXCJmb3JtYXR0aW5nXCIgJiYgZS5mb3JtYXR0aW5nVmFsdWVzKSB7XG4gICAgICBjb25zdCBhID0gZS5kZWZhdWx0Rm9ybWF0dGluZ1dpZHRoIHx8IGUuZGVmYXVsdFdpZHRoLCBvID0gbiAhPSBudWxsICYmIG4ud2lkdGggPyBTdHJpbmcobi53aWR0aCkgOiBhO1xuICAgICAgaSA9IGUuZm9ybWF0dGluZ1ZhbHVlc1tvXSB8fCBlLmZvcm1hdHRpbmdWYWx1ZXNbYV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGEgPSBlLmRlZmF1bHRXaWR0aCwgbyA9IG4gIT0gbnVsbCAmJiBuLndpZHRoID8gU3RyaW5nKG4ud2lkdGgpIDogZS5kZWZhdWx0V2lkdGg7XG4gICAgICBpID0gZS52YWx1ZXNbb10gfHwgZS52YWx1ZXNbYV07XG4gICAgfVxuICAgIGNvbnN0IHMgPSBlLmFyZ3VtZW50Q2FsbGJhY2sgPyBlLmFyZ3VtZW50Q2FsbGJhY2sodCkgOiB0O1xuICAgIHJldHVybiBpW3NdO1xuICB9O1xufVxuZnVuY3Rpb24gaGkoZSkge1xuICByZXR1cm4gKHQsIG4gPSB7fSkgPT4ge1xuICAgIGNvbnN0IHIgPSBuLndpZHRoLCBpID0gciAmJiBlLm1hdGNoUGF0dGVybnNbcl0gfHwgZS5tYXRjaFBhdHRlcm5zW2UuZGVmYXVsdE1hdGNoV2lkdGhdLCBzID0gdC5tYXRjaChpKTtcbiAgICBpZiAoIXMpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBhID0gc1swXSwgbyA9IHIgJiYgZS5wYXJzZVBhdHRlcm5zW3JdIHx8IGUucGFyc2VQYXR0ZXJuc1tlLmRlZmF1bHRQYXJzZVdpZHRoXSwgbCA9IEFycmF5LmlzQXJyYXkobykgPyBmMChvLCAoZCkgPT4gZC50ZXN0KGEpKSA6IChcbiAgICAgIC8vIFtUT0RPXSAtLSBJIGNoYWxsZW5nZSB5b3UgdG8gZml4IHRoZSB0eXBlXG4gICAgICBwMChvLCAoZCkgPT4gZC50ZXN0KGEpKVxuICAgICk7XG4gICAgbGV0IGM7XG4gICAgYyA9IGUudmFsdWVDYWxsYmFjayA/IGUudmFsdWVDYWxsYmFjayhsKSA6IGwsIGMgPSBuLnZhbHVlQ2FsbGJhY2sgPyAoXG4gICAgICAvLyBbVE9ET10gLS0gSSBjaGFsbGVuZ2UgeW91IHRvIGZpeCB0aGUgdHlwZVxuICAgICAgbi52YWx1ZUNhbGxiYWNrKGMpXG4gICAgKSA6IGM7XG4gICAgY29uc3QgdSA9IHQuc2xpY2UoYS5sZW5ndGgpO1xuICAgIHJldHVybiB7IHZhbHVlOiBjLCByZXN0OiB1IH07XG4gIH07XG59XG5mdW5jdGlvbiBwMChlLCB0KSB7XG4gIGZvciAoY29uc3QgbiBpbiBlKVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwgbikgJiYgdChlW25dKSlcbiAgICAgIHJldHVybiBuO1xufVxuZnVuY3Rpb24gZjAoZSwgdCkge1xuICBmb3IgKGxldCBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspXG4gICAgaWYgKHQoZVtuXSkpXG4gICAgICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIG0wKGUpIHtcbiAgcmV0dXJuICh0LCBuID0ge30pID0+IHtcbiAgICBjb25zdCByID0gdC5tYXRjaChlLm1hdGNoUGF0dGVybik7XG4gICAgaWYgKCFyKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBpID0gclswXSwgcyA9IHQubWF0Y2goZS5wYXJzZVBhdHRlcm4pO1xuICAgIGlmICghcykgcmV0dXJuIG51bGw7XG4gICAgbGV0IGEgPSBlLnZhbHVlQ2FsbGJhY2sgPyBlLnZhbHVlQ2FsbGJhY2soc1swXSkgOiBzWzBdO1xuICAgIGEgPSBuLnZhbHVlQ2FsbGJhY2sgPyBuLnZhbHVlQ2FsbGJhY2soYSkgOiBhO1xuICAgIGNvbnN0IG8gPSB0LnNsaWNlKGkubGVuZ3RoKTtcbiAgICByZXR1cm4geyB2YWx1ZTogYSwgcmVzdDogbyB9O1xuICB9O1xufVxuY29uc3QgY2YgPSA2MDQ4ZTUsIGcwID0gODY0ZTUsIHVmID0gNmU0LCBoZiA9IDM2ZTUsIFJ1ID0gU3ltYm9sLmZvcihcImNvbnN0cnVjdERhdGVGcm9tXCIpO1xuZnVuY3Rpb24gTGUoZSwgdCkge1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZSh0KSA6IGUgJiYgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBSdSBpbiBlID8gZVtSdV0odCkgOiBlIGluc3RhbmNlb2YgRGF0ZSA/IG5ldyBlLmNvbnN0cnVjdG9yKHQpIDogbmV3IERhdGUodCk7XG59XG5mdW5jdGlvbiB1cihlLCAuLi50KSB7XG4gIGNvbnN0IG4gPSBMZS5iaW5kKFxuICAgIG51bGwsXG4gICAgdC5maW5kKChyKSA9PiB0eXBlb2YgciA9PSBcIm9iamVjdFwiKVxuICApO1xuICByZXR1cm4gdC5tYXAobik7XG59XG5sZXQgdjAgPSB7fTtcbmZ1bmN0aW9uIHphKCkge1xuICByZXR1cm4gdjA7XG59XG5mdW5jdGlvbiBIdChlLCB0KSB7XG4gIHJldHVybiBMZSh0IHx8IGUsIGUpO1xufVxuZnVuY3Rpb24gV2koZSwgdCkge1xuICB2YXIgbiwgciwgaSwgcztcbiAgY29uc3QgYSA9IHphKCksIG8gPSAodCA9PSBudWxsID8gdm9pZCAwIDogdC53ZWVrU3RhcnRzT24pID8/ICgociA9IChuID0gdCA9PSBudWxsID8gdm9pZCAwIDogdC5sb2NhbGUpID09IG51bGwgPyB2b2lkIDAgOiBuLm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiByLndlZWtTdGFydHNPbikgPz8gYS53ZWVrU3RhcnRzT24gPz8gKChzID0gKGkgPSBhLmxvY2FsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGkub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IHMud2Vla1N0YXJ0c09uKSA/PyAwLCBsID0gSHQoZSwgdCA9PSBudWxsID8gdm9pZCAwIDogdC5pbiksIGMgPSBsLmdldERheSgpLCB1ID0gKGMgPCBvID8gNyA6IDApICsgYyAtIG87XG4gIHJldHVybiBsLnNldERhdGUobC5nZXREYXRlKCkgLSB1KSwgbC5zZXRIb3VycygwLCAwLCAwLCAwKSwgbDtcbn1cbmNvbnN0IHkwID0ge1xuICBsZXNzVGhhblhTZWNvbmRzOiB7XG4gICAgb25lOiBcImxlc3MgdGhhbiBhIHNlY29uZFwiLFxuICAgIG90aGVyOiBcImxlc3MgdGhhbiB7e2NvdW50fX0gc2Vjb25kc1wiXG4gIH0sXG4gIHhTZWNvbmRzOiB7XG4gICAgb25lOiBcIjEgc2Vjb25kXCIsXG4gICAgb3RoZXI6IFwie3tjb3VudH19IHNlY29uZHNcIlxuICB9LFxuICBoYWxmQU1pbnV0ZTogXCJoYWxmIGEgbWludXRlXCIsXG4gIGxlc3NUaGFuWE1pbnV0ZXM6IHtcbiAgICBvbmU6IFwibGVzcyB0aGFuIGEgbWludXRlXCIsXG4gICAgb3RoZXI6IFwibGVzcyB0aGFuIHt7Y291bnR9fSBtaW51dGVzXCJcbiAgfSxcbiAgeE1pbnV0ZXM6IHtcbiAgICBvbmU6IFwiMSBtaW51dGVcIixcbiAgICBvdGhlcjogXCJ7e2NvdW50fX0gbWludXRlc1wiXG4gIH0sXG4gIGFib3V0WEhvdXJzOiB7XG4gICAgb25lOiBcImFib3V0IDEgaG91clwiLFxuICAgIG90aGVyOiBcImFib3V0IHt7Y291bnR9fSBob3Vyc1wiXG4gIH0sXG4gIHhIb3Vyczoge1xuICAgIG9uZTogXCIxIGhvdXJcIixcbiAgICBvdGhlcjogXCJ7e2NvdW50fX0gaG91cnNcIlxuICB9LFxuICB4RGF5czoge1xuICAgIG9uZTogXCIxIGRheVwiLFxuICAgIG90aGVyOiBcInt7Y291bnR9fSBkYXlzXCJcbiAgfSxcbiAgYWJvdXRYV2Vla3M6IHtcbiAgICBvbmU6IFwiYWJvdXQgMSB3ZWVrXCIsXG4gICAgb3RoZXI6IFwiYWJvdXQge3tjb3VudH19IHdlZWtzXCJcbiAgfSxcbiAgeFdlZWtzOiB7XG4gICAgb25lOiBcIjEgd2Vla1wiLFxuICAgIG90aGVyOiBcInt7Y291bnR9fSB3ZWVrc1wiXG4gIH0sXG4gIGFib3V0WE1vbnRoczoge1xuICAgIG9uZTogXCJhYm91dCAxIG1vbnRoXCIsXG4gICAgb3RoZXI6IFwiYWJvdXQge3tjb3VudH19IG1vbnRoc1wiXG4gIH0sXG4gIHhNb250aHM6IHtcbiAgICBvbmU6IFwiMSBtb250aFwiLFxuICAgIG90aGVyOiBcInt7Y291bnR9fSBtb250aHNcIlxuICB9LFxuICBhYm91dFhZZWFyczoge1xuICAgIG9uZTogXCJhYm91dCAxIHllYXJcIixcbiAgICBvdGhlcjogXCJhYm91dCB7e2NvdW50fX0geWVhcnNcIlxuICB9LFxuICB4WWVhcnM6IHtcbiAgICBvbmU6IFwiMSB5ZWFyXCIsXG4gICAgb3RoZXI6IFwie3tjb3VudH19IHllYXJzXCJcbiAgfSxcbiAgb3ZlclhZZWFyczoge1xuICAgIG9uZTogXCJvdmVyIDEgeWVhclwiLFxuICAgIG90aGVyOiBcIm92ZXIge3tjb3VudH19IHllYXJzXCJcbiAgfSxcbiAgYWxtb3N0WFllYXJzOiB7XG4gICAgb25lOiBcImFsbW9zdCAxIHllYXJcIixcbiAgICBvdGhlcjogXCJhbG1vc3Qge3tjb3VudH19IHllYXJzXCJcbiAgfVxufSwgeDAgPSAoZSwgdCwgbikgPT4ge1xuICBsZXQgcjtcbiAgY29uc3QgaSA9IHkwW2VdO1xuICByZXR1cm4gdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiA/IHIgPSBpIDogdCA9PT0gMSA/IHIgPSBpLm9uZSA6IHIgPSBpLm90aGVyLnJlcGxhY2UoXCJ7e2NvdW50fX1cIiwgdC50b1N0cmluZygpKSwgbiAhPSBudWxsICYmIG4uYWRkU3VmZml4ID8gbi5jb21wYXJpc29uICYmIG4uY29tcGFyaXNvbiA+IDAgPyBcImluIFwiICsgciA6IHIgKyBcIiBhZ29cIiA6IHI7XG59LCBiMCA9IHtcbiAgbGFzdFdlZWs6IFwiJ2xhc3QnIGVlZWUgJ2F0JyBwXCIsXG4gIHllc3RlcmRheTogXCIneWVzdGVyZGF5IGF0JyBwXCIsXG4gIHRvZGF5OiBcIid0b2RheSBhdCcgcFwiLFxuICB0b21vcnJvdzogXCIndG9tb3Jyb3cgYXQnIHBcIixcbiAgbmV4dFdlZWs6IFwiZWVlZSAnYXQnIHBcIixcbiAgb3RoZXI6IFwiUFwiXG59LCBfMCA9IChlLCB0LCBuLCByKSA9PiBiMFtlXSwgRTAgPSB7XG4gIG5hcnJvdzogW1wiQlwiLCBcIkFcIl0sXG4gIGFiYnJldmlhdGVkOiBbXCJCQ1wiLCBcIkFEXCJdLFxuICB3aWRlOiBbXCJCZWZvcmUgQ2hyaXN0XCIsIFwiQW5ubyBEb21pbmlcIl1cbn0sIE8wID0ge1xuICBuYXJyb3c6IFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIl0sXG4gIGFiYnJldmlhdGVkOiBbXCJRMVwiLCBcIlEyXCIsIFwiUTNcIiwgXCJRNFwiXSxcbiAgd2lkZTogW1wiMXN0IHF1YXJ0ZXJcIiwgXCIybmQgcXVhcnRlclwiLCBcIjNyZCBxdWFydGVyXCIsIFwiNHRoIHF1YXJ0ZXJcIl1cbn0sIFMwID0ge1xuICBuYXJyb3c6IFtcIkpcIiwgXCJGXCIsIFwiTVwiLCBcIkFcIiwgXCJNXCIsIFwiSlwiLCBcIkpcIiwgXCJBXCIsIFwiU1wiLCBcIk9cIiwgXCJOXCIsIFwiRFwiXSxcbiAgYWJicmV2aWF0ZWQ6IFtcbiAgICBcIkphblwiLFxuICAgIFwiRmViXCIsXG4gICAgXCJNYXJcIixcbiAgICBcIkFwclwiLFxuICAgIFwiTWF5XCIsXG4gICAgXCJKdW5cIixcbiAgICBcIkp1bFwiLFxuICAgIFwiQXVnXCIsXG4gICAgXCJTZXBcIixcbiAgICBcIk9jdFwiLFxuICAgIFwiTm92XCIsXG4gICAgXCJEZWNcIlxuICBdLFxuICB3aWRlOiBbXG4gICAgXCJKYW51YXJ5XCIsXG4gICAgXCJGZWJydWFyeVwiLFxuICAgIFwiTWFyY2hcIixcbiAgICBcIkFwcmlsXCIsXG4gICAgXCJNYXlcIixcbiAgICBcIkp1bmVcIixcbiAgICBcIkp1bHlcIixcbiAgICBcIkF1Z3VzdFwiLFxuICAgIFwiU2VwdGVtYmVyXCIsXG4gICAgXCJPY3RvYmVyXCIsXG4gICAgXCJOb3ZlbWJlclwiLFxuICAgIFwiRGVjZW1iZXJcIlxuICBdXG59LCBUMCA9IHtcbiAgbmFycm93OiBbXCJTXCIsIFwiTVwiLCBcIlRcIiwgXCJXXCIsIFwiVFwiLCBcIkZcIiwgXCJTXCJdLFxuICBzaG9ydDogW1wiU3VcIiwgXCJNb1wiLCBcIlR1XCIsIFwiV2VcIiwgXCJUaFwiLCBcIkZyXCIsIFwiU2FcIl0sXG4gIGFiYnJldmlhdGVkOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gIHdpZGU6IFtcbiAgICBcIlN1bmRheVwiLFxuICAgIFwiTW9uZGF5XCIsXG4gICAgXCJUdWVzZGF5XCIsXG4gICAgXCJXZWRuZXNkYXlcIixcbiAgICBcIlRodXJzZGF5XCIsXG4gICAgXCJGcmlkYXlcIixcbiAgICBcIlNhdHVyZGF5XCJcbiAgXVxufSwgdzAgPSB7XG4gIG5hcnJvdzoge1xuICAgIGFtOiBcImFcIixcbiAgICBwbTogXCJwXCIsXG4gICAgbWlkbmlnaHQ6IFwibWlcIixcbiAgICBub29uOiBcIm5cIixcbiAgICBtb3JuaW5nOiBcIm1vcm5pbmdcIixcbiAgICBhZnRlcm5vb246IFwiYWZ0ZXJub29uXCIsXG4gICAgZXZlbmluZzogXCJldmVuaW5nXCIsXG4gICAgbmlnaHQ6IFwibmlnaHRcIlxuICB9LFxuICBhYmJyZXZpYXRlZDoge1xuICAgIGFtOiBcIkFNXCIsXG4gICAgcG06IFwiUE1cIixcbiAgICBtaWRuaWdodDogXCJtaWRuaWdodFwiLFxuICAgIG5vb246IFwibm9vblwiLFxuICAgIG1vcm5pbmc6IFwibW9ybmluZ1wiLFxuICAgIGFmdGVybm9vbjogXCJhZnRlcm5vb25cIixcbiAgICBldmVuaW5nOiBcImV2ZW5pbmdcIixcbiAgICBuaWdodDogXCJuaWdodFwiXG4gIH0sXG4gIHdpZGU6IHtcbiAgICBhbTogXCJhLm0uXCIsXG4gICAgcG06IFwicC5tLlwiLFxuICAgIG1pZG5pZ2h0OiBcIm1pZG5pZ2h0XCIsXG4gICAgbm9vbjogXCJub29uXCIsXG4gICAgbW9ybmluZzogXCJtb3JuaW5nXCIsXG4gICAgYWZ0ZXJub29uOiBcImFmdGVybm9vblwiLFxuICAgIGV2ZW5pbmc6IFwiZXZlbmluZ1wiLFxuICAgIG5pZ2h0OiBcIm5pZ2h0XCJcbiAgfVxufSwgJDAgPSB7XG4gIG5hcnJvdzoge1xuICAgIGFtOiBcImFcIixcbiAgICBwbTogXCJwXCIsXG4gICAgbWlkbmlnaHQ6IFwibWlcIixcbiAgICBub29uOiBcIm5cIixcbiAgICBtb3JuaW5nOiBcImluIHRoZSBtb3JuaW5nXCIsXG4gICAgYWZ0ZXJub29uOiBcImluIHRoZSBhZnRlcm5vb25cIixcbiAgICBldmVuaW5nOiBcImluIHRoZSBldmVuaW5nXCIsXG4gICAgbmlnaHQ6IFwiYXQgbmlnaHRcIlxuICB9LFxuICBhYmJyZXZpYXRlZDoge1xuICAgIGFtOiBcIkFNXCIsXG4gICAgcG06IFwiUE1cIixcbiAgICBtaWRuaWdodDogXCJtaWRuaWdodFwiLFxuICAgIG5vb246IFwibm9vblwiLFxuICAgIG1vcm5pbmc6IFwiaW4gdGhlIG1vcm5pbmdcIixcbiAgICBhZnRlcm5vb246IFwiaW4gdGhlIGFmdGVybm9vblwiLFxuICAgIGV2ZW5pbmc6IFwiaW4gdGhlIGV2ZW5pbmdcIixcbiAgICBuaWdodDogXCJhdCBuaWdodFwiXG4gIH0sXG4gIHdpZGU6IHtcbiAgICBhbTogXCJhLm0uXCIsXG4gICAgcG06IFwicC5tLlwiLFxuICAgIG1pZG5pZ2h0OiBcIm1pZG5pZ2h0XCIsXG4gICAgbm9vbjogXCJub29uXCIsXG4gICAgbW9ybmluZzogXCJpbiB0aGUgbW9ybmluZ1wiLFxuICAgIGFmdGVybm9vbjogXCJpbiB0aGUgYWZ0ZXJub29uXCIsXG4gICAgZXZlbmluZzogXCJpbiB0aGUgZXZlbmluZ1wiLFxuICAgIG5pZ2h0OiBcImF0IG5pZ2h0XCJcbiAgfVxufSwgTTAgPSAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gTnVtYmVyKGUpLCByID0gbiAlIDEwMDtcbiAgaWYgKHIgPiAyMCB8fCByIDwgMTApXG4gICAgc3dpdGNoIChyICUgMTApIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIG4gKyBcInN0XCI7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBuICsgXCJuZFwiO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gbiArIFwicmRcIjtcbiAgICB9XG4gIHJldHVybiBuICsgXCJ0aFwiO1xufSwgQzAgPSB7XG4gIG9yZGluYWxOdW1iZXI6IE0wLFxuICBlcmE6IHVpKHtcbiAgICB2YWx1ZXM6IEUwLFxuICAgIGRlZmF1bHRXaWR0aDogXCJ3aWRlXCJcbiAgfSksXG4gIHF1YXJ0ZXI6IHVpKHtcbiAgICB2YWx1ZXM6IE8wLFxuICAgIGRlZmF1bHRXaWR0aDogXCJ3aWRlXCIsXG4gICAgYXJndW1lbnRDYWxsYmFjazogKGUpID0+IGUgLSAxXG4gIH0pLFxuICBtb250aDogdWkoe1xuICAgIHZhbHVlczogUzAsXG4gICAgZGVmYXVsdFdpZHRoOiBcIndpZGVcIlxuICB9KSxcbiAgZGF5OiB1aSh7XG4gICAgdmFsdWVzOiBUMCxcbiAgICBkZWZhdWx0V2lkdGg6IFwid2lkZVwiXG4gIH0pLFxuICBkYXlQZXJpb2Q6IHVpKHtcbiAgICB2YWx1ZXM6IHcwLFxuICAgIGRlZmF1bHRXaWR0aDogXCJ3aWRlXCIsXG4gICAgZm9ybWF0dGluZ1ZhbHVlczogJDAsXG4gICAgZGVmYXVsdEZvcm1hdHRpbmdXaWR0aDogXCJ3aWRlXCJcbiAgfSlcbn0sIEEwID0gL14oXFxkKykodGh8c3R8bmR8cmQpPy9pLCBMMCA9IC9cXGQrL2ksIGswID0ge1xuICBuYXJyb3c6IC9eKGJ8YSkvaSxcbiAgYWJicmV2aWF0ZWQ6IC9eKGJcXC4/XFxzP2NcXC4/fGJcXC4/XFxzP2NcXC4/XFxzP2VcXC4/fGFcXC4/XFxzP2RcXC4/fGNcXC4/XFxzP2VcXC4/KS9pLFxuICB3aWRlOiAvXihiZWZvcmUgY2hyaXN0fGJlZm9yZSBjb21tb24gZXJhfGFubm8gZG9taW5pfGNvbW1vbiBlcmEpL2lcbn0sIEQwID0ge1xuICBhbnk6IFsvXmIvaSwgL14oYXxjKS9pXVxufSwgUjAgPSB7XG4gIG5hcnJvdzogL15bMTIzNF0vaSxcbiAgYWJicmV2aWF0ZWQ6IC9ecVsxMjM0XS9pLFxuICB3aWRlOiAvXlsxMjM0XSh0aHxzdHxuZHxyZCk/IHF1YXJ0ZXIvaVxufSwgSTAgPSB7XG4gIGFueTogWy8xL2ksIC8yL2ksIC8zL2ksIC80L2ldXG59LCBOMCA9IHtcbiAgbmFycm93OiAvXltqZm1hc29uZF0vaSxcbiAgYWJicmV2aWF0ZWQ6IC9eKGphbnxmZWJ8bWFyfGFwcnxtYXl8anVufGp1bHxhdWd8c2VwfG9jdHxub3Z8ZGVjKS9pLFxuICB3aWRlOiAvXihqYW51YXJ5fGZlYnJ1YXJ5fG1hcmNofGFwcmlsfG1heXxqdW5lfGp1bHl8YXVndXN0fHNlcHRlbWJlcnxvY3RvYmVyfG5vdmVtYmVyfGRlY2VtYmVyKS9pXG59LCBQMCA9IHtcbiAgbmFycm93OiBbXG4gICAgL15qL2ksXG4gICAgL15mL2ksXG4gICAgL15tL2ksXG4gICAgL15hL2ksXG4gICAgL15tL2ksXG4gICAgL15qL2ksXG4gICAgL15qL2ksXG4gICAgL15hL2ksXG4gICAgL15zL2ksXG4gICAgL15vL2ksXG4gICAgL15uL2ksXG4gICAgL15kL2lcbiAgXSxcbiAgYW55OiBbXG4gICAgL15qYS9pLFxuICAgIC9eZi9pLFxuICAgIC9ebWFyL2ksXG4gICAgL15hcC9pLFxuICAgIC9ebWF5L2ksXG4gICAgL15qdW4vaSxcbiAgICAvXmp1bC9pLFxuICAgIC9eYXUvaSxcbiAgICAvXnMvaSxcbiAgICAvXm8vaSxcbiAgICAvXm4vaSxcbiAgICAvXmQvaVxuICBdXG59LCBVMCA9IHtcbiAgbmFycm93OiAvXltzbXR3Zl0vaSxcbiAgc2hvcnQ6IC9eKHN1fG1vfHR1fHdlfHRofGZyfHNhKS9pLFxuICBhYmJyZXZpYXRlZDogL14oc3VufG1vbnx0dWV8d2VkfHRodXxmcml8c2F0KS9pLFxuICB3aWRlOiAvXihzdW5kYXl8bW9uZGF5fHR1ZXNkYXl8d2VkbmVzZGF5fHRodXJzZGF5fGZyaWRheXxzYXR1cmRheSkvaVxufSwgQjAgPSB7XG4gIG5hcnJvdzogWy9ecy9pLCAvXm0vaSwgL150L2ksIC9edy9pLCAvXnQvaSwgL15mL2ksIC9ecy9pXSxcbiAgYW55OiBbL15zdS9pLCAvXm0vaSwgL150dS9pLCAvXncvaSwgL150aC9pLCAvXmYvaSwgL15zYS9pXVxufSwgSDAgPSB7XG4gIG5hcnJvdzogL14oYXxwfG1pfG58KGluIHRoZXxhdCkgKG1vcm5pbmd8YWZ0ZXJub29ufGV2ZW5pbmd8bmlnaHQpKS9pLFxuICBhbnk6IC9eKFthcF1cXC4/XFxzP21cXC4/fG1pZG5pZ2h0fG5vb258KGluIHRoZXxhdCkgKG1vcm5pbmd8YWZ0ZXJub29ufGV2ZW5pbmd8bmlnaHQpKS9pXG59LCBWMCA9IHtcbiAgYW55OiB7XG4gICAgYW06IC9eYS9pLFxuICAgIHBtOiAvXnAvaSxcbiAgICBtaWRuaWdodDogL15taS9pLFxuICAgIG5vb246IC9ebm8vaSxcbiAgICBtb3JuaW5nOiAvbW9ybmluZy9pLFxuICAgIGFmdGVybm9vbjogL2FmdGVybm9vbi9pLFxuICAgIGV2ZW5pbmc6IC9ldmVuaW5nL2ksXG4gICAgbmlnaHQ6IC9uaWdodC9pXG4gIH1cbn0sIEcwID0ge1xuICBvcmRpbmFsTnVtYmVyOiBtMCh7XG4gICAgbWF0Y2hQYXR0ZXJuOiBBMCxcbiAgICBwYXJzZVBhdHRlcm46IEwwLFxuICAgIHZhbHVlQ2FsbGJhY2s6IChlKSA9PiBwYXJzZUludChlLCAxMClcbiAgfSksXG4gIGVyYTogaGkoe1xuICAgIG1hdGNoUGF0dGVybnM6IGswLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiBcIndpZGVcIixcbiAgICBwYXJzZVBhdHRlcm5zOiBEMCxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogXCJhbnlcIlxuICB9KSxcbiAgcXVhcnRlcjogaGkoe1xuICAgIG1hdGNoUGF0dGVybnM6IFIwLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiBcIndpZGVcIixcbiAgICBwYXJzZVBhdHRlcm5zOiBJMCxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogXCJhbnlcIixcbiAgICB2YWx1ZUNhbGxiYWNrOiAoZSkgPT4gZSArIDFcbiAgfSksXG4gIG1vbnRoOiBoaSh7XG4gICAgbWF0Y2hQYXR0ZXJuczogTjAsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6IFwid2lkZVwiLFxuICAgIHBhcnNlUGF0dGVybnM6IFAwLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiBcImFueVwiXG4gIH0pLFxuICBkYXk6IGhpKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBVMCxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogXCJ3aWRlXCIsXG4gICAgcGFyc2VQYXR0ZXJuczogQjAsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6IFwiYW55XCJcbiAgfSksXG4gIGRheVBlcmlvZDogaGkoe1xuICAgIG1hdGNoUGF0dGVybnM6IEgwLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiBcImFueVwiLFxuICAgIHBhcnNlUGF0dGVybnM6IFYwLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiBcImFueVwiXG4gIH0pXG59LCB6MCA9IHtcbiAgZnVsbDogXCJFRUVFLCBNTU1NIGRvLCB5XCIsXG4gIGxvbmc6IFwiTU1NTSBkbywgeVwiLFxuICBtZWRpdW06IFwiTU1NIGQsIHlcIixcbiAgc2hvcnQ6IFwiTU0vZGQveXl5eVwiXG59LCBGMCA9IHtcbiAgZnVsbDogXCJoOm1tOnNzIGEgenp6elwiLFxuICBsb25nOiBcImg6bW06c3MgYSB6XCIsXG4gIG1lZGl1bTogXCJoOm1tOnNzIGFcIixcbiAgc2hvcnQ6IFwiaDptbSBhXCJcbn0sIGowID0ge1xuICBmdWxsOiBcInt7ZGF0ZX19ICdhdCcge3t0aW1lfX1cIixcbiAgbG9uZzogXCJ7e2RhdGV9fSAnYXQnIHt7dGltZX19XCIsXG4gIG1lZGl1bTogXCJ7e2RhdGV9fSwge3t0aW1lfX1cIixcbiAgc2hvcnQ6IFwie3tkYXRlfX0sIHt7dGltZX19XCJcbn0sIFcwID0ge1xuICBkYXRlOiBUbyh7XG4gICAgZm9ybWF0czogejAsXG4gICAgZGVmYXVsdFdpZHRoOiBcImZ1bGxcIlxuICB9KSxcbiAgdGltZTogVG8oe1xuICAgIGZvcm1hdHM6IEYwLFxuICAgIGRlZmF1bHRXaWR0aDogXCJmdWxsXCJcbiAgfSksXG4gIGRhdGVUaW1lOiBUbyh7XG4gICAgZm9ybWF0czogajAsXG4gICAgZGVmYXVsdFdpZHRoOiBcImZ1bGxcIlxuICB9KVxufSwgZGYgPSB7XG4gIGNvZGU6IFwiZW4tVVNcIixcbiAgZm9ybWF0RGlzdGFuY2U6IHgwLFxuICBmb3JtYXRMb25nOiBXMCxcbiAgZm9ybWF0UmVsYXRpdmU6IF8wLFxuICBsb2NhbGl6ZTogQzAsXG4gIG1hdGNoOiBHMCxcbiAgb3B0aW9uczoge1xuICAgIHdlZWtTdGFydHNPbjogMCxcbiAgICBmaXJzdFdlZWtDb250YWluc0RhdGU6IDFcbiAgfVxufTtcbnZhciBwZiA9IHR5cGVvZiBnbG9iYWwgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbCwgcTAgPSB0eXBlb2Ygc2VsZiA9PSBcIm9iamVjdFwiICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmLCBXZSA9IHBmIHx8IHEwIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSwga2UgPSBXZS5TeW1ib2wsIGZmID0gT2JqZWN0LnByb3RvdHlwZSwgWTAgPSBmZi5oYXNPd25Qcm9wZXJ0eSwgWDAgPSBmZi50b1N0cmluZywgZGkgPSBrZSA/IGtlLnRvU3RyaW5nVGFnIDogdm9pZCAwO1xuZnVuY3Rpb24gWjAoZSkge1xuICB2YXIgdCA9IFkwLmNhbGwoZSwgZGkpLCBuID0gZVtkaV07XG4gIHRyeSB7XG4gICAgZVtkaV0gPSB2b2lkIDA7XG4gICAgdmFyIHIgPSAhMDtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgdmFyIGkgPSBYMC5jYWxsKGUpO1xuICByZXR1cm4gciAmJiAodCA/IGVbZGldID0gbiA6IGRlbGV0ZSBlW2RpXSksIGk7XG59XG52YXIgSzAgPSBPYmplY3QucHJvdG90eXBlLCBRMCA9IEswLnRvU3RyaW5nO1xuZnVuY3Rpb24gSjAoZSkge1xuICByZXR1cm4gUTAuY2FsbChlKTtcbn1cbnZhciB0MSA9IFwiW29iamVjdCBOdWxsXVwiLCBlMSA9IFwiW29iamVjdCBVbmRlZmluZWRdXCIsIEl1ID0ga2UgPyBrZS50b1N0cmluZ1RhZyA6IHZvaWQgMDtcbmZ1bmN0aW9uIGhyKGUpIHtcbiAgcmV0dXJuIGUgPT0gbnVsbCA/IGUgPT09IHZvaWQgMCA/IGUxIDogdDEgOiBJdSAmJiBJdSBpbiBPYmplY3QoZSkgPyBaMChlKSA6IEowKGUpO1xufVxuZnVuY3Rpb24gcm4oZSkge1xuICByZXR1cm4gZSAhPSBudWxsICYmIHR5cGVvZiBlID09IFwib2JqZWN0XCI7XG59XG52YXIgbjEgPSBcIltvYmplY3QgU3ltYm9sXVwiO1xuZnVuY3Rpb24gRmEoZSkge1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJzeW1ib2xcIiB8fCBybihlKSAmJiBocihlKSA9PSBuMTtcbn1cbmZ1bmN0aW9uIGZjKGUsIHQpIHtcbiAgZm9yICh2YXIgbiA9IC0xLCByID0gZSA9PSBudWxsID8gMCA6IGUubGVuZ3RoLCBpID0gQXJyYXkocik7ICsrbiA8IHI7IClcbiAgICBpW25dID0gdChlW25dLCBuLCBlKTtcbiAgcmV0dXJuIGk7XG59XG52YXIgS3QgPSBBcnJheS5pc0FycmF5LCBOdSA9IGtlID8ga2UucHJvdG90eXBlIDogdm9pZCAwLCBQdSA9IE51ID8gTnUudG9TdHJpbmcgOiB2b2lkIDA7XG5mdW5jdGlvbiBtZihlKSB7XG4gIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBlO1xuICBpZiAoS3QoZSkpXG4gICAgcmV0dXJuIGZjKGUsIG1mKSArIFwiXCI7XG4gIGlmIChGYShlKSlcbiAgICByZXR1cm4gUHUgPyBQdS5jYWxsKGUpIDogXCJcIjtcbiAgdmFyIHQgPSBlICsgXCJcIjtcbiAgcmV0dXJuIHQgPT0gXCIwXCIgJiYgMSAvIGUgPT0gLTEgLyAwID8gXCItMFwiIDogdDtcbn1cbmZ1bmN0aW9uIERlKGUpIHtcbiAgdmFyIHQgPSB0eXBlb2YgZTtcbiAgcmV0dXJuIGUgIT0gbnVsbCAmJiAodCA9PSBcIm9iamVjdFwiIHx8IHQgPT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIG1jKGUpIHtcbiAgcmV0dXJuIGU7XG59XG52YXIgcjEgPSBcIltvYmplY3QgQXN5bmNGdW5jdGlvbl1cIiwgaTEgPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsIHMxID0gXCJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXVwiLCBhMSA9IFwiW29iamVjdCBQcm94eV1cIjtcbmZ1bmN0aW9uIGdjKGUpIHtcbiAgaWYgKCFEZShlKSlcbiAgICByZXR1cm4gITE7XG4gIHZhciB0ID0gaHIoZSk7XG4gIHJldHVybiB0ID09IGkxIHx8IHQgPT0gczEgfHwgdCA9PSByMSB8fCB0ID09IGExO1xufVxudmFyIHdvID0gV2VbXCJfX2NvcmUtanNfc2hhcmVkX19cIl0sIFV1ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlID0gL1teLl0rJC8uZXhlYyh3byAmJiB3by5rZXlzICYmIHdvLmtleXMuSUVfUFJPVE8gfHwgXCJcIik7XG4gIHJldHVybiBlID8gXCJTeW1ib2woc3JjKV8xLlwiICsgZSA6IFwiXCI7XG59KCk7XG5mdW5jdGlvbiBvMShlKSB7XG4gIHJldHVybiAhIVV1ICYmIFV1IGluIGU7XG59XG52YXIgbDEgPSBGdW5jdGlvbi5wcm90b3R5cGUsIGMxID0gbDEudG9TdHJpbmc7XG5mdW5jdGlvbiBkcihlKSB7XG4gIGlmIChlICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGMxLmNhbGwoZSk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZSArIFwiXCI7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIHJldHVybiBcIlwiO1xufVxudmFyIHUxID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nLCBoMSA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC8sIGQxID0gRnVuY3Rpb24ucHJvdG90eXBlLCBwMSA9IE9iamVjdC5wcm90b3R5cGUsIGYxID0gZDEudG9TdHJpbmcsIG0xID0gcDEuaGFzT3duUHJvcGVydHksIGcxID0gUmVnRXhwKFxuICBcIl5cIiArIGYxLmNhbGwobTEpLnJlcGxhY2UodTEsIFwiXFxcXCQmXCIpLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csIFwiJDEuKj9cIikgKyBcIiRcIlxuKTtcbmZ1bmN0aW9uIHYxKGUpIHtcbiAgaWYgKCFEZShlKSB8fCBvMShlKSlcbiAgICByZXR1cm4gITE7XG4gIHZhciB0ID0gZ2MoZSkgPyBnMSA6IGgxO1xuICByZXR1cm4gdC50ZXN0KGRyKGUpKTtcbn1cbmZ1bmN0aW9uIHkxKGUsIHQpIHtcbiAgcmV0dXJuIGUgPT0gbnVsbCA/IHZvaWQgMCA6IGVbdF07XG59XG5mdW5jdGlvbiBwcihlLCB0KSB7XG4gIHZhciBuID0geTEoZSwgdCk7XG4gIHJldHVybiB2MShuKSA/IG4gOiB2b2lkIDA7XG59XG52YXIgbWwgPSBwcihXZSwgXCJXZWFrTWFwXCIpLCBCdSA9IE9iamVjdC5jcmVhdGUsIHgxID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBlKCkge1xuICB9XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgaWYgKCFEZSh0KSlcbiAgICAgIHJldHVybiB7fTtcbiAgICBpZiAoQnUpXG4gICAgICByZXR1cm4gQnUodCk7XG4gICAgZS5wcm90b3R5cGUgPSB0O1xuICAgIHZhciBuID0gbmV3IGUoKTtcbiAgICByZXR1cm4gZS5wcm90b3R5cGUgPSB2b2lkIDAsIG47XG4gIH07XG59KCk7XG5mdW5jdGlvbiBiMShlLCB0LCBuKSB7XG4gIHN3aXRjaCAobi5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gZS5jYWxsKHQpO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBlLmNhbGwodCwgblswXSk7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGUuY2FsbCh0LCBuWzBdLCBuWzFdKTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gZS5jYWxsKHQsIG5bMF0sIG5bMV0sIG5bMl0pO1xuICB9XG4gIHJldHVybiBlLmFwcGx5KHQsIG4pO1xufVxuZnVuY3Rpb24gXzEoKSB7XG59XG5mdW5jdGlvbiBnZihlLCB0KSB7XG4gIHZhciBuID0gLTEsIHIgPSBlLmxlbmd0aDtcbiAgZm9yICh0IHx8ICh0ID0gQXJyYXkocikpOyArK24gPCByOyApXG4gICAgdFtuXSA9IGVbbl07XG4gIHJldHVybiB0O1xufVxudmFyIEUxID0gODAwLCBPMSA9IDE2LCBTMSA9IERhdGUubm93O1xuZnVuY3Rpb24gVDEoZSkge1xuICB2YXIgdCA9IDAsIG4gPSAwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHIgPSBTMSgpLCBpID0gTzEgLSAociAtIG4pO1xuICAgIGlmIChuID0gciwgaSA+IDApIHtcbiAgICAgIGlmICgrK3QgPj0gRTEpXG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlXG4gICAgICB0ID0gMDtcbiAgICByZXR1cm4gZS5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5mdW5jdGlvbiB3MShlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZTtcbiAgfTtcbn1cbnZhciBhYSA9IGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBlID0gcHIoT2JqZWN0LCBcImRlZmluZVByb3BlcnR5XCIpO1xuICAgIHJldHVybiBlKHt9LCBcIlwiLCB7fSksIGU7XG4gIH0gY2F0Y2gge1xuICB9XG59KCksICQxID0gYWEgPyBmdW5jdGlvbihlLCB0KSB7XG4gIHJldHVybiBhYShlLCBcInRvU3RyaW5nXCIsIHtcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIGVudW1lcmFibGU6ICExLFxuICAgIHZhbHVlOiB3MSh0KSxcbiAgICB3cml0YWJsZTogITBcbiAgfSk7XG59IDogbWMsIHZmID0gVDEoJDEpO1xuZnVuY3Rpb24gTTEoZSwgdCkge1xuICBmb3IgKHZhciBuID0gLTEsIHIgPSBlID09IG51bGwgPyAwIDogZS5sZW5ndGg7ICsrbiA8IHIgJiYgdChlW25dLCBuLCBlKSAhPT0gITE7IClcbiAgICA7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gQzEoZSwgdCwgbiwgcikge1xuICBmb3IgKHZhciBpID0gZS5sZW5ndGgsIHMgPSBuICsgLTE7ICsrcyA8IGk7IClcbiAgICBpZiAodChlW3NdLCBzLCBlKSlcbiAgICAgIHJldHVybiBzO1xuICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBBMShlKSB7XG4gIHJldHVybiBlICE9PSBlO1xufVxuZnVuY3Rpb24gTDEoZSwgdCwgbikge1xuICBmb3IgKHZhciByID0gbiAtIDEsIGkgPSBlLmxlbmd0aDsgKytyIDwgaTsgKVxuICAgIGlmIChlW3JdID09PSB0KVxuICAgICAgcmV0dXJuIHI7XG4gIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGsxKGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgPT09IHQgPyBMMShlLCB0LCBuKSA6IEMxKGUsIEExLCBuKTtcbn1cbmZ1bmN0aW9uIEQxKGUsIHQpIHtcbiAgdmFyIG4gPSBlID09IG51bGwgPyAwIDogZS5sZW5ndGg7XG4gIHJldHVybiAhIW4gJiYgazEoZSwgdCwgMCkgPiAtMTtcbn1cbnZhciBSMSA9IDkwMDcxOTkyNTQ3NDA5OTEsIEkxID0gL14oPzowfFsxLTldXFxkKikkLztcbmZ1bmN0aW9uIHZjKGUsIHQpIHtcbiAgdmFyIG4gPSB0eXBlb2YgZTtcbiAgcmV0dXJuIHQgPSB0ID8/IFIxLCAhIXQgJiYgKG4gPT0gXCJudW1iZXJcIiB8fCBuICE9IFwic3ltYm9sXCIgJiYgSTEudGVzdChlKSkgJiYgZSA+IC0xICYmIGUgJSAxID09IDAgJiYgZSA8IHQ7XG59XG5mdW5jdGlvbiBqYShlLCB0LCBuKSB7XG4gIHQgPT0gXCJfX3Byb3RvX19cIiAmJiBhYSA/IGFhKGUsIHQsIHtcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIHZhbHVlOiBuLFxuICAgIHdyaXRhYmxlOiAhMFxuICB9KSA6IGVbdF0gPSBuO1xufVxuZnVuY3Rpb24gb3MoZSwgdCkge1xuICByZXR1cm4gZSA9PT0gdCB8fCBlICE9PSBlICYmIHQgIT09IHQ7XG59XG52YXIgTjEgPSBPYmplY3QucHJvdG90eXBlLCBQMSA9IE4xLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24geWYoZSwgdCwgbikge1xuICB2YXIgciA9IGVbdF07XG4gICghKFAxLmNhbGwoZSwgdCkgJiYgb3MociwgbikpIHx8IG4gPT09IHZvaWQgMCAmJiAhKHQgaW4gZSkpICYmIGphKGUsIHQsIG4pO1xufVxuZnVuY3Rpb24gcmkoZSwgdCwgbiwgcikge1xuICB2YXIgaSA9ICFuO1xuICBuIHx8IChuID0ge30pO1xuICBmb3IgKHZhciBzID0gLTEsIGEgPSB0Lmxlbmd0aDsgKytzIDwgYTsgKSB7XG4gICAgdmFyIG8gPSB0W3NdLCBsID0gdm9pZCAwO1xuICAgIGwgPT09IHZvaWQgMCAmJiAobCA9IGVbb10pLCBpID8gamEobiwgbywgbCkgOiB5ZihuLCBvLCBsKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbnZhciBIdSA9IE1hdGgubWF4O1xuZnVuY3Rpb24geGYoZSwgdCwgbikge1xuICByZXR1cm4gdCA9IEh1KHQgPT09IHZvaWQgMCA/IGUubGVuZ3RoIC0gMSA6IHQsIDApLCBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciByID0gYXJndW1lbnRzLCBpID0gLTEsIHMgPSBIdShyLmxlbmd0aCAtIHQsIDApLCBhID0gQXJyYXkocyk7ICsraSA8IHM7IClcbiAgICAgIGFbaV0gPSByW3QgKyBpXTtcbiAgICBpID0gLTE7XG4gICAgZm9yICh2YXIgbyA9IEFycmF5KHQgKyAxKTsgKytpIDwgdDsgKVxuICAgICAgb1tpXSA9IHJbaV07XG4gICAgcmV0dXJuIG9bdF0gPSBuKGEpLCBiMShlLCB0aGlzLCBvKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHljKGUsIHQpIHtcbiAgcmV0dXJuIHZmKHhmKGUsIHQsIG1jKSwgZSArIFwiXCIpO1xufVxudmFyIFUxID0gOTAwNzE5OTI1NDc0MDk5MTtcbmZ1bmN0aW9uIHhjKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwibnVtYmVyXCIgJiYgZSA+IC0xICYmIGUgJSAxID09IDAgJiYgZSA8PSBVMTtcbn1cbmZ1bmN0aW9uIGZyKGUpIHtcbiAgcmV0dXJuIGUgIT0gbnVsbCAmJiB4YyhlLmxlbmd0aCkgJiYgIWdjKGUpO1xufVxuZnVuY3Rpb24gQjEoZSwgdCwgbikge1xuICBpZiAoIURlKG4pKVxuICAgIHJldHVybiAhMTtcbiAgdmFyIHIgPSB0eXBlb2YgdDtcbiAgcmV0dXJuIChyID09IFwibnVtYmVyXCIgPyBmcihuKSAmJiB2Yyh0LCBuLmxlbmd0aCkgOiByID09IFwic3RyaW5nXCIgJiYgdCBpbiBuKSA/IG9zKG5bdF0sIGUpIDogITE7XG59XG5mdW5jdGlvbiBIMShlKSB7XG4gIHJldHVybiB5YyhmdW5jdGlvbih0LCBuKSB7XG4gICAgdmFyIHIgPSAtMSwgaSA9IG4ubGVuZ3RoLCBzID0gaSA+IDEgPyBuW2kgLSAxXSA6IHZvaWQgMCwgYSA9IGkgPiAyID8gblsyXSA6IHZvaWQgMDtcbiAgICBmb3IgKHMgPSBlLmxlbmd0aCA+IDMgJiYgdHlwZW9mIHMgPT0gXCJmdW5jdGlvblwiID8gKGktLSwgcykgOiB2b2lkIDAsIGEgJiYgQjEoblswXSwgblsxXSwgYSkgJiYgKHMgPSBpIDwgMyA/IHZvaWQgMCA6IHMsIGkgPSAxKSwgdCA9IE9iamVjdCh0KTsgKytyIDwgaTsgKSB7XG4gICAgICB2YXIgbyA9IG5bcl07XG4gICAgICBvICYmIGUodCwgbywgciwgcyk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9KTtcbn1cbnZhciBWMSA9IE9iamVjdC5wcm90b3R5cGU7XG5mdW5jdGlvbiBXYShlKSB7XG4gIHZhciB0ID0gZSAmJiBlLmNvbnN0cnVjdG9yLCBuID0gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiICYmIHQucHJvdG90eXBlIHx8IFYxO1xuICByZXR1cm4gZSA9PT0gbjtcbn1cbmZ1bmN0aW9uIEcxKGUsIHQpIHtcbiAgZm9yICh2YXIgbiA9IC0xLCByID0gQXJyYXkoZSk7ICsrbiA8IGU7IClcbiAgICByW25dID0gdChuKTtcbiAgcmV0dXJuIHI7XG59XG52YXIgejEgPSBcIltvYmplY3QgQXJndW1lbnRzXVwiO1xuZnVuY3Rpb24gVnUoZSkge1xuICByZXR1cm4gcm4oZSkgJiYgaHIoZSkgPT0gejE7XG59XG52YXIgYmYgPSBPYmplY3QucHJvdG90eXBlLCBGMSA9IGJmLmhhc093blByb3BlcnR5LCBqMSA9IGJmLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBqciA9IFZ1KC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cztcbn0oKSkgPyBWdSA6IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIHJuKGUpICYmIEYxLmNhbGwoZSwgXCJjYWxsZWVcIikgJiYgIWoxLmNhbGwoZSwgXCJjYWxsZWVcIik7XG59O1xuZnVuY3Rpb24gVzEoKSB7XG4gIHJldHVybiAhMTtcbn1cbnZhciBfZiA9IHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzLCBHdSA9IF9mICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIiAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGUsIHExID0gR3UgJiYgR3UuZXhwb3J0cyA9PT0gX2YsIHp1ID0gcTEgPyBXZS5CdWZmZXIgOiB2b2lkIDAsIFkxID0genUgPyB6dS5pc0J1ZmZlciA6IHZvaWQgMCwgV3IgPSBZMSB8fCBXMSwgWDEgPSBcIltvYmplY3QgQXJndW1lbnRzXVwiLCBaMSA9IFwiW29iamVjdCBBcnJheV1cIiwgSzEgPSBcIltvYmplY3QgQm9vbGVhbl1cIiwgUTEgPSBcIltvYmplY3QgRGF0ZV1cIiwgSjEgPSBcIltvYmplY3QgRXJyb3JdXCIsIHR5ID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLCBleSA9IFwiW29iamVjdCBNYXBdXCIsIG55ID0gXCJbb2JqZWN0IE51bWJlcl1cIiwgcnkgPSBcIltvYmplY3QgT2JqZWN0XVwiLCBpeSA9IFwiW29iamVjdCBSZWdFeHBdXCIsIHN5ID0gXCJbb2JqZWN0IFNldF1cIiwgYXkgPSBcIltvYmplY3QgU3RyaW5nXVwiLCBveSA9IFwiW29iamVjdCBXZWFrTWFwXVwiLCBseSA9IFwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIiwgY3kgPSBcIltvYmplY3QgRGF0YVZpZXddXCIsIHV5ID0gXCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIiwgaHkgPSBcIltvYmplY3QgRmxvYXQ2NEFycmF5XVwiLCBkeSA9IFwiW29iamVjdCBJbnQ4QXJyYXldXCIsIHB5ID0gXCJbb2JqZWN0IEludDE2QXJyYXldXCIsIGZ5ID0gXCJbb2JqZWN0IEludDMyQXJyYXldXCIsIG15ID0gXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCIsIGd5ID0gXCJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XVwiLCB2eSA9IFwiW29iamVjdCBVaW50MTZBcnJheV1cIiwgeXkgPSBcIltvYmplY3QgVWludDMyQXJyYXldXCIsIEx0ID0ge307XG5MdFt1eV0gPSBMdFtoeV0gPSBMdFtkeV0gPSBMdFtweV0gPSBMdFtmeV0gPSBMdFtteV0gPSBMdFtneV0gPSBMdFt2eV0gPSBMdFt5eV0gPSAhMDtcbkx0W1gxXSA9IEx0W1oxXSA9IEx0W2x5XSA9IEx0W0sxXSA9IEx0W2N5XSA9IEx0W1ExXSA9IEx0W0oxXSA9IEx0W3R5XSA9IEx0W2V5XSA9IEx0W255XSA9IEx0W3J5XSA9IEx0W2l5XSA9IEx0W3N5XSA9IEx0W2F5XSA9IEx0W295XSA9ICExO1xuZnVuY3Rpb24geHkoZSkge1xuICByZXR1cm4gcm4oZSkgJiYgeGMoZS5sZW5ndGgpICYmICEhTHRbaHIoZSldO1xufVxuZnVuY3Rpb24gYmMoZSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBlKHQpO1xuICB9O1xufVxudmFyIEVmID0gdHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHMsIFVpID0gRWYgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZSwgYnkgPSBVaSAmJiBVaS5leHBvcnRzID09PSBFZiwgJG8gPSBieSAmJiBwZi5wcm9jZXNzLCBxciA9IGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBlID0gVWkgJiYgVWkucmVxdWlyZSAmJiBVaS5yZXF1aXJlKFwidXRpbFwiKS50eXBlcztcbiAgICByZXR1cm4gZSB8fCAkbyAmJiAkby5iaW5kaW5nICYmICRvLmJpbmRpbmcoXCJ1dGlsXCIpO1xuICB9IGNhdGNoIHtcbiAgfVxufSgpLCBGdSA9IHFyICYmIHFyLmlzVHlwZWRBcnJheSwgcWEgPSBGdSA/IGJjKEZ1KSA6IHh5LCBfeSA9IE9iamVjdC5wcm90b3R5cGUsIEV5ID0gX3kuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBPZihlLCB0KSB7XG4gIHZhciBuID0gS3QoZSksIHIgPSAhbiAmJiBqcihlKSwgaSA9ICFuICYmICFyICYmIFdyKGUpLCBzID0gIW4gJiYgIXIgJiYgIWkgJiYgcWEoZSksIGEgPSBuIHx8IHIgfHwgaSB8fCBzLCBvID0gYSA/IEcxKGUubGVuZ3RoLCBTdHJpbmcpIDogW10sIGwgPSBvLmxlbmd0aDtcbiAgZm9yICh2YXIgYyBpbiBlKVxuICAgICh0IHx8IEV5LmNhbGwoZSwgYykpICYmICEoYSAmJiAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgKGMgPT0gXCJsZW5ndGhcIiB8fCAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICBpICYmIChjID09IFwib2Zmc2V0XCIgfHwgYyA9PSBcInBhcmVudFwiKSB8fCAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgcyAmJiAoYyA9PSBcImJ1ZmZlclwiIHx8IGMgPT0gXCJieXRlTGVuZ3RoXCIgfHwgYyA9PSBcImJ5dGVPZmZzZXRcIikgfHwgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgIHZjKGMsIGwpKSkgJiYgby5wdXNoKGMpO1xuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIFNmKGUsIHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gZSh0KG4pKTtcbiAgfTtcbn1cbnZhciBPeSA9IFNmKE9iamVjdC5rZXlzLCBPYmplY3QpLCBTeSA9IE9iamVjdC5wcm90b3R5cGUsIFR5ID0gU3kuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBUZihlKSB7XG4gIGlmICghV2EoZSkpXG4gICAgcmV0dXJuIE95KGUpO1xuICB2YXIgdCA9IFtdO1xuICBmb3IgKHZhciBuIGluIE9iamVjdChlKSlcbiAgICBUeS5jYWxsKGUsIG4pICYmIG4gIT0gXCJjb25zdHJ1Y3RvclwiICYmIHQucHVzaChuKTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBscyhlKSB7XG4gIHJldHVybiBmcihlKSA/IE9mKGUpIDogVGYoZSk7XG59XG5mdW5jdGlvbiB3eShlKSB7XG4gIHZhciB0ID0gW107XG4gIGlmIChlICE9IG51bGwpXG4gICAgZm9yICh2YXIgbiBpbiBPYmplY3QoZSkpXG4gICAgICB0LnB1c2gobik7XG4gIHJldHVybiB0O1xufVxudmFyICR5ID0gT2JqZWN0LnByb3RvdHlwZSwgTXkgPSAkeS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIEN5KGUpIHtcbiAgaWYgKCFEZShlKSlcbiAgICByZXR1cm4gd3koZSk7XG4gIHZhciB0ID0gV2EoZSksIG4gPSBbXTtcbiAgZm9yICh2YXIgciBpbiBlKVxuICAgIHIgPT0gXCJjb25zdHJ1Y3RvclwiICYmICh0IHx8ICFNeS5jYWxsKGUsIHIpKSB8fCBuLnB1c2gocik7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gY3MoZSkge1xuICByZXR1cm4gZnIoZSkgPyBPZihlLCAhMCkgOiBDeShlKTtcbn1cbnZhciBBeSA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sIEx5ID0gL15cXHcqJC87XG5mdW5jdGlvbiBfYyhlLCB0KSB7XG4gIGlmIChLdChlKSlcbiAgICByZXR1cm4gITE7XG4gIHZhciBuID0gdHlwZW9mIGU7XG4gIHJldHVybiBuID09IFwibnVtYmVyXCIgfHwgbiA9PSBcInN5bWJvbFwiIHx8IG4gPT0gXCJib29sZWFuXCIgfHwgZSA9PSBudWxsIHx8IEZhKGUpID8gITAgOiBMeS50ZXN0KGUpIHx8ICFBeS50ZXN0KGUpIHx8IHQgIT0gbnVsbCAmJiBlIGluIE9iamVjdCh0KTtcbn1cbnZhciBxaSA9IHByKE9iamVjdCwgXCJjcmVhdGVcIik7XG5mdW5jdGlvbiBreSgpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IHFpID8gcWkobnVsbCkgOiB7fSwgdGhpcy5zaXplID0gMDtcbn1cbmZ1bmN0aW9uIER5KGUpIHtcbiAgdmFyIHQgPSB0aGlzLmhhcyhlKSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1tlXTtcbiAgcmV0dXJuIHRoaXMuc2l6ZSAtPSB0ID8gMSA6IDAsIHQ7XG59XG52YXIgUnkgPSBcIl9fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX19cIiwgSXkgPSBPYmplY3QucHJvdG90eXBlLCBOeSA9IEl5Lmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gUHkoZSkge1xuICB2YXIgdCA9IHRoaXMuX19kYXRhX187XG4gIGlmIChxaSkge1xuICAgIHZhciBuID0gdFtlXTtcbiAgICByZXR1cm4gbiA9PT0gUnkgPyB2b2lkIDAgOiBuO1xuICB9XG4gIHJldHVybiBOeS5jYWxsKHQsIGUpID8gdFtlXSA6IHZvaWQgMDtcbn1cbnZhciBVeSA9IE9iamVjdC5wcm90b3R5cGUsIEJ5ID0gVXkuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBIeShlKSB7XG4gIHZhciB0ID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIHFpID8gdFtlXSAhPT0gdm9pZCAwIDogQnkuY2FsbCh0LCBlKTtcbn1cbnZhciBWeSA9IFwiX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfX1wiO1xuZnVuY3Rpb24gR3koZSwgdCkge1xuICB2YXIgbiA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiB0aGlzLnNpemUgKz0gdGhpcy5oYXMoZSkgPyAwIDogMSwgbltlXSA9IHFpICYmIHQgPT09IHZvaWQgMCA/IFZ5IDogdCwgdGhpcztcbn1cbmZ1bmN0aW9uIGVyKGUpIHtcbiAgdmFyIHQgPSAtMSwgbiA9IGUgPT0gbnVsbCA/IDAgOiBlLmxlbmd0aDtcbiAgZm9yICh0aGlzLmNsZWFyKCk7ICsrdCA8IG47ICkge1xuICAgIHZhciByID0gZVt0XTtcbiAgICB0aGlzLnNldChyWzBdLCByWzFdKTtcbiAgfVxufVxuZXIucHJvdG90eXBlLmNsZWFyID0ga3k7XG5lci5wcm90b3R5cGUuZGVsZXRlID0gRHk7XG5lci5wcm90b3R5cGUuZ2V0ID0gUHk7XG5lci5wcm90b3R5cGUuaGFzID0gSHk7XG5lci5wcm90b3R5cGUuc2V0ID0gR3k7XG5mdW5jdGlvbiB6eSgpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdLCB0aGlzLnNpemUgPSAwO1xufVxuZnVuY3Rpb24gWWEoZSwgdCkge1xuICBmb3IgKHZhciBuID0gZS5sZW5ndGg7IG4tLTsgKVxuICAgIGlmIChvcyhlW25dWzBdLCB0KSlcbiAgICAgIHJldHVybiBuO1xuICByZXR1cm4gLTE7XG59XG52YXIgRnkgPSBBcnJheS5wcm90b3R5cGUsIGp5ID0gRnkuc3BsaWNlO1xuZnVuY3Rpb24gV3koZSkge1xuICB2YXIgdCA9IHRoaXMuX19kYXRhX18sIG4gPSBZYSh0LCBlKTtcbiAgaWYgKG4gPCAwKVxuICAgIHJldHVybiAhMTtcbiAgdmFyIHIgPSB0Lmxlbmd0aCAtIDE7XG4gIHJldHVybiBuID09IHIgPyB0LnBvcCgpIDogankuY2FsbCh0LCBuLCAxKSwgLS10aGlzLnNpemUsICEwO1xufVxuZnVuY3Rpb24gcXkoZSkge1xuICB2YXIgdCA9IHRoaXMuX19kYXRhX18sIG4gPSBZYSh0LCBlKTtcbiAgcmV0dXJuIG4gPCAwID8gdm9pZCAwIDogdFtuXVsxXTtcbn1cbmZ1bmN0aW9uIFl5KGUpIHtcbiAgcmV0dXJuIFlhKHRoaXMuX19kYXRhX18sIGUpID4gLTE7XG59XG5mdW5jdGlvbiBYeShlLCB0KSB7XG4gIHZhciBuID0gdGhpcy5fX2RhdGFfXywgciA9IFlhKG4sIGUpO1xuICByZXR1cm4gciA8IDAgPyAoKyt0aGlzLnNpemUsIG4ucHVzaChbZSwgdF0pKSA6IG5bcl1bMV0gPSB0LCB0aGlzO1xufVxuZnVuY3Rpb24gTG4oZSkge1xuICB2YXIgdCA9IC0xLCBuID0gZSA9PSBudWxsID8gMCA6IGUubGVuZ3RoO1xuICBmb3IgKHRoaXMuY2xlYXIoKTsgKyt0IDwgbjsgKSB7XG4gICAgdmFyIHIgPSBlW3RdO1xuICAgIHRoaXMuc2V0KHJbMF0sIHJbMV0pO1xuICB9XG59XG5Mbi5wcm90b3R5cGUuY2xlYXIgPSB6eTtcbkxuLnByb3RvdHlwZS5kZWxldGUgPSBXeTtcbkxuLnByb3RvdHlwZS5nZXQgPSBxeTtcbkxuLnByb3RvdHlwZS5oYXMgPSBZeTtcbkxuLnByb3RvdHlwZS5zZXQgPSBYeTtcbnZhciBZaSA9IHByKFdlLCBcIk1hcFwiKTtcbmZ1bmN0aW9uIFp5KCkge1xuICB0aGlzLnNpemUgPSAwLCB0aGlzLl9fZGF0YV9fID0ge1xuICAgIGhhc2g6IG5ldyBlcigpLFxuICAgIG1hcDogbmV3IChZaSB8fCBMbikoKSxcbiAgICBzdHJpbmc6IG5ldyBlcigpXG4gIH07XG59XG5mdW5jdGlvbiBLeShlKSB7XG4gIHZhciB0ID0gdHlwZW9mIGU7XG4gIHJldHVybiB0ID09IFwic3RyaW5nXCIgfHwgdCA9PSBcIm51bWJlclwiIHx8IHQgPT0gXCJzeW1ib2xcIiB8fCB0ID09IFwiYm9vbGVhblwiID8gZSAhPT0gXCJfX3Byb3RvX19cIiA6IGUgPT09IG51bGw7XG59XG5mdW5jdGlvbiBYYShlLCB0KSB7XG4gIHZhciBuID0gZS5fX2RhdGFfXztcbiAgcmV0dXJuIEt5KHQpID8gblt0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gXCJzdHJpbmdcIiA6IFwiaGFzaFwiXSA6IG4ubWFwO1xufVxuZnVuY3Rpb24gUXkoZSkge1xuICB2YXIgdCA9IFhhKHRoaXMsIGUpLmRlbGV0ZShlKTtcbiAgcmV0dXJuIHRoaXMuc2l6ZSAtPSB0ID8gMSA6IDAsIHQ7XG59XG5mdW5jdGlvbiBKeShlKSB7XG4gIHJldHVybiBYYSh0aGlzLCBlKS5nZXQoZSk7XG59XG5mdW5jdGlvbiB0eChlKSB7XG4gIHJldHVybiBYYSh0aGlzLCBlKS5oYXMoZSk7XG59XG5mdW5jdGlvbiBleChlLCB0KSB7XG4gIHZhciBuID0gWGEodGhpcywgZSksIHIgPSBuLnNpemU7XG4gIHJldHVybiBuLnNldChlLCB0KSwgdGhpcy5zaXplICs9IG4uc2l6ZSA9PSByID8gMCA6IDEsIHRoaXM7XG59XG5mdW5jdGlvbiBrbihlKSB7XG4gIHZhciB0ID0gLTEsIG4gPSBlID09IG51bGwgPyAwIDogZS5sZW5ndGg7XG4gIGZvciAodGhpcy5jbGVhcigpOyArK3QgPCBuOyApIHtcbiAgICB2YXIgciA9IGVbdF07XG4gICAgdGhpcy5zZXQoclswXSwgclsxXSk7XG4gIH1cbn1cbmtuLnByb3RvdHlwZS5jbGVhciA9IFp5O1xua24ucHJvdG90eXBlLmRlbGV0ZSA9IFF5O1xua24ucHJvdG90eXBlLmdldCA9IEp5O1xua24ucHJvdG90eXBlLmhhcyA9IHR4O1xua24ucHJvdG90eXBlLnNldCA9IGV4O1xudmFyIG54ID0gXCJFeHBlY3RlZCBhIGZ1bmN0aW9uXCI7XG5mdW5jdGlvbiBFYyhlLCB0KSB7XG4gIGlmICh0eXBlb2YgZSAhPSBcImZ1bmN0aW9uXCIgfHwgdCAhPSBudWxsICYmIHR5cGVvZiB0ICE9IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG54KTtcbiAgdmFyIG4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgciA9IGFyZ3VtZW50cywgaSA9IHQgPyB0LmFwcGx5KHRoaXMsIHIpIDogclswXSwgcyA9IG4uY2FjaGU7XG4gICAgaWYgKHMuaGFzKGkpKVxuICAgICAgcmV0dXJuIHMuZ2V0KGkpO1xuICAgIHZhciBhID0gZS5hcHBseSh0aGlzLCByKTtcbiAgICByZXR1cm4gbi5jYWNoZSA9IHMuc2V0KGksIGEpIHx8IHMsIGE7XG4gIH07XG4gIHJldHVybiBuLmNhY2hlID0gbmV3IChFYy5DYWNoZSB8fCBrbikoKSwgbjtcbn1cbkVjLkNhY2hlID0ga247XG52YXIgcnggPSA1MDA7XG5mdW5jdGlvbiBpeChlKSB7XG4gIHZhciB0ID0gRWMoZSwgZnVuY3Rpb24ocikge1xuICAgIHJldHVybiBuLnNpemUgPT09IHJ4ICYmIG4uY2xlYXIoKSwgcjtcbiAgfSksIG4gPSB0LmNhY2hlO1xuICByZXR1cm4gdDtcbn1cbnZhciBzeCA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZywgYXggPSAvXFxcXChcXFxcKT8vZywgb3ggPSBpeChmdW5jdGlvbihlKSB7XG4gIHZhciB0ID0gW107XG4gIHJldHVybiBlLmNoYXJDb2RlQXQoMCkgPT09IDQ2ICYmIHQucHVzaChcIlwiKSwgZS5yZXBsYWNlKHN4LCBmdW5jdGlvbihuLCByLCBpLCBzKSB7XG4gICAgdC5wdXNoKGkgPyBzLnJlcGxhY2UoYXgsIFwiJDFcIikgOiByIHx8IG4pO1xuICB9KSwgdDtcbn0pO1xuZnVuY3Rpb24gdXMoZSkge1xuICByZXR1cm4gZSA9PSBudWxsID8gXCJcIiA6IG1mKGUpO1xufVxuZnVuY3Rpb24gWmEoZSwgdCkge1xuICByZXR1cm4gS3QoZSkgPyBlIDogX2MoZSwgdCkgPyBbZV0gOiBveCh1cyhlKSk7XG59XG5mdW5jdGlvbiBocyhlKSB7XG4gIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiIHx8IEZhKGUpKVxuICAgIHJldHVybiBlO1xuICB2YXIgdCA9IGUgKyBcIlwiO1xuICByZXR1cm4gdCA9PSBcIjBcIiAmJiAxIC8gZSA9PSAtMSAvIDAgPyBcIi0wXCIgOiB0O1xufVxuZnVuY3Rpb24gT2MoZSwgdCkge1xuICB0ID0gWmEodCwgZSk7XG4gIGZvciAodmFyIG4gPSAwLCByID0gdC5sZW5ndGg7IGUgIT0gbnVsbCAmJiBuIDwgcjsgKVxuICAgIGUgPSBlW2hzKHRbbisrXSldO1xuICByZXR1cm4gbiAmJiBuID09IHIgPyBlIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gZ3QoZSwgdCwgbikge1xuICB2YXIgciA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IE9jKGUsIHQpO1xuICByZXR1cm4gciA9PT0gdm9pZCAwID8gbiA6IHI7XG59XG5mdW5jdGlvbiBTYyhlLCB0KSB7XG4gIGZvciAodmFyIG4gPSAtMSwgciA9IHQubGVuZ3RoLCBpID0gZS5sZW5ndGg7ICsrbiA8IHI7IClcbiAgICBlW2kgKyBuXSA9IHRbbl07XG4gIHJldHVybiBlO1xufVxudmFyIGp1ID0ga2UgPyBrZS5pc0NvbmNhdFNwcmVhZGFibGUgOiB2b2lkIDA7XG5mdW5jdGlvbiBseChlKSB7XG4gIHJldHVybiBLdChlKSB8fCBqcihlKSB8fCAhIShqdSAmJiBlICYmIGVbanVdKTtcbn1cbmZ1bmN0aW9uIEthKGUsIHQsIG4sIHIsIGkpIHtcbiAgdmFyIHMgPSAtMSwgYSA9IGUubGVuZ3RoO1xuICBmb3IgKG4gfHwgKG4gPSBseCksIGkgfHwgKGkgPSBbXSk7ICsrcyA8IGE7ICkge1xuICAgIHZhciBvID0gZVtzXTtcbiAgICB0ID4gMCAmJiBuKG8pID8gdCA+IDEgPyBLYShvLCB0IC0gMSwgbiwgciwgaSkgOiBTYyhpLCBvKSA6IHIgfHwgKGlbaS5sZW5ndGhdID0gbyk7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG52YXIgVGMgPSBTZihPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCksIGN4ID0gXCJbb2JqZWN0IE9iamVjdF1cIiwgdXggPSBGdW5jdGlvbi5wcm90b3R5cGUsIGh4ID0gT2JqZWN0LnByb3RvdHlwZSwgd2YgPSB1eC50b1N0cmluZywgZHggPSBoeC5oYXNPd25Qcm9wZXJ0eSwgcHggPSB3Zi5jYWxsKE9iamVjdCk7XG5mdW5jdGlvbiAkZihlKSB7XG4gIGlmICghcm4oZSkgfHwgaHIoZSkgIT0gY3gpXG4gICAgcmV0dXJuICExO1xuICB2YXIgdCA9IFRjKGUpO1xuICBpZiAodCA9PT0gbnVsbClcbiAgICByZXR1cm4gITA7XG4gIHZhciBuID0gZHguY2FsbCh0LCBcImNvbnN0cnVjdG9yXCIpICYmIHQuY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgbiA9PSBcImZ1bmN0aW9uXCIgJiYgbiBpbnN0YW5jZW9mIG4gJiYgd2YuY2FsbChuKSA9PSBweDtcbn1cbmZ1bmN0aW9uIGZ4KCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExuKCksIHRoaXMuc2l6ZSA9IDA7XG59XG5mdW5jdGlvbiBteChlKSB7XG4gIHZhciB0ID0gdGhpcy5fX2RhdGFfXywgbiA9IHQuZGVsZXRlKGUpO1xuICByZXR1cm4gdGhpcy5zaXplID0gdC5zaXplLCBuO1xufVxuZnVuY3Rpb24gZ3goZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoZSk7XG59XG5mdW5jdGlvbiB2eChlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhlKTtcbn1cbnZhciB5eCA9IDIwMDtcbmZ1bmN0aW9uIHh4KGUsIHQpIHtcbiAgdmFyIG4gPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobiBpbnN0YW5jZW9mIExuKSB7XG4gICAgdmFyIHIgPSBuLl9fZGF0YV9fO1xuICAgIGlmICghWWkgfHwgci5sZW5ndGggPCB5eCAtIDEpXG4gICAgICByZXR1cm4gci5wdXNoKFtlLCB0XSksIHRoaXMuc2l6ZSA9ICsrbi5zaXplLCB0aGlzO1xuICAgIG4gPSB0aGlzLl9fZGF0YV9fID0gbmV3IGtuKHIpO1xuICB9XG4gIHJldHVybiBuLnNldChlLCB0KSwgdGhpcy5zaXplID0gbi5zaXplLCB0aGlzO1xufVxuZnVuY3Rpb24gR2UoZSkge1xuICB2YXIgdCA9IHRoaXMuX19kYXRhX18gPSBuZXcgTG4oZSk7XG4gIHRoaXMuc2l6ZSA9IHQuc2l6ZTtcbn1cbkdlLnByb3RvdHlwZS5jbGVhciA9IGZ4O1xuR2UucHJvdG90eXBlLmRlbGV0ZSA9IG14O1xuR2UucHJvdG90eXBlLmdldCA9IGd4O1xuR2UucHJvdG90eXBlLmhhcyA9IHZ4O1xuR2UucHJvdG90eXBlLnNldCA9IHh4O1xuZnVuY3Rpb24gYngoZSwgdCkge1xuICByZXR1cm4gZSAmJiByaSh0LCBscyh0KSwgZSk7XG59XG5mdW5jdGlvbiBfeChlLCB0KSB7XG4gIHJldHVybiBlICYmIHJpKHQsIGNzKHQpLCBlKTtcbn1cbnZhciBNZiA9IHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzLCBXdSA9IE1mICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIiAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGUsIEV4ID0gV3UgJiYgV3UuZXhwb3J0cyA9PT0gTWYsIHF1ID0gRXggPyBXZS5CdWZmZXIgOiB2b2lkIDAsIFl1ID0gcXUgPyBxdS5hbGxvY1Vuc2FmZSA6IHZvaWQgMDtcbmZ1bmN0aW9uIENmKGUsIHQpIHtcbiAgaWYgKHQpXG4gICAgcmV0dXJuIGUuc2xpY2UoKTtcbiAgdmFyIG4gPSBlLmxlbmd0aCwgciA9IFl1ID8gWXUobikgOiBuZXcgZS5jb25zdHJ1Y3RvcihuKTtcbiAgcmV0dXJuIGUuY29weShyKSwgcjtcbn1cbmZ1bmN0aW9uIE94KGUsIHQpIHtcbiAgZm9yICh2YXIgbiA9IC0xLCByID0gZSA9PSBudWxsID8gMCA6IGUubGVuZ3RoLCBpID0gMCwgcyA9IFtdOyArK24gPCByOyApIHtcbiAgICB2YXIgYSA9IGVbbl07XG4gICAgdChhLCBuLCBlKSAmJiAoc1tpKytdID0gYSk7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBBZigpIHtcbiAgcmV0dXJuIFtdO1xufVxudmFyIFN4ID0gT2JqZWN0LnByb3RvdHlwZSwgVHggPSBTeC5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgWHUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCB3YyA9IFh1ID8gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gZSA9PSBudWxsID8gW10gOiAoZSA9IE9iamVjdChlKSwgT3goWHUoZSksIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gVHguY2FsbChlLCB0KTtcbiAgfSkpO1xufSA6IEFmO1xuZnVuY3Rpb24gd3goZSwgdCkge1xuICByZXR1cm4gcmkoZSwgd2MoZSksIHQpO1xufVxudmFyICR4ID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgTGYgPSAkeCA/IGZ1bmN0aW9uKGUpIHtcbiAgZm9yICh2YXIgdCA9IFtdOyBlOyApXG4gICAgU2ModCwgd2MoZSkpLCBlID0gVGMoZSk7XG4gIHJldHVybiB0O1xufSA6IEFmO1xuZnVuY3Rpb24gTXgoZSwgdCkge1xuICByZXR1cm4gcmkoZSwgTGYoZSksIHQpO1xufVxuZnVuY3Rpb24ga2YoZSwgdCwgbikge1xuICB2YXIgciA9IHQoZSk7XG4gIHJldHVybiBLdChlKSA/IHIgOiBTYyhyLCBuKGUpKTtcbn1cbmZ1bmN0aW9uIGdsKGUpIHtcbiAgcmV0dXJuIGtmKGUsIGxzLCB3Yyk7XG59XG5mdW5jdGlvbiBEZihlKSB7XG4gIHJldHVybiBrZihlLCBjcywgTGYpO1xufVxudmFyIHZsID0gcHIoV2UsIFwiRGF0YVZpZXdcIiksIHlsID0gcHIoV2UsIFwiUHJvbWlzZVwiKSwgVnIgPSBwcihXZSwgXCJTZXRcIiksIFp1ID0gXCJbb2JqZWN0IE1hcF1cIiwgQ3ggPSBcIltvYmplY3QgT2JqZWN0XVwiLCBLdSA9IFwiW29iamVjdCBQcm9taXNlXVwiLCBRdSA9IFwiW29iamVjdCBTZXRdXCIsIEp1ID0gXCJbb2JqZWN0IFdlYWtNYXBdXCIsIHRoID0gXCJbb2JqZWN0IERhdGFWaWV3XVwiLCBBeCA9IGRyKHZsKSwgTHggPSBkcihZaSksIGt4ID0gZHIoeWwpLCBEeCA9IGRyKFZyKSwgUnggPSBkcihtbCksICRlID0gaHI7XG4odmwgJiYgJGUobmV3IHZsKG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IHRoIHx8IFlpICYmICRlKG5ldyBZaSgpKSAhPSBadSB8fCB5bCAmJiAkZSh5bC5yZXNvbHZlKCkpICE9IEt1IHx8IFZyICYmICRlKG5ldyBWcigpKSAhPSBRdSB8fCBtbCAmJiAkZShuZXcgbWwoKSkgIT0gSnUpICYmICgkZSA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHQgPSBocihlKSwgbiA9IHQgPT0gQ3ggPyBlLmNvbnN0cnVjdG9yIDogdm9pZCAwLCByID0gbiA/IGRyKG4pIDogXCJcIjtcbiAgaWYgKHIpXG4gICAgc3dpdGNoIChyKSB7XG4gICAgICBjYXNlIEF4OlxuICAgICAgICByZXR1cm4gdGg7XG4gICAgICBjYXNlIEx4OlxuICAgICAgICByZXR1cm4gWnU7XG4gICAgICBjYXNlIGt4OlxuICAgICAgICByZXR1cm4gS3U7XG4gICAgICBjYXNlIER4OlxuICAgICAgICByZXR1cm4gUXU7XG4gICAgICBjYXNlIFJ4OlxuICAgICAgICByZXR1cm4gSnU7XG4gICAgfVxuICByZXR1cm4gdDtcbn0pO1xudmFyIEl4ID0gT2JqZWN0LnByb3RvdHlwZSwgTnggPSBJeC5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIFB4KGUpIHtcbiAgdmFyIHQgPSBlLmxlbmd0aCwgbiA9IG5ldyBlLmNvbnN0cnVjdG9yKHQpO1xuICByZXR1cm4gdCAmJiB0eXBlb2YgZVswXSA9PSBcInN0cmluZ1wiICYmIE54LmNhbGwoZSwgXCJpbmRleFwiKSAmJiAobi5pbmRleCA9IGUuaW5kZXgsIG4uaW5wdXQgPSBlLmlucHV0KSwgbjtcbn1cbnZhciBvYSA9IFdlLlVpbnQ4QXJyYXk7XG5mdW5jdGlvbiAkYyhlKSB7XG4gIHZhciB0ID0gbmV3IGUuY29uc3RydWN0b3IoZS5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIG5ldyBvYSh0KS5zZXQobmV3IG9hKGUpKSwgdDtcbn1cbmZ1bmN0aW9uIFV4KGUsIHQpIHtcbiAgdmFyIG4gPSB0ID8gJGMoZS5idWZmZXIpIDogZS5idWZmZXI7XG4gIHJldHVybiBuZXcgZS5jb25zdHJ1Y3RvcihuLCBlLmJ5dGVPZmZzZXQsIGUuYnl0ZUxlbmd0aCk7XG59XG52YXIgQnggPSAvXFx3KiQvO1xuZnVuY3Rpb24gSHgoZSkge1xuICB2YXIgdCA9IG5ldyBlLmNvbnN0cnVjdG9yKGUuc291cmNlLCBCeC5leGVjKGUpKTtcbiAgcmV0dXJuIHQubGFzdEluZGV4ID0gZS5sYXN0SW5kZXgsIHQ7XG59XG52YXIgZWggPSBrZSA/IGtlLnByb3RvdHlwZSA6IHZvaWQgMCwgbmggPSBlaCA/IGVoLnZhbHVlT2YgOiB2b2lkIDA7XG5mdW5jdGlvbiBWeChlKSB7XG4gIHJldHVybiBuaCA/IE9iamVjdChuaC5jYWxsKGUpKSA6IHt9O1xufVxuZnVuY3Rpb24gUmYoZSwgdCkge1xuICB2YXIgbiA9IHQgPyAkYyhlLmJ1ZmZlcikgOiBlLmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyBlLmNvbnN0cnVjdG9yKG4sIGUuYnl0ZU9mZnNldCwgZS5sZW5ndGgpO1xufVxudmFyIEd4ID0gXCJbb2JqZWN0IEJvb2xlYW5dXCIsIHp4ID0gXCJbb2JqZWN0IERhdGVdXCIsIEZ4ID0gXCJbb2JqZWN0IE1hcF1cIiwganggPSBcIltvYmplY3QgTnVtYmVyXVwiLCBXeCA9IFwiW29iamVjdCBSZWdFeHBdXCIsIHF4ID0gXCJbb2JqZWN0IFNldF1cIiwgWXggPSBcIltvYmplY3QgU3RyaW5nXVwiLCBYeCA9IFwiW29iamVjdCBTeW1ib2xdXCIsIFp4ID0gXCJbb2JqZWN0IEFycmF5QnVmZmVyXVwiLCBLeCA9IFwiW29iamVjdCBEYXRhVmlld11cIiwgUXggPSBcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiLCBKeCA9IFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCIsIHRiID0gXCJbb2JqZWN0IEludDhBcnJheV1cIiwgZWIgPSBcIltvYmplY3QgSW50MTZBcnJheV1cIiwgbmIgPSBcIltvYmplY3QgSW50MzJBcnJheV1cIiwgcmIgPSBcIltvYmplY3QgVWludDhBcnJheV1cIiwgaWIgPSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCIsIHNiID0gXCJbb2JqZWN0IFVpbnQxNkFycmF5XVwiLCBhYiA9IFwiW29iamVjdCBVaW50MzJBcnJheV1cIjtcbmZ1bmN0aW9uIG9iKGUsIHQsIG4pIHtcbiAgdmFyIHIgPSBlLmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlIFp4OlxuICAgICAgcmV0dXJuICRjKGUpO1xuICAgIGNhc2UgR3g6XG4gICAgY2FzZSB6eDpcbiAgICAgIHJldHVybiBuZXcgcigrZSk7XG4gICAgY2FzZSBLeDpcbiAgICAgIHJldHVybiBVeChlLCBuKTtcbiAgICBjYXNlIFF4OlxuICAgIGNhc2UgSng6XG4gICAgY2FzZSB0YjpcbiAgICBjYXNlIGViOlxuICAgIGNhc2UgbmI6XG4gICAgY2FzZSByYjpcbiAgICBjYXNlIGliOlxuICAgIGNhc2Ugc2I6XG4gICAgY2FzZSBhYjpcbiAgICAgIHJldHVybiBSZihlLCBuKTtcbiAgICBjYXNlIEZ4OlxuICAgICAgcmV0dXJuIG5ldyByKCk7XG4gICAgY2FzZSBqeDpcbiAgICBjYXNlIFl4OlxuICAgICAgcmV0dXJuIG5ldyByKGUpO1xuICAgIGNhc2UgV3g6XG4gICAgICByZXR1cm4gSHgoZSk7XG4gICAgY2FzZSBxeDpcbiAgICAgIHJldHVybiBuZXcgcigpO1xuICAgIGNhc2UgWHg6XG4gICAgICByZXR1cm4gVngoZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIElmKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlLmNvbnN0cnVjdG9yID09IFwiZnVuY3Rpb25cIiAmJiAhV2EoZSkgPyB4MShUYyhlKSkgOiB7fTtcbn1cbnZhciBsYiA9IFwiW29iamVjdCBNYXBdXCI7XG5mdW5jdGlvbiBjYihlKSB7XG4gIHJldHVybiBybihlKSAmJiAkZShlKSA9PSBsYjtcbn1cbnZhciByaCA9IHFyICYmIHFyLmlzTWFwLCB1YiA9IHJoID8gYmMocmgpIDogY2IsIGhiID0gXCJbb2JqZWN0IFNldF1cIjtcbmZ1bmN0aW9uIGRiKGUpIHtcbiAgcmV0dXJuIHJuKGUpICYmICRlKGUpID09IGhiO1xufVxudmFyIGloID0gcXIgJiYgcXIuaXNTZXQsIHBiID0gaWggPyBiYyhpaCkgOiBkYiwgZmIgPSAxLCBtYiA9IDIsIGdiID0gNCwgTmYgPSBcIltvYmplY3QgQXJndW1lbnRzXVwiLCB2YiA9IFwiW29iamVjdCBBcnJheV1cIiwgeWIgPSBcIltvYmplY3QgQm9vbGVhbl1cIiwgeGIgPSBcIltvYmplY3QgRGF0ZV1cIiwgYmIgPSBcIltvYmplY3QgRXJyb3JdXCIsIFBmID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLCBfYiA9IFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIiwgRWIgPSBcIltvYmplY3QgTWFwXVwiLCBPYiA9IFwiW29iamVjdCBOdW1iZXJdXCIsIFVmID0gXCJbb2JqZWN0IE9iamVjdF1cIiwgU2IgPSBcIltvYmplY3QgUmVnRXhwXVwiLCBUYiA9IFwiW29iamVjdCBTZXRdXCIsIHdiID0gXCJbb2JqZWN0IFN0cmluZ11cIiwgJGIgPSBcIltvYmplY3QgU3ltYm9sXVwiLCBNYiA9IFwiW29iamVjdCBXZWFrTWFwXVwiLCBDYiA9IFwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIiwgQWIgPSBcIltvYmplY3QgRGF0YVZpZXddXCIsIExiID0gXCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIiwga2IgPSBcIltvYmplY3QgRmxvYXQ2NEFycmF5XVwiLCBEYiA9IFwiW29iamVjdCBJbnQ4QXJyYXldXCIsIFJiID0gXCJbb2JqZWN0IEludDE2QXJyYXldXCIsIEliID0gXCJbb2JqZWN0IEludDMyQXJyYXldXCIsIE5iID0gXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCIsIFBiID0gXCJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XVwiLCBVYiA9IFwiW29iamVjdCBVaW50MTZBcnJheV1cIiwgQmIgPSBcIltvYmplY3QgVWludDMyQXJyYXldXCIsICR0ID0ge307XG4kdFtOZl0gPSAkdFt2Yl0gPSAkdFtDYl0gPSAkdFtBYl0gPSAkdFt5Yl0gPSAkdFt4Yl0gPSAkdFtMYl0gPSAkdFtrYl0gPSAkdFtEYl0gPSAkdFtSYl0gPSAkdFtJYl0gPSAkdFtFYl0gPSAkdFtPYl0gPSAkdFtVZl0gPSAkdFtTYl0gPSAkdFtUYl0gPSAkdFt3Yl0gPSAkdFskYl0gPSAkdFtOYl0gPSAkdFtQYl0gPSAkdFtVYl0gPSAkdFtCYl0gPSAhMDtcbiR0W2JiXSA9ICR0W1BmXSA9ICR0W01iXSA9ICExO1xuZnVuY3Rpb24gQmkoZSwgdCwgbiwgciwgaSwgcykge1xuICB2YXIgYSwgbyA9IHQgJiBmYiwgbCA9IHQgJiBtYiwgYyA9IHQgJiBnYjtcbiAgaWYgKG4gJiYgKGEgPSBpID8gbihlLCByLCBpLCBzKSA6IG4oZSkpLCBhICE9PSB2b2lkIDApXG4gICAgcmV0dXJuIGE7XG4gIGlmICghRGUoZSkpXG4gICAgcmV0dXJuIGU7XG4gIHZhciB1ID0gS3QoZSk7XG4gIGlmICh1KSB7XG4gICAgaWYgKGEgPSBQeChlKSwgIW8pXG4gICAgICByZXR1cm4gZ2YoZSwgYSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGQgPSAkZShlKSwgaCA9IGQgPT0gUGYgfHwgZCA9PSBfYjtcbiAgICBpZiAoV3IoZSkpXG4gICAgICByZXR1cm4gQ2YoZSwgbyk7XG4gICAgaWYgKGQgPT0gVWYgfHwgZCA9PSBOZiB8fCBoICYmICFpKSB7XG4gICAgICBpZiAoYSA9IGwgfHwgaCA/IHt9IDogSWYoZSksICFvKVxuICAgICAgICByZXR1cm4gbCA/IE14KGUsIF94KGEsIGUpKSA6IHd4KGUsIGJ4KGEsIGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEkdFtkXSlcbiAgICAgICAgcmV0dXJuIGkgPyBlIDoge307XG4gICAgICBhID0gb2IoZSwgZCwgbyk7XG4gICAgfVxuICB9XG4gIHMgfHwgKHMgPSBuZXcgR2UoKSk7XG4gIHZhciBwID0gcy5nZXQoZSk7XG4gIGlmIChwKVxuICAgIHJldHVybiBwO1xuICBzLnNldChlLCBhKSwgcGIoZSkgPyBlLmZvckVhY2goZnVuY3Rpb24obSkge1xuICAgIGEuYWRkKEJpKG0sIHQsIG4sIG0sIGUsIHMpKTtcbiAgfSkgOiB1YihlKSAmJiBlLmZvckVhY2goZnVuY3Rpb24obSwgdikge1xuICAgIGEuc2V0KHYsIEJpKG0sIHQsIG4sIHYsIGUsIHMpKTtcbiAgfSk7XG4gIHZhciBmID0gYyA/IGwgPyBEZiA6IGdsIDogbCA/IGNzIDogbHMsIGcgPSB1ID8gdm9pZCAwIDogZihlKTtcbiAgcmV0dXJuIE0xKGcgfHwgZSwgZnVuY3Rpb24obSwgdikge1xuICAgIGcgJiYgKHYgPSBtLCBtID0gZVt2XSksIHlmKGEsIHYsIEJpKG0sIHQsIG4sIHYsIGUsIHMpKTtcbiAgfSksIGE7XG59XG52YXIgSGIgPSAxLCBWYiA9IDQ7XG5mdW5jdGlvbiBTbihlKSB7XG4gIHJldHVybiBCaShlLCBIYiB8IFZiKTtcbn1cbnZhciBHYiA9IFwiX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfX1wiO1xuZnVuY3Rpb24gemIoZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5zZXQoZSwgR2IpLCB0aGlzO1xufVxuZnVuY3Rpb24gRmIoZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoZSk7XG59XG5mdW5jdGlvbiBYaShlKSB7XG4gIHZhciB0ID0gLTEsIG4gPSBlID09IG51bGwgPyAwIDogZS5sZW5ndGg7XG4gIGZvciAodGhpcy5fX2RhdGFfXyA9IG5ldyBrbigpOyArK3QgPCBuOyApXG4gICAgdGhpcy5hZGQoZVt0XSk7XG59XG5YaS5wcm90b3R5cGUuYWRkID0gWGkucHJvdG90eXBlLnB1c2ggPSB6YjtcblhpLnByb3RvdHlwZS5oYXMgPSBGYjtcbmZ1bmN0aW9uIEJmKGUsIHQpIHtcbiAgZm9yICh2YXIgbiA9IC0xLCByID0gZSA9PSBudWxsID8gMCA6IGUubGVuZ3RoOyArK24gPCByOyApXG4gICAgaWYgKHQoZVtuXSwgbiwgZSkpXG4gICAgICByZXR1cm4gITA7XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIEhmKGUsIHQpIHtcbiAgcmV0dXJuIGUuaGFzKHQpO1xufVxudmFyIGpiID0gMSwgV2IgPSAyO1xuZnVuY3Rpb24gVmYoZSwgdCwgbiwgciwgaSwgcykge1xuICB2YXIgYSA9IG4gJiBqYiwgbyA9IGUubGVuZ3RoLCBsID0gdC5sZW5ndGg7XG4gIGlmIChvICE9IGwgJiYgIShhICYmIGwgPiBvKSlcbiAgICByZXR1cm4gITE7XG4gIHZhciBjID0gcy5nZXQoZSksIHUgPSBzLmdldCh0KTtcbiAgaWYgKGMgJiYgdSlcbiAgICByZXR1cm4gYyA9PSB0ICYmIHUgPT0gZTtcbiAgdmFyIGQgPSAtMSwgaCA9ICEwLCBwID0gbiAmIFdiID8gbmV3IFhpKCkgOiB2b2lkIDA7XG4gIGZvciAocy5zZXQoZSwgdCksIHMuc2V0KHQsIGUpOyArK2QgPCBvOyApIHtcbiAgICB2YXIgZiA9IGVbZF0sIGcgPSB0W2RdO1xuICAgIGlmIChyKVxuICAgICAgdmFyIG0gPSBhID8gcihnLCBmLCBkLCB0LCBlLCBzKSA6IHIoZiwgZywgZCwgZSwgdCwgcyk7XG4gICAgaWYgKG0gIT09IHZvaWQgMCkge1xuICAgICAgaWYgKG0pXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaCA9ICExO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChwKSB7XG4gICAgICBpZiAoIUJmKHQsIGZ1bmN0aW9uKHYsIHgpIHtcbiAgICAgICAgaWYgKCFIZihwLCB4KSAmJiAoZiA9PT0gdiB8fCBpKGYsIHYsIG4sIHIsIHMpKSlcbiAgICAgICAgICByZXR1cm4gcC5wdXNoKHgpO1xuICAgICAgfSkpIHtcbiAgICAgICAgaCA9ICExO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoZiA9PT0gZyB8fCBpKGYsIGcsIG4sIHIsIHMpKSkge1xuICAgICAgaCA9ICExO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBzLmRlbGV0ZShlKSwgcy5kZWxldGUodCksIGg7XG59XG5mdW5jdGlvbiBxYihlKSB7XG4gIHZhciB0ID0gLTEsIG4gPSBBcnJheShlLnNpemUpO1xuICByZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKHIsIGkpIHtcbiAgICBuWysrdF0gPSBbaSwgcl07XG4gIH0pLCBuO1xufVxuZnVuY3Rpb24gTWMoZSkge1xuICB2YXIgdCA9IC0xLCBuID0gQXJyYXkoZS5zaXplKTtcbiAgcmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgblsrK3RdID0gcjtcbiAgfSksIG47XG59XG52YXIgWWIgPSAxLCBYYiA9IDIsIFpiID0gXCJbb2JqZWN0IEJvb2xlYW5dXCIsIEtiID0gXCJbb2JqZWN0IERhdGVdXCIsIFFiID0gXCJbb2JqZWN0IEVycm9yXVwiLCBKYiA9IFwiW29iamVjdCBNYXBdXCIsIHRfID0gXCJbb2JqZWN0IE51bWJlcl1cIiwgZV8gPSBcIltvYmplY3QgUmVnRXhwXVwiLCBuXyA9IFwiW29iamVjdCBTZXRdXCIsIHJfID0gXCJbb2JqZWN0IFN0cmluZ11cIiwgaV8gPSBcIltvYmplY3QgU3ltYm9sXVwiLCBzXyA9IFwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIiwgYV8gPSBcIltvYmplY3QgRGF0YVZpZXddXCIsIHNoID0ga2UgPyBrZS5wcm90b3R5cGUgOiB2b2lkIDAsIE1vID0gc2ggPyBzaC52YWx1ZU9mIDogdm9pZCAwO1xuZnVuY3Rpb24gb18oZSwgdCwgbiwgciwgaSwgcywgYSkge1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIGFfOlxuICAgICAgaWYgKGUuYnl0ZUxlbmd0aCAhPSB0LmJ5dGVMZW5ndGggfHwgZS5ieXRlT2Zmc2V0ICE9IHQuYnl0ZU9mZnNldClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgZSA9IGUuYnVmZmVyLCB0ID0gdC5idWZmZXI7XG4gICAgY2FzZSBzXzpcbiAgICAgIHJldHVybiAhKGUuYnl0ZUxlbmd0aCAhPSB0LmJ5dGVMZW5ndGggfHwgIXMobmV3IG9hKGUpLCBuZXcgb2EodCkpKTtcbiAgICBjYXNlIFpiOlxuICAgIGNhc2UgS2I6XG4gICAgY2FzZSB0XzpcbiAgICAgIHJldHVybiBvcygrZSwgK3QpO1xuICAgIGNhc2UgUWI6XG4gICAgICByZXR1cm4gZS5uYW1lID09IHQubmFtZSAmJiBlLm1lc3NhZ2UgPT0gdC5tZXNzYWdlO1xuICAgIGNhc2UgZV86XG4gICAgY2FzZSByXzpcbiAgICAgIHJldHVybiBlID09IHQgKyBcIlwiO1xuICAgIGNhc2UgSmI6XG4gICAgICB2YXIgbyA9IHFiO1xuICAgIGNhc2Ugbl86XG4gICAgICB2YXIgbCA9IHIgJiBZYjtcbiAgICAgIGlmIChvIHx8IChvID0gTWMpLCBlLnNpemUgIT0gdC5zaXplICYmICFsKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICB2YXIgYyA9IGEuZ2V0KGUpO1xuICAgICAgaWYgKGMpXG4gICAgICAgIHJldHVybiBjID09IHQ7XG4gICAgICByIHw9IFhiLCBhLnNldChlLCB0KTtcbiAgICAgIHZhciB1ID0gVmYobyhlKSwgbyh0KSwgciwgaSwgcywgYSk7XG4gICAgICByZXR1cm4gYS5kZWxldGUoZSksIHU7XG4gICAgY2FzZSBpXzpcbiAgICAgIGlmIChNbylcbiAgICAgICAgcmV0dXJuIE1vLmNhbGwoZSkgPT0gTW8uY2FsbCh0KTtcbiAgfVxuICByZXR1cm4gITE7XG59XG52YXIgbF8gPSAxLCBjXyA9IE9iamVjdC5wcm90b3R5cGUsIHVfID0gY18uaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoXyhlLCB0LCBuLCByLCBpLCBzKSB7XG4gIHZhciBhID0gbiAmIGxfLCBvID0gZ2woZSksIGwgPSBvLmxlbmd0aCwgYyA9IGdsKHQpLCB1ID0gYy5sZW5ndGg7XG4gIGlmIChsICE9IHUgJiYgIWEpXG4gICAgcmV0dXJuICExO1xuICBmb3IgKHZhciBkID0gbDsgZC0tOyApIHtcbiAgICB2YXIgaCA9IG9bZF07XG4gICAgaWYgKCEoYSA/IGggaW4gdCA6IHVfLmNhbGwodCwgaCkpKVxuICAgICAgcmV0dXJuICExO1xuICB9XG4gIHZhciBwID0gcy5nZXQoZSksIGYgPSBzLmdldCh0KTtcbiAgaWYgKHAgJiYgZilcbiAgICByZXR1cm4gcCA9PSB0ICYmIGYgPT0gZTtcbiAgdmFyIGcgPSAhMDtcbiAgcy5zZXQoZSwgdCksIHMuc2V0KHQsIGUpO1xuICBmb3IgKHZhciBtID0gYTsgKytkIDwgbDsgKSB7XG4gICAgaCA9IG9bZF07XG4gICAgdmFyIHYgPSBlW2hdLCB4ID0gdFtoXTtcbiAgICBpZiAocilcbiAgICAgIHZhciBfID0gYSA/IHIoeCwgdiwgaCwgdCwgZSwgcykgOiByKHYsIHgsIGgsIGUsIHQsIHMpO1xuICAgIGlmICghKF8gPT09IHZvaWQgMCA/IHYgPT09IHggfHwgaSh2LCB4LCBuLCByLCBzKSA6IF8pKSB7XG4gICAgICBnID0gITE7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbSB8fCAobSA9IGggPT0gXCJjb25zdHJ1Y3RvclwiKTtcbiAgfVxuICBpZiAoZyAmJiAhbSkge1xuICAgIHZhciBFID0gZS5jb25zdHJ1Y3RvciwgYiA9IHQuY29uc3RydWN0b3I7XG4gICAgRSAhPSBiICYmIFwiY29uc3RydWN0b3JcIiBpbiBlICYmIFwiY29uc3RydWN0b3JcIiBpbiB0ICYmICEodHlwZW9mIEUgPT0gXCJmdW5jdGlvblwiICYmIEUgaW5zdGFuY2VvZiBFICYmIHR5cGVvZiBiID09IFwiZnVuY3Rpb25cIiAmJiBiIGluc3RhbmNlb2YgYikgJiYgKGcgPSAhMSk7XG4gIH1cbiAgcmV0dXJuIHMuZGVsZXRlKGUpLCBzLmRlbGV0ZSh0KSwgZztcbn1cbnZhciBkXyA9IDEsIGFoID0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIiwgb2ggPSBcIltvYmplY3QgQXJyYXldXCIsIFRzID0gXCJbb2JqZWN0IE9iamVjdF1cIiwgcF8gPSBPYmplY3QucHJvdG90eXBlLCBsaCA9IHBfLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gZl8oZSwgdCwgbiwgciwgaSwgcykge1xuICB2YXIgYSA9IEt0KGUpLCBvID0gS3QodCksIGwgPSBhID8gb2ggOiAkZShlKSwgYyA9IG8gPyBvaCA6ICRlKHQpO1xuICBsID0gbCA9PSBhaCA/IFRzIDogbCwgYyA9IGMgPT0gYWggPyBUcyA6IGM7XG4gIHZhciB1ID0gbCA9PSBUcywgZCA9IGMgPT0gVHMsIGggPSBsID09IGM7XG4gIGlmIChoICYmIFdyKGUpKSB7XG4gICAgaWYgKCFXcih0KSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBhID0gITAsIHUgPSAhMTtcbiAgfVxuICBpZiAoaCAmJiAhdSlcbiAgICByZXR1cm4gcyB8fCAocyA9IG5ldyBHZSgpKSwgYSB8fCBxYShlKSA/IFZmKGUsIHQsIG4sIHIsIGksIHMpIDogb18oZSwgdCwgbCwgbiwgciwgaSwgcyk7XG4gIGlmICghKG4gJiBkXykpIHtcbiAgICB2YXIgcCA9IHUgJiYgbGguY2FsbChlLCBcIl9fd3JhcHBlZF9fXCIpLCBmID0gZCAmJiBsaC5jYWxsKHQsIFwiX193cmFwcGVkX19cIik7XG4gICAgaWYgKHAgfHwgZikge1xuICAgICAgdmFyIGcgPSBwID8gZS52YWx1ZSgpIDogZSwgbSA9IGYgPyB0LnZhbHVlKCkgOiB0O1xuICAgICAgcmV0dXJuIHMgfHwgKHMgPSBuZXcgR2UoKSksIGkoZywgbSwgbiwgciwgcyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBoID8gKHMgfHwgKHMgPSBuZXcgR2UoKSksIGhfKGUsIHQsIG4sIHIsIGksIHMpKSA6ICExO1xufVxuZnVuY3Rpb24gUWEoZSwgdCwgbiwgciwgaSkge1xuICByZXR1cm4gZSA9PT0gdCA/ICEwIDogZSA9PSBudWxsIHx8IHQgPT0gbnVsbCB8fCAhcm4oZSkgJiYgIXJuKHQpID8gZSAhPT0gZSAmJiB0ICE9PSB0IDogZl8oZSwgdCwgbiwgciwgUWEsIGkpO1xufVxudmFyIG1fID0gMSwgZ18gPSAyO1xuZnVuY3Rpb24gdl8oZSwgdCwgbiwgcikge1xuICB2YXIgaSA9IG4ubGVuZ3RoLCBzID0gaTtcbiAgaWYgKGUgPT0gbnVsbClcbiAgICByZXR1cm4gIXM7XG4gIGZvciAoZSA9IE9iamVjdChlKTsgaS0tOyApIHtcbiAgICB2YXIgYSA9IG5baV07XG4gICAgaWYgKGFbMl0gPyBhWzFdICE9PSBlW2FbMF1dIDogIShhWzBdIGluIGUpKVxuICAgICAgcmV0dXJuICExO1xuICB9XG4gIGZvciAoOyArK2kgPCBzOyApIHtcbiAgICBhID0gbltpXTtcbiAgICB2YXIgbyA9IGFbMF0sIGwgPSBlW29dLCBjID0gYVsxXTtcbiAgICBpZiAoYVsyXSkge1xuICAgICAgaWYgKGwgPT09IHZvaWQgMCAmJiAhKG8gaW4gZSkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHUgPSBuZXcgR2UoKSwgZDtcbiAgICAgIGlmICghKGQgPT09IHZvaWQgMCA/IFFhKGMsIGwsIG1fIHwgZ18sIHIsIHUpIDogZCkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gR2YoZSkge1xuICByZXR1cm4gZSA9PT0gZSAmJiAhRGUoZSk7XG59XG5mdW5jdGlvbiB5XyhlKSB7XG4gIGZvciAodmFyIHQgPSBscyhlKSwgbiA9IHQubGVuZ3RoOyBuLS07ICkge1xuICAgIHZhciByID0gdFtuXSwgaSA9IGVbcl07XG4gICAgdFtuXSA9IFtyLCBpLCBHZihpKV07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiB6ZihlLCB0KSB7XG4gIHJldHVybiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIG4gPT0gbnVsbCA/ICExIDogbltlXSA9PT0gdCAmJiAodCAhPT0gdm9pZCAwIHx8IGUgaW4gT2JqZWN0KG4pKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHhfKGUpIHtcbiAgdmFyIHQgPSB5XyhlKTtcbiAgcmV0dXJuIHQubGVuZ3RoID09IDEgJiYgdFswXVsyXSA/IHpmKHRbMF1bMF0sIHRbMF1bMV0pIDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiBuID09PSBlIHx8IHZfKG4sIGUsIHQpO1xuICB9O1xufVxuZnVuY3Rpb24gYl8oZSwgdCkge1xuICByZXR1cm4gZSAhPSBudWxsICYmIHQgaW4gT2JqZWN0KGUpO1xufVxuZnVuY3Rpb24gX18oZSwgdCwgbikge1xuICB0ID0gWmEodCwgZSk7XG4gIGZvciAodmFyIHIgPSAtMSwgaSA9IHQubGVuZ3RoLCBzID0gITE7ICsrciA8IGk7ICkge1xuICAgIHZhciBhID0gaHModFtyXSk7XG4gICAgaWYgKCEocyA9IGUgIT0gbnVsbCAmJiBuKGUsIGEpKSlcbiAgICAgIGJyZWFrO1xuICAgIGUgPSBlW2FdO1xuICB9XG4gIHJldHVybiBzIHx8ICsrciAhPSBpID8gcyA6IChpID0gZSA9PSBudWxsID8gMCA6IGUubGVuZ3RoLCAhIWkgJiYgeGMoaSkgJiYgdmMoYSwgaSkgJiYgKEt0KGUpIHx8IGpyKGUpKSk7XG59XG5mdW5jdGlvbiBFXyhlLCB0KSB7XG4gIHJldHVybiBlICE9IG51bGwgJiYgX18oZSwgdCwgYl8pO1xufVxudmFyIE9fID0gMSwgU18gPSAyO1xuZnVuY3Rpb24gVF8oZSwgdCkge1xuICByZXR1cm4gX2MoZSkgJiYgR2YodCkgPyB6ZihocyhlKSwgdCkgOiBmdW5jdGlvbihuKSB7XG4gICAgdmFyIHIgPSBndChuLCBlKTtcbiAgICByZXR1cm4gciA9PT0gdm9pZCAwICYmIHIgPT09IHQgPyBFXyhuLCBlKSA6IFFhKHQsIHIsIE9fIHwgU18pO1xuICB9O1xufVxuZnVuY3Rpb24gd18oZSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0ID09IG51bGwgPyB2b2lkIDAgOiB0W2VdO1xuICB9O1xufVxuZnVuY3Rpb24gJF8oZSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBPYyh0LCBlKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIE1fKGUpIHtcbiAgcmV0dXJuIF9jKGUpID8gd18oaHMoZSkpIDogJF8oZSk7XG59XG5mdW5jdGlvbiBKYShlKSB7XG4gIHJldHVybiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlIDogZSA9PSBudWxsID8gbWMgOiB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gS3QoZSkgPyBUXyhlWzBdLCBlWzFdKSA6IHhfKGUpIDogTV8oZSk7XG59XG5mdW5jdGlvbiBDXyhlKSB7XG4gIHJldHVybiBmdW5jdGlvbih0LCBuLCByKSB7XG4gICAgZm9yICh2YXIgaSA9IC0xLCBzID0gT2JqZWN0KHQpLCBhID0gcih0KSwgbyA9IGEubGVuZ3RoOyBvLS07ICkge1xuICAgICAgdmFyIGwgPSBhWysraV07XG4gICAgICBpZiAobihzW2xdLCBsLCBzKSA9PT0gITEpXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfTtcbn1cbnZhciBGZiA9IENfKCk7XG5mdW5jdGlvbiB4bChlLCB0LCBuKSB7XG4gIChuICE9PSB2b2lkIDAgJiYgIW9zKGVbdF0sIG4pIHx8IG4gPT09IHZvaWQgMCAmJiAhKHQgaW4gZSkpICYmIGphKGUsIHQsIG4pO1xufVxuZnVuY3Rpb24gYmwoZSkge1xuICByZXR1cm4gcm4oZSkgJiYgZnIoZSk7XG59XG5mdW5jdGlvbiBfbChlLCB0KSB7XG4gIGlmICghKHQgPT09IFwiY29uc3RydWN0b3JcIiAmJiB0eXBlb2YgZVt0XSA9PSBcImZ1bmN0aW9uXCIpICYmIHQgIT0gXCJfX3Byb3RvX19cIilcbiAgICByZXR1cm4gZVt0XTtcbn1cbmZ1bmN0aW9uIEFfKGUpIHtcbiAgcmV0dXJuIHJpKGUsIGNzKGUpKTtcbn1cbmZ1bmN0aW9uIExfKGUsIHQsIG4sIHIsIGksIHMsIGEpIHtcbiAgdmFyIG8gPSBfbChlLCBuKSwgbCA9IF9sKHQsIG4pLCBjID0gYS5nZXQobCk7XG4gIGlmIChjKSB7XG4gICAgeGwoZSwgbiwgYyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB1ID0gcyA/IHMobywgbCwgbiArIFwiXCIsIGUsIHQsIGEpIDogdm9pZCAwLCBkID0gdSA9PT0gdm9pZCAwO1xuICBpZiAoZCkge1xuICAgIHZhciBoID0gS3QobCksIHAgPSAhaCAmJiBXcihsKSwgZiA9ICFoICYmICFwICYmIHFhKGwpO1xuICAgIHUgPSBsLCBoIHx8IHAgfHwgZiA/IEt0KG8pID8gdSA9IG8gOiBibChvKSA/IHUgPSBnZihvKSA6IHAgPyAoZCA9ICExLCB1ID0gQ2YobCwgITApKSA6IGYgPyAoZCA9ICExLCB1ID0gUmYobCwgITApKSA6IHUgPSBbXSA6ICRmKGwpIHx8IGpyKGwpID8gKHUgPSBvLCBqcihvKSA/IHUgPSBBXyhvKSA6ICghRGUobykgfHwgZ2MobykpICYmICh1ID0gSWYobCkpKSA6IGQgPSAhMTtcbiAgfVxuICBkICYmIChhLnNldChsLCB1KSwgaSh1LCBsLCByLCBzLCBhKSwgYS5kZWxldGUobCkpLCB4bChlLCBuLCB1KTtcbn1cbmZ1bmN0aW9uIGpmKGUsIHQsIG4sIHIsIGkpIHtcbiAgZSAhPT0gdCAmJiBGZih0LCBmdW5jdGlvbihzLCBhKSB7XG4gICAgaWYgKGkgfHwgKGkgPSBuZXcgR2UoKSksIERlKHMpKVxuICAgICAgTF8oZSwgdCwgYSwgbiwgamYsIHIsIGkpO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIG8gPSByID8gcihfbChlLCBhKSwgcywgYSArIFwiXCIsIGUsIHQsIGkpIDogdm9pZCAwO1xuICAgICAgbyA9PT0gdm9pZCAwICYmIChvID0gcyksIHhsKGUsIGEsIG8pO1xuICAgIH1cbiAgfSwgY3MpO1xufVxuZnVuY3Rpb24gV2YoZSkge1xuICB2YXIgdCA9IGUgPT0gbnVsbCA/IDAgOiBlLmxlbmd0aDtcbiAgcmV0dXJuIHQgPyBlW3QgLSAxXSA6IHZvaWQgMDtcbn1cbnZhciBrXyA9IFwiW29iamVjdCBNYXBdXCIsIERfID0gXCJbb2JqZWN0IFNldF1cIiwgUl8gPSBPYmplY3QucHJvdG90eXBlLCBJXyA9IFJfLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gQmUoZSkge1xuICBpZiAoZSA9PSBudWxsKVxuICAgIHJldHVybiAhMDtcbiAgaWYgKGZyKGUpICYmIChLdChlKSB8fCB0eXBlb2YgZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBlLnNwbGljZSA9PSBcImZ1bmN0aW9uXCIgfHwgV3IoZSkgfHwgcWEoZSkgfHwganIoZSkpKVxuICAgIHJldHVybiAhZS5sZW5ndGg7XG4gIHZhciB0ID0gJGUoZSk7XG4gIGlmICh0ID09IGtfIHx8IHQgPT0gRF8pXG4gICAgcmV0dXJuICFlLnNpemU7XG4gIGlmIChXYShlKSlcbiAgICByZXR1cm4gIVRmKGUpLmxlbmd0aDtcbiAgZm9yICh2YXIgbiBpbiBlKVxuICAgIGlmIChJXy5jYWxsKGUsIG4pKVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59XG52YXIgYXQgPSBIMShmdW5jdGlvbihlLCB0LCBuKSB7XG4gIGpmKGUsIHQsIG4pO1xufSksIE5fID0gMSAvIDAsIFBfID0gVnIgJiYgMSAvIE1jKG5ldyBWcihbLCAtMF0pKVsxXSA9PSBOXyA/IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIG5ldyBWcihlKTtcbn0gOiBfMSwgVV8gPSAyMDA7XG5mdW5jdGlvbiBxZihlLCB0LCBuKSB7XG4gIHZhciByID0gLTEsIGkgPSBEMSwgcyA9IGUubGVuZ3RoLCBhID0gITAsIG8gPSBbXSwgbCA9IG87XG4gIGlmIChzID49IFVfKSB7XG4gICAgdmFyIGMgPSB0ID8gbnVsbCA6IFBfKGUpO1xuICAgIGlmIChjKVxuICAgICAgcmV0dXJuIE1jKGMpO1xuICAgIGEgPSAhMSwgaSA9IEhmLCBsID0gbmV3IFhpKCk7XG4gIH0gZWxzZVxuICAgIGwgPSB0ID8gW10gOiBvO1xuICB0OlxuICAgIGZvciAoOyArK3IgPCBzOyApIHtcbiAgICAgIHZhciB1ID0gZVtyXSwgZCA9IHQgPyB0KHUpIDogdTtcbiAgICAgIGlmICh1ID0gdSAhPT0gMCA/IHUgOiAwLCBhICYmIGQgPT09IGQpIHtcbiAgICAgICAgZm9yICh2YXIgaCA9IGwubGVuZ3RoOyBoLS07IClcbiAgICAgICAgICBpZiAobFtoXSA9PT0gZClcbiAgICAgICAgICAgIGNvbnRpbnVlIHQ7XG4gICAgICAgIHQgJiYgbC5wdXNoKGQpLCBvLnB1c2godSk7XG4gICAgICB9IGVsc2UgaShsLCBkLCBuKSB8fCAobCAhPT0gbyAmJiBsLnB1c2goZCksIG8ucHVzaCh1KSk7XG4gICAgfVxuICByZXR1cm4gbztcbn1cbnZhciBCXyA9IHljKGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHQgPSBXZihlKTtcbiAgcmV0dXJuIGJsKHQpICYmICh0ID0gdm9pZCAwKSwgcWYoS2EoZSwgMSwgYmwsICEwKSwgSmEodCkpO1xufSk7XG5mdW5jdGlvbiBaaShlKSB7XG4gIHJldHVybiBlICYmIGUubGVuZ3RoID8gcWYoZSkgOiBbXTtcbn1cbmZ1bmN0aW9uIEpuKGUsIHQpIHtcbiAgcmV0dXJuIGUgPT0gbnVsbCB8fCB0ID09IG51bGwgPyBOYU4gOiBlIDwgdCA/IC0xIDogZSA+IHQgPyAxIDogZSA+PSB0ID8gMCA6IE5hTjtcbn1cbmZ1bmN0aW9uIEhfKGUsIHQpIHtcbiAgcmV0dXJuIGUgPT0gbnVsbCB8fCB0ID09IG51bGwgPyBOYU4gOiB0IDwgZSA/IC0xIDogdCA+IGUgPyAxIDogdCA+PSBlID8gMCA6IE5hTjtcbn1cbmZ1bmN0aW9uIENjKGUpIHtcbiAgbGV0IHQsIG4sIHI7XG4gIGUubGVuZ3RoICE9PSAyID8gKHQgPSBKbiwgbiA9IChvLCBsKSA9PiBKbihlKG8pLCBsKSwgciA9IChvLCBsKSA9PiBlKG8pIC0gbCkgOiAodCA9IGUgPT09IEpuIHx8IGUgPT09IEhfID8gZSA6IFZfLCBuID0gZSwgciA9IGUpO1xuICBmdW5jdGlvbiBpKG8sIGwsIGMgPSAwLCB1ID0gby5sZW5ndGgpIHtcbiAgICBpZiAoYyA8IHUpIHtcbiAgICAgIGlmICh0KGwsIGwpICE9PSAwKSByZXR1cm4gdTtcbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3QgZCA9IGMgKyB1ID4+PiAxO1xuICAgICAgICBuKG9bZF0sIGwpIDwgMCA/IGMgPSBkICsgMSA6IHUgPSBkO1xuICAgICAgfSB3aGlsZSAoYyA8IHUpO1xuICAgIH1cbiAgICByZXR1cm4gYztcbiAgfVxuICBmdW5jdGlvbiBzKG8sIGwsIGMgPSAwLCB1ID0gby5sZW5ndGgpIHtcbiAgICBpZiAoYyA8IHUpIHtcbiAgICAgIGlmICh0KGwsIGwpICE9PSAwKSByZXR1cm4gdTtcbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3QgZCA9IGMgKyB1ID4+PiAxO1xuICAgICAgICBuKG9bZF0sIGwpIDw9IDAgPyBjID0gZCArIDEgOiB1ID0gZDtcbiAgICAgIH0gd2hpbGUgKGMgPCB1KTtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG4gIH1cbiAgZnVuY3Rpb24gYShvLCBsLCBjID0gMCwgdSA9IG8ubGVuZ3RoKSB7XG4gICAgY29uc3QgZCA9IGkobywgbCwgYywgdSAtIDEpO1xuICAgIHJldHVybiBkID4gYyAmJiByKG9bZCAtIDFdLCBsKSA+IC1yKG9bZF0sIGwpID8gZCAtIDEgOiBkO1xuICB9XG4gIHJldHVybiB7IGxlZnQ6IGksIGNlbnRlcjogYSwgcmlnaHQ6IHMgfTtcbn1cbmZ1bmN0aW9uIFZfKCkge1xuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIEdfKGUpIHtcbiAgcmV0dXJuIGUgPT09IG51bGwgPyBOYU4gOiArZTtcbn1cbmZ1bmN0aW9uKiB6XyhlLCB0KSB7XG4gIGZvciAobGV0IG4gb2YgZSlcbiAgICBuICE9IG51bGwgJiYgKG4gPSArbikgPj0gbiAmJiAoeWllbGQgbik7XG59XG5jb25zdCBGXyA9IENjKEpuKSwgQWMgPSBGXy5yaWdodDtcbkNjKEdfKS5jZW50ZXI7XG5mdW5jdGlvbiB6ZShlLCB0KSB7XG4gIGxldCBuLCByO1xuICBpZiAodCA9PT0gdm9pZCAwKVxuICAgIGZvciAoY29uc3QgaSBvZiBlKVxuICAgICAgaSAhPSBudWxsICYmIChuID09PSB2b2lkIDAgPyBpID49IGkgJiYgKG4gPSByID0gaSkgOiAobiA+IGkgJiYgKG4gPSBpKSwgciA8IGkgJiYgKHIgPSBpKSkpO1xuICBlbHNlIHtcbiAgICBsZXQgaSA9IC0xO1xuICAgIGZvciAobGV0IHMgb2YgZSlcbiAgICAgIChzID0gdChzLCArK2ksIGUpKSAhPSBudWxsICYmIChuID09PSB2b2lkIDAgPyBzID49IHMgJiYgKG4gPSByID0gcykgOiAobiA+IHMgJiYgKG4gPSBzKSwgciA8IHMgJiYgKHIgPSBzKSkpO1xuICB9XG4gIHJldHVybiBbbiwgcl07XG59XG5sZXQgY2ggPSBjbGFzcyBleHRlbmRzIE1hcCB7XG4gIGNvbnN0cnVjdG9yKHQsIG4gPSBxXykge1xuICAgIGlmIChzdXBlcigpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IF9pbnRlcm46IHsgdmFsdWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkgfSwgX2tleTogeyB2YWx1ZTogbiB9IH0pLCB0ICE9IG51bGwpIGZvciAoY29uc3QgW3IsIGldIG9mIHQpIHRoaXMuc2V0KHIsIGkpO1xuICB9XG4gIGdldCh0KSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldCh1aCh0aGlzLCB0KSk7XG4gIH1cbiAgaGFzKHQpIHtcbiAgICByZXR1cm4gc3VwZXIuaGFzKHVoKHRoaXMsIHQpKTtcbiAgfVxuICBzZXQodCwgbikge1xuICAgIHJldHVybiBzdXBlci5zZXQoal8odGhpcywgdCksIG4pO1xuICB9XG4gIGRlbGV0ZSh0KSB7XG4gICAgcmV0dXJuIHN1cGVyLmRlbGV0ZShXXyh0aGlzLCB0KSk7XG4gIH1cbn07XG5mdW5jdGlvbiB1aCh7IF9pbnRlcm46IGUsIF9rZXk6IHQgfSwgbikge1xuICBjb25zdCByID0gdChuKTtcbiAgcmV0dXJuIGUuaGFzKHIpID8gZS5nZXQocikgOiBuO1xufVxuZnVuY3Rpb24gal8oeyBfaW50ZXJuOiBlLCBfa2V5OiB0IH0sIG4pIHtcbiAgY29uc3QgciA9IHQobik7XG4gIHJldHVybiBlLmhhcyhyKSA/IGUuZ2V0KHIpIDogKGUuc2V0KHIsIG4pLCBuKTtcbn1cbmZ1bmN0aW9uIFdfKHsgX2ludGVybjogZSwgX2tleTogdCB9LCBuKSB7XG4gIGNvbnN0IHIgPSB0KG4pO1xuICByZXR1cm4gZS5oYXMocikgJiYgKG4gPSBlLmdldChyKSwgZS5kZWxldGUocikpLCBuO1xufVxuZnVuY3Rpb24gcV8oZSkge1xuICByZXR1cm4gZSAhPT0gbnVsbCAmJiB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZS52YWx1ZU9mKCkgOiBlO1xufVxuY29uc3QgWV8gPSBNYXRoLnNxcnQoNTApLCBYXyA9IE1hdGguc3FydCgxMCksIFpfID0gTWF0aC5zcXJ0KDIpO1xuZnVuY3Rpb24gbGEoZSwgdCwgbikge1xuICBjb25zdCByID0gKHQgLSBlKSAvIE1hdGgubWF4KDAsIG4pLCBpID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKHIpKSwgcyA9IHIgLyBNYXRoLnBvdygxMCwgaSksIGEgPSBzID49IFlfID8gMTAgOiBzID49IFhfID8gNSA6IHMgPj0gWl8gPyAyIDogMTtcbiAgbGV0IG8sIGwsIGM7XG4gIHJldHVybiBpIDwgMCA/IChjID0gTWF0aC5wb3coMTAsIC1pKSAvIGEsIG8gPSBNYXRoLnJvdW5kKGUgKiBjKSwgbCA9IE1hdGgucm91bmQodCAqIGMpLCBvIC8gYyA8IGUgJiYgKytvLCBsIC8gYyA+IHQgJiYgLS1sLCBjID0gLWMpIDogKGMgPSBNYXRoLnBvdygxMCwgaSkgKiBhLCBvID0gTWF0aC5yb3VuZChlIC8gYyksIGwgPSBNYXRoLnJvdW5kKHQgLyBjKSwgbyAqIGMgPCBlICYmICsrbywgbCAqIGMgPiB0ICYmIC0tbCksIGwgPCBvICYmIDAuNSA8PSBuICYmIG4gPCAyID8gbGEoZSwgdCwgbiAqIDIpIDogW28sIGwsIGNdO1xufVxuZnVuY3Rpb24gY2EoZSwgdCwgbikge1xuICBpZiAodCA9ICt0LCBlID0gK2UsIG4gPSArbiwgIShuID4gMCkpIHJldHVybiBbXTtcbiAgaWYgKGUgPT09IHQpIHJldHVybiBbZV07XG4gIGNvbnN0IHIgPSB0IDwgZSwgW2ksIHMsIGFdID0gciA/IGxhKHQsIGUsIG4pIDogbGEoZSwgdCwgbik7XG4gIGlmICghKHMgPj0gaSkpIHJldHVybiBbXTtcbiAgY29uc3QgbyA9IHMgLSBpICsgMSwgbCA9IG5ldyBBcnJheShvKTtcbiAgaWYgKHIpXG4gICAgaWYgKGEgPCAwKSBmb3IgKGxldCBjID0gMDsgYyA8IG87ICsrYykgbFtjXSA9IChzIC0gYykgLyAtYTtcbiAgICBlbHNlIGZvciAobGV0IGMgPSAwOyBjIDwgbzsgKytjKSBsW2NdID0gKHMgLSBjKSAqIGE7XG4gIGVsc2UgaWYgKGEgPCAwKSBmb3IgKGxldCBjID0gMDsgYyA8IG87ICsrYykgbFtjXSA9IChpICsgYykgLyAtYTtcbiAgZWxzZSBmb3IgKGxldCBjID0gMDsgYyA8IG87ICsrYykgbFtjXSA9IChpICsgYykgKiBhO1xuICByZXR1cm4gbDtcbn1cbmZ1bmN0aW9uIFlyKGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgPSArdCwgZSA9ICtlLCBuID0gK24sIGxhKGUsIHQsIG4pWzJdO1xufVxuZnVuY3Rpb24gRWwoZSwgdCwgbikge1xuICB0ID0gK3QsIGUgPSArZSwgbiA9ICtuO1xuICBjb25zdCByID0gdCA8IGUsIGkgPSByID8gWXIodCwgZSwgbikgOiBZcihlLCB0LCBuKTtcbiAgcmV0dXJuIChyID8gLTEgOiAxKSAqIChpIDwgMCA/IDEgLyAtaSA6IGkpO1xufVxuZnVuY3Rpb24gbnIoZSwgdCkge1xuICBsZXQgbjtcbiAgaWYgKHQgPT09IHZvaWQgMClcbiAgICBmb3IgKGNvbnN0IHIgb2YgZSlcbiAgICAgIHIgIT0gbnVsbCAmJiAobiA8IHIgfHwgbiA9PT0gdm9pZCAwICYmIHIgPj0gcikgJiYgKG4gPSByKTtcbiAgZWxzZSB7XG4gICAgbGV0IHIgPSAtMTtcbiAgICBmb3IgKGxldCBpIG9mIGUpXG4gICAgICAoaSA9IHQoaSwgKytyLCBlKSkgIT0gbnVsbCAmJiAobiA8IGkgfHwgbiA9PT0gdm9pZCAwICYmIGkgPj0gaSkgJiYgKG4gPSBpKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIEJuKGUsIHQpIHtcbiAgbGV0IG47XG4gIGZvciAoY29uc3QgciBvZiBlKVxuICAgIHIgIT0gbnVsbCAmJiAobiA+IHIgfHwgbiA9PT0gdm9pZCAwICYmIHIgPj0gcikgJiYgKG4gPSByKTtcbiAgcmV0dXJuIG47XG59XG52YXIgS18gPSB7IHZhbHVlOiAoKSA9PiB7XG59IH07XG5mdW5jdGlvbiBMYygpIHtcbiAgZm9yICh2YXIgZSA9IDAsIHQgPSBhcmd1bWVudHMubGVuZ3RoLCBuID0ge30sIHI7IGUgPCB0OyArK2UpIHtcbiAgICBpZiAoIShyID0gYXJndW1lbnRzW2VdICsgXCJcIikgfHwgciBpbiBuIHx8IC9bXFxzLl0vLnRlc3QocikpIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgdHlwZTogXCIgKyByKTtcbiAgICBuW3JdID0gW107XG4gIH1cbiAgcmV0dXJuIG5ldyBZcyhuKTtcbn1cbmZ1bmN0aW9uIFlzKGUpIHtcbiAgdGhpcy5fID0gZTtcbn1cbmZ1bmN0aW9uIFFfKGUsIHQpIHtcbiAgcmV0dXJuIGUudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24obikge1xuICAgIHZhciByID0gXCJcIiwgaSA9IG4uaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCAmJiAociA9IG4uc2xpY2UoaSArIDEpLCBuID0gbi5zbGljZSgwLCBpKSksIG4gJiYgIXQuaGFzT3duUHJvcGVydHkobikpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyBuKTtcbiAgICByZXR1cm4geyB0eXBlOiBuLCBuYW1lOiByIH07XG4gIH0pO1xufVxuWXMucHJvdG90eXBlID0gTGMucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogWXMsXG4gIG9uOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgdmFyIG4gPSB0aGlzLl8sIHIgPSBRXyhlICsgXCJcIiwgbiksIGksIHMgPSAtMSwgYSA9IHIubGVuZ3RoO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgZm9yICg7ICsrcyA8IGE7ICkgaWYgKChpID0gKGUgPSByW3NdKS50eXBlKSAmJiAoaSA9IEpfKG5baV0sIGUubmFtZSkpKSByZXR1cm4gaTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHQgIT0gbnVsbCAmJiB0eXBlb2YgdCAhPSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2FsbGJhY2s6IFwiICsgdCk7XG4gICAgZm9yICg7ICsrcyA8IGE7IClcbiAgICAgIGlmIChpID0gKGUgPSByW3NdKS50eXBlKSBuW2ldID0gaGgobltpXSwgZS5uYW1lLCB0KTtcbiAgICAgIGVsc2UgaWYgKHQgPT0gbnVsbCkgZm9yIChpIGluIG4pIG5baV0gPSBoaChuW2ldLCBlLm5hbWUsIG51bGwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZSA9IHt9LCB0ID0gdGhpcy5fO1xuICAgIGZvciAodmFyIG4gaW4gdCkgZVtuXSA9IHRbbl0uc2xpY2UoKTtcbiAgICByZXR1cm4gbmV3IFlzKGUpO1xuICB9LFxuICBjYWxsOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgaWYgKChpID0gYXJndW1lbnRzLmxlbmd0aCAtIDIpID4gMCkgZm9yICh2YXIgbiA9IG5ldyBBcnJheShpKSwgciA9IDAsIGksIHM7IHIgPCBpOyArK3IpIG5bcl0gPSBhcmd1bWVudHNbciArIDJdO1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgZSk7XG4gICAgZm9yIChzID0gdGhpcy5fW2VdLCByID0gMCwgaSA9IHMubGVuZ3RoOyByIDwgaTsgKytyKSBzW3JdLnZhbHVlLmFwcGx5KHQsIG4pO1xuICB9LFxuICBhcHBseTogZnVuY3Rpb24oZSwgdCwgbikge1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgZSk7XG4gICAgZm9yICh2YXIgciA9IHRoaXMuX1tlXSwgaSA9IDAsIHMgPSByLmxlbmd0aDsgaSA8IHM7ICsraSkgcltpXS52YWx1ZS5hcHBseSh0LCBuKTtcbiAgfVxufTtcbmZ1bmN0aW9uIEpfKGUsIHQpIHtcbiAgZm9yICh2YXIgbiA9IDAsIHIgPSBlLmxlbmd0aCwgaTsgbiA8IHI7ICsrbilcbiAgICBpZiAoKGkgPSBlW25dKS5uYW1lID09PSB0KVxuICAgICAgcmV0dXJuIGkudmFsdWU7XG59XG5mdW5jdGlvbiBoaChlLCB0LCBuKSB7XG4gIGZvciAodmFyIHIgPSAwLCBpID0gZS5sZW5ndGg7IHIgPCBpOyArK3IpXG4gICAgaWYgKGVbcl0ubmFtZSA9PT0gdCkge1xuICAgICAgZVtyXSA9IEtfLCBlID0gZS5zbGljZSgwLCByKS5jb25jYXQoZS5zbGljZShyICsgMSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gbiAhPSBudWxsICYmIGUucHVzaCh7IG5hbWU6IHQsIHZhbHVlOiBuIH0pLCBlO1xufVxudmFyIE9sID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG5jb25zdCBkaCA9IHtcbiAgc3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIHhodG1sOiBPbCxcbiAgeGxpbms6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICB4bWw6IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvXCJcbn07XG5mdW5jdGlvbiB0byhlKSB7XG4gIHZhciB0ID0gZSArPSBcIlwiLCBuID0gdC5pbmRleE9mKFwiOlwiKTtcbiAgcmV0dXJuIG4gPj0gMCAmJiAodCA9IGUuc2xpY2UoMCwgbikpICE9PSBcInhtbG5zXCIgJiYgKGUgPSBlLnNsaWNlKG4gKyAxKSksIGRoLmhhc093blByb3BlcnR5KHQpID8geyBzcGFjZTogZGhbdF0sIGxvY2FsOiBlIH0gOiBlO1xufVxuZnVuY3Rpb24gdEUoZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSB0aGlzLm93bmVyRG9jdW1lbnQsIG4gPSB0aGlzLm5hbWVzcGFjZVVSSTtcbiAgICByZXR1cm4gbiA9PT0gT2wgJiYgdC5kb2N1bWVudEVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBPbCA/IHQuY3JlYXRlRWxlbWVudChlKSA6IHQuY3JlYXRlRWxlbWVudE5TKG4sIGUpO1xuICB9O1xufVxuZnVuY3Rpb24gZUUoZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZS5zcGFjZSwgZS5sb2NhbCk7XG4gIH07XG59XG5mdW5jdGlvbiBZZihlKSB7XG4gIHZhciB0ID0gdG8oZSk7XG4gIHJldHVybiAodC5sb2NhbCA/IGVFIDogdEUpKHQpO1xufVxuZnVuY3Rpb24gbkUoKSB7XG59XG5mdW5jdGlvbiBrYyhlKSB7XG4gIHJldHVybiBlID09IG51bGwgPyBuRSA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoZSk7XG4gIH07XG59XG5mdW5jdGlvbiByRShlKSB7XG4gIHR5cGVvZiBlICE9IFwiZnVuY3Rpb25cIiAmJiAoZSA9IGtjKGUpKTtcbiAgZm9yICh2YXIgdCA9IHRoaXMuX2dyb3VwcywgbiA9IHQubGVuZ3RoLCByID0gbmV3IEFycmF5KG4pLCBpID0gMDsgaSA8IG47ICsraSlcbiAgICBmb3IgKHZhciBzID0gdFtpXSwgYSA9IHMubGVuZ3RoLCBvID0gcltpXSA9IG5ldyBBcnJheShhKSwgbCwgYywgdSA9IDA7IHUgPCBhOyArK3UpXG4gICAgICAobCA9IHNbdV0pICYmIChjID0gZS5jYWxsKGwsIGwuX19kYXRhX18sIHUsIHMpKSAmJiAoXCJfX2RhdGFfX1wiIGluIGwgJiYgKGMuX19kYXRhX18gPSBsLl9fZGF0YV9fKSwgb1t1XSA9IGMpO1xuICByZXR1cm4gbmV3IF9lKHIsIHRoaXMuX3BhcmVudHMpO1xufVxuZnVuY3Rpb24gaUUoZSkge1xuICByZXR1cm4gZSA9PSBudWxsID8gW10gOiBBcnJheS5pc0FycmF5KGUpID8gZSA6IEFycmF5LmZyb20oZSk7XG59XG5mdW5jdGlvbiBzRSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gWGYoZSkge1xuICByZXR1cm4gZSA9PSBudWxsID8gc0UgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKGUpO1xuICB9O1xufVxuZnVuY3Rpb24gYUUoZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlFKGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG5mdW5jdGlvbiBvRShlKSB7XG4gIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUgPSBhRShlKSA6IGUgPSBYZihlKTtcbiAgZm9yICh2YXIgdCA9IHRoaXMuX2dyb3VwcywgbiA9IHQubGVuZ3RoLCByID0gW10sIGkgPSBbXSwgcyA9IDA7IHMgPCBuOyArK3MpXG4gICAgZm9yICh2YXIgYSA9IHRbc10sIG8gPSBhLmxlbmd0aCwgbCwgYyA9IDA7IGMgPCBvOyArK2MpXG4gICAgICAobCA9IGFbY10pICYmIChyLnB1c2goZS5jYWxsKGwsIGwuX19kYXRhX18sIGMsIGEpKSwgaS5wdXNoKGwpKTtcbiAgcmV0dXJuIG5ldyBfZShyLCBpKTtcbn1cbmZ1bmN0aW9uIFpmKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoZXMoZSk7XG4gIH07XG59XG5mdW5jdGlvbiBLZihlKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQubWF0Y2hlcyhlKTtcbiAgfTtcbn1cbnZhciBsRSA9IEFycmF5LnByb3RvdHlwZS5maW5kO1xuZnVuY3Rpb24gY0UoZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxFLmNhbGwodGhpcy5jaGlsZHJlbiwgZSk7XG4gIH07XG59XG5mdW5jdGlvbiB1RSgpIHtcbiAgcmV0dXJuIHRoaXMuZmlyc3RFbGVtZW50Q2hpbGQ7XG59XG5mdW5jdGlvbiBoRShlKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdChlID09IG51bGwgPyB1RSA6IGNFKHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUgOiBLZihlKSkpO1xufVxudmFyIGRFID0gQXJyYXkucHJvdG90eXBlLmZpbHRlcjtcbmZ1bmN0aW9uIHBFKCkge1xuICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIGZFKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkRS5jYWxsKHRoaXMuY2hpbGRyZW4sIGUpO1xuICB9O1xufVxuZnVuY3Rpb24gbUUoZSkge1xuICByZXR1cm4gdGhpcy5zZWxlY3RBbGwoZSA9PSBudWxsID8gcEUgOiBmRSh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlIDogS2YoZSkpKTtcbn1cbmZ1bmN0aW9uIGdFKGUpIHtcbiAgdHlwZW9mIGUgIT0gXCJmdW5jdGlvblwiICYmIChlID0gWmYoZSkpO1xuICBmb3IgKHZhciB0ID0gdGhpcy5fZ3JvdXBzLCBuID0gdC5sZW5ndGgsIHIgPSBuZXcgQXJyYXkobiksIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGZvciAodmFyIHMgPSB0W2ldLCBhID0gcy5sZW5ndGgsIG8gPSByW2ldID0gW10sIGwsIGMgPSAwOyBjIDwgYTsgKytjKVxuICAgICAgKGwgPSBzW2NdKSAmJiBlLmNhbGwobCwgbC5fX2RhdGFfXywgYywgcykgJiYgby5wdXNoKGwpO1xuICByZXR1cm4gbmV3IF9lKHIsIHRoaXMuX3BhcmVudHMpO1xufVxuZnVuY3Rpb24gUWYoZSkge1xuICByZXR1cm4gbmV3IEFycmF5KGUubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIHZFKCkge1xuICByZXR1cm4gbmV3IF9lKHRoaXMuX2VudGVyIHx8IHRoaXMuX2dyb3Vwcy5tYXAoUWYpLCB0aGlzLl9wYXJlbnRzKTtcbn1cbmZ1bmN0aW9uIHVhKGUsIHQpIHtcbiAgdGhpcy5vd25lckRvY3VtZW50ID0gZS5vd25lckRvY3VtZW50LCB0aGlzLm5hbWVzcGFjZVVSSSA9IGUubmFtZXNwYWNlVVJJLCB0aGlzLl9uZXh0ID0gbnVsbCwgdGhpcy5fcGFyZW50ID0gZSwgdGhpcy5fX2RhdGFfXyA9IHQ7XG59XG51YS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiB1YSxcbiAgYXBwZW5kQ2hpbGQ6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydEJlZm9yZShlLCB0aGlzLl9uZXh0KTtcbiAgfSxcbiAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoZSwgdCk7XG4gIH0sXG4gIHF1ZXJ5U2VsZWN0b3I6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3IoZSk7XG4gIH0sXG4gIHF1ZXJ5U2VsZWN0b3JBbGw6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZSk7XG4gIH1cbn07XG5mdW5jdGlvbiB5RShlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHhFKGUsIHQsIG4sIHIsIGksIHMpIHtcbiAgZm9yICh2YXIgYSA9IDAsIG8sIGwgPSB0Lmxlbmd0aCwgYyA9IHMubGVuZ3RoOyBhIDwgYzsgKythKVxuICAgIChvID0gdFthXSkgPyAoby5fX2RhdGFfXyA9IHNbYV0sIHJbYV0gPSBvKSA6IG5bYV0gPSBuZXcgdWEoZSwgc1thXSk7XG4gIGZvciAoOyBhIDwgbDsgKythKVxuICAgIChvID0gdFthXSkgJiYgKGlbYV0gPSBvKTtcbn1cbmZ1bmN0aW9uIGJFKGUsIHQsIG4sIHIsIGksIHMsIGEpIHtcbiAgdmFyIG8sIGwsIGMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB1ID0gdC5sZW5ndGgsIGQgPSBzLmxlbmd0aCwgaCA9IG5ldyBBcnJheSh1KSwgcDtcbiAgZm9yIChvID0gMDsgbyA8IHU7ICsrbylcbiAgICAobCA9IHRbb10pICYmIChoW29dID0gcCA9IGEuY2FsbChsLCBsLl9fZGF0YV9fLCBvLCB0KSArIFwiXCIsIGMuaGFzKHApID8gaVtvXSA9IGwgOiBjLnNldChwLCBsKSk7XG4gIGZvciAobyA9IDA7IG8gPCBkOyArK28pXG4gICAgcCA9IGEuY2FsbChlLCBzW29dLCBvLCBzKSArIFwiXCIsIChsID0gYy5nZXQocCkpID8gKHJbb10gPSBsLCBsLl9fZGF0YV9fID0gc1tvXSwgYy5kZWxldGUocCkpIDogbltvXSA9IG5ldyB1YShlLCBzW29dKTtcbiAgZm9yIChvID0gMDsgbyA8IHU7ICsrbylcbiAgICAobCA9IHRbb10pICYmIGMuZ2V0KGhbb10pID09PSBsICYmIChpW29dID0gbCk7XG59XG5mdW5jdGlvbiBfRShlKSB7XG4gIHJldHVybiBlLl9fZGF0YV9fO1xufVxuZnVuY3Rpb24gRUUoZSwgdCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBBcnJheS5mcm9tKHRoaXMsIF9FKTtcbiAgdmFyIG4gPSB0ID8gYkUgOiB4RSwgciA9IHRoaXMuX3BhcmVudHMsIGkgPSB0aGlzLl9ncm91cHM7XG4gIHR5cGVvZiBlICE9IFwiZnVuY3Rpb25cIiAmJiAoZSA9IHlFKGUpKTtcbiAgZm9yICh2YXIgcyA9IGkubGVuZ3RoLCBhID0gbmV3IEFycmF5KHMpLCBvID0gbmV3IEFycmF5KHMpLCBsID0gbmV3IEFycmF5KHMpLCBjID0gMDsgYyA8IHM7ICsrYykge1xuICAgIHZhciB1ID0gcltjXSwgZCA9IGlbY10sIGggPSBkLmxlbmd0aCwgcCA9IE9FKGUuY2FsbCh1LCB1ICYmIHUuX19kYXRhX18sIGMsIHIpKSwgZiA9IHAubGVuZ3RoLCBnID0gb1tjXSA9IG5ldyBBcnJheShmKSwgbSA9IGFbY10gPSBuZXcgQXJyYXkoZiksIHYgPSBsW2NdID0gbmV3IEFycmF5KGgpO1xuICAgIG4odSwgZCwgZywgbSwgdiwgcCwgdCk7XG4gICAgZm9yICh2YXIgeCA9IDAsIF8gPSAwLCBFLCBiOyB4IDwgZjsgKyt4KVxuICAgICAgaWYgKEUgPSBnW3hdKSB7XG4gICAgICAgIGZvciAoeCA+PSBfICYmIChfID0geCArIDEpOyAhKGIgPSBtW19dKSAmJiArK18gPCBmOyApIDtcbiAgICAgICAgRS5fbmV4dCA9IGIgfHwgbnVsbDtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gYSA9IG5ldyBfZShhLCByKSwgYS5fZW50ZXIgPSBvLCBhLl9leGl0ID0gbCwgYTtcbn1cbmZ1bmN0aW9uIE9FKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgXCJsZW5ndGhcIiBpbiBlID8gZSA6IEFycmF5LmZyb20oZSk7XG59XG5mdW5jdGlvbiBTRSgpIHtcbiAgcmV0dXJuIG5ldyBfZSh0aGlzLl9leGl0IHx8IHRoaXMuX2dyb3Vwcy5tYXAoUWYpLCB0aGlzLl9wYXJlbnRzKTtcbn1cbmZ1bmN0aW9uIFRFKGUsIHQsIG4pIHtcbiAgdmFyIHIgPSB0aGlzLmVudGVyKCksIGkgPSB0aGlzLCBzID0gdGhpcy5leGl0KCk7XG4gIHJldHVybiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyAociA9IGUociksIHIgJiYgKHIgPSByLnNlbGVjdGlvbigpKSkgOiByID0gci5hcHBlbmQoZSArIFwiXCIpLCB0ICE9IG51bGwgJiYgKGkgPSB0KGkpLCBpICYmIChpID0gaS5zZWxlY3Rpb24oKSkpLCBuID09IG51bGwgPyBzLnJlbW92ZSgpIDogbihzKSwgciAmJiBpID8gci5tZXJnZShpKS5vcmRlcigpIDogaTtcbn1cbmZ1bmN0aW9uIHdFKGUpIHtcbiAgZm9yICh2YXIgdCA9IGUuc2VsZWN0aW9uID8gZS5zZWxlY3Rpb24oKSA6IGUsIG4gPSB0aGlzLl9ncm91cHMsIHIgPSB0Ll9ncm91cHMsIGkgPSBuLmxlbmd0aCwgcyA9IHIubGVuZ3RoLCBhID0gTWF0aC5taW4oaSwgcyksIG8gPSBuZXcgQXJyYXkoaSksIGwgPSAwOyBsIDwgYTsgKytsKVxuICAgIGZvciAodmFyIGMgPSBuW2xdLCB1ID0gcltsXSwgZCA9IGMubGVuZ3RoLCBoID0gb1tsXSA9IG5ldyBBcnJheShkKSwgcCwgZiA9IDA7IGYgPCBkOyArK2YpXG4gICAgICAocCA9IGNbZl0gfHwgdVtmXSkgJiYgKGhbZl0gPSBwKTtcbiAgZm9yICg7IGwgPCBpOyArK2wpXG4gICAgb1tsXSA9IG5bbF07XG4gIHJldHVybiBuZXcgX2UobywgdGhpcy5fcGFyZW50cyk7XG59XG5mdW5jdGlvbiAkRSgpIHtcbiAgZm9yICh2YXIgZSA9IHRoaXMuX2dyb3VwcywgdCA9IC0xLCBuID0gZS5sZW5ndGg7ICsrdCA8IG47IClcbiAgICBmb3IgKHZhciByID0gZVt0XSwgaSA9IHIubGVuZ3RoIC0gMSwgcyA9IHJbaV0sIGE7IC0taSA+PSAwOyApXG4gICAgICAoYSA9IHJbaV0pICYmIChzICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24ocykgXiA0ICYmIHMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSwgcyksIHMgPSBhKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBNRShlKSB7XG4gIGUgfHwgKGUgPSBDRSk7XG4gIGZ1bmN0aW9uIHQoZCwgaCkge1xuICAgIHJldHVybiBkICYmIGggPyBlKGQuX19kYXRhX18sIGguX19kYXRhX18pIDogIWQgLSAhaDtcbiAgfVxuICBmb3IgKHZhciBuID0gdGhpcy5fZ3JvdXBzLCByID0gbi5sZW5ndGgsIGkgPSBuZXcgQXJyYXkociksIHMgPSAwOyBzIDwgcjsgKytzKSB7XG4gICAgZm9yICh2YXIgYSA9IG5bc10sIG8gPSBhLmxlbmd0aCwgbCA9IGlbc10gPSBuZXcgQXJyYXkobyksIGMsIHUgPSAwOyB1IDwgbzsgKyt1KVxuICAgICAgKGMgPSBhW3VdKSAmJiAobFt1XSA9IGMpO1xuICAgIGwuc29ydCh0KTtcbiAgfVxuICByZXR1cm4gbmV3IF9lKGksIHRoaXMuX3BhcmVudHMpLm9yZGVyKCk7XG59XG5mdW5jdGlvbiBDRShlLCB0KSB7XG4gIHJldHVybiBlIDwgdCA/IC0xIDogZSA+IHQgPyAxIDogZSA+PSB0ID8gMCA6IE5hTjtcbn1cbmZ1bmN0aW9uIEFFKCkge1xuICB2YXIgZSA9IGFyZ3VtZW50c1swXTtcbiAgcmV0dXJuIGFyZ3VtZW50c1swXSA9IHRoaXMsIGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKSwgdGhpcztcbn1cbmZ1bmN0aW9uIExFKCkge1xuICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzKTtcbn1cbmZ1bmN0aW9uIGtFKCkge1xuICBmb3IgKHZhciBlID0gdGhpcy5fZ3JvdXBzLCB0ID0gMCwgbiA9IGUubGVuZ3RoOyB0IDwgbjsgKyt0KVxuICAgIGZvciAodmFyIHIgPSBlW3RdLCBpID0gMCwgcyA9IHIubGVuZ3RoOyBpIDwgczsgKytpKSB7XG4gICAgICB2YXIgYSA9IHJbaV07XG4gICAgICBpZiAoYSkgcmV0dXJuIGE7XG4gICAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIERFKCkge1xuICBsZXQgZSA9IDA7XG4gIGZvciAoY29uc3QgdCBvZiB0aGlzKSArK2U7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gUkUoKSB7XG4gIHJldHVybiAhdGhpcy5ub2RlKCk7XG59XG5mdW5jdGlvbiBJRShlKSB7XG4gIGZvciAodmFyIHQgPSB0aGlzLl9ncm91cHMsIG4gPSAwLCByID0gdC5sZW5ndGg7IG4gPCByOyArK24pXG4gICAgZm9yICh2YXIgaSA9IHRbbl0sIHMgPSAwLCBhID0gaS5sZW5ndGgsIG87IHMgPCBhOyArK3MpXG4gICAgICAobyA9IGlbc10pICYmIGUuY2FsbChvLCBvLl9fZGF0YV9fLCBzLCBpKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBORShlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShlKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIFBFKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZS5zcGFjZSwgZS5sb2NhbCk7XG4gIH07XG59XG5mdW5jdGlvbiBVRShlLCB0KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShlLCB0KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIEJFKGUsIHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlTlMoZS5zcGFjZSwgZS5sb2NhbCwgdCk7XG4gIH07XG59XG5mdW5jdGlvbiBIRShlLCB0KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBuID09IG51bGwgPyB0aGlzLnJlbW92ZUF0dHJpYnV0ZShlKSA6IHRoaXMuc2V0QXR0cmlidXRlKGUsIG4pO1xuICB9O1xufVxuZnVuY3Rpb24gVkUoZSwgdCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgbiA9PSBudWxsID8gdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhlLnNwYWNlLCBlLmxvY2FsKSA6IHRoaXMuc2V0QXR0cmlidXRlTlMoZS5zcGFjZSwgZS5sb2NhbCwgbik7XG4gIH07XG59XG5mdW5jdGlvbiBHRShlLCB0KSB7XG4gIHZhciBuID0gdG8oZSk7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciByID0gdGhpcy5ub2RlKCk7XG4gICAgcmV0dXJuIG4ubG9jYWwgPyByLmdldEF0dHJpYnV0ZU5TKG4uc3BhY2UsIG4ubG9jYWwpIDogci5nZXRBdHRyaWJ1dGUobik7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZWFjaCgodCA9PSBudWxsID8gbi5sb2NhbCA/IFBFIDogTkUgOiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyBuLmxvY2FsID8gVkUgOiBIRSA6IG4ubG9jYWwgPyBCRSA6IFVFKShuLCB0KSk7XG59XG5mdW5jdGlvbiBKZihlKSB7XG4gIHJldHVybiBlLm93bmVyRG9jdW1lbnQgJiYgZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IGUuZG9jdW1lbnQgJiYgZSB8fCBlLmRlZmF1bHRWaWV3O1xufVxuZnVuY3Rpb24gekUoZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShlKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIEZFKGUsIHQsIG4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkoZSwgdCwgbik7XG4gIH07XG59XG5mdW5jdGlvbiBqRShlLCB0LCBuKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgciA9IHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByID09IG51bGwgPyB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KGUpIDogdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShlLCByLCBuKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIFdFKGUsIHQsIG4pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gdGhpcy5lYWNoKCh0ID09IG51bGwgPyB6RSA6IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IGpFIDogRkUpKGUsIHQsIG4gPz8gXCJcIikpIDogWHIodGhpcy5ub2RlKCksIGUpO1xufVxuZnVuY3Rpb24gWHIoZSwgdCkge1xuICByZXR1cm4gZS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHQpIHx8IEpmKGUpLmdldENvbXB1dGVkU3R5bGUoZSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZSh0KTtcbn1cbmZ1bmN0aW9uIHFFKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSB0aGlzW2VdO1xuICB9O1xufVxuZnVuY3Rpb24gWUUoZSwgdCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpc1tlXSA9IHQ7XG4gIH07XG59XG5mdW5jdGlvbiBYRShlLCB0KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBuID09IG51bGwgPyBkZWxldGUgdGhpc1tlXSA6IHRoaXNbZV0gPSBuO1xuICB9O1xufVxuZnVuY3Rpb24gWkUoZSwgdCkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyB0aGlzLmVhY2goKHQgPT0gbnVsbCA/IHFFIDogdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gWEUgOiBZRSkoZSwgdCkpIDogdGhpcy5ub2RlKClbZV07XG59XG5mdW5jdGlvbiB0bShlKSB7XG4gIHJldHVybiBlLnRyaW0oKS5zcGxpdCgvXnxcXHMrLyk7XG59XG5mdW5jdGlvbiBEYyhlKSB7XG4gIHJldHVybiBlLmNsYXNzTGlzdCB8fCBuZXcgZW0oZSk7XG59XG5mdW5jdGlvbiBlbShlKSB7XG4gIHRoaXMuX25vZGUgPSBlLCB0aGlzLl9uYW1lcyA9IHRtKGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIik7XG59XG5lbS5wcm90b3R5cGUgPSB7XG4gIGFkZDogZnVuY3Rpb24oZSkge1xuICAgIHZhciB0ID0gdGhpcy5fbmFtZXMuaW5kZXhPZihlKTtcbiAgICB0IDwgMCAmJiAodGhpcy5fbmFtZXMucHVzaChlKSwgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSkpO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgdCA9IHRoaXMuX25hbWVzLmluZGV4T2YoZSk7XG4gICAgdCA+PSAwICYmICh0aGlzLl9uYW1lcy5zcGxpY2UodCwgMSksIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpKTtcbiAgfSxcbiAgY29udGFpbnM6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZXMuaW5kZXhPZihlKSA+PSAwO1xuICB9XG59O1xuZnVuY3Rpb24gbm0oZSwgdCkge1xuICBmb3IgKHZhciBuID0gRGMoZSksIHIgPSAtMSwgaSA9IHQubGVuZ3RoOyArK3IgPCBpOyApIG4uYWRkKHRbcl0pO1xufVxuZnVuY3Rpb24gcm0oZSwgdCkge1xuICBmb3IgKHZhciBuID0gRGMoZSksIHIgPSAtMSwgaSA9IHQubGVuZ3RoOyArK3IgPCBpOyApIG4ucmVtb3ZlKHRbcl0pO1xufVxuZnVuY3Rpb24gS0UoZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgbm0odGhpcywgZSk7XG4gIH07XG59XG5mdW5jdGlvbiBRRShlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBybSh0aGlzLCBlKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIEpFKGUsIHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICh0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgPyBubSA6IHJtKSh0aGlzLCBlKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHRPKGUsIHQpIHtcbiAgdmFyIG4gPSB0bShlICsgXCJcIik7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIGZvciAodmFyIHIgPSBEYyh0aGlzLm5vZGUoKSksIGkgPSAtMSwgcyA9IG4ubGVuZ3RoOyArK2kgPCBzOyApIGlmICghci5jb250YWlucyhuW2ldKSkgcmV0dXJuICExO1xuICAgIHJldHVybiAhMDtcbiAgfVxuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyBKRSA6IHQgPyBLRSA6IFFFKShuLCB0KSk7XG59XG5mdW5jdGlvbiBlTygpIHtcbiAgdGhpcy50ZXh0Q29udGVudCA9IFwiXCI7XG59XG5mdW5jdGlvbiBuTyhlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHJPKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB0ID8/IFwiXCI7XG4gIH07XG59XG5mdW5jdGlvbiBpTyhlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5lYWNoKGUgPT0gbnVsbCA/IGVPIDogKHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IHJPIDogbk8pKGUpKSA6IHRoaXMubm9kZSgpLnRleHRDb250ZW50O1xufVxuZnVuY3Rpb24gc08oKSB7XG4gIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcbn1cbmZ1bmN0aW9uIGFPKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5uZXJIVE1MID0gZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG9PKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuaW5uZXJIVE1MID0gdCA/PyBcIlwiO1xuICB9O1xufVxuZnVuY3Rpb24gbE8oZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuZWFjaChlID09IG51bGwgPyBzTyA6ICh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBvTyA6IGFPKShlKSkgOiB0aGlzLm5vZGUoKS5pbm5lckhUTUw7XG59XG5mdW5jdGlvbiBjTygpIHtcbiAgdGhpcy5uZXh0U2libGluZyAmJiB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcyk7XG59XG5mdW5jdGlvbiB1TygpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChjTyk7XG59XG5mdW5jdGlvbiBoTygpIHtcbiAgdGhpcy5wcmV2aW91c1NpYmxpbmcgJiYgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLCB0aGlzLnBhcmVudE5vZGUuZmlyc3RDaGlsZCk7XG59XG5mdW5jdGlvbiBkTygpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChoTyk7XG59XG5mdW5jdGlvbiBwTyhlKSB7XG4gIHZhciB0ID0gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZSA6IFlmKGUpO1xuICByZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwZW5kQ2hpbGQodC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBmTygpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBtTyhlLCB0KSB7XG4gIHZhciBuID0gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZSA6IFlmKGUpLCByID0gdCA9PSBudWxsID8gZk8gOiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyB0IDoga2ModCk7XG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUobi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCByLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgbnVsbCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ08oKSB7XG4gIHZhciBlID0gdGhpcy5wYXJlbnROb2RlO1xuICBlICYmIGUucmVtb3ZlQ2hpbGQodGhpcyk7XG59XG5mdW5jdGlvbiB2TygpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChnTyk7XG59XG5mdW5jdGlvbiB5TygpIHtcbiAgdmFyIGUgPSB0aGlzLmNsb25lTm9kZSghMSksIHQgPSB0aGlzLnBhcmVudE5vZGU7XG4gIHJldHVybiB0ID8gdC5pbnNlcnRCZWZvcmUoZSwgdGhpcy5uZXh0U2libGluZykgOiBlO1xufVxuZnVuY3Rpb24geE8oKSB7XG4gIHZhciBlID0gdGhpcy5jbG9uZU5vZGUoITApLCB0ID0gdGhpcy5wYXJlbnROb2RlO1xuICByZXR1cm4gdCA/IHQuaW5zZXJ0QmVmb3JlKGUsIHRoaXMubmV4dFNpYmxpbmcpIDogZTtcbn1cbmZ1bmN0aW9uIGJPKGUpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGUgPyB4TyA6IHlPKTtcbn1cbmZ1bmN0aW9uIF9PKGUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIiwgZSkgOiB0aGlzLm5vZGUoKS5fX2RhdGFfXztcbn1cbmZ1bmN0aW9uIEVPKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBlLmNhbGwodGhpcywgdCwgdGhpcy5fX2RhdGFfXyk7XG4gIH07XG59XG5mdW5jdGlvbiBPTyhlKSB7XG4gIHJldHVybiBlLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbiA9IFwiXCIsIHIgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIHJldHVybiByID49IDAgJiYgKG4gPSB0LnNsaWNlKHIgKyAxKSwgdCA9IHQuc2xpY2UoMCwgcikpLCB7IHR5cGU6IHQsIG5hbWU6IG4gfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBTTyhlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IHRoaXMuX19vbjtcbiAgICBpZiAodCkge1xuICAgICAgZm9yICh2YXIgbiA9IDAsIHIgPSAtMSwgaSA9IHQubGVuZ3RoLCBzOyBuIDwgaTsgKytuKVxuICAgICAgICBzID0gdFtuXSwgKCFlLnR5cGUgfHwgcy50eXBlID09PSBlLnR5cGUpICYmIHMubmFtZSA9PT0gZS5uYW1lID8gdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHMudHlwZSwgcy5saXN0ZW5lciwgcy5vcHRpb25zKSA6IHRbKytyXSA9IHM7XG4gICAgICArK3IgPyB0Lmxlbmd0aCA9IHIgOiBkZWxldGUgdGhpcy5fX29uO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIFRPKGUsIHQsIG4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gdGhpcy5fX29uLCBpLCBzID0gRU8odCk7XG4gICAgaWYgKHIpIHtcbiAgICAgIGZvciAodmFyIGEgPSAwLCBvID0gci5sZW5ndGg7IGEgPCBvOyArK2EpXG4gICAgICAgIGlmICgoaSA9IHJbYV0pLnR5cGUgPT09IGUudHlwZSAmJiBpLm5hbWUgPT09IGUubmFtZSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihpLnR5cGUsIGkubGlzdGVuZXIsIGkub3B0aW9ucyksIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihpLnR5cGUsIGkubGlzdGVuZXIgPSBzLCBpLm9wdGlvbnMgPSBuKSwgaS52YWx1ZSA9IHQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlLnR5cGUsIHMsIG4pLCBpID0geyB0eXBlOiBlLnR5cGUsIG5hbWU6IGUubmFtZSwgdmFsdWU6IHQsIGxpc3RlbmVyOiBzLCBvcHRpb25zOiBuIH0sIHIgPyByLnB1c2goaSkgOiB0aGlzLl9fb24gPSBbaV07XG4gIH07XG59XG5mdW5jdGlvbiB3TyhlLCB0LCBuKSB7XG4gIHZhciByID0gT08oZSArIFwiXCIpLCBpLCBzID0gci5sZW5ndGgsIGE7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBvID0gdGhpcy5ub2RlKCkuX19vbjtcbiAgICBpZiAobykge1xuICAgICAgZm9yICh2YXIgbCA9IDAsIGMgPSBvLmxlbmd0aCwgdTsgbCA8IGM7ICsrbClcbiAgICAgICAgZm9yIChpID0gMCwgdSA9IG9bbF07IGkgPCBzOyArK2kpXG4gICAgICAgICAgaWYgKChhID0gcltpXSkudHlwZSA9PT0gdS50eXBlICYmIGEubmFtZSA9PT0gdS5uYW1lKVxuICAgICAgICAgICAgcmV0dXJuIHUudmFsdWU7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKG8gPSB0ID8gVE8gOiBTTywgaSA9IDA7IGkgPCBzOyArK2kpIHRoaXMuZWFjaChvKHJbaV0sIHQsIG4pKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBpbShlLCB0LCBuKSB7XG4gIHZhciByID0gSmYoZSksIGkgPSByLkN1c3RvbUV2ZW50O1xuICB0eXBlb2YgaSA9PSBcImZ1bmN0aW9uXCIgPyBpID0gbmV3IGkodCwgbikgOiAoaSA9IHIuZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKSwgbiA/IChpLmluaXRFdmVudCh0LCBuLmJ1YmJsZXMsIG4uY2FuY2VsYWJsZSksIGkuZGV0YWlsID0gbi5kZXRhaWwpIDogaS5pbml0RXZlbnQodCwgITEsICExKSksIGUuZGlzcGF0Y2hFdmVudChpKTtcbn1cbmZ1bmN0aW9uICRPKGUsIHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpbSh0aGlzLCBlLCB0KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIE1PKGUsIHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpbSh0aGlzLCBlLCB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuZnVuY3Rpb24gQ08oZSwgdCkge1xuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyBNTyA6ICRPKShlLCB0KSk7XG59XG5mdW5jdGlvbiogQU8oKSB7XG4gIGZvciAodmFyIGUgPSB0aGlzLl9ncm91cHMsIHQgPSAwLCBuID0gZS5sZW5ndGg7IHQgPCBuOyArK3QpXG4gICAgZm9yICh2YXIgciA9IGVbdF0sIGkgPSAwLCBzID0gci5sZW5ndGgsIGE7IGkgPCBzOyArK2kpXG4gICAgICAoYSA9IHJbaV0pICYmICh5aWVsZCBhKTtcbn1cbnZhciBzbSA9IFtudWxsXTtcbmZ1bmN0aW9uIF9lKGUsIHQpIHtcbiAgdGhpcy5fZ3JvdXBzID0gZSwgdGhpcy5fcGFyZW50cyA9IHQ7XG59XG5mdW5jdGlvbiBkcygpIHtcbiAgcmV0dXJuIG5ldyBfZShbW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF1dLCBzbSk7XG59XG5mdW5jdGlvbiBMTygpIHtcbiAgcmV0dXJuIHRoaXM7XG59XG5fZS5wcm90b3R5cGUgPSBkcy5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBfZSxcbiAgc2VsZWN0OiByRSxcbiAgc2VsZWN0QWxsOiBvRSxcbiAgc2VsZWN0Q2hpbGQ6IGhFLFxuICBzZWxlY3RDaGlsZHJlbjogbUUsXG4gIGZpbHRlcjogZ0UsXG4gIGRhdGE6IEVFLFxuICBlbnRlcjogdkUsXG4gIGV4aXQ6IFNFLFxuICBqb2luOiBURSxcbiAgbWVyZ2U6IHdFLFxuICBzZWxlY3Rpb246IExPLFxuICBvcmRlcjogJEUsXG4gIHNvcnQ6IE1FLFxuICBjYWxsOiBBRSxcbiAgbm9kZXM6IExFLFxuICBub2RlOiBrRSxcbiAgc2l6ZTogREUsXG4gIGVtcHR5OiBSRSxcbiAgZWFjaDogSUUsXG4gIGF0dHI6IEdFLFxuICBzdHlsZTogV0UsXG4gIHByb3BlcnR5OiBaRSxcbiAgY2xhc3NlZDogdE8sXG4gIHRleHQ6IGlPLFxuICBodG1sOiBsTyxcbiAgcmFpc2U6IHVPLFxuICBsb3dlcjogZE8sXG4gIGFwcGVuZDogcE8sXG4gIGluc2VydDogbU8sXG4gIHJlbW92ZTogdk8sXG4gIGNsb25lOiBiTyxcbiAgZGF0dW06IF9PLFxuICBvbjogd08sXG4gIGRpc3BhdGNoOiBDTyxcbiAgW1N5bWJvbC5pdGVyYXRvcl06IEFPXG59O1xuZnVuY3Rpb24ga08oZSkge1xuICBsZXQgdDtcbiAgZm9yICg7IHQgPSBlLnNvdXJjZUV2ZW50OyApIGUgPSB0O1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHJyKGUsIHQpIHtcbiAgaWYgKGUgPSBrTyhlKSwgdCA9PT0gdm9pZCAwICYmICh0ID0gZS5jdXJyZW50VGFyZ2V0KSwgdCkge1xuICAgIHZhciBuID0gdC5vd25lclNWR0VsZW1lbnQgfHwgdDtcbiAgICBpZiAobi5jcmVhdGVTVkdQb2ludCkge1xuICAgICAgdmFyIHIgPSBuLmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgICByZXR1cm4gci54ID0gZS5jbGllbnRYLCByLnkgPSBlLmNsaWVudFksIHIgPSByLm1hdHJpeFRyYW5zZm9ybSh0LmdldFNjcmVlbkNUTSgpLmludmVyc2UoKSksIFtyLngsIHIueV07XG4gICAgfVxuICAgIGlmICh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCkge1xuICAgICAgdmFyIGkgPSB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmV0dXJuIFtlLmNsaWVudFggLSBpLmxlZnQgLSB0LmNsaWVudExlZnQsIGUuY2xpZW50WSAtIGkudG9wIC0gdC5jbGllbnRUb3BdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2UucGFnZVgsIGUucGFnZVldO1xufVxuZnVuY3Rpb24gUmMoZSwgdCwgbikge1xuICBlLnByb3RvdHlwZSA9IHQucHJvdG90eXBlID0gbiwgbi5jb25zdHJ1Y3RvciA9IGU7XG59XG5mdW5jdGlvbiBhbShlLCB0KSB7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHIgaW4gdCkgbltyXSA9IHRbcl07XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gcHMoKSB7XG59XG52YXIgS2kgPSAwLjcsIGhhID0gMSAvIEtpLCBHciA9IFwiXFxcXHMqKFsrLV0/XFxcXGQrKVxcXFxzKlwiLCBRaSA9IFwiXFxcXHMqKFsrLV0/KD86XFxcXGQqXFxcXC4pP1xcXFxkKyg/OltlRV1bKy1dP1xcXFxkKyk/KVxcXFxzKlwiLCB0biA9IFwiXFxcXHMqKFsrLV0/KD86XFxcXGQqXFxcXC4pP1xcXFxkKyg/OltlRV1bKy1dP1xcXFxkKyk/KSVcXFxccypcIiwgRE8gPSAvXiMoWzAtOWEtZl17Myw4fSkkLywgUk8gPSBuZXcgUmVnRXhwKGBecmdiXFxcXCgke0dyfSwke0dyfSwke0dyfVxcXFwpJGApLCBJTyA9IG5ldyBSZWdFeHAoYF5yZ2JcXFxcKCR7dG59LCR7dG59LCR7dG59XFxcXCkkYCksIE5PID0gbmV3IFJlZ0V4cChgXnJnYmFcXFxcKCR7R3J9LCR7R3J9LCR7R3J9LCR7UWl9XFxcXCkkYCksIFBPID0gbmV3IFJlZ0V4cChgXnJnYmFcXFxcKCR7dG59LCR7dG59LCR7dG59LCR7UWl9XFxcXCkkYCksIFVPID0gbmV3IFJlZ0V4cChgXmhzbFxcXFwoJHtRaX0sJHt0bn0sJHt0bn1cXFxcKSRgKSwgQk8gPSBuZXcgUmVnRXhwKGBeaHNsYVxcXFwoJHtRaX0sJHt0bn0sJHt0bn0sJHtRaX1cXFxcKSRgKSwgcGggPSB7XG4gIGFsaWNlYmx1ZTogMTU3OTIzODMsXG4gIGFudGlxdWV3aGl0ZTogMTY0NDQzNzUsXG4gIGFxdWE6IDY1NTM1LFxuICBhcXVhbWFyaW5lOiA4Mzg4NTY0LFxuICBhenVyZTogMTU3OTQxNzUsXG4gIGJlaWdlOiAxNjExOTI2MCxcbiAgYmlzcXVlOiAxNjc3MDI0NCxcbiAgYmxhY2s6IDAsXG4gIGJsYW5jaGVkYWxtb25kOiAxNjc3MjA0NSxcbiAgYmx1ZTogMjU1LFxuICBibHVldmlvbGV0OiA5MDU1MjAyLFxuICBicm93bjogMTA4MjQyMzQsXG4gIGJ1cmx5d29vZDogMTQ1OTYyMzEsXG4gIGNhZGV0Ymx1ZTogNjI2NjUyOCxcbiAgY2hhcnRyZXVzZTogODM4ODM1MixcbiAgY2hvY29sYXRlOiAxMzc4OTQ3MCxcbiAgY29yYWw6IDE2NzQ0MjcyLFxuICBjb3JuZmxvd2VyYmx1ZTogNjU5MTk4MSxcbiAgY29ybnNpbGs6IDE2Nzc1Mzg4LFxuICBjcmltc29uOiAxNDQyMzEwMCxcbiAgY3lhbjogNjU1MzUsXG4gIGRhcmtibHVlOiAxMzksXG4gIGRhcmtjeWFuOiAzNTcyMyxcbiAgZGFya2dvbGRlbnJvZDogMTIwOTI5MzksXG4gIGRhcmtncmF5OiAxMTExOTAxNyxcbiAgZGFya2dyZWVuOiAyNTYwMCxcbiAgZGFya2dyZXk6IDExMTE5MDE3LFxuICBkYXJra2hha2k6IDEyNDMzMjU5LFxuICBkYXJrbWFnZW50YTogOTEwOTY0MyxcbiAgZGFya29saXZlZ3JlZW46IDU1OTc5OTksXG4gIGRhcmtvcmFuZ2U6IDE2NzQ3NTIwLFxuICBkYXJrb3JjaGlkOiAxMDA0MDAxMixcbiAgZGFya3JlZDogOTEwOTUwNCxcbiAgZGFya3NhbG1vbjogMTUzMDg0MTAsXG4gIGRhcmtzZWFncmVlbjogOTQxOTkxOSxcbiAgZGFya3NsYXRlYmx1ZTogNDczNDM0NyxcbiAgZGFya3NsYXRlZ3JheTogMzEwMDQ5NSxcbiAgZGFya3NsYXRlZ3JleTogMzEwMDQ5NSxcbiAgZGFya3R1cnF1b2lzZTogNTI5NDUsXG4gIGRhcmt2aW9sZXQ6IDk2OTk1MzksXG4gIGRlZXBwaW5rOiAxNjcxNjk0NyxcbiAgZGVlcHNreWJsdWU6IDQ5MTUxLFxuICBkaW1ncmF5OiA2OTA4MjY1LFxuICBkaW1ncmV5OiA2OTA4MjY1LFxuICBkb2RnZXJibHVlOiAyMDAzMTk5LFxuICBmaXJlYnJpY2s6IDExNjc0MTQ2LFxuICBmbG9yYWx3aGl0ZTogMTY3NzU5MjAsXG4gIGZvcmVzdGdyZWVuOiAyMjYzODQyLFxuICBmdWNoc2lhOiAxNjcxMTkzNSxcbiAgZ2FpbnNib3JvOiAxNDQ3NDQ2MCxcbiAgZ2hvc3R3aGl0ZTogMTYzMTY2NzEsXG4gIGdvbGQ6IDE2NzY2NzIwLFxuICBnb2xkZW5yb2Q6IDE0MzI5MTIwLFxuICBncmF5OiA4NDIxNTA0LFxuICBncmVlbjogMzI3NjgsXG4gIGdyZWVueWVsbG93OiAxMTQwMzA1NSxcbiAgZ3JleTogODQyMTUwNCxcbiAgaG9uZXlkZXc6IDE1Nzk0MTYwLFxuICBob3RwaW5rOiAxNjczODc0MCxcbiAgaW5kaWFucmVkOiAxMzQ1ODUyNCxcbiAgaW5kaWdvOiA0OTE1MzMwLFxuICBpdm9yeTogMTY3NzcyMDAsXG4gIGtoYWtpOiAxNTc4NzY2MCxcbiAgbGF2ZW5kZXI6IDE1MTMyNDEwLFxuICBsYXZlbmRlcmJsdXNoOiAxNjc3MzM2NSxcbiAgbGF3bmdyZWVuOiA4MTkwOTc2LFxuICBsZW1vbmNoaWZmb246IDE2Nzc1ODg1LFxuICBsaWdodGJsdWU6IDExMzkzMjU0LFxuICBsaWdodGNvcmFsOiAxNTc2MTUzNixcbiAgbGlnaHRjeWFuOiAxNDc0NTU5OSxcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDE2NDQ4MjEwLFxuICBsaWdodGdyYXk6IDEzODgyMzIzLFxuICBsaWdodGdyZWVuOiA5NDk4MjU2LFxuICBsaWdodGdyZXk6IDEzODgyMzIzLFxuICBsaWdodHBpbms6IDE2NzU4NDY1LFxuICBsaWdodHNhbG1vbjogMTY3NTI3NjIsXG4gIGxpZ2h0c2VhZ3JlZW46IDIxNDI4OTAsXG4gIGxpZ2h0c2t5Ymx1ZTogODkwMDM0NixcbiAgbGlnaHRzbGF0ZWdyYXk6IDc4MzM3NTMsXG4gIGxpZ2h0c2xhdGVncmV5OiA3ODMzNzUzLFxuICBsaWdodHN0ZWVsYmx1ZTogMTE1ODQ3MzQsXG4gIGxpZ2h0eWVsbG93OiAxNjc3NzE4NCxcbiAgbGltZTogNjUyODAsXG4gIGxpbWVncmVlbjogMzMyOTMzMCxcbiAgbGluZW46IDE2NDQ1NjcwLFxuICBtYWdlbnRhOiAxNjcxMTkzNSxcbiAgbWFyb29uOiA4Mzg4NjA4LFxuICBtZWRpdW1hcXVhbWFyaW5lOiA2NzM3MzIyLFxuICBtZWRpdW1ibHVlOiAyMDUsXG4gIG1lZGl1bW9yY2hpZDogMTIyMTE2NjcsXG4gIG1lZGl1bXB1cnBsZTogOTY2MjY4MyxcbiAgbWVkaXVtc2VhZ3JlZW46IDM5NzgwOTcsXG4gIG1lZGl1bXNsYXRlYmx1ZTogODA4Nzc5MCxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IDY0MTU0LFxuICBtZWRpdW10dXJxdW9pc2U6IDQ3NzIzMDAsXG4gIG1lZGl1bXZpb2xldHJlZDogMTMwNDcxNzMsXG4gIG1pZG5pZ2h0Ymx1ZTogMTY0NDkxMixcbiAgbWludGNyZWFtOiAxNjEyMTg1MCxcbiAgbWlzdHlyb3NlOiAxNjc3MDI3MyxcbiAgbW9jY2FzaW46IDE2NzcwMjI5LFxuICBuYXZham93aGl0ZTogMTY3Njg2ODUsXG4gIG5hdnk6IDEyOCxcbiAgb2xkbGFjZTogMTY2NDM1NTgsXG4gIG9saXZlOiA4NDIxMzc2LFxuICBvbGl2ZWRyYWI6IDcwNDg3MzksXG4gIG9yYW5nZTogMTY3NTM5MjAsXG4gIG9yYW5nZXJlZDogMTY3MjkzNDQsXG4gIG9yY2hpZDogMTQzMTU3MzQsXG4gIHBhbGVnb2xkZW5yb2Q6IDE1NjU3MTMwLFxuICBwYWxlZ3JlZW46IDEwMDI1ODgwLFxuICBwYWxldHVycXVvaXNlOiAxMTUyOTk2NixcbiAgcGFsZXZpb2xldHJlZDogMTQzODEyMDMsXG4gIHBhcGF5YXdoaXA6IDE2NzczMDc3LFxuICBwZWFjaHB1ZmY6IDE2NzY3NjczLFxuICBwZXJ1OiAxMzQ2ODk5MSxcbiAgcGluazogMTY3NjEwMzUsXG4gIHBsdW06IDE0NTI0NjM3LFxuICBwb3dkZXJibHVlOiAxMTU5MTkxMCxcbiAgcHVycGxlOiA4Mzg4NzM2LFxuICByZWJlY2NhcHVycGxlOiA2Njk3ODgxLFxuICByZWQ6IDE2NzExNjgwLFxuICByb3N5YnJvd246IDEyMzU3NTE5LFxuICByb3lhbGJsdWU6IDQyODY5NDUsXG4gIHNhZGRsZWJyb3duOiA5MTI3MTg3LFxuICBzYWxtb246IDE2NDE2ODgyLFxuICBzYW5keWJyb3duOiAxNjAzMjg2NCxcbiAgc2VhZ3JlZW46IDMwNTAzMjcsXG4gIHNlYXNoZWxsOiAxNjc3NDYzOCxcbiAgc2llbm5hOiAxMDUwNjc5NyxcbiAgc2lsdmVyOiAxMjYzMjI1NixcbiAgc2t5Ymx1ZTogODkwMDMzMSxcbiAgc2xhdGVibHVlOiA2OTcwMDYxLFxuICBzbGF0ZWdyYXk6IDczNzI5NDQsXG4gIHNsYXRlZ3JleTogNzM3Mjk0NCxcbiAgc25vdzogMTY3NzU5MzAsXG4gIHNwcmluZ2dyZWVuOiA2NTQwNyxcbiAgc3RlZWxibHVlOiA0NjIwOTgwLFxuICB0YW46IDEzODA4NzgwLFxuICB0ZWFsOiAzMjg5NixcbiAgdGhpc3RsZTogMTQyMDQ4ODgsXG4gIHRvbWF0bzogMTY3MzcwOTUsXG4gIHR1cnF1b2lzZTogNDI1MTg1NixcbiAgdmlvbGV0OiAxNTYzMTA4NixcbiAgd2hlYXQ6IDE2MTEzMzMxLFxuICB3aGl0ZTogMTY3NzcyMTUsXG4gIHdoaXRlc21va2U6IDE2MTE5Mjg1LFxuICB5ZWxsb3c6IDE2Nzc2OTYwLFxuICB5ZWxsb3dncmVlbjogMTAxNDUwNzRcbn07XG5SYyhwcywgVG4sIHtcbiAgY29weShlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IHRoaXMuY29uc3RydWN0b3IoKSwgdGhpcywgZSk7XG4gIH0sXG4gIGRpc3BsYXlhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnJnYigpLmRpc3BsYXlhYmxlKCk7XG4gIH0sXG4gIGhleDogZmgsXG4gIC8vIERlcHJlY2F0ZWQhIFVzZSBjb2xvci5mb3JtYXRIZXguXG4gIGZvcm1hdEhleDogZmgsXG4gIGZvcm1hdEhleDg6IEhPLFxuICBmb3JtYXRIc2w6IFZPLFxuICBmb3JtYXRSZ2I6IG1oLFxuICB0b1N0cmluZzogbWhcbn0pO1xuZnVuY3Rpb24gZmgoKSB7XG4gIHJldHVybiB0aGlzLnJnYigpLmZvcm1hdEhleCgpO1xufVxuZnVuY3Rpb24gSE8oKSB7XG4gIHJldHVybiB0aGlzLnJnYigpLmZvcm1hdEhleDgoKTtcbn1cbmZ1bmN0aW9uIFZPKCkge1xuICByZXR1cm4gb20odGhpcykuZm9ybWF0SHNsKCk7XG59XG5mdW5jdGlvbiBtaCgpIHtcbiAgcmV0dXJuIHRoaXMucmdiKCkuZm9ybWF0UmdiKCk7XG59XG5mdW5jdGlvbiBUbihlKSB7XG4gIHZhciB0LCBuO1xuICByZXR1cm4gZSA9IChlICsgXCJcIikudHJpbSgpLnRvTG93ZXJDYXNlKCksICh0ID0gRE8uZXhlYyhlKSkgPyAobiA9IHRbMV0ubGVuZ3RoLCB0ID0gcGFyc2VJbnQodFsxXSwgMTYpLCBuID09PSA2ID8gZ2godCkgOiBuID09PSAzID8gbmV3IGhlKHQgPj4gOCAmIDE1IHwgdCA+PiA0ICYgMjQwLCB0ID4+IDQgJiAxNSB8IHQgJiAyNDAsICh0ICYgMTUpIDw8IDQgfCB0ICYgMTUsIDEpIDogbiA9PT0gOCA/IHdzKHQgPj4gMjQgJiAyNTUsIHQgPj4gMTYgJiAyNTUsIHQgPj4gOCAmIDI1NSwgKHQgJiAyNTUpIC8gMjU1KSA6IG4gPT09IDQgPyB3cyh0ID4+IDEyICYgMTUgfCB0ID4+IDggJiAyNDAsIHQgPj4gOCAmIDE1IHwgdCA+PiA0ICYgMjQwLCB0ID4+IDQgJiAxNSB8IHQgJiAyNDAsICgodCAmIDE1KSA8PCA0IHwgdCAmIDE1KSAvIDI1NSkgOiBudWxsKSA6ICh0ID0gUk8uZXhlYyhlKSkgPyBuZXcgaGUodFsxXSwgdFsyXSwgdFszXSwgMSkgOiAodCA9IElPLmV4ZWMoZSkpID8gbmV3IGhlKHRbMV0gKiAyNTUgLyAxMDAsIHRbMl0gKiAyNTUgLyAxMDAsIHRbM10gKiAyNTUgLyAxMDAsIDEpIDogKHQgPSBOTy5leGVjKGUpKSA/IHdzKHRbMV0sIHRbMl0sIHRbM10sIHRbNF0pIDogKHQgPSBQTy5leGVjKGUpKSA/IHdzKHRbMV0gKiAyNTUgLyAxMDAsIHRbMl0gKiAyNTUgLyAxMDAsIHRbM10gKiAyNTUgLyAxMDAsIHRbNF0pIDogKHQgPSBVTy5leGVjKGUpKSA/IHhoKHRbMV0sIHRbMl0gLyAxMDAsIHRbM10gLyAxMDAsIDEpIDogKHQgPSBCTy5leGVjKGUpKSA/IHhoKHRbMV0sIHRbMl0gLyAxMDAsIHRbM10gLyAxMDAsIHRbNF0pIDogcGguaGFzT3duUHJvcGVydHkoZSkgPyBnaChwaFtlXSkgOiBlID09PSBcInRyYW5zcGFyZW50XCIgPyBuZXcgaGUoTmFOLCBOYU4sIE5hTiwgMCkgOiBudWxsO1xufVxuZnVuY3Rpb24gZ2goZSkge1xuICByZXR1cm4gbmV3IGhlKGUgPj4gMTYgJiAyNTUsIGUgPj4gOCAmIDI1NSwgZSAmIDI1NSwgMSk7XG59XG5mdW5jdGlvbiB3cyhlLCB0LCBuLCByKSB7XG4gIHJldHVybiByIDw9IDAgJiYgKGUgPSB0ID0gbiA9IE5hTiksIG5ldyBoZShlLCB0LCBuLCByKTtcbn1cbmZ1bmN0aW9uIEdPKGUpIHtcbiAgcmV0dXJuIGUgaW5zdGFuY2VvZiBwcyB8fCAoZSA9IFRuKGUpKSwgZSA/IChlID0gZS5yZ2IoKSwgbmV3IGhlKGUuciwgZS5nLCBlLmIsIGUub3BhY2l0eSkpIDogbmV3IGhlKCk7XG59XG5mdW5jdGlvbiBTbChlLCB0LCBuLCByKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gR08oZSkgOiBuZXcgaGUoZSwgdCwgbiwgciA/PyAxKTtcbn1cbmZ1bmN0aW9uIGhlKGUsIHQsIG4sIHIpIHtcbiAgdGhpcy5yID0gK2UsIHRoaXMuZyA9ICt0LCB0aGlzLmIgPSArbiwgdGhpcy5vcGFjaXR5ID0gK3I7XG59XG5SYyhoZSwgU2wsIGFtKHBzLCB7XG4gIGJyaWdodGVyKGUpIHtcbiAgICByZXR1cm4gZSA9IGUgPT0gbnVsbCA/IGhhIDogTWF0aC5wb3coaGEsIGUpLCBuZXcgaGUodGhpcy5yICogZSwgdGhpcy5nICogZSwgdGhpcy5iICogZSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyKGUpIHtcbiAgICByZXR1cm4gZSA9IGUgPT0gbnVsbCA/IEtpIDogTWF0aC5wb3coS2ksIGUpLCBuZXcgaGUodGhpcy5yICogZSwgdGhpcy5nICogZSwgdGhpcy5iICogZSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjbGFtcCgpIHtcbiAgICByZXR1cm4gbmV3IGhlKHRyKHRoaXMuciksIHRyKHRoaXMuZyksIHRyKHRoaXMuYiksIGRhKHRoaXMub3BhY2l0eSkpO1xuICB9LFxuICBkaXNwbGF5YWJsZSgpIHtcbiAgICByZXR1cm4gLTAuNSA8PSB0aGlzLnIgJiYgdGhpcy5yIDwgMjU1LjUgJiYgLTAuNSA8PSB0aGlzLmcgJiYgdGhpcy5nIDwgMjU1LjUgJiYgLTAuNSA8PSB0aGlzLmIgJiYgdGhpcy5iIDwgMjU1LjUgJiYgMCA8PSB0aGlzLm9wYWNpdHkgJiYgdGhpcy5vcGFjaXR5IDw9IDE7XG4gIH0sXG4gIGhleDogdmgsXG4gIC8vIERlcHJlY2F0ZWQhIFVzZSBjb2xvci5mb3JtYXRIZXguXG4gIGZvcm1hdEhleDogdmgsXG4gIGZvcm1hdEhleDg6IHpPLFxuICBmb3JtYXRSZ2I6IHloLFxuICB0b1N0cmluZzogeWhcbn0pKTtcbmZ1bmN0aW9uIHZoKCkge1xuICByZXR1cm4gYCMke1FuKHRoaXMucil9JHtRbih0aGlzLmcpfSR7UW4odGhpcy5iKX1gO1xufVxuZnVuY3Rpb24gek8oKSB7XG4gIHJldHVybiBgIyR7UW4odGhpcy5yKX0ke1FuKHRoaXMuZyl9JHtRbih0aGlzLmIpfSR7UW4oKGlzTmFOKHRoaXMub3BhY2l0eSkgPyAxIDogdGhpcy5vcGFjaXR5KSAqIDI1NSl9YDtcbn1cbmZ1bmN0aW9uIHloKCkge1xuICBjb25zdCBlID0gZGEodGhpcy5vcGFjaXR5KTtcbiAgcmV0dXJuIGAke2UgPT09IDEgPyBcInJnYihcIiA6IFwicmdiYShcIn0ke3RyKHRoaXMucil9LCAke3RyKHRoaXMuZyl9LCAke3RyKHRoaXMuYil9JHtlID09PSAxID8gXCIpXCIgOiBgLCAke2V9KWB9YDtcbn1cbmZ1bmN0aW9uIGRhKGUpIHtcbiAgcmV0dXJuIGlzTmFOKGUpID8gMSA6IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGUpKTtcbn1cbmZ1bmN0aW9uIHRyKGUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZChlKSB8fCAwKSk7XG59XG5mdW5jdGlvbiBRbihlKSB7XG4gIHJldHVybiBlID0gdHIoZSksIChlIDwgMTYgPyBcIjBcIiA6IFwiXCIpICsgZS50b1N0cmluZygxNik7XG59XG5mdW5jdGlvbiB4aChlLCB0LCBuLCByKSB7XG4gIHJldHVybiByIDw9IDAgPyBlID0gdCA9IG4gPSBOYU4gOiBuIDw9IDAgfHwgbiA+PSAxID8gZSA9IHQgPSBOYU4gOiB0IDw9IDAgJiYgKGUgPSBOYU4pLCBuZXcgSGUoZSwgdCwgbiwgcik7XG59XG5mdW5jdGlvbiBvbShlKSB7XG4gIGlmIChlIGluc3RhbmNlb2YgSGUpIHJldHVybiBuZXcgSGUoZS5oLCBlLnMsIGUubCwgZS5vcGFjaXR5KTtcbiAgaWYgKGUgaW5zdGFuY2VvZiBwcyB8fCAoZSA9IFRuKGUpKSwgIWUpIHJldHVybiBuZXcgSGUoKTtcbiAgaWYgKGUgaW5zdGFuY2VvZiBIZSkgcmV0dXJuIGU7XG4gIGUgPSBlLnJnYigpO1xuICB2YXIgdCA9IGUuciAvIDI1NSwgbiA9IGUuZyAvIDI1NSwgciA9IGUuYiAvIDI1NSwgaSA9IE1hdGgubWluKHQsIG4sIHIpLCBzID0gTWF0aC5tYXgodCwgbiwgciksIGEgPSBOYU4sIG8gPSBzIC0gaSwgbCA9IChzICsgaSkgLyAyO1xuICByZXR1cm4gbyA/ICh0ID09PSBzID8gYSA9IChuIC0gcikgLyBvICsgKG4gPCByKSAqIDYgOiBuID09PSBzID8gYSA9IChyIC0gdCkgLyBvICsgMiA6IGEgPSAodCAtIG4pIC8gbyArIDQsIG8gLz0gbCA8IDAuNSA/IHMgKyBpIDogMiAtIHMgLSBpLCBhICo9IDYwKSA6IG8gPSBsID4gMCAmJiBsIDwgMSA/IDAgOiBhLCBuZXcgSGUoYSwgbywgbCwgZS5vcGFjaXR5KTtcbn1cbmZ1bmN0aW9uIGxtKGUsIHQsIG4sIHIpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBvbShlKSA6IG5ldyBIZShlLCB0LCBuLCByID8/IDEpO1xufVxuZnVuY3Rpb24gSGUoZSwgdCwgbiwgcikge1xuICB0aGlzLmggPSArZSwgdGhpcy5zID0gK3QsIHRoaXMubCA9ICtuLCB0aGlzLm9wYWNpdHkgPSArcjtcbn1cblJjKEhlLCBsbSwgYW0ocHMsIHtcbiAgYnJpZ2h0ZXIoZSkge1xuICAgIHJldHVybiBlID0gZSA9PSBudWxsID8gaGEgOiBNYXRoLnBvdyhoYSwgZSksIG5ldyBIZSh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogZSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyKGUpIHtcbiAgICByZXR1cm4gZSA9IGUgPT0gbnVsbCA/IEtpIDogTWF0aC5wb3coS2ksIGUpLCBuZXcgSGUodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGUsIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYigpIHtcbiAgICB2YXIgZSA9IHRoaXMuaCAlIDM2MCArICh0aGlzLmggPCAwKSAqIDM2MCwgdCA9IGlzTmFOKGUpIHx8IGlzTmFOKHRoaXMucykgPyAwIDogdGhpcy5zLCBuID0gdGhpcy5sLCByID0gbiArIChuIDwgMC41ID8gbiA6IDEgLSBuKSAqIHQsIGkgPSAyICogbiAtIHI7XG4gICAgcmV0dXJuIG5ldyBoZShcbiAgICAgIENvKGUgPj0gMjQwID8gZSAtIDI0MCA6IGUgKyAxMjAsIGksIHIpLFxuICAgICAgQ28oZSwgaSwgciksXG4gICAgICBDbyhlIDwgMTIwID8gZSArIDI0MCA6IGUgLSAxMjAsIGksIHIpLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfSxcbiAgY2xhbXAoKSB7XG4gICAgcmV0dXJuIG5ldyBIZShiaCh0aGlzLmgpLCAkcyh0aGlzLnMpLCAkcyh0aGlzLmwpLCBkYSh0aGlzLm9wYWNpdHkpKTtcbiAgfSxcbiAgZGlzcGxheWFibGUoKSB7XG4gICAgcmV0dXJuICgwIDw9IHRoaXMucyAmJiB0aGlzLnMgPD0gMSB8fCBpc05hTih0aGlzLnMpKSAmJiAwIDw9IHRoaXMubCAmJiB0aGlzLmwgPD0gMSAmJiAwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMTtcbiAgfSxcbiAgZm9ybWF0SHNsKCkge1xuICAgIGNvbnN0IGUgPSBkYSh0aGlzLm9wYWNpdHkpO1xuICAgIHJldHVybiBgJHtlID09PSAxID8gXCJoc2woXCIgOiBcImhzbGEoXCJ9JHtiaCh0aGlzLmgpfSwgJHskcyh0aGlzLnMpICogMTAwfSUsICR7JHModGhpcy5sKSAqIDEwMH0lJHtlID09PSAxID8gXCIpXCIgOiBgLCAke2V9KWB9YDtcbiAgfVxufSkpO1xuZnVuY3Rpb24gYmgoZSkge1xuICByZXR1cm4gZSA9IChlIHx8IDApICUgMzYwLCBlIDwgMCA/IGUgKyAzNjAgOiBlO1xufVxuZnVuY3Rpb24gJHMoZSkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgZSB8fCAwKSk7XG59XG5mdW5jdGlvbiBDbyhlLCB0LCBuKSB7XG4gIHJldHVybiAoZSA8IDYwID8gdCArIChuIC0gdCkgKiBlIC8gNjAgOiBlIDwgMTgwID8gbiA6IGUgPCAyNDAgPyB0ICsgKG4gLSB0KSAqICgyNDAgLSBlKSAvIDYwIDogdCkgKiAyNTU7XG59XG5jb25zdCBJYyA9IChlKSA9PiAoKSA9PiBlO1xuZnVuY3Rpb24gRk8oZSwgdCkge1xuICByZXR1cm4gZnVuY3Rpb24obikge1xuICAgIHJldHVybiBlICsgbiAqIHQ7XG4gIH07XG59XG5mdW5jdGlvbiBqTyhlLCB0LCBuKSB7XG4gIHJldHVybiBlID0gTWF0aC5wb3coZSwgbiksIHQgPSBNYXRoLnBvdyh0LCBuKSAtIGUsIG4gPSAxIC8gbiwgZnVuY3Rpb24ocikge1xuICAgIHJldHVybiBNYXRoLnBvdyhlICsgciAqIHQsIG4pO1xuICB9O1xufVxuZnVuY3Rpb24gV08oZSkge1xuICByZXR1cm4gKGUgPSArZSkgPT0gMSA/IGNtIDogZnVuY3Rpb24odCwgbikge1xuICAgIHJldHVybiBuIC0gdCA/IGpPKHQsIG4sIGUpIDogSWMoaXNOYU4odCkgPyBuIDogdCk7XG4gIH07XG59XG5mdW5jdGlvbiBjbShlLCB0KSB7XG4gIHZhciBuID0gdCAtIGU7XG4gIHJldHVybiBuID8gRk8oZSwgbikgOiBJYyhpc05hTihlKSA/IHQgOiBlKTtcbn1cbmNvbnN0IHBhID0gZnVuY3Rpb24gZSh0KSB7XG4gIHZhciBuID0gV08odCk7XG4gIGZ1bmN0aW9uIHIoaSwgcykge1xuICAgIHZhciBhID0gbigoaSA9IFNsKGkpKS5yLCAocyA9IFNsKHMpKS5yKSwgbyA9IG4oaS5nLCBzLmcpLCBsID0gbihpLmIsIHMuYiksIGMgPSBjbShpLm9wYWNpdHksIHMub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHUpIHtcbiAgICAgIHJldHVybiBpLnIgPSBhKHUpLCBpLmcgPSBvKHUpLCBpLmIgPSBsKHUpLCBpLm9wYWNpdHkgPSBjKHUpLCBpICsgXCJcIjtcbiAgICB9O1xuICB9XG4gIHJldHVybiByLmdhbW1hID0gZSwgcjtcbn0oMSk7XG5mdW5jdGlvbiBxTyhlLCB0KSB7XG4gIHQgfHwgKHQgPSBbXSk7XG4gIHZhciBuID0gZSA/IE1hdGgubWluKHQubGVuZ3RoLCBlLmxlbmd0aCkgOiAwLCByID0gdC5zbGljZSgpLCBpO1xuICByZXR1cm4gZnVuY3Rpb24ocykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHJbaV0gPSBlW2ldICogKDEgLSBzKSArIHRbaV0gKiBzO1xuICAgIHJldHVybiByO1xuICB9O1xufVxuZnVuY3Rpb24gWU8oZSkge1xuICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGUpICYmICEoZSBpbnN0YW5jZW9mIERhdGFWaWV3KTtcbn1cbmZ1bmN0aW9uIFhPKGUsIHQpIHtcbiAgdmFyIG4gPSB0ID8gdC5sZW5ndGggOiAwLCByID0gZSA/IE1hdGgubWluKG4sIGUubGVuZ3RoKSA6IDAsIGkgPSBuZXcgQXJyYXkociksIHMgPSBuZXcgQXJyYXkobiksIGE7XG4gIGZvciAoYSA9IDA7IGEgPCByOyArK2EpIGlbYV0gPSBmcyhlW2FdLCB0W2FdKTtcbiAgZm9yICg7IGEgPCBuOyArK2EpIHNbYV0gPSB0W2FdO1xuICByZXR1cm4gZnVuY3Rpb24obykge1xuICAgIGZvciAoYSA9IDA7IGEgPCByOyArK2EpIHNbYV0gPSBpW2FdKG8pO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuZnVuY3Rpb24gWk8oZSwgdCkge1xuICB2YXIgbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICByZXR1cm4gZSA9ICtlLCB0ID0gK3QsIGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gbi5zZXRUaW1lKGUgKiAoMSAtIHIpICsgdCAqIHIpLCBuO1xuICB9O1xufVxuZnVuY3Rpb24geGUoZSwgdCkge1xuICByZXR1cm4gZSA9ICtlLCB0ID0gK3QsIGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gZSAqICgxIC0gbikgKyB0ICogbjtcbiAgfTtcbn1cbmZ1bmN0aW9uIEtPKGUsIHQpIHtcbiAgdmFyIG4gPSB7fSwgciA9IHt9LCBpO1xuICAoZSA9PT0gbnVsbCB8fCB0eXBlb2YgZSAhPSBcIm9iamVjdFwiKSAmJiAoZSA9IHt9KSwgKHQgPT09IG51bGwgfHwgdHlwZW9mIHQgIT0gXCJvYmplY3RcIikgJiYgKHQgPSB7fSk7XG4gIGZvciAoaSBpbiB0KVxuICAgIGkgaW4gZSA/IG5baV0gPSBmcyhlW2ldLCB0W2ldKSA6IHJbaV0gPSB0W2ldO1xuICByZXR1cm4gZnVuY3Rpb24ocykge1xuICAgIGZvciAoaSBpbiBuKSByW2ldID0gbltpXShzKTtcbiAgICByZXR1cm4gcjtcbiAgfTtcbn1cbnZhciBUbCA9IC9bLStdPyg/OlxcZCtcXC4/XFxkKnxcXC4/XFxkKykoPzpbZUVdWy0rXT9cXGQrKT8vZywgQW8gPSBuZXcgUmVnRXhwKFRsLnNvdXJjZSwgXCJnXCIpO1xuZnVuY3Rpb24gUU8oZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGU7XG4gIH07XG59XG5mdW5jdGlvbiBKTyhlKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGUodCkgKyBcIlwiO1xuICB9O1xufVxuZnVuY3Rpb24gdW0oZSwgdCkge1xuICB2YXIgbiA9IFRsLmxhc3RJbmRleCA9IEFvLmxhc3RJbmRleCA9IDAsIHIsIGksIHMsIGEgPSAtMSwgbyA9IFtdLCBsID0gW107XG4gIGZvciAoZSA9IGUgKyBcIlwiLCB0ID0gdCArIFwiXCI7IChyID0gVGwuZXhlYyhlKSkgJiYgKGkgPSBBby5leGVjKHQpKTsgKVxuICAgIChzID0gaS5pbmRleCkgPiBuICYmIChzID0gdC5zbGljZShuLCBzKSwgb1thXSA/IG9bYV0gKz0gcyA6IG9bKythXSA9IHMpLCAociA9IHJbMF0pID09PSAoaSA9IGlbMF0pID8gb1thXSA/IG9bYV0gKz0gaSA6IG9bKythXSA9IGkgOiAob1srK2FdID0gbnVsbCwgbC5wdXNoKHsgaTogYSwgeDogeGUociwgaSkgfSkpLCBuID0gQW8ubGFzdEluZGV4O1xuICByZXR1cm4gbiA8IHQubGVuZ3RoICYmIChzID0gdC5zbGljZShuKSwgb1thXSA/IG9bYV0gKz0gcyA6IG9bKythXSA9IHMpLCBvLmxlbmd0aCA8IDIgPyBsWzBdID8gSk8obFswXS54KSA6IFFPKHQpIDogKHQgPSBsLmxlbmd0aCwgZnVuY3Rpb24oYykge1xuICAgIGZvciAodmFyIHUgPSAwLCBkOyB1IDwgdDsgKyt1KSBvWyhkID0gbFt1XSkuaV0gPSBkLngoYyk7XG4gICAgcmV0dXJuIG8uam9pbihcIlwiKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBmcyhlLCB0KSB7XG4gIHZhciBuID0gdHlwZW9mIHQsIHI7XG4gIHJldHVybiB0ID09IG51bGwgfHwgbiA9PT0gXCJib29sZWFuXCIgPyBJYyh0KSA6IChuID09PSBcIm51bWJlclwiID8geGUgOiBuID09PSBcInN0cmluZ1wiID8gKHIgPSBUbih0KSkgPyAodCA9IHIsIHBhKSA6IHVtIDogdCBpbnN0YW5jZW9mIFRuID8gcGEgOiB0IGluc3RhbmNlb2YgRGF0ZSA/IFpPIDogWU8odCkgPyBxTyA6IEFycmF5LmlzQXJyYXkodCkgPyBYTyA6IHR5cGVvZiB0LnZhbHVlT2YgIT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB0LnRvU3RyaW5nICE9IFwiZnVuY3Rpb25cIiB8fCBpc05hTih0KSA/IEtPIDogeGUpKGUsIHQpO1xufVxuZnVuY3Rpb24gaG0oZSwgdCkge1xuICByZXR1cm4gZSA9ICtlLCB0ID0gK3QsIGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChlICogKDEgLSBuKSArIHQgKiBuKTtcbiAgfTtcbn1cbnZhciBfaCA9IDE4MCAvIE1hdGguUEksIGRtID0ge1xuICB0cmFuc2xhdGVYOiAwLFxuICB0cmFuc2xhdGVZOiAwLFxuICByb3RhdGU6IDAsXG4gIHNrZXdYOiAwLFxuICBzY2FsZVg6IDEsXG4gIHNjYWxlWTogMVxufTtcbmZ1bmN0aW9uIHBtKGUsIHQsIG4sIHIsIGksIHMpIHtcbiAgdmFyIGEsIG8sIGw7XG4gIHJldHVybiAoYSA9IE1hdGguc3FydChlICogZSArIHQgKiB0KSkgJiYgKGUgLz0gYSwgdCAvPSBhKSwgKGwgPSBlICogbiArIHQgKiByKSAmJiAobiAtPSBlICogbCwgciAtPSB0ICogbCksIChvID0gTWF0aC5zcXJ0KG4gKiBuICsgciAqIHIpKSAmJiAobiAvPSBvLCByIC89IG8sIGwgLz0gbyksIGUgKiByIDwgdCAqIG4gJiYgKGUgPSAtZSwgdCA9IC10LCBsID0gLWwsIGEgPSAtYSksIHtcbiAgICB0cmFuc2xhdGVYOiBpLFxuICAgIHRyYW5zbGF0ZVk6IHMsXG4gICAgcm90YXRlOiBNYXRoLmF0YW4yKHQsIGUpICogX2gsXG4gICAgc2tld1g6IE1hdGguYXRhbihsKSAqIF9oLFxuICAgIHNjYWxlWDogYSxcbiAgICBzY2FsZVk6IG9cbiAgfTtcbn1cbnZhciBNcztcbmZ1bmN0aW9uIHRTKGUpIHtcbiAgY29uc3QgdCA9IG5ldyAodHlwZW9mIERPTU1hdHJpeCA9PSBcImZ1bmN0aW9uXCIgPyBET01NYXRyaXggOiBXZWJLaXRDU1NNYXRyaXgpKGUgKyBcIlwiKTtcbiAgcmV0dXJuIHQuaXNJZGVudGl0eSA/IGRtIDogcG0odC5hLCB0LmIsIHQuYywgdC5kLCB0LmUsIHQuZik7XG59XG5mdW5jdGlvbiBlUyhlKSB7XG4gIHJldHVybiBlID09IG51bGwgfHwgKE1zIHx8IChNcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKSksIE1zLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBlKSwgIShlID0gTXMudHJhbnNmb3JtLmJhc2VWYWwuY29uc29saWRhdGUoKSkpID8gZG0gOiAoZSA9IGUubWF0cml4LCBwbShlLmEsIGUuYiwgZS5jLCBlLmQsIGUuZSwgZS5mKSk7XG59XG5mdW5jdGlvbiBmbShlLCB0LCBuLCByKSB7XG4gIGZ1bmN0aW9uIGkoYykge1xuICAgIHJldHVybiBjLmxlbmd0aCA/IGMucG9wKCkgKyBcIiBcIiA6IFwiXCI7XG4gIH1cbiAgZnVuY3Rpb24gcyhjLCB1LCBkLCBoLCBwLCBmKSB7XG4gICAgaWYgKGMgIT09IGQgfHwgdSAhPT0gaCkge1xuICAgICAgdmFyIGcgPSBwLnB1c2goXCJ0cmFuc2xhdGUoXCIsIG51bGwsIHQsIG51bGwsIG4pO1xuICAgICAgZi5wdXNoKHsgaTogZyAtIDQsIHg6IHhlKGMsIGQpIH0sIHsgaTogZyAtIDIsIHg6IHhlKHUsIGgpIH0pO1xuICAgIH0gZWxzZSAoZCB8fCBoKSAmJiBwLnB1c2goXCJ0cmFuc2xhdGUoXCIgKyBkICsgdCArIGggKyBuKTtcbiAgfVxuICBmdW5jdGlvbiBhKGMsIHUsIGQsIGgpIHtcbiAgICBjICE9PSB1ID8gKGMgLSB1ID4gMTgwID8gdSArPSAzNjAgOiB1IC0gYyA+IDE4MCAmJiAoYyArPSAzNjApLCBoLnB1c2goeyBpOiBkLnB1c2goaShkKSArIFwicm90YXRlKFwiLCBudWxsLCByKSAtIDIsIHg6IHhlKGMsIHUpIH0pKSA6IHUgJiYgZC5wdXNoKGkoZCkgKyBcInJvdGF0ZShcIiArIHUgKyByKTtcbiAgfVxuICBmdW5jdGlvbiBvKGMsIHUsIGQsIGgpIHtcbiAgICBjICE9PSB1ID8gaC5wdXNoKHsgaTogZC5wdXNoKGkoZCkgKyBcInNrZXdYKFwiLCBudWxsLCByKSAtIDIsIHg6IHhlKGMsIHUpIH0pIDogdSAmJiBkLnB1c2goaShkKSArIFwic2tld1goXCIgKyB1ICsgcik7XG4gIH1cbiAgZnVuY3Rpb24gbChjLCB1LCBkLCBoLCBwLCBmKSB7XG4gICAgaWYgKGMgIT09IGQgfHwgdSAhPT0gaCkge1xuICAgICAgdmFyIGcgPSBwLnB1c2goaShwKSArIFwic2NhbGUoXCIsIG51bGwsIFwiLFwiLCBudWxsLCBcIilcIik7XG4gICAgICBmLnB1c2goeyBpOiBnIC0gNCwgeDogeGUoYywgZCkgfSwgeyBpOiBnIC0gMiwgeDogeGUodSwgaCkgfSk7XG4gICAgfSBlbHNlIChkICE9PSAxIHx8IGggIT09IDEpICYmIHAucHVzaChpKHApICsgXCJzY2FsZShcIiArIGQgKyBcIixcIiArIGggKyBcIilcIik7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKGMsIHUpIHtcbiAgICB2YXIgZCA9IFtdLCBoID0gW107XG4gICAgcmV0dXJuIGMgPSBlKGMpLCB1ID0gZSh1KSwgcyhjLnRyYW5zbGF0ZVgsIGMudHJhbnNsYXRlWSwgdS50cmFuc2xhdGVYLCB1LnRyYW5zbGF0ZVksIGQsIGgpLCBhKGMucm90YXRlLCB1LnJvdGF0ZSwgZCwgaCksIG8oYy5za2V3WCwgdS5za2V3WCwgZCwgaCksIGwoYy5zY2FsZVgsIGMuc2NhbGVZLCB1LnNjYWxlWCwgdS5zY2FsZVksIGQsIGgpLCBjID0gdSA9IG51bGwsIGZ1bmN0aW9uKHApIHtcbiAgICAgIGZvciAodmFyIGYgPSAtMSwgZyA9IGgubGVuZ3RoLCBtOyArK2YgPCBnOyApIGRbKG0gPSBoW2ZdKS5pXSA9IG0ueChwKTtcbiAgICAgIHJldHVybiBkLmpvaW4oXCJcIik7XG4gICAgfTtcbiAgfTtcbn1cbnZhciBuUyA9IGZtKHRTLCBcInB4LCBcIiwgXCJweClcIiwgXCJkZWcpXCIpLCByUyA9IGZtKGVTLCBcIiwgXCIsIFwiKVwiLCBcIilcIiksIFpyID0gMCwgVGkgPSAwLCBwaSA9IDAsIG1tID0gMWUzLCBmYSwgd2ksIG1hID0gMCwgaXIgPSAwLCBlbyA9IDAsIEppID0gdHlwZW9mIHBlcmZvcm1hbmNlID09IFwib2JqZWN0XCIgJiYgcGVyZm9ybWFuY2Uubm93ID8gcGVyZm9ybWFuY2UgOiBEYXRlLCBnbSA9IHR5cGVvZiB3aW5kb3cgPT0gXCJvYmplY3RcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdykgOiBmdW5jdGlvbihlKSB7XG4gIHNldFRpbWVvdXQoZSwgMTcpO1xufTtcbmZ1bmN0aW9uIE5jKCkge1xuICByZXR1cm4gaXIgfHwgKGdtKGlTKSwgaXIgPSBKaS5ub3coKSArIGVvKTtcbn1cbmZ1bmN0aW9uIGlTKCkge1xuICBpciA9IDA7XG59XG5mdW5jdGlvbiBnYSgpIHtcbiAgdGhpcy5fY2FsbCA9IHRoaXMuX3RpbWUgPSB0aGlzLl9uZXh0ID0gbnVsbDtcbn1cbmdhLnByb3RvdHlwZSA9IHZtLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IGdhLFxuICByZXN0YXJ0OiBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgaWYgKHR5cGVvZiBlICE9IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgIG4gPSAobiA9PSBudWxsID8gTmMoKSA6ICtuKSArICh0ID09IG51bGwgPyAwIDogK3QpLCAhdGhpcy5fbmV4dCAmJiB3aSAhPT0gdGhpcyAmJiAod2kgPyB3aS5fbmV4dCA9IHRoaXMgOiBmYSA9IHRoaXMsIHdpID0gdGhpcyksIHRoaXMuX2NhbGwgPSBlLCB0aGlzLl90aW1lID0gbiwgd2woKTtcbiAgfSxcbiAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2FsbCAmJiAodGhpcy5fY2FsbCA9IG51bGwsIHRoaXMuX3RpbWUgPSAxIC8gMCwgd2woKSk7XG4gIH1cbn07XG5mdW5jdGlvbiB2bShlLCB0LCBuKSB7XG4gIHZhciByID0gbmV3IGdhKCk7XG4gIHJldHVybiByLnJlc3RhcnQoZSwgdCwgbiksIHI7XG59XG5mdW5jdGlvbiBzUygpIHtcbiAgTmMoKSwgKytacjtcbiAgZm9yICh2YXIgZSA9IGZhLCB0OyBlOyApXG4gICAgKHQgPSBpciAtIGUuX3RpbWUpID49IDAgJiYgZS5fY2FsbC5jYWxsKHZvaWQgMCwgdCksIGUgPSBlLl9uZXh0O1xuICAtLVpyO1xufVxuZnVuY3Rpb24gRWgoKSB7XG4gIGlyID0gKG1hID0gSmkubm93KCkpICsgZW8sIFpyID0gVGkgPSAwO1xuICB0cnkge1xuICAgIHNTKCk7XG4gIH0gZmluYWxseSB7XG4gICAgWnIgPSAwLCBvUygpLCBpciA9IDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGFTKCkge1xuICB2YXIgZSA9IEppLm5vdygpLCB0ID0gZSAtIG1hO1xuICB0ID4gbW0gJiYgKGVvIC09IHQsIG1hID0gZSk7XG59XG5mdW5jdGlvbiBvUygpIHtcbiAgZm9yICh2YXIgZSwgdCA9IGZhLCBuLCByID0gMSAvIDA7IHQ7IClcbiAgICB0Ll9jYWxsID8gKHIgPiB0Ll90aW1lICYmIChyID0gdC5fdGltZSksIGUgPSB0LCB0ID0gdC5fbmV4dCkgOiAobiA9IHQuX25leHQsIHQuX25leHQgPSBudWxsLCB0ID0gZSA/IGUuX25leHQgPSBuIDogZmEgPSBuKTtcbiAgd2kgPSBlLCB3bChyKTtcbn1cbmZ1bmN0aW9uIHdsKGUpIHtcbiAgaWYgKCFacikge1xuICAgIFRpICYmIChUaSA9IGNsZWFyVGltZW91dChUaSkpO1xuICAgIHZhciB0ID0gZSAtIGlyO1xuICAgIHQgPiAyNCA/IChlIDwgMSAvIDAgJiYgKFRpID0gc2V0VGltZW91dChFaCwgZSAtIEppLm5vdygpIC0gZW8pKSwgcGkgJiYgKHBpID0gY2xlYXJJbnRlcnZhbChwaSkpKSA6IChwaSB8fCAobWEgPSBKaS5ub3coKSwgcGkgPSBzZXRJbnRlcnZhbChhUywgbW0pKSwgWnIgPSAxLCBnbShFaCkpO1xuICB9XG59XG5mdW5jdGlvbiBPaChlLCB0LCBuKSB7XG4gIHZhciByID0gbmV3IGdhKCk7XG4gIHJldHVybiB0ID0gdCA9PSBudWxsID8gMCA6ICt0LCByLnJlc3RhcnQoKGkpID0+IHtcbiAgICByLnN0b3AoKSwgZShpICsgdCk7XG4gIH0sIHQsIG4pLCByO1xufVxudmFyIGxTID0gTGMoXCJzdGFydFwiLCBcImVuZFwiLCBcImNhbmNlbFwiLCBcImludGVycnVwdFwiKSwgY1MgPSBbXSwgeW0gPSAwLCBTaCA9IDEsICRsID0gMiwgWHMgPSAzLCBUaCA9IDQsIE1sID0gNSwgWnMgPSA2O1xuZnVuY3Rpb24gbm8oZSwgdCwgbiwgciwgaSwgcykge1xuICB2YXIgYSA9IGUuX190cmFuc2l0aW9uO1xuICBpZiAoIWEpIGUuX190cmFuc2l0aW9uID0ge307XG4gIGVsc2UgaWYgKG4gaW4gYSkgcmV0dXJuO1xuICB1UyhlLCBuLCB7XG4gICAgbmFtZTogdCxcbiAgICBpbmRleDogcixcbiAgICAvLyBGb3IgY29udGV4dCBkdXJpbmcgY2FsbGJhY2suXG4gICAgZ3JvdXA6IGksXG4gICAgLy8gRm9yIGNvbnRleHQgZHVyaW5nIGNhbGxiYWNrLlxuICAgIG9uOiBsUyxcbiAgICB0d2VlbjogY1MsXG4gICAgdGltZTogcy50aW1lLFxuICAgIGRlbGF5OiBzLmRlbGF5LFxuICAgIGR1cmF0aW9uOiBzLmR1cmF0aW9uLFxuICAgIGVhc2U6IHMuZWFzZSxcbiAgICB0aW1lcjogbnVsbCxcbiAgICBzdGF0ZTogeW1cbiAgfSk7XG59XG5mdW5jdGlvbiBQYyhlLCB0KSB7XG4gIHZhciBuID0gcWUoZSwgdCk7XG4gIGlmIChuLnN0YXRlID4geW0pIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHNjaGVkdWxlZFwiKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBzbihlLCB0KSB7XG4gIHZhciBuID0gcWUoZSwgdCk7XG4gIGlmIChuLnN0YXRlID4gWHMpIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gcWUoZSwgdCkge1xuICB2YXIgbiA9IGUuX190cmFuc2l0aW9uO1xuICBpZiAoIW4gfHwgIShuID0gblt0XSkpIHRocm93IG5ldyBFcnJvcihcInRyYW5zaXRpb24gbm90IGZvdW5kXCIpO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHVTKGUsIHQsIG4pIHtcbiAgdmFyIHIgPSBlLl9fdHJhbnNpdGlvbiwgaTtcbiAgclt0XSA9IG4sIG4udGltZXIgPSB2bShzLCAwLCBuLnRpbWUpO1xuICBmdW5jdGlvbiBzKGMpIHtcbiAgICBuLnN0YXRlID0gU2gsIG4udGltZXIucmVzdGFydChhLCBuLmRlbGF5LCBuLnRpbWUpLCBuLmRlbGF5IDw9IGMgJiYgYShjIC0gbi5kZWxheSk7XG4gIH1cbiAgZnVuY3Rpb24gYShjKSB7XG4gICAgdmFyIHUsIGQsIGgsIHA7XG4gICAgaWYgKG4uc3RhdGUgIT09IFNoKSByZXR1cm4gbCgpO1xuICAgIGZvciAodSBpbiByKVxuICAgICAgaWYgKHAgPSByW3VdLCBwLm5hbWUgPT09IG4ubmFtZSkge1xuICAgICAgICBpZiAocC5zdGF0ZSA9PT0gWHMpIHJldHVybiBPaChhKTtcbiAgICAgICAgcC5zdGF0ZSA9PT0gVGggPyAocC5zdGF0ZSA9IFpzLCBwLnRpbWVyLnN0b3AoKSwgcC5vbi5jYWxsKFwiaW50ZXJydXB0XCIsIGUsIGUuX19kYXRhX18sIHAuaW5kZXgsIHAuZ3JvdXApLCBkZWxldGUgclt1XSkgOiArdSA8IHQgJiYgKHAuc3RhdGUgPSBacywgcC50aW1lci5zdG9wKCksIHAub24uY2FsbChcImNhbmNlbFwiLCBlLCBlLl9fZGF0YV9fLCBwLmluZGV4LCBwLmdyb3VwKSwgZGVsZXRlIHJbdV0pO1xuICAgICAgfVxuICAgIGlmIChPaChmdW5jdGlvbigpIHtcbiAgICAgIG4uc3RhdGUgPT09IFhzICYmIChuLnN0YXRlID0gVGgsIG4udGltZXIucmVzdGFydChvLCBuLmRlbGF5LCBuLnRpbWUpLCBvKGMpKTtcbiAgICB9KSwgbi5zdGF0ZSA9ICRsLCBuLm9uLmNhbGwoXCJzdGFydFwiLCBlLCBlLl9fZGF0YV9fLCBuLmluZGV4LCBuLmdyb3VwKSwgbi5zdGF0ZSA9PT0gJGwpIHtcbiAgICAgIGZvciAobi5zdGF0ZSA9IFhzLCBpID0gbmV3IEFycmF5KGggPSBuLnR3ZWVuLmxlbmd0aCksIHUgPSAwLCBkID0gLTE7IHUgPCBoOyArK3UpXG4gICAgICAgIChwID0gbi50d2Vlblt1XS52YWx1ZS5jYWxsKGUsIGUuX19kYXRhX18sIG4uaW5kZXgsIG4uZ3JvdXApKSAmJiAoaVsrK2RdID0gcCk7XG4gICAgICBpLmxlbmd0aCA9IGQgKyAxO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvKGMpIHtcbiAgICBmb3IgKHZhciB1ID0gYyA8IG4uZHVyYXRpb24gPyBuLmVhc2UuY2FsbChudWxsLCBjIC8gbi5kdXJhdGlvbikgOiAobi50aW1lci5yZXN0YXJ0KGwpLCBuLnN0YXRlID0gTWwsIDEpLCBkID0gLTEsIGggPSBpLmxlbmd0aDsgKytkIDwgaDsgKVxuICAgICAgaVtkXS5jYWxsKGUsIHUpO1xuICAgIG4uc3RhdGUgPT09IE1sICYmIChuLm9uLmNhbGwoXCJlbmRcIiwgZSwgZS5fX2RhdGFfXywgbi5pbmRleCwgbi5ncm91cCksIGwoKSk7XG4gIH1cbiAgZnVuY3Rpb24gbCgpIHtcbiAgICBuLnN0YXRlID0gWnMsIG4udGltZXIuc3RvcCgpLCBkZWxldGUgclt0XTtcbiAgICBmb3IgKHZhciBjIGluIHIpIHJldHVybjtcbiAgICBkZWxldGUgZS5fX3RyYW5zaXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIENsKGUsIHQpIHtcbiAgdmFyIG4gPSBlLl9fdHJhbnNpdGlvbiwgciwgaSwgcyA9ICEwLCBhO1xuICBpZiAobikge1xuICAgIHQgPSB0ID09IG51bGwgPyBudWxsIDogdCArIFwiXCI7XG4gICAgZm9yIChhIGluIG4pIHtcbiAgICAgIGlmICgociA9IG5bYV0pLm5hbWUgIT09IHQpIHtcbiAgICAgICAgcyA9ICExO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGkgPSByLnN0YXRlID4gJGwgJiYgci5zdGF0ZSA8IE1sLCByLnN0YXRlID0gWnMsIHIudGltZXIuc3RvcCgpLCByLm9uLmNhbGwoaSA/IFwiaW50ZXJydXB0XCIgOiBcImNhbmNlbFwiLCBlLCBlLl9fZGF0YV9fLCByLmluZGV4LCByLmdyb3VwKSwgZGVsZXRlIG5bYV07XG4gICAgfVxuICAgIHMgJiYgZGVsZXRlIGUuX190cmFuc2l0aW9uO1xuICB9XG59XG5mdW5jdGlvbiBoUyhlKSB7XG4gIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgQ2wodGhpcywgZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZFMoZSwgdCkge1xuICB2YXIgbiwgcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBpID0gc24odGhpcywgZSksIHMgPSBpLnR3ZWVuO1xuICAgIGlmIChzICE9PSBuKSB7XG4gICAgICByID0gbiA9IHM7XG4gICAgICBmb3IgKHZhciBhID0gMCwgbyA9IHIubGVuZ3RoOyBhIDwgbzsgKythKVxuICAgICAgICBpZiAoclthXS5uYW1lID09PSB0KSB7XG4gICAgICAgICAgciA9IHIuc2xpY2UoKSwgci5zcGxpY2UoYSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaS50d2VlbiA9IHI7XG4gIH07XG59XG5mdW5jdGlvbiBwUyhlLCB0LCBuKSB7XG4gIHZhciByLCBpO1xuICBpZiAodHlwZW9mIG4gIT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzID0gc24odGhpcywgZSksIGEgPSBzLnR3ZWVuO1xuICAgIGlmIChhICE9PSByKSB7XG4gICAgICBpID0gKHIgPSBhKS5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgbyA9IHsgbmFtZTogdCwgdmFsdWU6IG4gfSwgbCA9IDAsIGMgPSBpLmxlbmd0aDsgbCA8IGM7ICsrbClcbiAgICAgICAgaWYgKGlbbF0ubmFtZSA9PT0gdCkge1xuICAgICAgICAgIGlbbF0gPSBvO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBsID09PSBjICYmIGkucHVzaChvKTtcbiAgICB9XG4gICAgcy50d2VlbiA9IGk7XG4gIH07XG59XG5mdW5jdGlvbiBmUyhlLCB0KSB7XG4gIHZhciBuID0gdGhpcy5faWQ7XG4gIGlmIChlICs9IFwiXCIsIGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgZm9yICh2YXIgciA9IHFlKHRoaXMubm9kZSgpLCBuKS50d2VlbiwgaSA9IDAsIHMgPSByLmxlbmd0aCwgYTsgaSA8IHM7ICsraSlcbiAgICAgIGlmICgoYSA9IHJbaV0pLm5hbWUgPT09IGUpXG4gICAgICAgIHJldHVybiBhLnZhbHVlO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB0aGlzLmVhY2goKHQgPT0gbnVsbCA/IGRTIDogcFMpKG4sIGUsIHQpKTtcbn1cbmZ1bmN0aW9uIFVjKGUsIHQsIG4pIHtcbiAgdmFyIHIgPSBlLl9pZDtcbiAgcmV0dXJuIGUuZWFjaChmdW5jdGlvbigpIHtcbiAgICB2YXIgaSA9IHNuKHRoaXMsIHIpO1xuICAgIChpLnZhbHVlIHx8IChpLnZhbHVlID0ge30pKVt0XSA9IG4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSksIGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gcWUoaSwgcikudmFsdWVbdF07XG4gIH07XG59XG5mdW5jdGlvbiB4bShlLCB0KSB7XG4gIHZhciBuO1xuICByZXR1cm4gKHR5cGVvZiB0ID09IFwibnVtYmVyXCIgPyB4ZSA6IHQgaW5zdGFuY2VvZiBUbiA/IHBhIDogKG4gPSBUbih0KSkgPyAodCA9IG4sIHBhKSA6IHVtKShlLCB0KTtcbn1cbmZ1bmN0aW9uIG1TKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKGUpO1xuICB9O1xufVxuZnVuY3Rpb24gZ1MoZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhlLnNwYWNlLCBlLmxvY2FsKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHZTKGUsIHQsIG4pIHtcbiAgdmFyIHIsIGkgPSBuICsgXCJcIiwgcztcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhID0gdGhpcy5nZXRBdHRyaWJ1dGUoZSk7XG4gICAgcmV0dXJuIGEgPT09IGkgPyBudWxsIDogYSA9PT0gciA/IHMgOiBzID0gdChyID0gYSwgbik7XG4gIH07XG59XG5mdW5jdGlvbiB5UyhlLCB0LCBuKSB7XG4gIHZhciByLCBpID0gbiArIFwiXCIsIHM7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSA9IHRoaXMuZ2V0QXR0cmlidXRlTlMoZS5zcGFjZSwgZS5sb2NhbCk7XG4gICAgcmV0dXJuIGEgPT09IGkgPyBudWxsIDogYSA9PT0gciA/IHMgOiBzID0gdChyID0gYSwgbik7XG4gIH07XG59XG5mdW5jdGlvbiB4UyhlLCB0LCBuKSB7XG4gIHZhciByLCBpLCBzO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGEsIG8gPSBuKHRoaXMpLCBsO1xuICAgIHJldHVybiBvID09IG51bGwgPyB2b2lkIHRoaXMucmVtb3ZlQXR0cmlidXRlKGUpIDogKGEgPSB0aGlzLmdldEF0dHJpYnV0ZShlKSwgbCA9IG8gKyBcIlwiLCBhID09PSBsID8gbnVsbCA6IGEgPT09IHIgJiYgbCA9PT0gaSA/IHMgOiAoaSA9IGwsIHMgPSB0KHIgPSBhLCBvKSkpO1xuICB9O1xufVxuZnVuY3Rpb24gYlMoZSwgdCwgbikge1xuICB2YXIgciwgaSwgcztcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhLCBvID0gbih0aGlzKSwgbDtcbiAgICByZXR1cm4gbyA9PSBudWxsID8gdm9pZCB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGUuc3BhY2UsIGUubG9jYWwpIDogKGEgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKGUuc3BhY2UsIGUubG9jYWwpLCBsID0gbyArIFwiXCIsIGEgPT09IGwgPyBudWxsIDogYSA9PT0gciAmJiBsID09PSBpID8gcyA6IChpID0gbCwgcyA9IHQociA9IGEsIG8pKSk7XG4gIH07XG59XG5mdW5jdGlvbiBfUyhlLCB0KSB7XG4gIHZhciBuID0gdG8oZSksIHIgPSBuID09PSBcInRyYW5zZm9ybVwiID8gclMgOiB4bTtcbiAgcmV0dXJuIHRoaXMuYXR0clR3ZWVuKGUsIHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IChuLmxvY2FsID8gYlMgOiB4UykobiwgciwgVWModGhpcywgXCJhdHRyLlwiICsgZSwgdCkpIDogdCA9PSBudWxsID8gKG4ubG9jYWwgPyBnUyA6IG1TKShuKSA6IChuLmxvY2FsID8geVMgOiB2UykobiwgciwgdCkpO1xufVxuZnVuY3Rpb24gRVMoZSwgdCkge1xuICByZXR1cm4gZnVuY3Rpb24obikge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKGUsIHQuY2FsbCh0aGlzLCBuKSk7XG4gIH07XG59XG5mdW5jdGlvbiBPUyhlLCB0KSB7XG4gIHJldHVybiBmdW5jdGlvbihuKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhlLnNwYWNlLCBlLmxvY2FsLCB0LmNhbGwodGhpcywgbikpO1xuICB9O1xufVxuZnVuY3Rpb24gU1MoZSwgdCkge1xuICB2YXIgbiwgcjtcbiAgZnVuY3Rpb24gaSgpIHtcbiAgICB2YXIgcyA9IHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gcyAhPT0gciAmJiAobiA9IChyID0gcykgJiYgT1MoZSwgcykpLCBuO1xuICB9XG4gIHJldHVybiBpLl92YWx1ZSA9IHQsIGk7XG59XG5mdW5jdGlvbiBUUyhlLCB0KSB7XG4gIHZhciBuLCByO1xuICBmdW5jdGlvbiBpKCkge1xuICAgIHZhciBzID0gdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBzICE9PSByICYmIChuID0gKHIgPSBzKSAmJiBFUyhlLCBzKSksIG47XG4gIH1cbiAgcmV0dXJuIGkuX3ZhbHVlID0gdCwgaTtcbn1cbmZ1bmN0aW9uIHdTKGUsIHQpIHtcbiAgdmFyIG4gPSBcImF0dHIuXCIgKyBlO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiAobiA9IHRoaXMudHdlZW4obikpICYmIG4uX3ZhbHVlO1xuICBpZiAodCA9PSBudWxsKSByZXR1cm4gdGhpcy50d2VlbihuLCBudWxsKTtcbiAgaWYgKHR5cGVvZiB0ICE9IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKCk7XG4gIHZhciByID0gdG8oZSk7XG4gIHJldHVybiB0aGlzLnR3ZWVuKG4sIChyLmxvY2FsID8gU1MgOiBUUykociwgdCkpO1xufVxuZnVuY3Rpb24gJFMoZSwgdCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgUGModGhpcywgZSkuZGVsYXkgPSArdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuZnVuY3Rpb24gTVMoZSwgdCkge1xuICByZXR1cm4gdCA9ICt0LCBmdW5jdGlvbigpIHtcbiAgICBQYyh0aGlzLCBlKS5kZWxheSA9IHQ7XG4gIH07XG59XG5mdW5jdGlvbiBDUyhlKSB7XG4gIHZhciB0ID0gdGhpcy5faWQ7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5lYWNoKCh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyAkUyA6IE1TKSh0LCBlKSkgOiBxZSh0aGlzLm5vZGUoKSwgdCkuZGVsYXk7XG59XG5mdW5jdGlvbiBBUyhlLCB0KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBzbih0aGlzLCBlKS5kdXJhdGlvbiA9ICt0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5mdW5jdGlvbiBMUyhlLCB0KSB7XG4gIHJldHVybiB0ID0gK3QsIGZ1bmN0aW9uKCkge1xuICAgIHNuKHRoaXMsIGUpLmR1cmF0aW9uID0gdDtcbiAgfTtcbn1cbmZ1bmN0aW9uIGtTKGUpIHtcbiAgdmFyIHQgPSB0aGlzLl9pZDtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLmVhY2goKHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IEFTIDogTFMpKHQsIGUpKSA6IHFlKHRoaXMubm9kZSgpLCB0KS5kdXJhdGlvbjtcbn1cbmZ1bmN0aW9uIERTKGUsIHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBzbih0aGlzLCBlKS5lYXNlID0gdDtcbiAgfTtcbn1cbmZ1bmN0aW9uIFJTKGUpIHtcbiAgdmFyIHQgPSB0aGlzLl9pZDtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLmVhY2goRFModCwgZSkpIDogcWUodGhpcy5ub2RlKCksIHQpLmVhc2U7XG59XG5mdW5jdGlvbiBJUyhlLCB0KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodHlwZW9mIG4gIT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICBzbih0aGlzLCBlKS5lYXNlID0gbjtcbiAgfTtcbn1cbmZ1bmN0aW9uIE5TKGUpIHtcbiAgaWYgKHR5cGVvZiBlICE9IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKCk7XG4gIHJldHVybiB0aGlzLmVhY2goSVModGhpcy5faWQsIGUpKTtcbn1cbmZ1bmN0aW9uIFBTKGUpIHtcbiAgdHlwZW9mIGUgIT0gXCJmdW5jdGlvblwiICYmIChlID0gWmYoZSkpO1xuICBmb3IgKHZhciB0ID0gdGhpcy5fZ3JvdXBzLCBuID0gdC5sZW5ndGgsIHIgPSBuZXcgQXJyYXkobiksIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGZvciAodmFyIHMgPSB0W2ldLCBhID0gcy5sZW5ndGgsIG8gPSByW2ldID0gW10sIGwsIGMgPSAwOyBjIDwgYTsgKytjKVxuICAgICAgKGwgPSBzW2NdKSAmJiBlLmNhbGwobCwgbC5fX2RhdGFfXywgYywgcykgJiYgby5wdXNoKGwpO1xuICByZXR1cm4gbmV3IHduKHIsIHRoaXMuX3BhcmVudHMsIHRoaXMuX25hbWUsIHRoaXMuX2lkKTtcbn1cbmZ1bmN0aW9uIFVTKGUpIHtcbiAgaWYgKGUuX2lkICE9PSB0aGlzLl9pZCkgdGhyb3cgbmV3IEVycm9yKCk7XG4gIGZvciAodmFyIHQgPSB0aGlzLl9ncm91cHMsIG4gPSBlLl9ncm91cHMsIHIgPSB0Lmxlbmd0aCwgaSA9IG4ubGVuZ3RoLCBzID0gTWF0aC5taW4ociwgaSksIGEgPSBuZXcgQXJyYXkociksIG8gPSAwOyBvIDwgczsgKytvKVxuICAgIGZvciAodmFyIGwgPSB0W29dLCBjID0gbltvXSwgdSA9IGwubGVuZ3RoLCBkID0gYVtvXSA9IG5ldyBBcnJheSh1KSwgaCwgcCA9IDA7IHAgPCB1OyArK3ApXG4gICAgICAoaCA9IGxbcF0gfHwgY1twXSkgJiYgKGRbcF0gPSBoKTtcbiAgZm9yICg7IG8gPCByOyArK28pXG4gICAgYVtvXSA9IHRbb107XG4gIHJldHVybiBuZXcgd24oYSwgdGhpcy5fcGFyZW50cywgdGhpcy5fbmFtZSwgdGhpcy5faWQpO1xufVxuZnVuY3Rpb24gQlMoZSkge1xuICByZXR1cm4gKGUgKyBcIlwiKS50cmltKCkuc3BsaXQoL158XFxzKy8pLmV2ZXJ5KGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbiA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgcmV0dXJuIG4gPj0gMCAmJiAodCA9IHQuc2xpY2UoMCwgbikpLCAhdCB8fCB0ID09PSBcInN0YXJ0XCI7XG4gIH0pO1xufVxuZnVuY3Rpb24gSFMoZSwgdCwgbikge1xuICB2YXIgciwgaSwgcyA9IEJTKHQpID8gUGMgOiBzbjtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhID0gcyh0aGlzLCBlKSwgbyA9IGEub247XG4gICAgbyAhPT0gciAmJiAoaSA9IChyID0gbykuY29weSgpKS5vbih0LCBuKSwgYS5vbiA9IGk7XG4gIH07XG59XG5mdW5jdGlvbiBWUyhlLCB0KSB7XG4gIHZhciBuID0gdGhpcy5faWQ7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHFlKHRoaXMubm9kZSgpLCBuKS5vbi5vbihlKSA6IHRoaXMuZWFjaChIUyhuLCBlLCB0KSk7XG59XG5mdW5jdGlvbiBHUyhlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICBmb3IgKHZhciBuIGluIHRoaXMuX190cmFuc2l0aW9uKSBpZiAoK24gIT09IGUpIHJldHVybjtcbiAgICB0ICYmIHQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gIH07XG59XG5mdW5jdGlvbiB6UygpIHtcbiAgcmV0dXJuIHRoaXMub24oXCJlbmQucmVtb3ZlXCIsIEdTKHRoaXMuX2lkKSk7XG59XG5mdW5jdGlvbiBGUyhlKSB7XG4gIHZhciB0ID0gdGhpcy5fbmFtZSwgbiA9IHRoaXMuX2lkO1xuICB0eXBlb2YgZSAhPSBcImZ1bmN0aW9uXCIgJiYgKGUgPSBrYyhlKSk7XG4gIGZvciAodmFyIHIgPSB0aGlzLl9ncm91cHMsIGkgPSByLmxlbmd0aCwgcyA9IG5ldyBBcnJheShpKSwgYSA9IDA7IGEgPCBpOyArK2EpXG4gICAgZm9yICh2YXIgbyA9IHJbYV0sIGwgPSBvLmxlbmd0aCwgYyA9IHNbYV0gPSBuZXcgQXJyYXkobCksIHUsIGQsIGggPSAwOyBoIDwgbDsgKytoKVxuICAgICAgKHUgPSBvW2hdKSAmJiAoZCA9IGUuY2FsbCh1LCB1Ll9fZGF0YV9fLCBoLCBvKSkgJiYgKFwiX19kYXRhX19cIiBpbiB1ICYmIChkLl9fZGF0YV9fID0gdS5fX2RhdGFfXyksIGNbaF0gPSBkLCBubyhjW2hdLCB0LCBuLCBoLCBjLCBxZSh1LCBuKSkpO1xuICByZXR1cm4gbmV3IHduKHMsIHRoaXMuX3BhcmVudHMsIHQsIG4pO1xufVxuZnVuY3Rpb24galMoZSkge1xuICB2YXIgdCA9IHRoaXMuX25hbWUsIG4gPSB0aGlzLl9pZDtcbiAgdHlwZW9mIGUgIT0gXCJmdW5jdGlvblwiICYmIChlID0gWGYoZSkpO1xuICBmb3IgKHZhciByID0gdGhpcy5fZ3JvdXBzLCBpID0gci5sZW5ndGgsIHMgPSBbXSwgYSA9IFtdLCBvID0gMDsgbyA8IGk7ICsrbylcbiAgICBmb3IgKHZhciBsID0gcltvXSwgYyA9IGwubGVuZ3RoLCB1LCBkID0gMDsgZCA8IGM7ICsrZClcbiAgICAgIGlmICh1ID0gbFtkXSkge1xuICAgICAgICBmb3IgKHZhciBoID0gZS5jYWxsKHUsIHUuX19kYXRhX18sIGQsIGwpLCBwLCBmID0gcWUodSwgbiksIGcgPSAwLCBtID0gaC5sZW5ndGg7IGcgPCBtOyArK2cpXG4gICAgICAgICAgKHAgPSBoW2ddKSAmJiBubyhwLCB0LCBuLCBnLCBoLCBmKTtcbiAgICAgICAgcy5wdXNoKGgpLCBhLnB1c2godSk7XG4gICAgICB9XG4gIHJldHVybiBuZXcgd24ocywgYSwgdCwgbik7XG59XG52YXIgV1MgPSBkcy5wcm90b3R5cGUuY29uc3RydWN0b3I7XG5mdW5jdGlvbiBxUygpIHtcbiAgcmV0dXJuIG5ldyBXUyh0aGlzLl9ncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufVxuZnVuY3Rpb24gWVMoZSwgdCkge1xuICB2YXIgbiwgciwgaTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzID0gWHIodGhpcywgZSksIGEgPSAodGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShlKSwgWHIodGhpcywgZSkpO1xuICAgIHJldHVybiBzID09PSBhID8gbnVsbCA6IHMgPT09IG4gJiYgYSA9PT0gciA/IGkgOiBpID0gdChuID0gcywgciA9IGEpO1xuICB9O1xufVxuZnVuY3Rpb24gYm0oZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShlKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIFhTKGUsIHQsIG4pIHtcbiAgdmFyIHIsIGkgPSBuICsgXCJcIiwgcztcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhID0gWHIodGhpcywgZSk7XG4gICAgcmV0dXJuIGEgPT09IGkgPyBudWxsIDogYSA9PT0gciA/IHMgOiBzID0gdChyID0gYSwgbik7XG4gIH07XG59XG5mdW5jdGlvbiBaUyhlLCB0LCBuKSB7XG4gIHZhciByLCBpLCBzO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGEgPSBYcih0aGlzLCBlKSwgbyA9IG4odGhpcyksIGwgPSBvICsgXCJcIjtcbiAgICByZXR1cm4gbyA9PSBudWxsICYmIChsID0gbyA9ICh0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KGUpLCBYcih0aGlzLCBlKSkpLCBhID09PSBsID8gbnVsbCA6IGEgPT09IHIgJiYgbCA9PT0gaSA/IHMgOiAoaSA9IGwsIHMgPSB0KHIgPSBhLCBvKSk7XG4gIH07XG59XG5mdW5jdGlvbiBLUyhlLCB0KSB7XG4gIHZhciBuLCByLCBpLCBzID0gXCJzdHlsZS5cIiArIHQsIGEgPSBcImVuZC5cIiArIHMsIG87XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbCA9IHNuKHRoaXMsIGUpLCBjID0gbC5vbiwgdSA9IGwudmFsdWVbc10gPT0gbnVsbCA/IG8gfHwgKG8gPSBibSh0KSkgOiB2b2lkIDA7XG4gICAgKGMgIT09IG4gfHwgaSAhPT0gdSkgJiYgKHIgPSAobiA9IGMpLmNvcHkoKSkub24oYSwgaSA9IHUpLCBsLm9uID0gcjtcbiAgfTtcbn1cbmZ1bmN0aW9uIFFTKGUsIHQsIG4pIHtcbiAgdmFyIHIgPSAoZSArPSBcIlwiKSA9PSBcInRyYW5zZm9ybVwiID8gblMgOiB4bTtcbiAgcmV0dXJuIHQgPT0gbnVsbCA/IHRoaXMuc3R5bGVUd2VlbihlLCBZUyhlLCByKSkub24oXCJlbmQuc3R5bGUuXCIgKyBlLCBibShlKSkgOiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLnN0eWxlVHdlZW4oZSwgWlMoZSwgciwgVWModGhpcywgXCJzdHlsZS5cIiArIGUsIHQpKSkuZWFjaChLUyh0aGlzLl9pZCwgZSkpIDogdGhpcy5zdHlsZVR3ZWVuKGUsIFhTKGUsIHIsIHQpLCBuKS5vbihcImVuZC5zdHlsZS5cIiArIGUsIG51bGwpO1xufVxuZnVuY3Rpb24gSlMoZSwgdCwgbikge1xuICByZXR1cm4gZnVuY3Rpb24ocikge1xuICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkoZSwgdC5jYWxsKHRoaXMsIHIpLCBuKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHRUKGUsIHQsIG4pIHtcbiAgdmFyIHIsIGk7XG4gIGZ1bmN0aW9uIHMoKSB7XG4gICAgdmFyIGEgPSB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGEgIT09IGkgJiYgKHIgPSAoaSA9IGEpICYmIEpTKGUsIGEsIG4pKSwgcjtcbiAgfVxuICByZXR1cm4gcy5fdmFsdWUgPSB0LCBzO1xufVxuZnVuY3Rpb24gZVQoZSwgdCwgbikge1xuICB2YXIgciA9IFwic3R5bGUuXCIgKyAoZSArPSBcIlwiKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gKHIgPSB0aGlzLnR3ZWVuKHIpKSAmJiByLl92YWx1ZTtcbiAgaWYgKHQgPT0gbnVsbCkgcmV0dXJuIHRoaXMudHdlZW4ociwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdCAhPSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcigpO1xuICByZXR1cm4gdGhpcy50d2VlbihyLCB0VChlLCB0LCBuID8/IFwiXCIpKTtcbn1cbmZ1bmN0aW9uIG5UKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSBlO1xuICB9O1xufVxuZnVuY3Rpb24gclQoZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSBlKHRoaXMpO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB0ID8/IFwiXCI7XG4gIH07XG59XG5mdW5jdGlvbiBpVChlKSB7XG4gIHJldHVybiB0aGlzLnR3ZWVuKFwidGV4dFwiLCB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyByVChVYyh0aGlzLCBcInRleHRcIiwgZSkpIDogblQoZSA9PSBudWxsID8gXCJcIiA6IGUgKyBcIlwiKSk7XG59XG5mdW5jdGlvbiBzVChlKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IGUuY2FsbCh0aGlzLCB0KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGFUKGUpIHtcbiAgdmFyIHQsIG47XG4gIGZ1bmN0aW9uIHIoKSB7XG4gICAgdmFyIGkgPSBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGkgIT09IG4gJiYgKHQgPSAobiA9IGkpICYmIHNUKGkpKSwgdDtcbiAgfVxuICByZXR1cm4gci5fdmFsdWUgPSBlLCByO1xufVxuZnVuY3Rpb24gb1QoZSkge1xuICB2YXIgdCA9IFwidGV4dFwiO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHJldHVybiAodCA9IHRoaXMudHdlZW4odCkpICYmIHQuX3ZhbHVlO1xuICBpZiAoZSA9PSBudWxsKSByZXR1cm4gdGhpcy50d2Vlbih0LCBudWxsKTtcbiAgaWYgKHR5cGVvZiBlICE9IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKCk7XG4gIHJldHVybiB0aGlzLnR3ZWVuKHQsIGFUKGUpKTtcbn1cbmZ1bmN0aW9uIGxUKCkge1xuICBmb3IgKHZhciBlID0gdGhpcy5fbmFtZSwgdCA9IHRoaXMuX2lkLCBuID0gX20oKSwgciA9IHRoaXMuX2dyb3VwcywgaSA9IHIubGVuZ3RoLCBzID0gMDsgcyA8IGk7ICsrcylcbiAgICBmb3IgKHZhciBhID0gcltzXSwgbyA9IGEubGVuZ3RoLCBsLCBjID0gMDsgYyA8IG87ICsrYylcbiAgICAgIGlmIChsID0gYVtjXSkge1xuICAgICAgICB2YXIgdSA9IHFlKGwsIHQpO1xuICAgICAgICBubyhsLCBlLCBuLCBjLCBhLCB7XG4gICAgICAgICAgdGltZTogdS50aW1lICsgdS5kZWxheSArIHUuZHVyYXRpb24sXG4gICAgICAgICAgZGVsYXk6IDAsXG4gICAgICAgICAgZHVyYXRpb246IHUuZHVyYXRpb24sXG4gICAgICAgICAgZWFzZTogdS5lYXNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICByZXR1cm4gbmV3IHduKHIsIHRoaXMuX3BhcmVudHMsIGUsIG4pO1xufVxuZnVuY3Rpb24gY1QoKSB7XG4gIHZhciBlLCB0LCBuID0gdGhpcywgciA9IG4uX2lkLCBpID0gbi5zaXplKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihzLCBhKSB7XG4gICAgdmFyIG8gPSB7IHZhbHVlOiBhIH0sIGwgPSB7IHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIC0taSA9PT0gMCAmJiBzKCk7XG4gICAgfSB9O1xuICAgIG4uZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjID0gc24odGhpcywgciksIHUgPSBjLm9uO1xuICAgICAgdSAhPT0gZSAmJiAodCA9IChlID0gdSkuY29weSgpLCB0Ll8uY2FuY2VsLnB1c2gobyksIHQuXy5pbnRlcnJ1cHQucHVzaChvKSwgdC5fLmVuZC5wdXNoKGwpKSwgYy5vbiA9IHQ7XG4gICAgfSksIGkgPT09IDAgJiYgcygpO1xuICB9KTtcbn1cbnZhciB1VCA9IDA7XG5mdW5jdGlvbiB3bihlLCB0LCBuLCByKSB7XG4gIHRoaXMuX2dyb3VwcyA9IGUsIHRoaXMuX3BhcmVudHMgPSB0LCB0aGlzLl9uYW1lID0gbiwgdGhpcy5faWQgPSByO1xufVxuZnVuY3Rpb24gX20oKSB7XG4gIHJldHVybiArK3VUO1xufVxudmFyIHVuID0gZHMucHJvdG90eXBlO1xud24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3Rvcjogd24sXG4gIHNlbGVjdDogRlMsXG4gIHNlbGVjdEFsbDogalMsXG4gIHNlbGVjdENoaWxkOiB1bi5zZWxlY3RDaGlsZCxcbiAgc2VsZWN0Q2hpbGRyZW46IHVuLnNlbGVjdENoaWxkcmVuLFxuICBmaWx0ZXI6IFBTLFxuICBtZXJnZTogVVMsXG4gIHNlbGVjdGlvbjogcVMsXG4gIHRyYW5zaXRpb246IGxULFxuICBjYWxsOiB1bi5jYWxsLFxuICBub2RlczogdW4ubm9kZXMsXG4gIG5vZGU6IHVuLm5vZGUsXG4gIHNpemU6IHVuLnNpemUsXG4gIGVtcHR5OiB1bi5lbXB0eSxcbiAgZWFjaDogdW4uZWFjaCxcbiAgb246IFZTLFxuICBhdHRyOiBfUyxcbiAgYXR0clR3ZWVuOiB3UyxcbiAgc3R5bGU6IFFTLFxuICBzdHlsZVR3ZWVuOiBlVCxcbiAgdGV4dDogaVQsXG4gIHRleHRUd2Vlbjogb1QsXG4gIHJlbW92ZTogelMsXG4gIHR3ZWVuOiBmUyxcbiAgZGVsYXk6IENTLFxuICBkdXJhdGlvbjoga1MsXG4gIGVhc2U6IFJTLFxuICBlYXNlVmFyeWluZzogTlMsXG4gIGVuZDogY1QsXG4gIFtTeW1ib2wuaXRlcmF0b3JdOiB1bltTeW1ib2wuaXRlcmF0b3JdXG59O1xuZnVuY3Rpb24gRW0oZSkge1xuICByZXR1cm4gKChlICo9IDIpIDw9IDEgPyBlICogZSAqIGUgOiAoZSAtPSAyKSAqIGUgKiBlICsgMikgLyAyO1xufVxudmFyIGhUID0ge1xuICB0aW1lOiBudWxsLFxuICAvLyBTZXQgb24gdXNlLlxuICBkZWxheTogMCxcbiAgZHVyYXRpb246IDI1MCxcbiAgZWFzZTogRW1cbn07XG5mdW5jdGlvbiBkVChlLCB0KSB7XG4gIGZvciAodmFyIG47ICEobiA9IGUuX190cmFuc2l0aW9uKSB8fCAhKG4gPSBuW3RdKTsgKVxuICAgIGlmICghKGUgPSBlLnBhcmVudE5vZGUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0cmFuc2l0aW9uICR7dH0gbm90IGZvdW5kYCk7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gcFQoZSkge1xuICB2YXIgdCwgbjtcbiAgZSBpbnN0YW5jZW9mIHduID8gKHQgPSBlLl9pZCwgZSA9IGUuX25hbWUpIDogKHQgPSBfbSgpLCAobiA9IGhUKS50aW1lID0gTmMoKSwgZSA9IGUgPT0gbnVsbCA/IG51bGwgOiBlICsgXCJcIik7XG4gIGZvciAodmFyIHIgPSB0aGlzLl9ncm91cHMsIGkgPSByLmxlbmd0aCwgcyA9IDA7IHMgPCBpOyArK3MpXG4gICAgZm9yICh2YXIgYSA9IHJbc10sIG8gPSBhLmxlbmd0aCwgbCwgYyA9IDA7IGMgPCBvOyArK2MpXG4gICAgICAobCA9IGFbY10pICYmIG5vKGwsIGUsIHQsIGMsIGEsIG4gfHwgZFQobCwgdCkpO1xuICByZXR1cm4gbmV3IHduKHIsIHRoaXMuX3BhcmVudHMsIGUsIHQpO1xufVxuZHMucHJvdG90eXBlLmludGVycnVwdCA9IGhTO1xuZHMucHJvdG90eXBlLnRyYW5zaXRpb24gPSBwVDtcbmZ1bmN0aW9uIGZUKGUpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGUgPSBNYXRoLnJvdW5kKGUpKSA+PSAxZTIxID8gZS50b0xvY2FsZVN0cmluZyhcImVuXCIpLnJlcGxhY2UoLywvZywgXCJcIikgOiBlLnRvU3RyaW5nKDEwKTtcbn1cbmZ1bmN0aW9uIHZhKGUsIHQpIHtcbiAgaWYgKChuID0gKGUgPSB0ID8gZS50b0V4cG9uZW50aWFsKHQgLSAxKSA6IGUudG9FeHBvbmVudGlhbCgpKS5pbmRleE9mKFwiZVwiKSkgPCAwKSByZXR1cm4gbnVsbDtcbiAgdmFyIG4sIHIgPSBlLnNsaWNlKDAsIG4pO1xuICByZXR1cm4gW1xuICAgIHIubGVuZ3RoID4gMSA/IHJbMF0gKyByLnNsaWNlKDIpIDogcixcbiAgICArZS5zbGljZShuICsgMSlcbiAgXTtcbn1cbmZ1bmN0aW9uIEtyKGUpIHtcbiAgcmV0dXJuIGUgPSB2YShNYXRoLmFicyhlKSksIGUgPyBlWzFdIDogTmFOO1xufVxuZnVuY3Rpb24gbVQoZSwgdCkge1xuICByZXR1cm4gZnVuY3Rpb24obiwgcikge1xuICAgIGZvciAodmFyIGkgPSBuLmxlbmd0aCwgcyA9IFtdLCBhID0gMCwgbyA9IGVbMF0sIGwgPSAwOyBpID4gMCAmJiBvID4gMCAmJiAobCArIG8gKyAxID4gciAmJiAobyA9IE1hdGgubWF4KDEsIHIgLSBsKSksIHMucHVzaChuLnN1YnN0cmluZyhpIC09IG8sIGkgKyBvKSksICEoKGwgKz0gbyArIDEpID4gcikpOyApXG4gICAgICBvID0gZVthID0gKGEgKyAxKSAlIGUubGVuZ3RoXTtcbiAgICByZXR1cm4gcy5yZXZlcnNlKCkuam9pbih0KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdUKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdC5yZXBsYWNlKC9bMC05XS9nLCBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4gZVsrbl07XG4gICAgfSk7XG4gIH07XG59XG52YXIgdlQgPSAvXig/OiguKT8oWzw+PV5dKSk/KFsrXFwtKCBdKT8oWyQjXSk/KDApPyhcXGQrKT8oLCk/KFxcLlxcZCspPyh+KT8oW2EteiVdKT8kL2k7XG5mdW5jdGlvbiB0cyhlKSB7XG4gIGlmICghKHQgPSB2VC5leGVjKGUpKSkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmb3JtYXQ6IFwiICsgZSk7XG4gIHZhciB0O1xuICByZXR1cm4gbmV3IEJjKHtcbiAgICBmaWxsOiB0WzFdLFxuICAgIGFsaWduOiB0WzJdLFxuICAgIHNpZ246IHRbM10sXG4gICAgc3ltYm9sOiB0WzRdLFxuICAgIHplcm86IHRbNV0sXG4gICAgd2lkdGg6IHRbNl0sXG4gICAgY29tbWE6IHRbN10sXG4gICAgcHJlY2lzaW9uOiB0WzhdICYmIHRbOF0uc2xpY2UoMSksXG4gICAgdHJpbTogdFs5XSxcbiAgICB0eXBlOiB0WzEwXVxuICB9KTtcbn1cbnRzLnByb3RvdHlwZSA9IEJjLnByb3RvdHlwZTtcbmZ1bmN0aW9uIEJjKGUpIHtcbiAgdGhpcy5maWxsID0gZS5maWxsID09PSB2b2lkIDAgPyBcIiBcIiA6IGUuZmlsbCArIFwiXCIsIHRoaXMuYWxpZ24gPSBlLmFsaWduID09PSB2b2lkIDAgPyBcIj5cIiA6IGUuYWxpZ24gKyBcIlwiLCB0aGlzLnNpZ24gPSBlLnNpZ24gPT09IHZvaWQgMCA/IFwiLVwiIDogZS5zaWduICsgXCJcIiwgdGhpcy5zeW1ib2wgPSBlLnN5bWJvbCA9PT0gdm9pZCAwID8gXCJcIiA6IGUuc3ltYm9sICsgXCJcIiwgdGhpcy56ZXJvID0gISFlLnplcm8sIHRoaXMud2lkdGggPSBlLndpZHRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiArZS53aWR0aCwgdGhpcy5jb21tYSA9ICEhZS5jb21tYSwgdGhpcy5wcmVjaXNpb24gPSBlLnByZWNpc2lvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogK2UucHJlY2lzaW9uLCB0aGlzLnRyaW0gPSAhIWUudHJpbSwgdGhpcy50eXBlID0gZS50eXBlID09PSB2b2lkIDAgPyBcIlwiIDogZS50eXBlICsgXCJcIjtcbn1cbkJjLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5maWxsICsgdGhpcy5hbGlnbiArIHRoaXMuc2lnbiArIHRoaXMuc3ltYm9sICsgKHRoaXMuemVybyA/IFwiMFwiIDogXCJcIikgKyAodGhpcy53aWR0aCA9PT0gdm9pZCAwID8gXCJcIiA6IE1hdGgubWF4KDEsIHRoaXMud2lkdGggfCAwKSkgKyAodGhpcy5jb21tYSA/IFwiLFwiIDogXCJcIikgKyAodGhpcy5wcmVjaXNpb24gPT09IHZvaWQgMCA/IFwiXCIgOiBcIi5cIiArIE1hdGgubWF4KDAsIHRoaXMucHJlY2lzaW9uIHwgMCkpICsgKHRoaXMudHJpbSA/IFwiflwiIDogXCJcIikgKyB0aGlzLnR5cGU7XG59O1xuZnVuY3Rpb24geVQoZSkge1xuICB0OiBmb3IgKHZhciB0ID0gZS5sZW5ndGgsIG4gPSAxLCByID0gLTEsIGk7IG4gPCB0OyArK24pXG4gICAgc3dpdGNoIChlW25dKSB7XG4gICAgICBjYXNlIFwiLlwiOlxuICAgICAgICByID0gaSA9IG47XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIjBcIjpcbiAgICAgICAgciA9PT0gMCAmJiAociA9IG4pLCBpID0gbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoIStlW25dKSBicmVhayB0O1xuICAgICAgICByID4gMCAmJiAociA9IDApO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiByID4gMCA/IGUuc2xpY2UoMCwgcikgKyBlLnNsaWNlKGkgKyAxKSA6IGU7XG59XG52YXIgT207XG5mdW5jdGlvbiB4VChlLCB0KSB7XG4gIHZhciBuID0gdmEoZSwgdCk7XG4gIGlmICghbikgcmV0dXJuIGUgKyBcIlwiO1xuICB2YXIgciA9IG5bMF0sIGkgPSBuWzFdLCBzID0gaSAtIChPbSA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGkgLyAzKSkpICogMykgKyAxLCBhID0gci5sZW5ndGg7XG4gIHJldHVybiBzID09PSBhID8gciA6IHMgPiBhID8gciArIG5ldyBBcnJheShzIC0gYSArIDEpLmpvaW4oXCIwXCIpIDogcyA+IDAgPyByLnNsaWNlKDAsIHMpICsgXCIuXCIgKyByLnNsaWNlKHMpIDogXCIwLlwiICsgbmV3IEFycmF5KDEgLSBzKS5qb2luKFwiMFwiKSArIHZhKGUsIE1hdGgubWF4KDAsIHQgKyBzIC0gMSkpWzBdO1xufVxuZnVuY3Rpb24gd2goZSwgdCkge1xuICB2YXIgbiA9IHZhKGUsIHQpO1xuICBpZiAoIW4pIHJldHVybiBlICsgXCJcIjtcbiAgdmFyIHIgPSBuWzBdLCBpID0gblsxXTtcbiAgcmV0dXJuIGkgPCAwID8gXCIwLlwiICsgbmV3IEFycmF5KC1pKS5qb2luKFwiMFwiKSArIHIgOiByLmxlbmd0aCA+IGkgKyAxID8gci5zbGljZSgwLCBpICsgMSkgKyBcIi5cIiArIHIuc2xpY2UoaSArIDEpIDogciArIG5ldyBBcnJheShpIC0gci5sZW5ndGggKyAyKS5qb2luKFwiMFwiKTtcbn1cbmNvbnN0ICRoID0ge1xuICBcIiVcIjogKGUsIHQpID0+IChlICogMTAwKS50b0ZpeGVkKHQpLFxuICBiOiAoZSkgPT4gTWF0aC5yb3VuZChlKS50b1N0cmluZygyKSxcbiAgYzogKGUpID0+IGUgKyBcIlwiLFxuICBkOiBmVCxcbiAgZTogKGUsIHQpID0+IGUudG9FeHBvbmVudGlhbCh0KSxcbiAgZjogKGUsIHQpID0+IGUudG9GaXhlZCh0KSxcbiAgZzogKGUsIHQpID0+IGUudG9QcmVjaXNpb24odCksXG4gIG86IChlKSA9PiBNYXRoLnJvdW5kKGUpLnRvU3RyaW5nKDgpLFxuICBwOiAoZSwgdCkgPT4gd2goZSAqIDEwMCwgdCksXG4gIHI6IHdoLFxuICBzOiB4VCxcbiAgWDogKGUpID0+IE1hdGgucm91bmQoZSkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCksXG4gIHg6IChlKSA9PiBNYXRoLnJvdW5kKGUpLnRvU3RyaW5nKDE2KVxufTtcbmZ1bmN0aW9uIE1oKGUpIHtcbiAgcmV0dXJuIGU7XG59XG52YXIgQ2ggPSBBcnJheS5wcm90b3R5cGUubWFwLCBBaCA9IFtcInlcIiwgXCJ6XCIsIFwiYVwiLCBcImZcIiwgXCJwXCIsIFwiblwiLCBcIsK1XCIsIFwibVwiLCBcIlwiLCBcImtcIiwgXCJNXCIsIFwiR1wiLCBcIlRcIiwgXCJQXCIsIFwiRVwiLCBcIlpcIiwgXCJZXCJdO1xuZnVuY3Rpb24gYlQoZSkge1xuICB2YXIgdCA9IGUuZ3JvdXBpbmcgPT09IHZvaWQgMCB8fCBlLnRob3VzYW5kcyA9PT0gdm9pZCAwID8gTWggOiBtVChDaC5jYWxsKGUuZ3JvdXBpbmcsIE51bWJlciksIGUudGhvdXNhbmRzICsgXCJcIiksIG4gPSBlLmN1cnJlbmN5ID09PSB2b2lkIDAgPyBcIlwiIDogZS5jdXJyZW5jeVswXSArIFwiXCIsIHIgPSBlLmN1cnJlbmN5ID09PSB2b2lkIDAgPyBcIlwiIDogZS5jdXJyZW5jeVsxXSArIFwiXCIsIGkgPSBlLmRlY2ltYWwgPT09IHZvaWQgMCA/IFwiLlwiIDogZS5kZWNpbWFsICsgXCJcIiwgcyA9IGUubnVtZXJhbHMgPT09IHZvaWQgMCA/IE1oIDogZ1QoQ2guY2FsbChlLm51bWVyYWxzLCBTdHJpbmcpKSwgYSA9IGUucGVyY2VudCA9PT0gdm9pZCAwID8gXCIlXCIgOiBlLnBlcmNlbnQgKyBcIlwiLCBvID0gZS5taW51cyA9PT0gdm9pZCAwID8gXCLiiJJcIiA6IGUubWludXMgKyBcIlwiLCBsID0gZS5uYW4gPT09IHZvaWQgMCA/IFwiTmFOXCIgOiBlLm5hbiArIFwiXCI7XG4gIGZ1bmN0aW9uIGMoZCkge1xuICAgIGQgPSB0cyhkKTtcbiAgICB2YXIgaCA9IGQuZmlsbCwgcCA9IGQuYWxpZ24sIGYgPSBkLnNpZ24sIGcgPSBkLnN5bWJvbCwgbSA9IGQuemVybywgdiA9IGQud2lkdGgsIHggPSBkLmNvbW1hLCBfID0gZC5wcmVjaXNpb24sIEUgPSBkLnRyaW0sIGIgPSBkLnR5cGU7XG4gICAgYiA9PT0gXCJuXCIgPyAoeCA9ICEwLCBiID0gXCJnXCIpIDogJGhbYl0gfHwgKF8gPT09IHZvaWQgMCAmJiAoXyA9IDEyKSwgRSA9ICEwLCBiID0gXCJnXCIpLCAobSB8fCBoID09PSBcIjBcIiAmJiBwID09PSBcIj1cIikgJiYgKG0gPSAhMCwgaCA9IFwiMFwiLCBwID0gXCI9XCIpO1xuICAgIHZhciBTID0gZyA9PT0gXCIkXCIgPyBuIDogZyA9PT0gXCIjXCIgJiYgL1tib3hYXS8udGVzdChiKSA/IFwiMFwiICsgYi50b0xvd2VyQ2FzZSgpIDogXCJcIiwgTSA9IGcgPT09IFwiJFwiID8gciA6IC9bJXBdLy50ZXN0KGIpID8gYSA6IFwiXCIsIEQgPSAkaFtiXSwgQSA9IC9bZGVmZ3BycyVdLy50ZXN0KGIpO1xuICAgIF8gPSBfID09PSB2b2lkIDAgPyA2IDogL1tncHJzXS8udGVzdChiKSA/IE1hdGgubWF4KDEsIE1hdGgubWluKDIxLCBfKSkgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigyMCwgXykpO1xuICAgIGZ1bmN0aW9uIFIoJCkge1xuICAgICAgdmFyIEggPSBTLCBQID0gTSwgQiwgTywgdztcbiAgICAgIGlmIChiID09PSBcImNcIilcbiAgICAgICAgUCA9IEQoJCkgKyBQLCAkID0gXCJcIjtcbiAgICAgIGVsc2Uge1xuICAgICAgICAkID0gKyQ7XG4gICAgICAgIHZhciBMID0gJCA8IDAgfHwgMSAvICQgPCAwO1xuICAgICAgICBpZiAoJCA9IGlzTmFOKCQpID8gbCA6IEQoTWF0aC5hYnMoJCksIF8pLCBFICYmICgkID0geVQoJCkpLCBMICYmICskID09IDAgJiYgZiAhPT0gXCIrXCIgJiYgKEwgPSAhMSksIEggPSAoTCA/IGYgPT09IFwiKFwiID8gZiA6IG8gOiBmID09PSBcIi1cIiB8fCBmID09PSBcIihcIiA/IFwiXCIgOiBmKSArIEgsIFAgPSAoYiA9PT0gXCJzXCIgPyBBaFs4ICsgT20gLyAzXSA6IFwiXCIpICsgUCArIChMICYmIGYgPT09IFwiKFwiID8gXCIpXCIgOiBcIlwiKSwgQSkge1xuICAgICAgICAgIGZvciAoQiA9IC0xLCBPID0gJC5sZW5ndGg7ICsrQiA8IE87IClcbiAgICAgICAgICAgIGlmICh3ID0gJC5jaGFyQ29kZUF0KEIpLCA0OCA+IHcgfHwgdyA+IDU3KSB7XG4gICAgICAgICAgICAgIFAgPSAodyA9PT0gNDYgPyBpICsgJC5zbGljZShCICsgMSkgOiAkLnNsaWNlKEIpKSArIFAsICQgPSAkLnNsaWNlKDAsIEIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgeCAmJiAhbSAmJiAoJCA9IHQoJCwgMSAvIDApKTtcbiAgICAgIHZhciBrID0gSC5sZW5ndGggKyAkLmxlbmd0aCArIFAubGVuZ3RoLCBVID0gayA8IHYgPyBuZXcgQXJyYXkodiAtIGsgKyAxKS5qb2luKGgpIDogXCJcIjtcbiAgICAgIHN3aXRjaCAoeCAmJiBtICYmICgkID0gdChVICsgJCwgVS5sZW5ndGggPyB2IC0gUC5sZW5ndGggOiAxIC8gMCksIFUgPSBcIlwiKSwgcCkge1xuICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgICQgPSBIICsgJCArIFAgKyBVO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiPVwiOlxuICAgICAgICAgICQgPSBIICsgVSArICQgKyBQO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiXlwiOlxuICAgICAgICAgICQgPSBVLnNsaWNlKDAsIGsgPSBVLmxlbmd0aCA+PiAxKSArIEggKyAkICsgUCArIFUuc2xpY2Uoayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgJCA9IFUgKyBIICsgJCArIFA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gcygkKTtcbiAgICB9XG4gICAgcmV0dXJuIFIudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkICsgXCJcIjtcbiAgICB9LCBSO1xuICB9XG4gIGZ1bmN0aW9uIHUoZCwgaCkge1xuICAgIHZhciBwID0gYygoZCA9IHRzKGQpLCBkLnR5cGUgPSBcImZcIiwgZCkpLCBmID0gTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoS3IoaCkgLyAzKSkpICogMywgZyA9IE1hdGgucG93KDEwLCAtZiksIG0gPSBBaFs4ICsgZiAvIDNdO1xuICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gcChnICogdikgKyBtO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmb3JtYXQ6IGMsXG4gICAgZm9ybWF0UHJlZml4OiB1XG4gIH07XG59XG52YXIgQ3MsIEhjLCBTbTtcbl9UKHtcbiAgdGhvdXNhbmRzOiBcIixcIixcbiAgZ3JvdXBpbmc6IFszXSxcbiAgY3VycmVuY3k6IFtcIiRcIiwgXCJcIl1cbn0pO1xuZnVuY3Rpb24gX1QoZSkge1xuICByZXR1cm4gQ3MgPSBiVChlKSwgSGMgPSBDcy5mb3JtYXQsIFNtID0gQ3MuZm9ybWF0UHJlZml4LCBDcztcbn1cbmZ1bmN0aW9uIEVUKGUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIC1LcihNYXRoLmFicyhlKSkpO1xufVxuZnVuY3Rpb24gT1QoZSwgdCkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoS3IodCkgLyAzKSkpICogMyAtIEtyKE1hdGguYWJzKGUpKSk7XG59XG5mdW5jdGlvbiBTVChlLCB0KSB7XG4gIHJldHVybiBlID0gTWF0aC5hYnMoZSksIHQgPSBNYXRoLmFicyh0KSAtIGUsIE1hdGgubWF4KDAsIEtyKHQpIC0gS3IoZSkpICsgMTtcbn1cbmZ1bmN0aW9uIGlpKGUsIHQpIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgdGhpcy5yYW5nZShlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLnJhbmdlKHQpLmRvbWFpbihlKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuY29uc3QgTGggPSBTeW1ib2woXCJpbXBsaWNpdFwiKTtcbmZ1bmN0aW9uIHJvKCkge1xuICB2YXIgZSA9IG5ldyBjaCgpLCB0ID0gW10sIG4gPSBbXSwgciA9IExoO1xuICBmdW5jdGlvbiBpKHMpIHtcbiAgICBsZXQgYSA9IGUuZ2V0KHMpO1xuICAgIGlmIChhID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChyICE9PSBMaCkgcmV0dXJuIHI7XG4gICAgICBlLnNldChzLCBhID0gdC5wdXNoKHMpIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiBuW2EgJSBuLmxlbmd0aF07XG4gIH1cbiAgcmV0dXJuIGkuZG9tYWluID0gZnVuY3Rpb24ocykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHQuc2xpY2UoKTtcbiAgICB0ID0gW10sIGUgPSBuZXcgY2goKTtcbiAgICBmb3IgKGNvbnN0IGEgb2YgcylcbiAgICAgIGUuaGFzKGEpIHx8IGUuc2V0KGEsIHQucHVzaChhKSAtIDEpO1xuICAgIHJldHVybiBpO1xuICB9LCBpLnJhbmdlID0gZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4gPSBBcnJheS5mcm9tKHMpLCBpKSA6IG4uc2xpY2UoKTtcbiAgfSwgaS51bmtub3duID0gZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHIgPSBzLCBpKSA6IHI7XG4gIH0sIGkuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBybyh0LCBuKS51bmtub3duKHIpO1xuICB9LCBpaS5hcHBseShpLCBhcmd1bWVudHMpLCBpO1xufVxuZnVuY3Rpb24gVFQoZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGU7XG4gIH07XG59XG5mdW5jdGlvbiB3VChlKSB7XG4gIHJldHVybiArZTtcbn1cbnZhciBraCA9IFswLCAxXTtcbmZ1bmN0aW9uIElyKGUpIHtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBBbChlLCB0KSB7XG4gIHJldHVybiAodCAtPSBlID0gK2UpID8gZnVuY3Rpb24obikge1xuICAgIHJldHVybiAobiAtIGUpIC8gdDtcbiAgfSA6IFRUKGlzTmFOKHQpID8gTmFOIDogMC41KTtcbn1cbmZ1bmN0aW9uICRUKGUsIHQpIHtcbiAgdmFyIG47XG4gIHJldHVybiBlID4gdCAmJiAobiA9IGUsIGUgPSB0LCB0ID0gbiksIGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoZSwgTWF0aC5taW4odCwgcikpO1xuICB9O1xufVxuZnVuY3Rpb24gTVQoZSwgdCwgbikge1xuICB2YXIgciA9IGVbMF0sIGkgPSBlWzFdLCBzID0gdFswXSwgYSA9IHRbMV07XG4gIHJldHVybiBpIDwgciA/IChyID0gQWwoaSwgciksIHMgPSBuKGEsIHMpKSA6IChyID0gQWwociwgaSksIHMgPSBuKHMsIGEpKSwgZnVuY3Rpb24obykge1xuICAgIHJldHVybiBzKHIobykpO1xuICB9O1xufVxuZnVuY3Rpb24gQ1QoZSwgdCwgbikge1xuICB2YXIgciA9IE1hdGgubWluKGUubGVuZ3RoLCB0Lmxlbmd0aCkgLSAxLCBpID0gbmV3IEFycmF5KHIpLCBzID0gbmV3IEFycmF5KHIpLCBhID0gLTE7XG4gIGZvciAoZVtyXSA8IGVbMF0gJiYgKGUgPSBlLnNsaWNlKCkucmV2ZXJzZSgpLCB0ID0gdC5zbGljZSgpLnJldmVyc2UoKSk7ICsrYSA8IHI7IClcbiAgICBpW2FdID0gQWwoZVthXSwgZVthICsgMV0pLCBzW2FdID0gbih0W2FdLCB0W2EgKyAxXSk7XG4gIHJldHVybiBmdW5jdGlvbihvKSB7XG4gICAgdmFyIGwgPSBBYyhlLCBvLCAxLCByKSAtIDE7XG4gICAgcmV0dXJuIHNbbF0oaVtsXShvKSk7XG4gIH07XG59XG5mdW5jdGlvbiBWYyhlLCB0KSB7XG4gIHJldHVybiB0LmRvbWFpbihlLmRvbWFpbigpKS5yYW5nZShlLnJhbmdlKCkpLmludGVycG9sYXRlKGUuaW50ZXJwb2xhdGUoKSkuY2xhbXAoZS5jbGFtcCgpKS51bmtub3duKGUudW5rbm93bigpKTtcbn1cbmZ1bmN0aW9uIFRtKCkge1xuICB2YXIgZSA9IGtoLCB0ID0ga2gsIG4gPSBmcywgciwgaSwgcywgYSA9IElyLCBvLCBsLCBjO1xuICBmdW5jdGlvbiB1KCkge1xuICAgIHZhciBoID0gTWF0aC5taW4oZS5sZW5ndGgsIHQubGVuZ3RoKTtcbiAgICByZXR1cm4gYSAhPT0gSXIgJiYgKGEgPSAkVChlWzBdLCBlW2ggLSAxXSkpLCBvID0gaCA+IDIgPyBDVCA6IE1ULCBsID0gYyA9IG51bGwsIGQ7XG4gIH1cbiAgZnVuY3Rpb24gZChoKSB7XG4gICAgcmV0dXJuIGggPT0gbnVsbCB8fCBpc05hTihoID0gK2gpID8gcyA6IChsIHx8IChsID0gbyhlLm1hcChyKSwgdCwgbikpKShyKGEoaCkpKTtcbiAgfVxuICByZXR1cm4gZC5pbnZlcnQgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIGEoaSgoYyB8fCAoYyA9IG8odCwgZS5tYXAociksIHhlKSkpKGgpKSk7XG4gIH0sIGQuZG9tYWluID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGUgPSBBcnJheS5mcm9tKGgsIHdUKSwgdSgpKSA6IGUuc2xpY2UoKTtcbiAgfSwgZC5yYW5nZSA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0ID0gQXJyYXkuZnJvbShoKSwgdSgpKSA6IHQuc2xpY2UoKTtcbiAgfSwgZC5yYW5nZVJvdW5kID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiB0ID0gQXJyYXkuZnJvbShoKSwgbiA9IGhtLCB1KCk7XG4gIH0sIGQuY2xhbXAgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYSA9IGggPyAhMCA6IElyLCB1KCkpIDogYSAhPT0gSXI7XG4gIH0sIGQuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9IGgsIHUoKSkgOiBuO1xuICB9LCBkLnVua25vd24gPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocyA9IGgsIGQpIDogcztcbiAgfSwgZnVuY3Rpb24oaCwgcCkge1xuICAgIHJldHVybiByID0gaCwgaSA9IHAsIHUoKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHdtKCkge1xuICByZXR1cm4gVG0oKShJciwgSXIpO1xufVxuZnVuY3Rpb24gQVQoZSwgdCwgbiwgcikge1xuICB2YXIgaSA9IEVsKGUsIHQsIG4pLCBzO1xuICBzd2l0Y2ggKHIgPSB0cyhyID8/IFwiLGZcIiksIHIudHlwZSkge1xuICAgIGNhc2UgXCJzXCI6IHtcbiAgICAgIHZhciBhID0gTWF0aC5tYXgoTWF0aC5hYnMoZSksIE1hdGguYWJzKHQpKTtcbiAgICAgIHJldHVybiByLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihzID0gT1QoaSwgYSkpICYmIChyLnByZWNpc2lvbiA9IHMpLCBTbShyLCBhKTtcbiAgICB9XG4gICAgY2FzZSBcIlwiOlxuICAgIGNhc2UgXCJlXCI6XG4gICAgY2FzZSBcImdcIjpcbiAgICBjYXNlIFwicFwiOlxuICAgIGNhc2UgXCJyXCI6IHtcbiAgICAgIHIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHMgPSBTVChpLCBNYXRoLm1heChNYXRoLmFicyhlKSwgTWF0aC5hYnModCkpKSkgJiYgKHIucHJlY2lzaW9uID0gcyAtIChyLnR5cGUgPT09IFwiZVwiKSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImZcIjpcbiAgICBjYXNlIFwiJVwiOiB7XG4gICAgICByLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihzID0gRVQoaSkpICYmIChyLnByZWNpc2lvbiA9IHMgLSAoci50eXBlID09PSBcIiVcIikgKiAyKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gSGMocik7XG59XG5mdW5jdGlvbiAkbShlKSB7XG4gIHZhciB0ID0gZS5kb21haW47XG4gIHJldHVybiBlLnRpY2tzID0gZnVuY3Rpb24obikge1xuICAgIHZhciByID0gdCgpO1xuICAgIHJldHVybiBjYShyWzBdLCByW3IubGVuZ3RoIC0gMV0sIG4gPz8gMTApO1xuICB9LCBlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihuLCByKSB7XG4gICAgdmFyIGkgPSB0KCk7XG4gICAgcmV0dXJuIEFUKGlbMF0sIGlbaS5sZW5ndGggLSAxXSwgbiA/PyAxMCwgcik7XG4gIH0sIGUubmljZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICBuID09IG51bGwgJiYgKG4gPSAxMCk7XG4gICAgdmFyIHIgPSB0KCksIGkgPSAwLCBzID0gci5sZW5ndGggLSAxLCBhID0gcltpXSwgbyA9IHJbc10sIGwsIGMsIHUgPSAxMDtcbiAgICBmb3IgKG8gPCBhICYmIChjID0gYSwgYSA9IG8sIG8gPSBjLCBjID0gaSwgaSA9IHMsIHMgPSBjKTsgdS0tID4gMDsgKSB7XG4gICAgICBpZiAoYyA9IFlyKGEsIG8sIG4pLCBjID09PSBsKVxuICAgICAgICByZXR1cm4gcltpXSA9IGEsIHJbc10gPSBvLCB0KHIpO1xuICAgICAgaWYgKGMgPiAwKVxuICAgICAgICBhID0gTWF0aC5mbG9vcihhIC8gYykgKiBjLCBvID0gTWF0aC5jZWlsKG8gLyBjKSAqIGM7XG4gICAgICBlbHNlIGlmIChjIDwgMClcbiAgICAgICAgYSA9IE1hdGguY2VpbChhICogYykgLyBjLCBvID0gTWF0aC5mbG9vcihvICogYykgLyBjO1xuICAgICAgZWxzZVxuICAgICAgICBicmVhaztcbiAgICAgIGwgPSBjO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSwgZTtcbn1cbmZ1bmN0aW9uIEZlKCkge1xuICB2YXIgZSA9IHdtKCk7XG4gIHJldHVybiBlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gVmMoZSwgRmUoKSk7XG4gIH0sIGlpLmFwcGx5KGUsIGFyZ3VtZW50cyksICRtKGUpO1xufVxuZnVuY3Rpb24gR2MoKSB7XG4gIHZhciBlID0gMCwgdCA9IDEsIG4gPSAxLCByID0gWzAuNV0sIGkgPSBbMCwgMV0sIHM7XG4gIGZ1bmN0aW9uIGEobCkge1xuICAgIHJldHVybiBsICE9IG51bGwgJiYgbCA8PSBsID8gaVtBYyhyLCBsLCAwLCBuKV0gOiBzO1xuICB9XG4gIGZ1bmN0aW9uIG8oKSB7XG4gICAgdmFyIGwgPSAtMTtcbiAgICBmb3IgKHIgPSBuZXcgQXJyYXkobik7ICsrbCA8IG47ICkgcltsXSA9ICgobCArIDEpICogdCAtIChsIC0gbikgKiBlKSAvIChuICsgMSk7XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgcmV0dXJuIGEuZG9tYWluID0gZnVuY3Rpb24obCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKFtlLCB0XSA9IGwsIGUgPSArZSwgdCA9ICt0LCBvKCkpIDogW2UsIHRdO1xuICB9LCBhLnJhbmdlID0gZnVuY3Rpb24obCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4gPSAoaSA9IEFycmF5LmZyb20obCkpLmxlbmd0aCAtIDEsIG8oKSkgOiBpLnNsaWNlKCk7XG4gIH0sIGEuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24obCkge1xuICAgIHZhciBjID0gaS5pbmRleE9mKGwpO1xuICAgIHJldHVybiBjIDwgMCA/IFtOYU4sIE5hTl0gOiBjIDwgMSA/IFtlLCByWzBdXSA6IGMgPj0gbiA/IFtyW24gLSAxXSwgdF0gOiBbcltjIC0gMV0sIHJbY11dO1xuICB9LCBhLnVua25vd24gPSBmdW5jdGlvbihsKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggJiYgKHMgPSBsKSwgYTtcbiAgfSwgYS50aHJlc2hvbGRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHIuc2xpY2UoKTtcbiAgfSwgYS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEdjKCkuZG9tYWluKFtlLCB0XSkucmFuZ2UoaSkudW5rbm93bihzKTtcbiAgfSwgaWkuYXBwbHkoJG0oYSksIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiAkaShlLCB0LCBuKSB7XG4gIHRoaXMuayA9IGUsIHRoaXMueCA9IHQsIHRoaXMueSA9IG47XG59XG4kaS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiAkaSxcbiAgc2NhbGU6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gZSA9PT0gMSA/IHRoaXMgOiBuZXcgJGkodGhpcy5rICogZSwgdGhpcy54LCB0aGlzLnkpO1xuICB9LFxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICByZXR1cm4gZSA9PT0gMCAmIHQgPT09IDAgPyB0aGlzIDogbmV3ICRpKHRoaXMuaywgdGhpcy54ICsgdGhpcy5rICogZSwgdGhpcy55ICsgdGhpcy5rICogdCk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIFtlWzBdICogdGhpcy5rICsgdGhpcy54LCBlWzFdICogdGhpcy5rICsgdGhpcy55XTtcbiAgfSxcbiAgYXBwbHlYOiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIGUgKiB0aGlzLmsgKyB0aGlzLng7XG4gIH0sXG4gIGFwcGx5WTogZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBlICogdGhpcy5rICsgdGhpcy55O1xuICB9LFxuICBpbnZlcnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gWyhlWzBdIC0gdGhpcy54KSAvIHRoaXMuaywgKGVbMV0gLSB0aGlzLnkpIC8gdGhpcy5rXTtcbiAgfSxcbiAgaW52ZXJ0WDogZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiAoZSAtIHRoaXMueCkgLyB0aGlzLms7XG4gIH0sXG4gIGludmVydFk6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gKGUgLSB0aGlzLnkpIC8gdGhpcy5rO1xuICB9LFxuICByZXNjYWxlWDogZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBlLmNvcHkoKS5kb21haW4oZS5yYW5nZSgpLm1hcCh0aGlzLmludmVydFgsIHRoaXMpLm1hcChlLmludmVydCwgZSkpO1xuICB9LFxuICByZXNjYWxlWTogZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBlLmNvcHkoKS5kb21haW4oZS5yYW5nZSgpLm1hcCh0aGlzLmludmVydFksIHRoaXMpLm1hcChlLmludmVydCwgZSkpO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgdGhpcy54ICsgXCIsXCIgKyB0aGlzLnkgKyBcIikgc2NhbGUoXCIgKyB0aGlzLmsgKyBcIilcIjtcbiAgfVxufTtcbiRpLnByb3RvdHlwZTtcbmNvbnN0IHVlID0gXCJjZHNcIiwgeW4gPSB7XG4gIG9wYWNpdHk6IHtcbiAgICB1bnNlbGVjdGVkOiAwLjA1LFxuICAgIHNlbGVjdGVkOiAwLjRcbiAgfVxufSwgUG4gPSB7XG4gIHRpY2tzOiB7XG4gICAgbnVtYmVyOiA3LFxuICAgIHZlcnRpY2FsU3BhY2VSYXRpbzogMi41LFxuICAgIGhvcml6b250YWxTcGFjZVJhdGlvOiAzLjVcbiAgfSxcbiAgcmF0aW86IHtcbiAgICByZWZlcmVuY2U6IFwidmFsdWVcIixcbiAgICBjb21wYXJlVG86IFwibWFya2VyXCJcbiAgfSxcbiAgcGFkZGluZ1JhdGlvOiAwLjEsXG4gIGhvdmVyOiB7XG4gICAgcmVjdGFuZ2xlUGFkZGluZzogNFxuICB9XG59LCBOciA9IHtcbiAgZHVyYXRpb246IDFlMyxcbiAgZWFzZTogRW0sXG4gIHpvb21MZXZlbDogM1xufSwgQ3IgPSB7XG4gIGNpcmNsZXM6IHtcbiAgICBmaWxsT3BhY2l0eTogMC4zLFxuICAgIGhvdmVyOiB7XG4gICAgICBzdHJva2U6IFwiI0ZGRlwiXG4gICAgfVxuICB9LFxuICBwYWRkaW5nOiB7XG4gICAgbWFpbkdyb3VwOiA0LFxuICAgIGNoaWxkcmVuOiAyXG4gIH0sXG4gIGRlcHRoOiAyXG59LCBNbSA9IHtcbiAgcGFpcmluZ09wdGlvbnM6IHtcbiAgICBcIjEtY29sb3JcIjogNCxcbiAgICBcIjItY29sb3JcIjogNSxcbiAgICBcIjMtY29sb3JcIjogNSxcbiAgICBcIjQtY29sb3JcIjogMyxcbiAgICBcIjUtY29sb3JcIjogMixcbiAgICBcIjE0LWNvbG9yXCI6IDFcbiAgfVxufSwgVGUgPSB7XG4gIGNpcmNsZToge1xuICAgIHJhZGl1czogNCxcbiAgICBvcGFjaXR5OiB7XG4gICAgICBob3ZlcmVkOiAxLFxuICAgICAgZGVmYXVsdDogMC4zXG4gICAgfVxuICB9LFxuICBib3g6IHtcbiAgICBvcGFjaXR5OiB7XG4gICAgICBob3ZlcmVkOiAwLjUsXG4gICAgICBkZWZhdWx0OiAwLjNcbiAgICB9XG4gIH0sXG4gIHN0cm9rZVdpZHRoOiB7XG4gICAgZGVmYXVsdDogMSxcbiAgICB0aGlja2VyOiAyXG4gIH1cbn0sIExUID0ge1xuICBkZWZhdWx0QmluczogMTBcbn0sIEl0ID0ge1xuICBpdGVtczoge1xuICAgIHN0YXR1czoge1xuICAgICAgQUNUSVZFOiAxLFxuICAgICAgRElTQUJMRUQ6IDBcbiAgICB9LFxuICAgIGhvcml6b250YWxTcGFjZTogMTIsXG4gICAgdmVydGljYWxTcGFjZTogMjQsXG4gICAgdGV4dFlPZmZzZXQ6IDgsXG4gICAgc3BhY2VBZnRlcjogNFxuICB9LFxuICBjaGVja2JveDoge1xuICAgIHJhZGl1czogNi41XG4gIH0sXG4gIHJhZGl1czoge1xuICAgIGljb25EYXRhOiBbXG4gICAgICB7IGN4OiA3LCBjeTogNywgcjogNi41IH0sXG4gICAgICB7IGN4OiA3LCBjeTogMTAsIHI6IDMuNSB9XG4gICAgXSxcbiAgICBmaWxsOiBudWxsLFxuICAgIHN0cm9rZTogXCIjOGM4YzhjXCJcbiAgfSxcbiAgbGluZToge1xuICAgIHlQb3NpdGlvbjogNixcbiAgICB3aWR0aDogMjQsXG4gICAgc3Ryb2tlV2lkdGg6IDEuNCxcbiAgICBmaWxsOiBudWxsLFxuICAgIHN0cm9rZTogXCIjOTk5OTk5XCJcbiAgfSxcbiAgYXJlYToge1xuICAgIHdpZHRoOiAyNCxcbiAgICBoZWlnaHQ6IDE0LFxuICAgIGZpbGw6IFwiIzZmNmY2ZlwiLFxuICAgIHN0cm9rZTogbnVsbFxuICB9LFxuICBzaXplOiB7XG4gICAgaWNvbkRhdGE6IFtcbiAgICAgIHsgd2lkdGg6IDIzLCBoZWlnaHQ6IDEyIH0sXG4gICAgICB7IHdpZHRoOiAxMywgaGVpZ2h0OiA2IH1cbiAgICBdLFxuICAgIGZpbGw6IG51bGwsXG4gICAgc3Ryb2tlOiBcIiM4RDhEOERcIlxuICB9LFxuICBxdWFydGlsZToge1xuICAgIGljb25EYXRhOiBbXG4gICAgICB7IHg6IDAsIHk6IDAsIHdpZHRoOiAyNCwgaGVpZ2h0OiAxMyB9LFxuICAgICAgeyB4OiAxMSwgeTogNCwgd2lkdGg6IDEsIGhlaWdodDogNCB9XG4gICAgXVxuICB9LFxuICB6b29tOiB7XG4gICAgaWNvbkRhdGE6IFt7IHg6IDAsIHk6IDAsIHdpZHRoOiAxMiwgaGVpZ2h0OiAxMiB9XSxcbiAgICBjb2xvcjogXCIjOEQ4RDhEXCJcbiAgfSxcbiAgY29sb3I6IHtcbiAgICBiYXJXaWR0aDogMzAwLFxuICAgIGJhckhlaWdodDogOCxcbiAgICBheGlzWVRyYW5zbGF0aW9uOiAxMFxuICB9XG59LCB2biA9IHtcbiAgb3BhY2l0eToge1xuICAgIHVuc2VsZWN0ZWQ6IDAuMyxcbiAgICBzZWxlY3RlZDogMVxuICB9LFxuICB3ZWlnaHQ6IHtcbiAgICBzZWxlY3RlZDogMixcbiAgICB1bnNlbGVjdGVkOiAxXG4gIH1cbn0sIFp0ID0ge1xuICBzdGF0dXNCYXI6IHtcbiAgICBwYWRkaW5nUmlnaHQ6IDVcbiAgfSxcbiAgc3RhdHVzOiB7XG4gICAgaW5kaWNhdG9yU2l6ZTogMTYsXG4gICAgcGFkZGluZ0xlZnQ6IDE1XG4gIH0sXG4gIHRvdGFsOiB7XG4gICAgcGFkZGluZ0xlZnQ6IDM2LFxuICAgIHBhZGRpbmdSaWdodDogMjRcbiAgfSxcbiAgaGVpZ2h0OiB7XG4gICAgZGVmYXVsdDogOCxcbiAgICBwcm9wb3J0aW9uYWw6IDE2XG4gIH0sXG4gIGRpdmlkZXJXaWR0aDogMlxufSwgTXQgPSB7XG4gIHJhZGl1c09mZnNldDogLTE1LFxuICBpbm5lclJhZGl1czogMixcbiAgcGFkQW5nbGU6IDdlLTMsXG4gIGhvdmVyQXJjOiB7XG4gICAgb3V0ZXJSYWRpdXNPZmZzZXQ6IDNcbiAgfSxcbiAgeE9mZnNldDogMzAsXG4gIHlPZmZzZXQ6IDIwLFxuICB5T2Zmc2V0Q2FsbG91dDogMTAsXG4gIGNhbGxvdXQ6IHtcbiAgICBtaW5TbGljZURlZ3JlZTogNSxcbiAgICBvZmZzZXRYOiAxNSxcbiAgICBvZmZzZXRZOiAxMixcbiAgICBob3Jpem9udGFsTGluZUxlbmd0aDogOCxcbiAgICB0ZXh0TWFyZ2luOiAyXG4gIH1cbn0sIFduID0ge1xuICBvcGFjaXR5OiB7XG4gICAgdW5zZWxlY3RlZDogMC4xLFxuICAgIHNlbGVjdGVkOiAwLjNcbiAgfSxcbiAgeExhYmVsUGFkZGluZzogMTAsXG4gIHlMYWJlbFBhZGRpbmc6IDgsXG4gIHlUaWNrc051bWJlcjogNCxcbiAgbWluUmFuZ2U6IDEwLFxuICB4QXhpc1JlY3RIZWlnaHQ6IDUwLFxuICBkb3RzUmFkaXVzOiA1XG59LCBQZSA9IHtcbiAgbm9kZVdpZHRoOiA0LFxuICBtaW5Ob2RlUGFkZGluZzogMjQsXG4gIG9wYWNpdHk6IHtcbiAgICB1bmZvY3VzOiAwLjMsXG4gICAgZGVmYXVsdDogMC44LFxuICAgIHNlbGVjdGVkOiAxXG4gIH1cbn0sIERoID0ge1xuICBtaW5DZWxsRGl2aWRlckRpbWVuc2lvbjogMTZcbn0sIFJoID0ge1xuICBkZWZhdWx0OiB7XG4gICAgc2l6ZTogMjRcbiAgfVxufSwgSWggPSB7XG4gIGRlZmF1bHRPZmZzZXQ6IDQsXG4gIGhvcml6b250YWxPZmZzZXQ6IDEwXG59LCBOaCA9IHtcbiAgZGVmYXVsdDoge1xuICAgIGR1cmF0aW9uOiAzMDBcbiAgfSxcbiAgcGllX3NsaWNlX21vdXNlb3Zlcjoge1xuICAgIGR1cmF0aW9uOiAxMDBcbiAgfSxcbiAgcGllX3NsaWNlX21vdXNlb3V0OiB7XG4gICAgZHVyYXRpb246IDEwMFxuICB9LFxuICBwaWVfY2hhcnRfdGl0bGVzOiB7XG4gICAgZHVyYXRpb246IDM3NVxuICB9LFxuICBncmFwaF9lbGVtZW50X21vdXNlb3Zlcl9maWxsX3VwZGF0ZToge1xuICAgIGR1cmF0aW9uOiAxMDBcbiAgfSxcbiAgZ3JhcGhfZWxlbWVudF9tb3VzZW91dF9maWxsX3VwZGF0ZToge1xuICAgIGR1cmF0aW9uOiAxMDBcbiAgfVxufSwgeWUgPSB7XG4gIGhlaWdodDoge1xuICAgIFtLZS5HUkFQSF9WSUVXXTogMzIsXG4gICAgW0tlLlNMSURFUl9WSUVXXTogMTBcbiAgfSxcbiAgc3BhY2VySGVpZ2h0OiA4LFxuICBoYW5kbGVXaWR0aDogNSxcbiAgaGFuZGxlQmFyV2lkdGg6IDEsXG4gIGhhbmRsZUJhckhlaWdodDogMTJcbn0sIGtUID0gW1xuICB7XG4gICAgdHlwZTogR3QuUkFESVVTLFxuICAgIG5hbWU6IFwiUmFkaXVzXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IEd0LkFSRUEsXG4gICAgbmFtZTogXCJQb29yIGFyZWFcIlxuICB9LFxuICB7XG4gICAgdHlwZTogR3QuQVJFQSxcbiAgICBuYW1lOiBcIlNhdGlzZmFjdG9yeSBhcmVhXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IEd0LkFSRUEsXG4gICAgbmFtZTogXCJHcmVhdCBhcmVhXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IEd0LlFVQVJUSUxFLFxuICAgIG5hbWU6IFwiUXVhcnRpbGVzXCJcbiAgfVxuXSwgUHIgPSB7XG4gIHR5cGU6IFZlLkVORF9MSU5FLFxuICB0aHJlc2hvbGQ6IDE2LFxuICBudW1DaGFyYWN0ZXI6IDE0XG59LCBEVCA9IHtcbiAgY29kZTogdHlwZW9mIG5hdmlnYXRvciA8IFwidVwiICYmIChuYXZpZ2F0b3IgPT0gbnVsbCA/IHZvaWQgMCA6IG5hdmlnYXRvci5sYW5ndWFnZSkgfHwgXCJlbi1VU1wiLFxuICAvLyByZWFkIGZyb20gYnJvd3NlcidzIG5hdmlnYXRvci5sYW5ndWFnZVxuICBudW1iZXI6IChlLCB0ID0gKG5hdmlnYXRvciA9PSBudWxsID8gdm9pZCAwIDogbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCBcImVuLVVTXCIpID0+IHtcbiAgICB2YXIgbjtcbiAgICByZXR1cm4gKG4gPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLnRvTG9jYWxlU3RyaW5nKSA9PSBudWxsID8gdm9pZCAwIDogbi5jYWxsKGUsIHQpO1xuICB9LFxuICAvLyBiYXNlZCBvbiBjb2RlIHByb3BlcnR5IGlmIHNwZWNpZmllZFxuICBkYXRlOiAoZSwgdCA9IChuYXZpZ2F0b3IgPT0gbnVsbCA/IHZvaWQgMCA6IG5hdmlnYXRvci5sYW5ndWFnZSkgfHwgXCJlbi1VU1wiLCBuID0ge30sIHIgPSBudWxsKSA9PiByIHx8IGUudG9Mb2NhbGVEYXRlU3RyaW5nKHQsIG4pLFxuICAvLyBiYXNlZCBvbiBjb2RlIHByb3BlcnR5IGlmIHNwZWNpZmllZFxuICB0aW1lOiAoZSwgdCA9IChuYXZpZ2F0b3IgPT0gbnVsbCA/IHZvaWQgMCA6IG5hdmlnYXRvci5sYW5ndWFnZSkgfHwgXCJlbi1VU1wiLCBuID0ge30sIHIgPSBudWxsKSA9PiByIHx8IGUudG9Mb2NhbGVUaW1lU3RyaW5nKHQsIG4pLFxuICAvLyBiYXNlZCBvbiBjb2RlIHByb3BlcnR5IGlmIHNwZWNpZmllZFxuICBvcHRpb25zT2JqZWN0OiB7XG4gICAgXCIxNXNlY29uZHNcIjoge1xuICAgICAgcHJpbWFyeToge1xuICAgICAgICBcIk1NTSBkLCBwcFwiOiB7XG4gICAgICAgICAgbW9udGg6IFwic2hvcnRcIixcbiAgICAgICAgICBkYXk6IFwibnVtZXJpY1wiLFxuICAgICAgICAgIGhvdXI6IFwibnVtZXJpY1wiLFxuICAgICAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgICAgICAgc2Vjb25kOiBcIjItZGlnaXRcIixcbiAgICAgICAgICBob3VyQ3ljbGU6IFwiaDEyXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJNTU0gZCwgaDptbTpzcy5TU1MgYVwiOiB7XG4gICAgICAgICAgbW9udGg6IFwic2hvcnRcIixcbiAgICAgICAgICBkYXk6IFwibnVtZXJpY1wiLFxuICAgICAgICAgIGhvdXI6IFwibnVtZXJpY1wiLFxuICAgICAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgICAgICAgZnJhY3Rpb25hbFNlY29uZERpZ2l0czogMyxcbiAgICAgICAgICBob3VyQ3ljbGU6IFwiaDEyXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNlY29uZGFyeToge1xuICAgICAgICBwcDoge1xuICAgICAgICAgIGhvdXI6IFwibnVtZXJpY1wiLFxuICAgICAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgICAgICAgc2Vjb25kOiBcIjItZGlnaXRcIixcbiAgICAgICAgICBob3VyQ3ljbGU6IFwiaDEyXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJoOm1tOnNzLlNTUyBhXCI6IHtcbiAgICAgICAgICBob3VyOiBcIm51bWVyaWNcIixcbiAgICAgICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgICAgICAgIGZyYWN0aW9uYWxTZWNvbmREaWdpdHM6IDMsXG4gICAgICAgICAgaG91ckN5Y2xlOiBcImgxMlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0eXBlOiBcInRpbWVcIlxuICAgIH0sXG4gICAgbWludXRlOiB7XG4gICAgICBwcmltYXJ5OiB7XG4gICAgICAgIFwiTU1NIGQsIHBcIjoge1xuICAgICAgICAgIG1vbnRoOiBcInNob3J0XCIsXG4gICAgICAgICAgZGF5OiBcIm51bWVyaWNcIixcbiAgICAgICAgICBob3VyOiBcIm51bWVyaWNcIixcbiAgICAgICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgICAgICAgIGhvdXJDeWNsZTogXCJoMTJcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2Vjb25kYXJ5OiB7XG4gICAgICAgIHA6IHtcbiAgICAgICAgICBob3VyOiBcIm51bWVyaWNcIixcbiAgICAgICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgICAgICAgIGhvdXJDeWNsZTogXCJoMTJcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHlwZTogXCJ0aW1lXCJcbiAgICB9LFxuICAgIFwiMzBtaW51dGVzXCI6IHtcbiAgICAgIHByaW1hcnk6IHtcbiAgICAgICAgXCJNTU0gZCwgcFwiOiB7XG4gICAgICAgICAgbW9udGg6IFwic2hvcnRcIixcbiAgICAgICAgICBkYXk6IFwibnVtZXJpY1wiLFxuICAgICAgICAgIGhvdXI6IFwibnVtZXJpY1wiLFxuICAgICAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgICAgICAgaG91ckN5Y2xlOiBcImgxMlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZWNvbmRhcnk6IHtcbiAgICAgICAgcDoge1xuICAgICAgICAgIGhvdXI6IFwibnVtZXJpY1wiLFxuICAgICAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgICAgICAgaG91ckN5Y2xlOiBcImgxMlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0eXBlOiBcInRpbWVcIlxuICAgIH0sXG4gICAgaG91cmx5OiB7XG4gICAgICBwcmltYXJ5OiB7XG4gICAgICAgIFwiTU1NIGQsIGhoIGFcIjoge1xuICAgICAgICAgIG1vbnRoOiBcInNob3J0XCIsXG4gICAgICAgICAgZGF5OiBcIm51bWVyaWNcIixcbiAgICAgICAgICBob3VyOiBcIjItZGlnaXRcIixcbiAgICAgICAgICBob3VyQ3ljbGU6IFwiaDEyXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNlY29uZGFyeToge1xuICAgICAgICBcImhoIGFcIjoge1xuICAgICAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgICAgICAgIGhvdXJDeWNsZTogXCJoMTJcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHlwZTogXCJ0aW1lXCJcbiAgICB9LFxuICAgIGRhaWx5OiB7XG4gICAgICBwcmltYXJ5OiB7XG4gICAgICAgIFwiTU1NIGRcIjoge1xuICAgICAgICAgIG1vbnRoOiBcInNob3J0XCIsXG4gICAgICAgICAgZGF5OiBcIm51bWVyaWNcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2Vjb25kYXJ5OiB7XG4gICAgICAgIGQ6IHtcbiAgICAgICAgICBkYXk6IFwibnVtZXJpY1wiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0eXBlOiBcImRhdGVcIlxuICAgIH0sXG4gICAgd2Vla2x5OiB7XG4gICAgICBwcmltYXJ5OiB7XG4gICAgICAgIFwiZWVlLCBNTU0gZFwiOiB7XG4gICAgICAgICAgd2Vla2RheTogXCJzaG9ydFwiLFxuICAgICAgICAgIG1vbnRoOiBcInNob3J0XCIsXG4gICAgICAgICAgZGF5OiBcIm51bWVyaWNcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2Vjb25kYXJ5OiB7XG4gICAgICAgIGVlZToge1xuICAgICAgICAgIHdlZWtkYXk6IFwic2hvcnRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHlwZTogXCJkYXRlXCJcbiAgICB9LFxuICAgIG1vbnRobHk6IHtcbiAgICAgIHByaW1hcnk6IHtcbiAgICAgICAgXCJNTU0geXl5eVwiOiB7XG4gICAgICAgICAgbW9udGg6IFwic2hvcnRcIixcbiAgICAgICAgICB5ZWFyOiBcIm51bWVyaWNcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2Vjb25kYXJ5OiB7XG4gICAgICAgIE1NTToge1xuICAgICAgICAgIG1vbnRoOiBcInNob3J0XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHR5cGU6IFwiZGF0ZVwiXG4gICAgfSxcbiAgICBxdWFydGVybHk6IHtcbiAgICAgIHByaW1hcnk6IHt9LFxuICAgICAgc2Vjb25kYXJ5OiB7fSxcbiAgICAgIHR5cGU6IFwiZGF0ZVwiXG4gICAgfSxcbiAgICB5ZWFybHk6IHtcbiAgICAgIHByaW1hcnk6IHtcbiAgICAgICAgeXl5eToge1xuICAgICAgICAgIHllYXI6IFwibnVtZXJpY1wiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZWNvbmRhcnk6IHtcbiAgICAgICAgeXl5eToge1xuICAgICAgICAgIHllYXI6IFwibnVtZXJpY1wiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0eXBlOiBcImRhdGVcIlxuICAgIH1cbiAgfSxcbiAgdHJhbnNsYXRpb25zOiB7XG4gICAgZ3JvdXA6IFwiR3JvdXBcIixcbiAgICB0b3RhbDogXCJUb3RhbFwiLFxuICAgIG1ldGVyOiB7XG4gICAgICB0aXRsZTogXCJcIlxuICAgICAgLy9kZWZhdWx0IGlzIGVtcGx5IHN0cmluZyBhcyBtZXRlciB0aXRsZSBpcyBkYXRhc2V0IGxhYmVsXG4gICAgfSxcbiAgICB0YWJ1bGFyUmVwOiB7XG4gICAgICB0aXRsZTogXCJUYWJ1bGFyIHJlcHJlc2VudGF0aW9uXCIsXG4gICAgICBkb3dubG9hZEFzQ1NWOiBcIkRvd25sb2FkIGFzIENTVlwiXG4gICAgfSxcbiAgICB0b29sYmFyOiB7XG4gICAgICBleHBvcnRBc0NTVjogXCJFeHBvcnQgdG8gQ1NWXCIsXG4gICAgICBleHBvcnRBc0pQRzogXCJFeHBvcnQgdG8gSlBHXCIsXG4gICAgICBleHBvcnRBc1BORzogXCJFeHBvcnQgdG8gUE5HXCIsXG4gICAgICB6b29tSW46IFwiWm9vbSBpblwiLFxuICAgICAgem9vbU91dDogXCJab29tIG91dFwiLFxuICAgICAgcmVzZXRab29tOiBcIlJlc2V0IHpvb21cIixcbiAgICAgIG1vcmVPcHRpb25zOiBcIk1vcmUgb3B0aW9uc1wiLFxuICAgICAgbWFrZUZ1bGxTY3JlZW46IFwiTWFrZSBmdWxsc2NyZWVuXCIsXG4gICAgICBleGl0RnVsbFNjcmVlbjogXCJFeGl0IGZ1bGxzY3JlZW5cIixcbiAgICAgIHNob3dBc1RhYmxlOiBcIlNob3cgYXMgdGFibGVcIlxuICAgIH1cbiAgfVxufSwgUlQgPSB7XG4gIGVuYWJsZWQ6ICEwLFxuICBwb3NpdGlvbjogTmkuQk9UVE9NLFxuICBjbGlja2FibGU6ICEwLFxuICB0cnVuY2F0aW9uOiBQcixcbiAgYWxpZ25tZW50OiBqdC5MRUZULFxuICBvcmRlcjogbnVsbCxcbiAgYWRkaXRpb25hbEl0ZW1zOiBbXVxufSwgSVQgPSB7XG4gIHg6IHtcbiAgICAvLyBzZXQgZW5hYmxlIHRvIGZhbHNlIHdpbGwgbm90IGRyYXcgZ3JpZCBhbmQgc3Ryb2tlIG9mIGdyaWQgYmFja2Ryb3BcbiAgICBlbmFibGVkOiAhMCxcbiAgICBudW1iZXJPZlRpY2tzOiAxNSxcbiAgICBhbGlnbldpdGhBeGlzVGlja3M6ICExXG4gIH0sXG4gIHk6IHtcbiAgICAvLyBzZXQgZW5hYmxlIHRvIGZhbHNlIHdpbGwgbm90IGRyYXcgZ3JpZCBhbmQgc3Ryb2tlIG9mIGdyaWQgYmFja2Ryb3BcbiAgICBlbmFibGVkOiAhMCxcbiAgICBudW1iZXJPZlRpY2tzOiA1LFxuICAgIGFsaWduV2l0aEF4aXNUaWNrczogITFcbiAgfVxufSwgTlQgPSB7XG4gIC8vIGVuYWJsZSBvciBkaXNhYmxlIHJ1bGVyXG4gIGVuYWJsZWQ6ICEwXG59LCBDbSA9IHtcbiAgZW5hYmxlZDogITAsXG4gIHNob3dUb3RhbDogITAsXG4gIHRydW5jYXRpb246IFByLFxuICBncm91cExhYmVsOiBcIkdyb3VwXCJcbn0sIEFtID0ge1xuICB0b3A6IHtcbiAgICB2aXNpYmxlOiAhMCxcbiAgICBpbmNsdWRlWmVybzogITAsXG4gICAgdHJ1bmNhdGlvbjogUHJcbiAgfSxcbiAgYm90dG9tOiB7XG4gICAgdmlzaWJsZTogITAsXG4gICAgaW5jbHVkZVplcm86ICEwLFxuICAgIHRydW5jYXRpb246IFByXG4gIH0sXG4gIGxlZnQ6IHtcbiAgICB2aXNpYmxlOiAhMCxcbiAgICBpbmNsdWRlWmVybzogITAsXG4gICAgdHJ1bmNhdGlvbjogUHJcbiAgfSxcbiAgcmlnaHQ6IHtcbiAgICB2aXNpYmxlOiAhMCxcbiAgICBpbmNsdWRlWmVybzogITAsXG4gICAgdHJ1bmNhdGlvbjogUHJcbiAgfVxufSwgaW8gPSB7XG4gIGFkZFNwYWNlT25FZGdlczogMSxcbiAgc2hvd0RheU5hbWU6ICExLFxuICBsb2NhbGVPYmplY3Q6IGRmLFxuICB0aW1lSW50ZXJ2YWxGb3JtYXRzOiB7XG4gICAgXCIxNXNlY29uZHNcIjogeyBwcmltYXJ5OiBcIk1NTSBkLCBwcFwiLCBzZWNvbmRhcnk6IFwicHBcIiB9LFxuICAgIG1pbnV0ZTogeyBwcmltYXJ5OiBcIk1NTSBkLCBwXCIsIHNlY29uZGFyeTogXCJwXCIgfSxcbiAgICBcIjMwbWludXRlc1wiOiB7IHByaW1hcnk6IFwiTU1NIGQsIHBcIiwgc2Vjb25kYXJ5OiBcInBcIiB9LFxuICAgIGhvdXJseTogeyBwcmltYXJ5OiBcIk1NTSBkLCBoaCBhXCIsIHNlY29uZGFyeTogXCJoaCBhXCIgfSxcbiAgICBkYWlseTogeyBwcmltYXJ5OiBcIk1NTSBkXCIsIHNlY29uZGFyeTogXCJkXCIgfSxcbiAgICB3ZWVrbHk6IHsgcHJpbWFyeTogXCJlZWUsIE1NTSBkXCIsIHNlY29uZGFyeTogXCJlZWVcIiB9LFxuICAgIG1vbnRobHk6IHsgcHJpbWFyeTogXCJNTU0geXl5eVwiLCBzZWNvbmRhcnk6IFwiTU1NXCIgfSxcbiAgICBxdWFydGVybHk6IHsgcHJpbWFyeTogXCJRUVEgJyd5eVwiLCBzZWNvbmRhcnk6IFwiUVFRXCIgfSxcbiAgICB5ZWFybHk6IHsgcHJpbWFyeTogXCJ5eXl5XCIsIHNlY29uZGFyeTogXCJ5eXl5XCIgfVxuICB9XG59O1xubGV0IExtID0gITE7XG50cnkge1xuICBMbSA9IHR5cGVvZiBkb2N1bWVudCA8IFwidVwiICYmIChkb2N1bWVudC5mdWxsc2NyZWVuRW5hYmxlZCB8fCBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRW5hYmxlZCB8fCBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRW5hYmxlZCB8fCBkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbmFibGVkKTtcbn0gY2F0Y2ggKGUpIHtcbiAgY29uc29sZS53YXJuKFwiRnVsbHNjcmVlbiBjYXBhYmlsaXRpZXMgY2hlY2sgZmFpbGVkOiBcIiwgZS5tZXNzYWdlKTtcbn1cbmNvbnN0IHJlID0ge1xuICB3aWR0aDogbnVsbCxcbiAgaGVpZ2h0OiBudWxsLFxuICByZXNpemFibGU6ICEwLFxuICB0aGVtZTogb2YuV0hJVEUsXG4gIHRvb2x0aXA6IENtLFxuICBsZWdlbmQ6IFJULFxuICBsb2NhbGU6IERULFxuICBzdHlsZToge1xuICAgIHByZWZpeDogXCJjY1wiXG4gIH0sXG4gIGRhdGE6IHtcbiAgICBncm91cE1hcHNUbzogXCJncm91cFwiLFxuICAgIGxvYWRpbmc6ICExLFxuICAgIHNlbGVjdGVkR3JvdXBzOiBbXVxuICB9LFxuICBjb2xvcjoge1xuICAgIHNjYWxlOiBudWxsLFxuICAgIHBhaXJpbmc6IHtcbiAgICAgIG51bWJlck9mVmFyaWFudHM6IG51bGwsXG4gICAgICBvcHRpb246IDFcbiAgICB9LFxuICAgIGdyYWRpZW50OiB7XG4gICAgICBlbmFibGVkOiAhMVxuICAgIH1cbiAgfSxcbiAgdG9vbGJhcjoge1xuICAgIGVuYWJsZWQ6ICEwLFxuICAgIG51bWJlck9mSWNvbnM6IDMsXG4gICAgY29udHJvbHM6IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogX3QuU0hPV19BU19EQVRBVEFCTEVcbiAgICAgIH0sXG4gICAgICAuLi5MbSA/IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IF90Lk1BS0VfRlVMTFNDUkVFTlxuICAgICAgICB9XG4gICAgICBdIDogW10sXG4gICAgICB7XG4gICAgICAgIHR5cGU6IF90LkVYUE9SVF9DU1ZcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHR5cGU6IF90LkVYUE9SVF9QTkdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHR5cGU6IF90LkVYUE9SVF9KUEdcbiAgICAgIH1cbiAgICBdXG4gIH1cbn0sIGttID0gYXQoe30sIHJlLCB7XG4gIHRoZW1hdGljOiB7XG4gICAgcHJvamVjdGlvbjogZ24uZ2VvTmF0dXJhbEVhcnRoMVxuICB9XG59KSwgbXMgPSBhdCh7fSwgcmUsIHtcbiAgYXhlczogQW0sXG4gIHRpbWVTY2FsZTogaW8sXG4gIGdyaWQ6IElULFxuICBydWxlcjogTlQsXG4gIHpvb21CYXI6IHtcbiAgICB6b29tUmF0aW86IDAuNCxcbiAgICBtaW5ab29tUmF0aW86IDAuMDEsXG4gICAgdG9wOiB7XG4gICAgICBlbmFibGVkOiAhMSxcbiAgICAgIHR5cGU6IEtlLkdSQVBIX1ZJRVdcbiAgICB9XG4gIH1cbn0pLCBzciA9IGF0KHt9LCBtcywge1xuICBiYXJzOiB7XG4gICAgbWF4V2lkdGg6IDE2LFxuICAgIHNwYWNpbmdGYWN0b3I6IDAuMjVcbiAgfSxcbiAgdGltZVNjYWxlOiBhdChpbywge1xuICAgIGFkZFNwYWNlT25FZGdlczogMVxuICB9KVxufSksIFBUID0gYXQoe30sIHNyLCB7fSksIFVUID0gYXQoe30sIHNyLCB7fSksIEJUID0gYXQoe30sIHNyLCB7XG4gIGJhcnM6IGF0KHt9LCBzci5iYXJzLCB7XG4gICAgZGl2aWRlclNpemU6IDEuNVxuICB9KVxufSksIEhUID0gYXQoe30sIHNyLCB7fSksIHpjID0gYXQoe30sIG1zLCB7XG4gIHBvaW50czoge1xuICAgIC8vIGRlZmF1bHQgcG9pbnQgcmFkaXVzIHRvIDRcbiAgICByYWRpdXM6IDQsXG4gICAgZmlsbE9wYWNpdHk6IDAuMyxcbiAgICBmaWxsZWQ6ICEwLFxuICAgIGVuYWJsZWQ6ICEwXG4gIH1cbn0pLCBWVCA9IHpjLCBEbSA9IGF0KHt9LCB6Yywge1xuICBwb2ludHM6IHtcbiAgICAvLyBkZWZhdWx0IHBvaW50IHJhZGl1cyB0byAzXG4gICAgcmFkaXVzOiAzLFxuICAgIGZpbGxlZDogITEsXG4gICAgZW5hYmxlZDogITBcbiAgfVxufSksIFJtID0gYXQoe30sIERtLCB7XG4gIHRpbWVTY2FsZTogYXQoaW8sIHtcbiAgICBhZGRTcGFjZU9uRWRnZXM6IDBcbiAgfSlcbn0pLCBHVCA9IFJtLCB6VCA9IGF0KHt9LCBtcywge1xuICBidWJibGU6IHtcbiAgICByYWRpdXNNYXBzVG86IFwicmFkaXVzXCIsXG4gICAgcmFkaXVzTGFiZWw6IFwiUmFkaXVzXCIsXG4gICAgcmFkaXVzUmFuZ2U6IChlKSA9PiB7XG4gICAgICBjb25zdCB0ID0gTWF0aC5taW4oZS53aWR0aCwgZS5oZWlnaHQpO1xuICAgICAgcmV0dXJuIFt0ICogMyAvIDQwMCwgdCAqIDI1IC8gNDAwXTtcbiAgICB9LFxuICAgIGZpbGxPcGFjaXR5OiAwLjIsXG4gICAgZW5hYmxlZDogITBcbiAgfSxcbiAgcG9pbnRzOiB7XG4gICAgZmlsbGVkOiAhMFxuICB9LFxuICBsZWdlbmQ6IHtcbiAgICBhZGRpdGlvbmFsSXRlbXM6IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogR3QuUkFESVVTLFxuICAgICAgICBuYW1lOiBcIlJhZGl1c1wiXG4gICAgICB9XG4gICAgXVxuICB9XG59KSwgRlQgPSBhdCh7fSwgbXMsIHtcbiAgYnVsbGV0OiB7XG4gICAgcGVyZm9ybWFuY2VBcmVhVGl0bGVzOiBbXCJQb29yXCIsIFwiU2F0aXNmYWN0b3J5XCIsIFwiR3JlYXRcIl1cbiAgfSxcbiAgZ3JpZDoge1xuICAgIHg6IHtcbiAgICAgIGVuYWJsZWQ6ICExXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICBlbmFibGVkOiAhMVxuICAgIH1cbiAgfSxcbiAgbGVnZW5kOiB7XG4gICAgYWRkaXRpb25hbEl0ZW1zOiBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IEd0LkFSRUEsXG4gICAgICAgIG5hbWU6IFwiUG9vciBhcmVhXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHR5cGU6IEd0LkFSRUEsXG4gICAgICAgIG5hbWU6IFwiU2F0aXNmYWN0b3J5IGFyZWFcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogR3QuQVJFQSxcbiAgICAgICAgbmFtZTogXCJHcmVhdCBhcmVhXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHR5cGU6IEd0LlFVQVJUSUxFLFxuICAgICAgICBuYW1lOiBcIlF1YXJ0aWxlc1wiXG4gICAgICB9XG4gICAgXVxuICB9XG59KSwgalQgPSBhdCh7fSwgc3IsIHtcbiAgYmFyczoge1xuICAgIGRpdmlkZXJTaXplOiAxLjVcbiAgfSxcbiAgdGltZVNjYWxlOiBhdChpbywge1xuICAgIGFkZFNwYWNlT25FZGdlczogMFxuICB9KVxufSksIFdUID0gYXQoe30sIHJlLCB7XG4gIHRvb2x0aXA6IGF0KHt9LCBDbSwge1xuICAgIHdvcmRMYWJlbDogXCJXb3JkXCIsXG4gICAgdmFsdWVMYWJlbDogXCJWYWx1ZVwiXG4gIH0pLFxuICB3b3JkQ2xvdWQ6IHtcbiAgICBmb250U2l6ZU1hcHNUbzogXCJ2YWx1ZVwiLFxuICAgIGZvbnRTaXplUmFuZ2U6IChlKSA9PiB7XG4gICAgICBjb25zdCB0ID0gTWF0aC5taW4oZS53aWR0aCwgZS5oZWlnaHQpO1xuICAgICAgcmV0dXJuIFt0ICogMjAgLyA0MDAsIHQgKiA3NSAvIDQwMF07XG4gICAgfSxcbiAgICB3b3JkTWFwc1RvOiBcIndvcmRcIlxuICB9XG59KSwgSW0gPSBhdCh7fSwgcmUsIHtcbiAgcGllOiB7XG4gICAgbGFiZWxzOiB7XG4gICAgICBmb3JtYXR0ZXI6IG51bGwsXG4gICAgICBlbmFibGVkOiAhMFxuICAgIH0sXG4gICAgYWxpZ25tZW50OiBqdC5MRUZULFxuICAgIHNvcnRGdW5jdGlvbjogbnVsbCxcbiAgICB2YWx1ZU1hcHNUbzogXCJ2YWx1ZVwiXG4gIH1cbn0pLCBxVCA9IGF0KHt9LCByZSwge1xuICBsZWdlbmQ6IHtcbiAgICBlbmFibGVkOiAhMVxuICB9LFxuICBnYXVnZToge1xuICAgIHR5cGU6IFJyLlNFTUksXG4gICAgYXJjV2lkdGg6IDE2LFxuICAgIGRlbHRhQXJyb3c6IHtcbiAgICAgIHNpemU6IChlKSA9PiBlIC8gOCxcbiAgICAgIGVuYWJsZWQ6ICEwXG4gICAgfSxcbiAgICBzaG93UGVyY2VudGFnZVN5bWJvbDogITAsXG4gICAgc3RhdHVzOiBudWxsLFxuICAgIG51bWJlclNwYWNpbmc6IDEwLFxuICAgIGRlbHRhRm9udFNpemU6IChlKSA9PiBlIC8gOCxcbiAgICB2YWx1ZUZvbnRTaXplOiAoZSkgPT4gZSAvIDIuNSxcbiAgICBhbGlnbm1lbnQ6IGp0LkxFRlRcbiAgfVxufSksIFlUID0gYXQoe30sIEltLCB7XG4gIGRvbnV0OiB7XG4gICAgY2VudGVyOiB7XG4gICAgICBudW1iZXJGb250U2l6ZTogKGUpID0+IGAke01hdGgubWluKGUgLyAxMDAgKiAyNCwgMjQpfXB4YCxcbiAgICAgIHRpdGxlRm9udFNpemU6IChlKSA9PiBgJHtNYXRoLm1pbihlIC8gMTAwICogMTUsIDE1KX1weGAsXG4gICAgICB0aXRsZVlQb3NpdGlvbjogKGUpID0+IE1hdGgubWluKGUgLyA4MCAqIDIwLCAyMClcbiAgICB9LFxuICAgIGFsaWdubWVudDoganQuTEVGVFxuICB9XG59KSwgTm0gPSBhdCh7fSwgcmUsIHtcbiAgbGVnZW5kOiB7XG4gICAgZW5hYmxlZDogITEsXG4gICAgY2xpY2thYmxlOiAhMVxuICB9LFxuICBtZXRlcjoge1xuICAgIHNob3dMYWJlbHM6ICEwLFxuICAgIHByb3BvcnRpb25hbDogbnVsbCxcbiAgICBzdGF0dXNCYXI6IHtcbiAgICAgIHBlcmNlbnRhZ2VJbmRpY2F0b3I6IHtcbiAgICAgICAgZW5hYmxlZDogITBcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pLCBYVCA9IGF0KHt9LCBObSwge1xuICBsZWdlbmQ6IHtcbiAgICBlbmFibGVkOiAhMFxuICB9XG59KSwgWlQgPSBhdCh7fSwgcmUsIHtcbiAgcmFkYXI6IHtcbiAgICBheGVzOiB7XG4gICAgICBhbmdsZTogXCJrZXlcIixcbiAgICAgIHZhbHVlOiBcInZhbHVlXCJcbiAgICB9LFxuICAgIGFsaWdubWVudDoganQuTEVGVFxuICB9LFxuICB0b29sdGlwOiB7XG4gICAgZ3JpZGxpbmU6IHtcbiAgICAgIGVuYWJsZWQ6ICEwXG4gICAgfVxuICB9XG59KSwgS1QgPSBhdCh7fSwgc3IsIHtcbiAgY29tYm9DaGFydFR5cGVzOiBbXVxufSksIFFUID0gYXQoXG4gIHtcbiAgICB0cmVlOiB7XG4gICAgICB0eXBlOiBwYy5UUkVFXG4gICAgfVxuICB9LFxuICByZSxcbiAge31cbiksIEpUID0gYXQoe30sIHJlLCB7XG4gIGRhdGE6IGF0KHJlLmRhdGEsIHtcbiAgICBncm91cE1hcHNUbzogXCJuYW1lXCJcbiAgfSlcbn0pLCB0dyA9IGF0KHt9LCByZSwgQ3IsIHtcbiAgZGF0YTogYXQocmUuZGF0YSwge1xuICAgIGdyb3VwTWFwc1RvOiBcIm5hbWVcIlxuICB9KVxufSksIGV3ID0gYXQoe30sIHJlLCB7XG4gIGFsbHV2aWFsOiB7XG4gICAgZGF0YTogYXQocmUuZGF0YSwge1xuICAgICAgZ3JvdXBNYXBzVG86IFwic291cmNlXCJcbiAgICB9KSxcbiAgICBub2RlQWxpZ25tZW50OiBqdC5DRU5URVIsXG4gICAgbm9kZVBhZGRpbmc6IDI0LFxuICAgIG1vbm9jaHJvbWU6ICExLFxuICAgIG5vZGVzOiBbXVxuICB9XG59KSwgbncgPSBhdCh7fSwgcmUsIHtcbiAgYXhlczogQW0sXG4gIGhlYXRtYXA6IHtcbiAgICBkaXZpZGVyOiB7XG4gICAgICBzdGF0ZTogUGkuQVVUT1xuICAgIH0sXG4gICAgY29sb3JMZWdlbmQ6IHtcbiAgICAgIHR5cGU6IFwibGluZWFyXCJcbiAgICB9XG4gIH1cbn0pLCBydyA9IGF0KHt9LCBrbSwge1xuICBjaG9yb3BsZXRoOiB7XG4gICAgY29sb3JMZWdlbmQ6IHtcbiAgICAgIHR5cGU6IFwibGluZWFyXCJcbiAgICB9XG4gIH1cbn0pLCB3dCA9IHtcbiAgYWxsdXZpYWxDaGFydDogZXcsXG4gIGFyZWFDaGFydDogUm0sXG4gIGF4aXNDaGFydDogbXMsXG4gIGJveHBsb3RDaGFydDogSFQsXG4gIGJ1YmJsZUNoYXJ0OiB6VCxcbiAgYnVsbGV0Q2hhcnQ6IEZULFxuICBjaGFydDogcmUsXG4gIGNpcmNsZVBhY2tDaGFydDogdHcsXG4gIGNob3JvcGxldGhDaGFydDogcncsXG4gIGNvbWJvQ2hhcnQ6IEtULFxuICBkb251dENoYXJ0OiBZVCxcbiAgZ2F1Z2VDaGFydDogcVQsXG4gIGdyb3VwZWRCYXJDaGFydDogVVQsXG4gIGhlYXRtYXBDaGFydDogbncsXG4gIGhpc3RvZ3JhbUNoYXJ0OiBqVCxcbiAgbGluZUNoYXJ0OiBEbSxcbiAgbG9sbGlwb3BDaGFydDogVlQsXG4gIG1ldGVyQ2hhcnQ6IE5tLFxuICBwaWVDaGFydDogSW0sXG4gIHByb3BvcnRpb25hbE1ldGVyQ2hhcnQ6IFhULFxuICByYWRhckNoYXJ0OiBaVCxcbiAgc2NhdHRlckNoYXJ0OiB6YyxcbiAgc2ltcGxlQmFyQ2hhcnQ6IFBULFxuICBzdGFja2VkQXJlYUNoYXJ0OiBHVCxcbiAgc3RhY2tlZEJhckNoYXJ0OiBCVCxcbiAgdGhlbWF0aWNDaGFydDoga20sXG4gIHRyZWVDaGFydDogUVQsXG4gIHRyZWVtYXBDaGFydDogSlQsXG4gIHdvcmRDbG91ZENoYXJ0OiBXVFxufTtcbmZ1bmN0aW9uIGl3KGUsIHQsIG4pIHtcbiAgbGV0IHIgPSBudWxsO1xuICByZXR1cm4gZnVuY3Rpb24oLi4uaSkge1xuICAgIGNvbnN0IHMgPSB0aGlzO1xuICAgIHMubW91c2VQb3NpdGlvbiA9IHJyKGlbMF0sIG4pLCBjbGVhclRpbWVvdXQociksIHIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgZS5hcHBseShzLCBpKTtcbiAgICB9LCB0KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIFJ0KGUsIHQpIHtcbiAgdmFyIG47XG4gIGNvbnN0IHIgPSBTbihlKSwgaSA9IE9iamVjdC5rZXlzKHQuYXhlcyB8fCB7fSk7XG4gIChuID0gdCA9PSBudWxsID8gdm9pZCAwIDogdC50b29sYmFyKSAhPSBudWxsICYmIG4uY29udHJvbHMgJiYgZGVsZXRlIHIudG9vbGJhci5jb250cm9scywgaS5sZW5ndGggPT09IDAgJiYgZGVsZXRlIHIuYXhlcztcbiAgZm9yIChjb25zdCBzIGluIHIuYXhlcylcbiAgICBpZiAoaS5pbmNsdWRlcyhzKSkge1xuICAgICAgY29uc3QgYSA9IHQuYXhlc1tzXTtcbiAgICAgIGlmICgoYS5wcmltYXJ5IHx8IGEuc2Vjb25kYXJ5KSAmJiBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiYHByaW1hcnlgICYgYHNlY29uZGFyeWAgYXJlIG5vIGxvbmdlciBuZWVkZWQgZm9yIGF4aXMgY29uZmlndXJhdGlvbnMuIFJlYWQgbW9yZSBoZXJlIGh0dHBzOi8vY2hhcnRzLmNhcmJvbmRlc2lnbnN5c3RlbS5jb20vXCJcbiAgICAgICksIGEubWFwc1RvID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgbCA9IGEuc2NhbGVUeXBlO1xuICAgICAgICBsID09IG51bGwgPyBhLm1hcHNUbyA9IFwidmFsdWVcIiA6IGwgPT09IGV0LlRJTUUgPyBhLm1hcHNUbyA9IFwiZGF0ZVwiIDogbCA9PT0gZXQuTEFCRUxTICYmIChhLm1hcHNUbyA9IFwia2V5XCIpO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgZGVsZXRlIHIuYXhlc1tzXTtcbiAgcmV0dXJuIEZjKHIsIHQpLCBhdChyLCB0KTtcbn1cbmZ1bmN0aW9uIGZuKGUpIHtcbiAgaWYgKCFlKVxuICAgIHJldHVybjtcbiAgY29uc3QgdCA9IC90cmFuc2xhdGVcXChbMC05XStcXC4/WzAtOV0qLFswLTldK1xcLj9bMC05XSpcXCkvLCBuID0gZS5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikubWF0Y2godCk7XG4gIGlmICghbilcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKG5bMF0pIHtcbiAgICBjb25zdCByID0gblswXS5yZXBsYWNlKC90cmFuc2xhdGVcXCgvLCBcIlwiKS5yZXBsYWNlKC9cXCkvLCBcIlwiKS5zcGxpdChcIixcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR4OiByWzBdLFxuICAgICAgdHk6IHJbMV1cbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gTWkoZSkge1xuICBjb25zdCB0ID0gL1xcKChbXildKylcXCkvLmV4ZWMoZSk7XG4gIGlmICh0ICYmIHQubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IG4gPSB0WzFdLnNwbGl0KFwiLFwiKTtcbiAgICBpZiAobi5sZW5ndGggPiAxKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcGFyc2VGbG9hdChuWzBdKSxcbiAgICAgICAgeTogcGFyc2VGbG9hdChuWzFdKVxuICAgICAgfTtcbiAgfVxuICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG59XG5mdW5jdGlvbiBMbyhlLCB0LCBuID0gXCJ2YWx1ZVwiLCByID0gITEpIHtcbiAgY29uc3QgaSA9IGUgLyB0LnJlZHVjZSgocywgYSkgPT4gcyArIGFbbl0sIDApICogMTAwO1xuICByZXR1cm4gciA/IGkgOiBpICUgMSAhPT0gMCA/IHBhcnNlRmxvYXQoaS50b0ZpeGVkKDEpKSA6IGk7XG59XG5mdW5jdGlvbiBlcyhlLCB0LCBuKSB7XG4gIGlmIChuID4gZS5sZW5ndGgpXG4gICAgcmV0dXJuIGU7XG4gIGlmICh0ID09PSBWZS5NSURfTElORSlcbiAgICByZXR1cm4gZS5zdWJzdHIoMCwgbiAvIDIpICsgXCIuLi5cIiArIGUuc3Vic3RyKC1uIC8gMik7XG4gIGlmICh0ID09PSBWZS5GUk9OVF9MSU5FKVxuICAgIHJldHVybiBcIi4uLlwiICsgZS5zdWJzdHIoLW4pO1xuICBpZiAodCA9PT0gVmUuRU5EX0xJTkUpXG4gICAgcmV0dXJuIGUuc3Vic3RyKDAsIG4pICsgXCIuLi5cIjtcbn1cbmZ1bmN0aW9uIEZjKGUsIHQpIHtcbiAgY29uc3QgbiA9IHkoZSwgXCJsZWdlbmRcIiwgXCJhZGRpdGlvbmFsSXRlbXNcIiksIHIgPSB5KHQsIFwibGVnZW5kXCIsIFwiYWRkaXRpb25hbEl0ZW1zXCIpO1xuICBpZiAobiAmJiByKSB7XG4gICAgY29uc3QgaSA9IHIubWFwKChvKSA9PiBvLnR5cGUpLCBzID0gbi5tYXAoKG8pID0+IG8udHlwZSksIGEgPSBrVC5maWx0ZXIoXG4gICAgICAobykgPT4gcy5pbmNsdWRlcyhvLnR5cGUpICYmICFpLmluY2x1ZGVzKG8udHlwZSlcbiAgICApO1xuICAgIGUubGVnZW5kLmFkZGl0aW9uYWxJdGVtcyA9IGEsIHQubGVnZW5kLmFkZGl0aW9uYWxJdGVtcyA9IEJfKFxuICAgICAgYSxcbiAgICAgIHIsXG4gICAgICBcIm5hbWVcIlxuICAgICk7XG4gIH1cbn1cbmNvbnN0IHkgPSAoZSwgLi4udCkgPT4ge1xuICBsZXQgbiA9IGU7XG4gIGlmIChuKSB7XG4gICAgZm9yIChjb25zdCByIG9mIHQpXG4gICAgICBpZiAobltyXSAhPT0gbnVsbCAmJiBuW3JdICE9PSB2b2lkIDApXG4gICAgICAgIG4gPSBuW3JdO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gbjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn0sIFBtID0gKGUsIHQpID0+IHQgPT09IEZ0LkhPUklaT05UQUwgPyB7XG4gIHkwOiBlLngwLFxuICB5MTogZS54MSxcbiAgeDA6IGUueTAsXG4gIHgxOiBlLnkxXG59IDogZSwgYWUgPSAoZSwgdCkgPT4ge1xuICBjb25zdCB7IHgwOiBuLCB4MTogciwgeTA6IGksIHkxOiBzIH0gPSBQbShlLCB0KTtcbiAgcmV0dXJuIGBNJHtufSwke2l9TCR7bn0sJHtzfUwke3J9LCR7c31MJHtyfSwke2l9TCR7bn0sJHtpfWA7XG59O1xuZnVuY3Rpb24gRW4oZSwgdCwgbikge1xuICByZXR1cm4gbiA9PT0gRnQuVkVSVElDQUwgPyBbZSwgdF0gOiBbdCwgZV07XG59XG5mdW5jdGlvbiBQaChlKSB7XG4gIGNvbnN0IHQgPSBIdChlKSwgbiA9IG5ldyBEYXRlKFxuICAgIERhdGUuVVRDKFxuICAgICAgdC5nZXRGdWxsWWVhcigpLFxuICAgICAgdC5nZXRNb250aCgpLFxuICAgICAgdC5nZXREYXRlKCksXG4gICAgICB0LmdldEhvdXJzKCksXG4gICAgICB0LmdldE1pbnV0ZXMoKSxcbiAgICAgIHQuZ2V0U2Vjb25kcygpLFxuICAgICAgdC5nZXRNaWxsaXNlY29uZHMoKVxuICAgIClcbiAgKTtcbiAgcmV0dXJuIG4uc2V0VVRDRnVsbFllYXIodC5nZXRGdWxsWWVhcigpKSwgK2UgLSArbjtcbn1cbmZ1bmN0aW9uIFVoKGUsIHQpIHtcbiAgY29uc3QgbiA9IEh0KGUsIHZvaWQgMCk7XG4gIHJldHVybiBuLnNldEhvdXJzKDAsIDAsIDAsIDApLCBuO1xufVxuZnVuY3Rpb24gVW0oZSwgdCwgbikge1xuICBjb25zdCBbciwgaV0gPSB1cihcbiAgICB2b2lkIDAsXG4gICAgZSxcbiAgICB0XG4gICksIHMgPSBVaChyKSwgYSA9IFVoKGkpLCBvID0gK3MgLSBQaChzKSwgbCA9ICthIC0gUGgoYSk7XG4gIHJldHVybiBNYXRoLnJvdW5kKChvIC0gbCkgLyBnMCk7XG59XG5mdW5jdGlvbiBzdyhlLCB0KSB7XG4gIGNvbnN0IG4gPSBIdChlLCB2b2lkIDApO1xuICByZXR1cm4gbi5zZXRGdWxsWWVhcihuLmdldEZ1bGxZZWFyKCksIDAsIDEpLCBuLnNldEhvdXJzKDAsIDAsIDAsIDApLCBuO1xufVxuZnVuY3Rpb24gYXcoZSwgdCkge1xuICBjb25zdCBuID0gSHQoZSwgdm9pZCAwKTtcbiAgcmV0dXJuIFVtKG4sIHN3KG4pKSArIDE7XG59XG5mdW5jdGlvbiB5YShlLCB0KSB7XG4gIHJldHVybiBXaShlLCB7IC4uLnQsIHdlZWtTdGFydHNPbjogMSB9KTtcbn1cbmZ1bmN0aW9uIEJtKGUsIHQpIHtcbiAgY29uc3QgbiA9IEh0KGUsIHZvaWQgMCksIHIgPSBuLmdldEZ1bGxZZWFyKCksIGkgPSBMZShuLCAwKTtcbiAgaS5zZXRGdWxsWWVhcihyICsgMSwgMCwgNCksIGkuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIGNvbnN0IHMgPSB5YShpKSwgYSA9IExlKG4sIDApO1xuICBhLnNldEZ1bGxZZWFyKHIsIDAsIDQpLCBhLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICBjb25zdCBvID0geWEoYSk7XG4gIHJldHVybiBuLmdldFRpbWUoKSA+PSBzLmdldFRpbWUoKSA/IHIgKyAxIDogbi5nZXRUaW1lKCkgPj0gby5nZXRUaW1lKCkgPyByIDogciAtIDE7XG59XG5mdW5jdGlvbiBvdyhlLCB0KSB7XG4gIGNvbnN0IG4gPSBCbShlKSwgciA9IExlKGUsIDApO1xuICByZXR1cm4gci5zZXRGdWxsWWVhcihuLCAwLCA0KSwgci5zZXRIb3VycygwLCAwLCAwLCAwKSwgeWEocik7XG59XG5mdW5jdGlvbiBsdyhlLCB0KSB7XG4gIGNvbnN0IG4gPSBIdChlLCB2b2lkIDApLCByID0gK3lhKG4pIC0gK293KG4pO1xuICByZXR1cm4gTWF0aC5yb3VuZChyIC8gY2YpICsgMTtcbn1cbmZ1bmN0aW9uIEhtKGUsIHQpIHtcbiAgdmFyIG4sIHIsIGksIHM7XG4gIGNvbnN0IGEgPSBIdChlLCB0ID09IG51bGwgPyB2b2lkIDAgOiB0LmluKSwgbyA9IGEuZ2V0RnVsbFllYXIoKSwgbCA9IHphKCksIGMgPSAodCA9PSBudWxsID8gdm9pZCAwIDogdC5maXJzdFdlZWtDb250YWluc0RhdGUpID8/ICgociA9IChuID0gdCA9PSBudWxsID8gdm9pZCAwIDogdC5sb2NhbGUpID09IG51bGwgPyB2b2lkIDAgOiBuLm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiByLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSkgPz8gbC5maXJzdFdlZWtDb250YWluc0RhdGUgPz8gKChzID0gKGkgPSBsLmxvY2FsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGkub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IHMuZmlyc3RXZWVrQ29udGFpbnNEYXRlKSA/PyAxLCB1ID0gTGUoKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuaW4pIHx8IGUsIDApO1xuICB1LnNldEZ1bGxZZWFyKG8gKyAxLCAwLCBjKSwgdS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgY29uc3QgZCA9IFdpKHUsIHQpLCBoID0gTGUoKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuaW4pIHx8IGUsIDApO1xuICBoLnNldEZ1bGxZZWFyKG8sIDAsIGMpLCBoLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICBjb25zdCBwID0gV2koaCwgdCk7XG4gIHJldHVybiArYSA+PSArZCA/IG8gKyAxIDogK2EgPj0gK3AgPyBvIDogbyAtIDE7XG59XG5mdW5jdGlvbiBjdyhlLCB0KSB7XG4gIHZhciBuLCByLCBpLCBzO1xuICBjb25zdCBhID0gemEoKSwgbyA9ICh0ID09IG51bGwgPyB2b2lkIDAgOiB0LmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSkgPz8gKChyID0gKG4gPSB0ID09IG51bGwgPyB2b2lkIDAgOiB0LmxvY2FsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IG4ub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IHIuZmlyc3RXZWVrQ29udGFpbnNEYXRlKSA/PyBhLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA/PyAoKHMgPSAoaSA9IGEubG9jYWxlKSA9PSBudWxsID8gdm9pZCAwIDogaS5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogcy5maXJzdFdlZWtDb250YWluc0RhdGUpID8/IDEsIGwgPSBIbShlLCB0KSwgYyA9IExlKCh0ID09IG51bGwgPyB2b2lkIDAgOiB0LmluKSB8fCBlLCAwKTtcbiAgcmV0dXJuIGMuc2V0RnVsbFllYXIobCwgMCwgbyksIGMuc2V0SG91cnMoMCwgMCwgMCwgMCksIFdpKGMsIHQpO1xufVxuZnVuY3Rpb24gdXcoZSwgdCkge1xuICBjb25zdCBuID0gSHQoZSwgdCA9PSBudWxsID8gdm9pZCAwIDogdC5pbiksIHIgPSArV2kobiwgdCkgLSArY3cobiwgdCk7XG4gIHJldHVybiBNYXRoLnJvdW5kKHIgLyBjZikgKyAxO1xufVxuZnVuY3Rpb24gRXQoZSwgdCkge1xuICBjb25zdCBuID0gZSA8IDAgPyBcIi1cIiA6IFwiXCIsIHIgPSBNYXRoLmFicyhlKS50b1N0cmluZygpLnBhZFN0YXJ0KHQsIFwiMFwiKTtcbiAgcmV0dXJuIG4gKyByO1xufVxuY29uc3QgUm4gPSB7XG4gIC8vIFllYXJcbiAgeShlLCB0KSB7XG4gICAgY29uc3QgbiA9IGUuZ2V0RnVsbFllYXIoKSwgciA9IG4gPiAwID8gbiA6IDEgLSBuO1xuICAgIHJldHVybiBFdCh0ID09PSBcInl5XCIgPyByICUgMTAwIDogciwgdC5sZW5ndGgpO1xuICB9LFxuICAvLyBNb250aFxuICBNKGUsIHQpIHtcbiAgICBjb25zdCBuID0gZS5nZXRNb250aCgpO1xuICAgIHJldHVybiB0ID09PSBcIk1cIiA/IFN0cmluZyhuICsgMSkgOiBFdChuICsgMSwgMik7XG4gIH0sXG4gIC8vIERheSBvZiB0aGUgbW9udGhcbiAgZChlLCB0KSB7XG4gICAgcmV0dXJuIEV0KGUuZ2V0RGF0ZSgpLCB0Lmxlbmd0aCk7XG4gIH0sXG4gIC8vIEFNIG9yIFBNXG4gIGEoZSwgdCkge1xuICAgIGNvbnN0IG4gPSBlLmdldEhvdXJzKCkgLyAxMiA+PSAxID8gXCJwbVwiIDogXCJhbVwiO1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgY2FzZSBcImFcIjpcbiAgICAgIGNhc2UgXCJhYVwiOlxuICAgICAgICByZXR1cm4gbi50b1VwcGVyQ2FzZSgpO1xuICAgICAgY2FzZSBcImFhYVwiOlxuICAgICAgICByZXR1cm4gbjtcbiAgICAgIGNhc2UgXCJhYWFhYVwiOlxuICAgICAgICByZXR1cm4gblswXTtcbiAgICAgIGNhc2UgXCJhYWFhXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbiA9PT0gXCJhbVwiID8gXCJhLm0uXCIgOiBcInAubS5cIjtcbiAgICB9XG4gIH0sXG4gIC8vIEhvdXIgWzEtMTJdXG4gIGgoZSwgdCkge1xuICAgIHJldHVybiBFdChlLmdldEhvdXJzKCkgJSAxMiB8fCAxMiwgdC5sZW5ndGgpO1xuICB9LFxuICAvLyBIb3VyIFswLTIzXVxuICBIKGUsIHQpIHtcbiAgICByZXR1cm4gRXQoZS5nZXRIb3VycygpLCB0Lmxlbmd0aCk7XG4gIH0sXG4gIC8vIE1pbnV0ZVxuICBtKGUsIHQpIHtcbiAgICByZXR1cm4gRXQoZS5nZXRNaW51dGVzKCksIHQubGVuZ3RoKTtcbiAgfSxcbiAgLy8gU2Vjb25kXG4gIHMoZSwgdCkge1xuICAgIHJldHVybiBFdChlLmdldFNlY29uZHMoKSwgdC5sZW5ndGgpO1xuICB9LFxuICAvLyBGcmFjdGlvbiBvZiBzZWNvbmRcbiAgUyhlLCB0KSB7XG4gICAgY29uc3QgbiA9IHQubGVuZ3RoLCByID0gZS5nZXRNaWxsaXNlY29uZHMoKSwgaSA9IE1hdGgudHJ1bmMoXG4gICAgICByICogTWF0aC5wb3coMTAsIG4gLSAzKVxuICAgICk7XG4gICAgcmV0dXJuIEV0KGksIHQubGVuZ3RoKTtcbiAgfVxufSwgT3IgPSB7XG4gIG1pZG5pZ2h0OiBcIm1pZG5pZ2h0XCIsXG4gIG5vb246IFwibm9vblwiLFxuICBtb3JuaW5nOiBcIm1vcm5pbmdcIixcbiAgYWZ0ZXJub29uOiBcImFmdGVybm9vblwiLFxuICBldmVuaW5nOiBcImV2ZW5pbmdcIixcbiAgbmlnaHQ6IFwibmlnaHRcIlxufSwgQmggPSB7XG4gIC8vIEVyYVxuICBHOiBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgY29uc3QgciA9IGUuZ2V0RnVsbFllYXIoKSA+IDAgPyAxIDogMDtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIC8vIEFELCBCQ1xuICAgICAgY2FzZSBcIkdcIjpcbiAgICAgIGNhc2UgXCJHR1wiOlxuICAgICAgY2FzZSBcIkdHR1wiOlxuICAgICAgICByZXR1cm4gbi5lcmEociwgeyB3aWR0aDogXCJhYmJyZXZpYXRlZFwiIH0pO1xuICAgICAgLy8gQSwgQlxuICAgICAgY2FzZSBcIkdHR0dHXCI6XG4gICAgICAgIHJldHVybiBuLmVyYShyLCB7IHdpZHRoOiBcIm5hcnJvd1wiIH0pO1xuICAgICAgLy8gQW5ubyBEb21pbmksIEJlZm9yZSBDaHJpc3RcbiAgICAgIGNhc2UgXCJHR0dHXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbi5lcmEociwgeyB3aWR0aDogXCJ3aWRlXCIgfSk7XG4gICAgfVxuICB9LFxuICAvLyBZZWFyXG4gIHk6IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICBpZiAodCA9PT0gXCJ5b1wiKSB7XG4gICAgICBjb25zdCByID0gZS5nZXRGdWxsWWVhcigpLCBpID0gciA+IDAgPyByIDogMSAtIHI7XG4gICAgICByZXR1cm4gbi5vcmRpbmFsTnVtYmVyKGksIHsgdW5pdDogXCJ5ZWFyXCIgfSk7XG4gICAgfVxuICAgIHJldHVybiBSbi55KGUsIHQpO1xuICB9LFxuICAvLyBMb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gIFk6IGZ1bmN0aW9uKGUsIHQsIG4sIHIpIHtcbiAgICBjb25zdCBpID0gSG0oZSwgciksIHMgPSBpID4gMCA/IGkgOiAxIC0gaTtcbiAgICBpZiAodCA9PT0gXCJZWVwiKSB7XG4gICAgICBjb25zdCBhID0gcyAlIDEwMDtcbiAgICAgIHJldHVybiBFdChhLCAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHQgPT09IFwiWW9cIiA/IG4ub3JkaW5hbE51bWJlcihzLCB7IHVuaXQ6IFwieWVhclwiIH0pIDogRXQocywgdC5sZW5ndGgpO1xuICB9LFxuICAvLyBJU08gd2Vlay1udW1iZXJpbmcgeWVhclxuICBSOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgY29uc3QgbiA9IEJtKGUpO1xuICAgIHJldHVybiBFdChuLCB0Lmxlbmd0aCk7XG4gIH0sXG4gIC8vIEV4dGVuZGVkIHllYXIuIFRoaXMgaXMgYSBzaW5nbGUgbnVtYmVyIGRlc2lnbmF0aW5nIHRoZSB5ZWFyIG9mIHRoaXMgY2FsZW5kYXIgc3lzdGVtLlxuICAvLyBUaGUgbWFpbiBkaWZmZXJlbmNlIGJldHdlZW4gYHlgIGFuZCBgdWAgbG9jYWxpemVycyBhcmUgQi5DLiB5ZWFyczpcbiAgLy8gfCBZZWFyIHwgYHlgIHwgYHVgIHxcbiAgLy8gfC0tLS0tLXwtLS0tLXwtLS0tLXxcbiAgLy8gfCBBQyAxIHwgICAxIHwgICAxIHxcbiAgLy8gfCBCQyAxIHwgICAxIHwgICAwIHxcbiAgLy8gfCBCQyAyIHwgICAyIHwgIC0xIHxcbiAgLy8gQWxzbyBgeXlgIGFsd2F5cyByZXR1cm5zIHRoZSBsYXN0IHR3byBkaWdpdHMgb2YgYSB5ZWFyLFxuICAvLyB3aGlsZSBgdXVgIHBhZHMgc2luZ2xlIGRpZ2l0IHllYXJzIHRvIDIgY2hhcmFjdGVycyBhbmQgcmV0dXJucyBvdGhlciB5ZWFycyB1bmNoYW5nZWQuXG4gIHU6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBjb25zdCBuID0gZS5nZXRGdWxsWWVhcigpO1xuICAgIHJldHVybiBFdChuLCB0Lmxlbmd0aCk7XG4gIH0sXG4gIC8vIFF1YXJ0ZXJcbiAgUTogZnVuY3Rpb24oZSwgdCwgbikge1xuICAgIGNvbnN0IHIgPSBNYXRoLmNlaWwoKGUuZ2V0TW9udGgoKSArIDEpIC8gMyk7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICAvLyAxLCAyLCAzLCA0XG4gICAgICBjYXNlIFwiUVwiOlxuICAgICAgICByZXR1cm4gU3RyaW5nKHIpO1xuICAgICAgLy8gMDEsIDAyLCAwMywgMDRcbiAgICAgIGNhc2UgXCJRUVwiOlxuICAgICAgICByZXR1cm4gRXQociwgMik7XG4gICAgICAvLyAxc3QsIDJuZCwgM3JkLCA0dGhcbiAgICAgIGNhc2UgXCJRb1wiOlxuICAgICAgICByZXR1cm4gbi5vcmRpbmFsTnVtYmVyKHIsIHsgdW5pdDogXCJxdWFydGVyXCIgfSk7XG4gICAgICAvLyBRMSwgUTIsIFEzLCBRNFxuICAgICAgY2FzZSBcIlFRUVwiOlxuICAgICAgICByZXR1cm4gbi5xdWFydGVyKHIsIHtcbiAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiXG4gICAgICAgIH0pO1xuICAgICAgLy8gMSwgMiwgMywgNCAobmFycm93IHF1YXJ0ZXI7IGNvdWxkIGJlIG5vdCBudW1lcmljYWwpXG4gICAgICBjYXNlIFwiUVFRUVFcIjpcbiAgICAgICAgcmV0dXJuIG4ucXVhcnRlcihyLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCJcbiAgICAgICAgfSk7XG4gICAgICAvLyAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLlxuICAgICAgY2FzZSBcIlFRUVFcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuLnF1YXJ0ZXIociwge1xuICAgICAgICAgIHdpZHRoOiBcIndpZGVcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIlxuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIFN0YW5kLWFsb25lIHF1YXJ0ZXJcbiAgcTogZnVuY3Rpb24oZSwgdCwgbikge1xuICAgIGNvbnN0IHIgPSBNYXRoLmNlaWwoKGUuZ2V0TW9udGgoKSArIDEpIC8gMyk7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICAvLyAxLCAyLCAzLCA0XG4gICAgICBjYXNlIFwicVwiOlxuICAgICAgICByZXR1cm4gU3RyaW5nKHIpO1xuICAgICAgLy8gMDEsIDAyLCAwMywgMDRcbiAgICAgIGNhc2UgXCJxcVwiOlxuICAgICAgICByZXR1cm4gRXQociwgMik7XG4gICAgICAvLyAxc3QsIDJuZCwgM3JkLCA0dGhcbiAgICAgIGNhc2UgXCJxb1wiOlxuICAgICAgICByZXR1cm4gbi5vcmRpbmFsTnVtYmVyKHIsIHsgdW5pdDogXCJxdWFydGVyXCIgfSk7XG4gICAgICAvLyBRMSwgUTIsIFEzLCBRNFxuICAgICAgY2FzZSBcInFxcVwiOlxuICAgICAgICByZXR1cm4gbi5xdWFydGVyKHIsIHtcbiAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwic3RhbmRhbG9uZVwiXG4gICAgICAgIH0pO1xuICAgICAgLy8gMSwgMiwgMywgNCAobmFycm93IHF1YXJ0ZXI7IGNvdWxkIGJlIG5vdCBudW1lcmljYWwpXG4gICAgICBjYXNlIFwicXFxcXFcIjpcbiAgICAgICAgcmV0dXJuIG4ucXVhcnRlcihyLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJzdGFuZGFsb25lXCJcbiAgICAgICAgfSk7XG4gICAgICAvLyAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLlxuICAgICAgY2FzZSBcInFxcXFcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuLnF1YXJ0ZXIociwge1xuICAgICAgICAgIHdpZHRoOiBcIndpZGVcIixcbiAgICAgICAgICBjb250ZXh0OiBcInN0YW5kYWxvbmVcIlxuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIE1vbnRoXG4gIE06IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICBjb25zdCByID0gZS5nZXRNb250aCgpO1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgY2FzZSBcIk1cIjpcbiAgICAgIGNhc2UgXCJNTVwiOlxuICAgICAgICByZXR1cm4gUm4uTShlLCB0KTtcbiAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDEydGhcbiAgICAgIGNhc2UgXCJNb1wiOlxuICAgICAgICByZXR1cm4gbi5vcmRpbmFsTnVtYmVyKHIgKyAxLCB7IHVuaXQ6IFwibW9udGhcIiB9KTtcbiAgICAgIC8vIEphbiwgRmViLCAuLi4sIERlY1xuICAgICAgY2FzZSBcIk1NTVwiOlxuICAgICAgICByZXR1cm4gbi5tb250aChyLCB7XG4gICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIlxuICAgICAgICB9KTtcbiAgICAgIC8vIEosIEYsIC4uLiwgRFxuICAgICAgY2FzZSBcIk1NTU1NXCI6XG4gICAgICAgIHJldHVybiBuLm1vbnRoKHIsIHtcbiAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIlxuICAgICAgICB9KTtcbiAgICAgIC8vIEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyXG4gICAgICBjYXNlIFwiTU1NTVwiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG4ubW9udGgociwgeyB3aWR0aDogXCJ3aWRlXCIsIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gU3RhbmQtYWxvbmUgbW9udGhcbiAgTDogZnVuY3Rpb24oZSwgdCwgbikge1xuICAgIGNvbnN0IHIgPSBlLmdldE1vbnRoKCk7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICAvLyAxLCAyLCAuLi4sIDEyXG4gICAgICBjYXNlIFwiTFwiOlxuICAgICAgICByZXR1cm4gU3RyaW5nKHIgKyAxKTtcbiAgICAgIC8vIDAxLCAwMiwgLi4uLCAxMlxuICAgICAgY2FzZSBcIkxMXCI6XG4gICAgICAgIHJldHVybiBFdChyICsgMSwgMik7XG4gICAgICAvLyAxc3QsIDJuZCwgLi4uLCAxMnRoXG4gICAgICBjYXNlIFwiTG9cIjpcbiAgICAgICAgcmV0dXJuIG4ub3JkaW5hbE51bWJlcihyICsgMSwgeyB1bml0OiBcIm1vbnRoXCIgfSk7XG4gICAgICAvLyBKYW4sIEZlYiwgLi4uLCBEZWNcbiAgICAgIGNhc2UgXCJMTExcIjpcbiAgICAgICAgcmV0dXJuIG4ubW9udGgociwge1xuICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgY29udGV4dDogXCJzdGFuZGFsb25lXCJcbiAgICAgICAgfSk7XG4gICAgICAvLyBKLCBGLCAuLi4sIERcbiAgICAgIGNhc2UgXCJMTExMTFwiOlxuICAgICAgICByZXR1cm4gbi5tb250aChyLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJzdGFuZGFsb25lXCJcbiAgICAgICAgfSk7XG4gICAgICAvLyBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlclxuICAgICAgY2FzZSBcIkxMTExcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuLm1vbnRoKHIsIHsgd2lkdGg6IFwid2lkZVwiLCBjb250ZXh0OiBcInN0YW5kYWxvbmVcIiB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIExvY2FsIHdlZWsgb2YgeWVhclxuICB3OiBmdW5jdGlvbihlLCB0LCBuLCByKSB7XG4gICAgY29uc3QgaSA9IHV3KGUsIHIpO1xuICAgIHJldHVybiB0ID09PSBcIndvXCIgPyBuLm9yZGluYWxOdW1iZXIoaSwgeyB1bml0OiBcIndlZWtcIiB9KSA6IEV0KGksIHQubGVuZ3RoKTtcbiAgfSxcbiAgLy8gSVNPIHdlZWsgb2YgeWVhclxuICBJOiBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgY29uc3QgciA9IGx3KGUpO1xuICAgIHJldHVybiB0ID09PSBcIklvXCIgPyBuLm9yZGluYWxOdW1iZXIociwgeyB1bml0OiBcIndlZWtcIiB9KSA6IEV0KHIsIHQubGVuZ3RoKTtcbiAgfSxcbiAgLy8gRGF5IG9mIHRoZSBtb250aFxuICBkOiBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgcmV0dXJuIHQgPT09IFwiZG9cIiA/IG4ub3JkaW5hbE51bWJlcihlLmdldERhdGUoKSwgeyB1bml0OiBcImRhdGVcIiB9KSA6IFJuLmQoZSwgdCk7XG4gIH0sXG4gIC8vIERheSBvZiB5ZWFyXG4gIEQ6IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICBjb25zdCByID0gYXcoZSk7XG4gICAgcmV0dXJuIHQgPT09IFwiRG9cIiA/IG4ub3JkaW5hbE51bWJlcihyLCB7IHVuaXQ6IFwiZGF5T2ZZZWFyXCIgfSkgOiBFdChyLCB0Lmxlbmd0aCk7XG4gIH0sXG4gIC8vIERheSBvZiB3ZWVrXG4gIEU6IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICBjb25zdCByID0gZS5nZXREYXkoKTtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIC8vIFR1ZVxuICAgICAgY2FzZSBcIkVcIjpcbiAgICAgIGNhc2UgXCJFRVwiOlxuICAgICAgY2FzZSBcIkVFRVwiOlxuICAgICAgICByZXR1cm4gbi5kYXkociwge1xuICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCJcbiAgICAgICAgfSk7XG4gICAgICAvLyBUXG4gICAgICBjYXNlIFwiRUVFRUVcIjpcbiAgICAgICAgcmV0dXJuIG4uZGF5KHIsIHtcbiAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIlxuICAgICAgICB9KTtcbiAgICAgIC8vIFR1XG4gICAgICBjYXNlIFwiRUVFRUVFXCI6XG4gICAgICAgIHJldHVybiBuLmRheShyLCB7XG4gICAgICAgICAgd2lkdGg6IFwic2hvcnRcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIlxuICAgICAgICB9KTtcbiAgICAgIC8vIFR1ZXNkYXlcbiAgICAgIGNhc2UgXCJFRUVFXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbi5kYXkociwge1xuICAgICAgICAgIHdpZHRoOiBcIndpZGVcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIlxuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIExvY2FsIGRheSBvZiB3ZWVrXG4gIGU6IGZ1bmN0aW9uKGUsIHQsIG4sIHIpIHtcbiAgICBjb25zdCBpID0gZS5nZXREYXkoKSwgcyA9IChpIC0gci53ZWVrU3RhcnRzT24gKyA4KSAlIDcgfHwgNztcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIC8vIE51bWVyaWNhbCB2YWx1ZSAoTnRoIGRheSBvZiB3ZWVrIHdpdGggY3VycmVudCBsb2NhbGUgb3Igd2Vla1N0YXJ0c09uKVxuICAgICAgY2FzZSBcImVcIjpcbiAgICAgICAgcmV0dXJuIFN0cmluZyhzKTtcbiAgICAgIC8vIFBhZGRlZCBudW1lcmljYWwgdmFsdWVcbiAgICAgIGNhc2UgXCJlZVwiOlxuICAgICAgICByZXR1cm4gRXQocywgMik7XG4gICAgICAvLyAxc3QsIDJuZCwgLi4uLCA3dGhcbiAgICAgIGNhc2UgXCJlb1wiOlxuICAgICAgICByZXR1cm4gbi5vcmRpbmFsTnVtYmVyKHMsIHsgdW5pdDogXCJkYXlcIiB9KTtcbiAgICAgIGNhc2UgXCJlZWVcIjpcbiAgICAgICAgcmV0dXJuIG4uZGF5KGksIHtcbiAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiXG4gICAgICAgIH0pO1xuICAgICAgLy8gVFxuICAgICAgY2FzZSBcImVlZWVlXCI6XG4gICAgICAgIHJldHVybiBuLmRheShpLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCJcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdVxuICAgICAgY2FzZSBcImVlZWVlZVwiOlxuICAgICAgICByZXR1cm4gbi5kYXkoaSwge1xuICAgICAgICAgIHdpZHRoOiBcInNob3J0XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCJcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdWVzZGF5XG4gICAgICBjYXNlIFwiZWVlZVwiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG4uZGF5KGksIHtcbiAgICAgICAgICB3aWR0aDogXCJ3aWRlXCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBTdGFuZC1hbG9uZSBsb2NhbCBkYXkgb2Ygd2Vla1xuICBjOiBmdW5jdGlvbihlLCB0LCBuLCByKSB7XG4gICAgY29uc3QgaSA9IGUuZ2V0RGF5KCksIHMgPSAoaSAtIHIud2Vla1N0YXJ0c09uICsgOCkgJSA3IHx8IDc7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICAvLyBOdW1lcmljYWwgdmFsdWUgKHNhbWUgYXMgaW4gYGVgKVxuICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgcmV0dXJuIFN0cmluZyhzKTtcbiAgICAgIC8vIFBhZGRlZCBudW1lcmljYWwgdmFsdWVcbiAgICAgIGNhc2UgXCJjY1wiOlxuICAgICAgICByZXR1cm4gRXQocywgdC5sZW5ndGgpO1xuICAgICAgLy8gMXN0LCAybmQsIC4uLiwgN3RoXG4gICAgICBjYXNlIFwiY29cIjpcbiAgICAgICAgcmV0dXJuIG4ub3JkaW5hbE51bWJlcihzLCB7IHVuaXQ6IFwiZGF5XCIgfSk7XG4gICAgICBjYXNlIFwiY2NjXCI6XG4gICAgICAgIHJldHVybiBuLmRheShpLCB7XG4gICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICBjb250ZXh0OiBcInN0YW5kYWxvbmVcIlxuICAgICAgICB9KTtcbiAgICAgIC8vIFRcbiAgICAgIGNhc2UgXCJjY2NjY1wiOlxuICAgICAgICByZXR1cm4gbi5kYXkoaSwge1xuICAgICAgICAgIHdpZHRoOiBcIm5hcnJvd1wiLFxuICAgICAgICAgIGNvbnRleHQ6IFwic3RhbmRhbG9uZVwiXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVcbiAgICAgIGNhc2UgXCJjY2NjY2NcIjpcbiAgICAgICAgcmV0dXJuIG4uZGF5KGksIHtcbiAgICAgICAgICB3aWR0aDogXCJzaG9ydFwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwic3RhbmRhbG9uZVwiXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVlc2RheVxuICAgICAgY2FzZSBcImNjY2NcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuLmRheShpLCB7XG4gICAgICAgICAgd2lkdGg6IFwid2lkZVwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwic3RhbmRhbG9uZVwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gSVNPIGRheSBvZiB3ZWVrXG4gIGk6IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICBjb25zdCByID0gZS5nZXREYXkoKSwgaSA9IHIgPT09IDAgPyA3IDogcjtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIC8vIDJcbiAgICAgIGNhc2UgXCJpXCI6XG4gICAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgICAvLyAwMlxuICAgICAgY2FzZSBcImlpXCI6XG4gICAgICAgIHJldHVybiBFdChpLCB0Lmxlbmd0aCk7XG4gICAgICAvLyAybmRcbiAgICAgIGNhc2UgXCJpb1wiOlxuICAgICAgICByZXR1cm4gbi5vcmRpbmFsTnVtYmVyKGksIHsgdW5pdDogXCJkYXlcIiB9KTtcbiAgICAgIC8vIFR1ZVxuICAgICAgY2FzZSBcImlpaVwiOlxuICAgICAgICByZXR1cm4gbi5kYXkociwge1xuICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCJcbiAgICAgICAgfSk7XG4gICAgICAvLyBUXG4gICAgICBjYXNlIFwiaWlpaWlcIjpcbiAgICAgICAgcmV0dXJuIG4uZGF5KHIsIHtcbiAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIlxuICAgICAgICB9KTtcbiAgICAgIC8vIFR1XG4gICAgICBjYXNlIFwiaWlpaWlpXCI6XG4gICAgICAgIHJldHVybiBuLmRheShyLCB7XG4gICAgICAgICAgd2lkdGg6IFwic2hvcnRcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIlxuICAgICAgICB9KTtcbiAgICAgIC8vIFR1ZXNkYXlcbiAgICAgIGNhc2UgXCJpaWlpXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbi5kYXkociwge1xuICAgICAgICAgIHdpZHRoOiBcIndpZGVcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIlxuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIEFNIG9yIFBNXG4gIGE6IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICBjb25zdCByID0gZS5nZXRIb3VycygpIC8gMTIgPj0gMSA/IFwicG1cIiA6IFwiYW1cIjtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIGNhc2UgXCJhXCI6XG4gICAgICBjYXNlIFwiYWFcIjpcbiAgICAgICAgcmV0dXJuIG4uZGF5UGVyaW9kKHIsIHtcbiAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBcImFhYVwiOlxuICAgICAgICByZXR1cm4gbi5kYXlQZXJpb2Qociwge1xuICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCJcbiAgICAgICAgfSkudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNhc2UgXCJhYWFhYVwiOlxuICAgICAgICByZXR1cm4gbi5kYXlQZXJpb2Qociwge1xuICAgICAgICAgIHdpZHRoOiBcIm5hcnJvd1wiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBcImFhYWFcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuLmRheVBlcmlvZChyLCB7XG4gICAgICAgICAgd2lkdGg6IFwid2lkZVwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gQU0sIFBNLCBtaWRuaWdodCwgbm9vblxuICBiOiBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgY29uc3QgciA9IGUuZ2V0SG91cnMoKTtcbiAgICBsZXQgaTtcbiAgICBzd2l0Y2ggKHIgPT09IDEyID8gaSA9IE9yLm5vb24gOiByID09PSAwID8gaSA9IE9yLm1pZG5pZ2h0IDogaSA9IHIgLyAxMiA+PSAxID8gXCJwbVwiIDogXCJhbVwiLCB0KSB7XG4gICAgICBjYXNlIFwiYlwiOlxuICAgICAgY2FzZSBcImJiXCI6XG4gICAgICAgIHJldHVybiBuLmRheVBlcmlvZChpLCB7XG4gICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIlxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJiYmJcIjpcbiAgICAgICAgcmV0dXJuIG4uZGF5UGVyaW9kKGksIHtcbiAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiXG4gICAgICAgIH0pLnRvTG93ZXJDYXNlKCk7XG4gICAgICBjYXNlIFwiYmJiYmJcIjpcbiAgICAgICAgcmV0dXJuIG4uZGF5UGVyaW9kKGksIHtcbiAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIlxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJiYmJiXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbi5kYXlQZXJpb2QoaSwge1xuICAgICAgICAgIHdpZHRoOiBcIndpZGVcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIlxuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIGluIHRoZSBtb3JuaW5nLCBpbiB0aGUgYWZ0ZXJub29uLCBpbiB0aGUgZXZlbmluZywgYXQgbmlnaHRcbiAgQjogZnVuY3Rpb24oZSwgdCwgbikge1xuICAgIGNvbnN0IHIgPSBlLmdldEhvdXJzKCk7XG4gICAgbGV0IGk7XG4gICAgc3dpdGNoIChyID49IDE3ID8gaSA9IE9yLmV2ZW5pbmcgOiByID49IDEyID8gaSA9IE9yLmFmdGVybm9vbiA6IHIgPj0gNCA/IGkgPSBPci5tb3JuaW5nIDogaSA9IE9yLm5pZ2h0LCB0KSB7XG4gICAgICBjYXNlIFwiQlwiOlxuICAgICAgY2FzZSBcIkJCXCI6XG4gICAgICBjYXNlIFwiQkJCXCI6XG4gICAgICAgIHJldHVybiBuLmRheVBlcmlvZChpLCB7XG4gICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIlxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJCQkJCQlwiOlxuICAgICAgICByZXR1cm4gbi5kYXlQZXJpb2QoaSwge1xuICAgICAgICAgIHdpZHRoOiBcIm5hcnJvd1wiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBcIkJCQkJcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuLmRheVBlcmlvZChpLCB7XG4gICAgICAgICAgd2lkdGg6IFwid2lkZVwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gSG91ciBbMS0xMl1cbiAgaDogZnVuY3Rpb24oZSwgdCwgbikge1xuICAgIGlmICh0ID09PSBcImhvXCIpIHtcbiAgICAgIGxldCByID0gZS5nZXRIb3VycygpICUgMTI7XG4gICAgICByZXR1cm4gciA9PT0gMCAmJiAociA9IDEyKSwgbi5vcmRpbmFsTnVtYmVyKHIsIHsgdW5pdDogXCJob3VyXCIgfSk7XG4gICAgfVxuICAgIHJldHVybiBSbi5oKGUsIHQpO1xuICB9LFxuICAvLyBIb3VyIFswLTIzXVxuICBIOiBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgcmV0dXJuIHQgPT09IFwiSG9cIiA/IG4ub3JkaW5hbE51bWJlcihlLmdldEhvdXJzKCksIHsgdW5pdDogXCJob3VyXCIgfSkgOiBSbi5IKGUsIHQpO1xuICB9LFxuICAvLyBIb3VyIFswLTExXVxuICBLOiBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgY29uc3QgciA9IGUuZ2V0SG91cnMoKSAlIDEyO1xuICAgIHJldHVybiB0ID09PSBcIktvXCIgPyBuLm9yZGluYWxOdW1iZXIociwgeyB1bml0OiBcImhvdXJcIiB9KSA6IEV0KHIsIHQubGVuZ3RoKTtcbiAgfSxcbiAgLy8gSG91ciBbMS0yNF1cbiAgazogZnVuY3Rpb24oZSwgdCwgbikge1xuICAgIGxldCByID0gZS5nZXRIb3VycygpO1xuICAgIHJldHVybiByID09PSAwICYmIChyID0gMjQpLCB0ID09PSBcImtvXCIgPyBuLm9yZGluYWxOdW1iZXIociwgeyB1bml0OiBcImhvdXJcIiB9KSA6IEV0KHIsIHQubGVuZ3RoKTtcbiAgfSxcbiAgLy8gTWludXRlXG4gIG06IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICByZXR1cm4gdCA9PT0gXCJtb1wiID8gbi5vcmRpbmFsTnVtYmVyKGUuZ2V0TWludXRlcygpLCB7IHVuaXQ6IFwibWludXRlXCIgfSkgOiBSbi5tKGUsIHQpO1xuICB9LFxuICAvLyBTZWNvbmRcbiAgczogZnVuY3Rpb24oZSwgdCwgbikge1xuICAgIHJldHVybiB0ID09PSBcInNvXCIgPyBuLm9yZGluYWxOdW1iZXIoZS5nZXRTZWNvbmRzKCksIHsgdW5pdDogXCJzZWNvbmRcIiB9KSA6IFJuLnMoZSwgdCk7XG4gIH0sXG4gIC8vIEZyYWN0aW9uIG9mIHNlY29uZFxuICBTOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgcmV0dXJuIFJuLlMoZSwgdCk7XG4gIH0sXG4gIC8vIFRpbWV6b25lIChJU08tODYwMS4gSWYgb2Zmc2V0IGlzIDAsIG91dHB1dCBpcyBhbHdheXMgYCdaJ2ApXG4gIFg6IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICBjb25zdCByID0gZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgIGlmIChyID09PSAwKVxuICAgICAgcmV0dXJuIFwiWlwiO1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgLy8gSG91cnMgYW5kIG9wdGlvbmFsIG1pbnV0ZXNcbiAgICAgIGNhc2UgXCJYXCI6XG4gICAgICAgIHJldHVybiBWaChyKTtcbiAgICAgIC8vIEhvdXJzLCBtaW51dGVzIGFuZCBvcHRpb25hbCBzZWNvbmRzIHdpdGhvdXQgYDpgIGRlbGltaXRlclxuICAgICAgLy8gTm90ZTogbmVpdGhlciBJU08tODYwMSBub3IgSmF2YVNjcmlwdCBzdXBwb3J0cyBzZWNvbmRzIGluIHRpbWV6b25lIG9mZnNldHNcbiAgICAgIC8vIHNvIHRoaXMgdG9rZW4gYWx3YXlzIGhhcyB0aGUgc2FtZSBvdXRwdXQgYXMgYFhYYFxuICAgICAgY2FzZSBcIlhYWFhcIjpcbiAgICAgIGNhc2UgXCJYWFwiOlxuICAgICAgICByZXR1cm4gWW4ocik7XG4gICAgICAvLyBIb3VycywgbWludXRlcyBhbmQgb3B0aW9uYWwgc2Vjb25kcyB3aXRoIGA6YCBkZWxpbWl0ZXJcbiAgICAgIC8vIE5vdGU6IG5laXRoZXIgSVNPLTg2MDEgbm9yIEphdmFTY3JpcHQgc3VwcG9ydHMgc2Vjb25kcyBpbiB0aW1lem9uZSBvZmZzZXRzXG4gICAgICAvLyBzbyB0aGlzIHRva2VuIGFsd2F5cyBoYXMgdGhlIHNhbWUgb3V0cHV0IGFzIGBYWFhgXG4gICAgICBjYXNlIFwiWFhYWFhcIjpcbiAgICAgIGNhc2UgXCJYWFhcIjpcbiAgICAgIC8vIEhvdXJzIGFuZCBtaW51dGVzIHdpdGggYDpgIGRlbGltaXRlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFluKHIsIFwiOlwiKTtcbiAgICB9XG4gIH0sXG4gIC8vIFRpbWV6b25lIChJU08tODYwMS4gSWYgb2Zmc2V0IGlzIDAsIG91dHB1dCBpcyBgJyswMDowMCdgIG9yIGVxdWl2YWxlbnQpXG4gIHg6IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICBjb25zdCByID0gZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgLy8gSG91cnMgYW5kIG9wdGlvbmFsIG1pbnV0ZXNcbiAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgIHJldHVybiBWaChyKTtcbiAgICAgIC8vIEhvdXJzLCBtaW51dGVzIGFuZCBvcHRpb25hbCBzZWNvbmRzIHdpdGhvdXQgYDpgIGRlbGltaXRlclxuICAgICAgLy8gTm90ZTogbmVpdGhlciBJU08tODYwMSBub3IgSmF2YVNjcmlwdCBzdXBwb3J0cyBzZWNvbmRzIGluIHRpbWV6b25lIG9mZnNldHNcbiAgICAgIC8vIHNvIHRoaXMgdG9rZW4gYWx3YXlzIGhhcyB0aGUgc2FtZSBvdXRwdXQgYXMgYHh4YFxuICAgICAgY2FzZSBcInh4eHhcIjpcbiAgICAgIGNhc2UgXCJ4eFwiOlxuICAgICAgICByZXR1cm4gWW4ocik7XG4gICAgICAvLyBIb3VycywgbWludXRlcyBhbmQgb3B0aW9uYWwgc2Vjb25kcyB3aXRoIGA6YCBkZWxpbWl0ZXJcbiAgICAgIC8vIE5vdGU6IG5laXRoZXIgSVNPLTg2MDEgbm9yIEphdmFTY3JpcHQgc3VwcG9ydHMgc2Vjb25kcyBpbiB0aW1lem9uZSBvZmZzZXRzXG4gICAgICAvLyBzbyB0aGlzIHRva2VuIGFsd2F5cyBoYXMgdGhlIHNhbWUgb3V0cHV0IGFzIGB4eHhgXG4gICAgICBjYXNlIFwieHh4eHhcIjpcbiAgICAgIGNhc2UgXCJ4eHhcIjpcbiAgICAgIC8vIEhvdXJzIGFuZCBtaW51dGVzIHdpdGggYDpgIGRlbGltaXRlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFluKHIsIFwiOlwiKTtcbiAgICB9XG4gIH0sXG4gIC8vIFRpbWV6b25lIChHTVQpXG4gIE86IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICBjb25zdCByID0gZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgLy8gU2hvcnRcbiAgICAgIGNhc2UgXCJPXCI6XG4gICAgICBjYXNlIFwiT09cIjpcbiAgICAgIGNhc2UgXCJPT09cIjpcbiAgICAgICAgcmV0dXJuIFwiR01UXCIgKyBIaChyLCBcIjpcIik7XG4gICAgICAvLyBMb25nXG4gICAgICBjYXNlIFwiT09PT1wiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFwiR01UXCIgKyBZbihyLCBcIjpcIik7XG4gICAgfVxuICB9LFxuICAvLyBUaW1lem9uZSAoc3BlY2lmaWMgbm9uLWxvY2F0aW9uKVxuICB6OiBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgY29uc3QgciA9IGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIC8vIFNob3J0XG4gICAgICBjYXNlIFwielwiOlxuICAgICAgY2FzZSBcInp6XCI6XG4gICAgICBjYXNlIFwienp6XCI6XG4gICAgICAgIHJldHVybiBcIkdNVFwiICsgSGgociwgXCI6XCIpO1xuICAgICAgLy8gTG9uZ1xuICAgICAgY2FzZSBcInp6enpcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBcIkdNVFwiICsgWW4ociwgXCI6XCIpO1xuICAgIH1cbiAgfSxcbiAgLy8gU2Vjb25kcyB0aW1lc3RhbXBcbiAgdDogZnVuY3Rpb24oZSwgdCwgbikge1xuICAgIGNvbnN0IHIgPSBNYXRoLnRydW5jKCtlIC8gMWUzKTtcbiAgICByZXR1cm4gRXQociwgdC5sZW5ndGgpO1xuICB9LFxuICAvLyBNaWxsaXNlY29uZHMgdGltZXN0YW1wXG4gIFQ6IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICByZXR1cm4gRXQoK2UsIHQubGVuZ3RoKTtcbiAgfVxufTtcbmZ1bmN0aW9uIEhoKGUsIHQgPSBcIlwiKSB7XG4gIGNvbnN0IG4gPSBlID4gMCA/IFwiLVwiIDogXCIrXCIsIHIgPSBNYXRoLmFicyhlKSwgaSA9IE1hdGgudHJ1bmMociAvIDYwKSwgcyA9IHIgJSA2MDtcbiAgcmV0dXJuIHMgPT09IDAgPyBuICsgU3RyaW5nKGkpIDogbiArIFN0cmluZyhpKSArIHQgKyBFdChzLCAyKTtcbn1cbmZ1bmN0aW9uIFZoKGUsIHQpIHtcbiAgcmV0dXJuIGUgJSA2MCA9PT0gMCA/IChlID4gMCA/IFwiLVwiIDogXCIrXCIpICsgRXQoTWF0aC5hYnMoZSkgLyA2MCwgMikgOiBZbihlLCB0KTtcbn1cbmZ1bmN0aW9uIFluKGUsIHQgPSBcIlwiKSB7XG4gIGNvbnN0IG4gPSBlID4gMCA/IFwiLVwiIDogXCIrXCIsIHIgPSBNYXRoLmFicyhlKSwgaSA9IEV0KE1hdGgudHJ1bmMociAvIDYwKSwgMiksIHMgPSBFdChyICUgNjAsIDIpO1xuICByZXR1cm4gbiArIGkgKyB0ICsgcztcbn1cbmNvbnN0IEdoID0gKGUsIHQpID0+IHtcbiAgc3dpdGNoIChlKSB7XG4gICAgY2FzZSBcIlBcIjpcbiAgICAgIHJldHVybiB0LmRhdGUoeyB3aWR0aDogXCJzaG9ydFwiIH0pO1xuICAgIGNhc2UgXCJQUFwiOlxuICAgICAgcmV0dXJuIHQuZGF0ZSh7IHdpZHRoOiBcIm1lZGl1bVwiIH0pO1xuICAgIGNhc2UgXCJQUFBcIjpcbiAgICAgIHJldHVybiB0LmRhdGUoeyB3aWR0aDogXCJsb25nXCIgfSk7XG4gICAgY2FzZSBcIlBQUFBcIjpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHQuZGF0ZSh7IHdpZHRoOiBcImZ1bGxcIiB9KTtcbiAgfVxufSwgVm0gPSAoZSwgdCkgPT4ge1xuICBzd2l0Y2ggKGUpIHtcbiAgICBjYXNlIFwicFwiOlxuICAgICAgcmV0dXJuIHQudGltZSh7IHdpZHRoOiBcInNob3J0XCIgfSk7XG4gICAgY2FzZSBcInBwXCI6XG4gICAgICByZXR1cm4gdC50aW1lKHsgd2lkdGg6IFwibWVkaXVtXCIgfSk7XG4gICAgY2FzZSBcInBwcFwiOlxuICAgICAgcmV0dXJuIHQudGltZSh7IHdpZHRoOiBcImxvbmdcIiB9KTtcbiAgICBjYXNlIFwicHBwcFwiOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdC50aW1lKHsgd2lkdGg6IFwiZnVsbFwiIH0pO1xuICB9XG59LCBodyA9IChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBlLm1hdGNoKC8oUCspKHArKT8vKSB8fCBbXSwgciA9IG5bMV0sIGkgPSBuWzJdO1xuICBpZiAoIWkpXG4gICAgcmV0dXJuIEdoKGUsIHQpO1xuICBsZXQgcztcbiAgc3dpdGNoIChyKSB7XG4gICAgY2FzZSBcIlBcIjpcbiAgICAgIHMgPSB0LmRhdGVUaW1lKHsgd2lkdGg6IFwic2hvcnRcIiB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQUFwiOlxuICAgICAgcyA9IHQuZGF0ZVRpbWUoeyB3aWR0aDogXCJtZWRpdW1cIiB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQUFBcIjpcbiAgICAgIHMgPSB0LmRhdGVUaW1lKHsgd2lkdGg6IFwibG9uZ1wiIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlBQUFBcIjpcbiAgICBkZWZhdWx0OlxuICAgICAgcyA9IHQuZGF0ZVRpbWUoeyB3aWR0aDogXCJmdWxsXCIgfSk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gcy5yZXBsYWNlKFwie3tkYXRlfX1cIiwgR2gociwgdCkpLnJlcGxhY2UoXCJ7e3RpbWV9fVwiLCBWbShpLCB0KSk7XG59LCBkdyA9IHtcbiAgcDogVm0sXG4gIFA6IGh3XG59LCBwdyA9IC9eRCskLywgZncgPSAvXlkrJC8sIG13ID0gW1wiRFwiLCBcIkREXCIsIFwiWVlcIiwgXCJZWVlZXCJdO1xuZnVuY3Rpb24gZ3coZSkge1xuICByZXR1cm4gcHcudGVzdChlKTtcbn1cbmZ1bmN0aW9uIHZ3KGUpIHtcbiAgcmV0dXJuIGZ3LnRlc3QoZSk7XG59XG5mdW5jdGlvbiB5dyhlLCB0LCBuKSB7XG4gIGNvbnN0IHIgPSB4dyhlLCB0LCBuKTtcbiAgaWYgKGNvbnNvbGUud2FybihyKSwgbXcuaW5jbHVkZXMoZSkpIHRocm93IG5ldyBSYW5nZUVycm9yKHIpO1xufVxuZnVuY3Rpb24geHcoZSwgdCwgbikge1xuICBjb25zdCByID0gZVswXSA9PT0gXCJZXCIgPyBcInllYXJzXCIgOiBcImRheXMgb2YgdGhlIG1vbnRoXCI7XG4gIHJldHVybiBgVXNlIFxcYCR7ZS50b0xvd2VyQ2FzZSgpfVxcYCBpbnN0ZWFkIG9mIFxcYCR7ZX1cXGAgKGluIFxcYCR7dH1cXGApIGZvciBmb3JtYXR0aW5nICR7cn0gdG8gdGhlIGlucHV0IFxcYCR7bn1cXGA7IHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdW5pY29kZVRva2Vucy5tZGA7XG59XG5mdW5jdGlvbiBidyhlKSB7XG4gIHJldHVybiBlIGluc3RhbmNlb2YgRGF0ZSB8fCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSA9PT0gXCJbb2JqZWN0IERhdGVdXCI7XG59XG5mdW5jdGlvbiBfdyhlKSB7XG4gIHJldHVybiAhKCFidyhlKSAmJiB0eXBlb2YgZSAhPSBcIm51bWJlclwiIHx8IGlzTmFOKCtIdChlKSkpO1xufVxuY29uc3QgRXcgPSAvW3lZUXFNTHdJZERlY2loSEtrbXNdb3woXFx3KVxcMSp8Jyd8JygnJ3xbXiddKSsoJ3wkKXwuL2csIE93ID0gL1ArcCt8UCt8cCt8Jyd8JygnJ3xbXiddKSsoJ3wkKXwuL2csIFN3ID0gL14nKFteXSo/KSc/JC8sIFR3ID0gLycnL2csIHd3ID0gL1thLXpBLVpdLztcbmZ1bmN0aW9uIExsKGUsIHQsIG4pIHtcbiAgdmFyIHIsIGksIHMsIGEsIG8sIGwsIGMsIHU7XG4gIGNvbnN0IGQgPSB6YSgpLCBoID0gKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4ubG9jYWxlKSA/PyBkLmxvY2FsZSA/PyBkZiwgcCA9IChuID09IG51bGwgPyB2b2lkIDAgOiBuLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSkgPz8gKChpID0gKHIgPSBuID09IG51bGwgPyB2b2lkIDAgOiBuLmxvY2FsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IHIub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IGkuZmlyc3RXZWVrQ29udGFpbnNEYXRlKSA/PyBkLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA/PyAoKGEgPSAocyA9IGQubG9jYWxlKSA9PSBudWxsID8gdm9pZCAwIDogcy5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogYS5maXJzdFdlZWtDb250YWluc0RhdGUpID8/IDEsIGYgPSAobiA9PSBudWxsID8gdm9pZCAwIDogbi53ZWVrU3RhcnRzT24pID8/ICgobCA9IChvID0gbiA9PSBudWxsID8gdm9pZCAwIDogbi5sb2NhbGUpID09IG51bGwgPyB2b2lkIDAgOiBvLm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBsLndlZWtTdGFydHNPbikgPz8gZC53ZWVrU3RhcnRzT24gPz8gKCh1ID0gKGMgPSBkLmxvY2FsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGMub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IHUud2Vla1N0YXJ0c09uKSA/PyAwLCBnID0gSHQoZSwgbiA9PSBudWxsID8gdm9pZCAwIDogbi5pbik7XG4gIGlmICghX3coZykpXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHRpbWUgdmFsdWVcIik7XG4gIGxldCBtID0gdC5tYXRjaChPdykubWFwKCh4KSA9PiB7XG4gICAgY29uc3QgXyA9IHhbMF07XG4gICAgaWYgKF8gPT09IFwicFwiIHx8IF8gPT09IFwiUFwiKSB7XG4gICAgICBjb25zdCBFID0gZHdbX107XG4gICAgICByZXR1cm4gRSh4LCBoLmZvcm1hdExvbmcpO1xuICAgIH1cbiAgICByZXR1cm4geDtcbiAgfSkuam9pbihcIlwiKS5tYXRjaChFdykubWFwKCh4KSA9PiB7XG4gICAgaWYgKHggPT09IFwiJydcIilcbiAgICAgIHJldHVybiB7IGlzVG9rZW46ICExLCB2YWx1ZTogXCInXCIgfTtcbiAgICBjb25zdCBfID0geFswXTtcbiAgICBpZiAoXyA9PT0gXCInXCIpXG4gICAgICByZXR1cm4geyBpc1Rva2VuOiAhMSwgdmFsdWU6ICR3KHgpIH07XG4gICAgaWYgKEJoW19dKVxuICAgICAgcmV0dXJuIHsgaXNUb2tlbjogITAsIHZhbHVlOiB4IH07XG4gICAgaWYgKF8ubWF0Y2god3cpKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICAgIFwiRm9ybWF0IHN0cmluZyBjb250YWlucyBhbiB1bmVzY2FwZWQgbGF0aW4gYWxwaGFiZXQgY2hhcmFjdGVyIGBcIiArIF8gKyBcImBcIlxuICAgICAgKTtcbiAgICByZXR1cm4geyBpc1Rva2VuOiAhMSwgdmFsdWU6IHggfTtcbiAgfSk7XG4gIGgubG9jYWxpemUucHJlcHJvY2Vzc29yICYmIChtID0gaC5sb2NhbGl6ZS5wcmVwcm9jZXNzb3IoZywgbSkpO1xuICBjb25zdCB2ID0ge1xuICAgIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZTogcCxcbiAgICB3ZWVrU3RhcnRzT246IGYsXG4gICAgbG9jYWxlOiBoXG4gIH07XG4gIHJldHVybiBtLm1hcCgoeCkgPT4ge1xuICAgIGlmICgheC5pc1Rva2VuKSByZXR1cm4geC52YWx1ZTtcbiAgICBjb25zdCBfID0geC52YWx1ZTtcbiAgICAoIShuICE9IG51bGwgJiYgbi51c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnMpICYmIHZ3KF8pIHx8ICEobiAhPSBudWxsICYmIG4udXNlQWRkaXRpb25hbERheU9mWWVhclRva2VucykgJiYgZ3coXykpICYmIHl3KF8sIHQsIFN0cmluZyhlKSk7XG4gICAgY29uc3QgRSA9IEJoW19bMF1dO1xuICAgIHJldHVybiBFKGcsIF8sIGgubG9jYWxpemUsIHYpO1xuICB9KS5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gJHcoZSkge1xuICBjb25zdCB0ID0gZS5tYXRjaChTdyk7XG4gIHJldHVybiB0ID8gdFsxXS5yZXBsYWNlKFR3LCBcIidcIikgOiBlO1xufVxuY29uc3Qga28gPSBbXG4gIFtcIjE1c2Vjb25kc1wiLCAxNSAqIDFlM10sXG4gIFtcIm1pbnV0ZVwiLCA2MCAqIDFlM10sXG4gIFtcIjMwbWludXRlc1wiLCAzMCAqIDYwICogMWUzXSxcbiAgW1wiaG91cmx5XCIsIDYwICogNjAgKiAxZTNdLFxuICBbXCJkYWlseVwiLCAyNCAqIDYwICogNjAgKiAxZTNdLFxuICBbXCJtb250aGx5XCIsIDMwICogMjQgKiA2MCAqIDYwICogMWUzXSxcbiAgW1wicXVhcnRlcmx5XCIsIDMgKiAzMCAqIDI0ICogNjAgKiA2MCAqIDFlM10sXG4gIFtcInllYXJseVwiLCAxMiAqIDMwICogMjQgKiA2MCAqIDYwICogMWUzXVxuXTtcbmZ1bmN0aW9uIEdtKGUsIHQsIG4sIHIsIGkpIHtcbiAgY29uc3QgcyA9IHQgPT09IDAsIGEgPSBOdW1iZXIoTGwobmV3IERhdGUoZSksIFwiY1wiKSkgPT09IDIsIG8gPSBOdW1iZXIoTGwobmV3IERhdGUoZSksIFwicVwiKSkgPT09IDEsIGwgPSB0ICE9PSAwID8gblt0IC0gMV0gOiBudWxsO1xuICBzd2l0Y2ggKHIpIHtcbiAgICBjYXNlIFwiMTVzZWNvbmRzXCI6XG4gICAgICByZXR1cm4gcyB8fCBBcyhlKSB8fCBmaShlLCBsKSB8fCBJbihlKTtcbiAgICBjYXNlIFwibWludXRlXCI6XG4gICAgICByZXR1cm4gcyB8fCBBcyhlKSB8fCBmaShlLCBsKSB8fCBJbihlKTtcbiAgICBjYXNlIFwiMzBtaW51dGVzXCI6XG4gICAgICByZXR1cm4gcyB8fCBBcyhlKSB8fCBmaShlLCBsKSB8fCBJbihlKTtcbiAgICBjYXNlIFwiaG91cmx5XCI6XG4gICAgICByZXR1cm4gcyB8fCBBcyhlKSB8fCBmaShlLCBsKSB8fCBJbihlKTtcbiAgICBjYXNlIFwiZGFpbHlcIjpcbiAgICAgIHJldHVybiBpID8gcyB8fCBhIHx8IEluKGUpIDogcyB8fCBmaShlLCBsKSB8fCBJbihlKTtcbiAgICBjYXNlIFwid2Vla2x5XCI6XG4gICAgICByZXR1cm4gcyB8fCBhIHx8IEluKGUpO1xuICAgIGNhc2UgXCJtb250aGx5XCI6XG4gICAgICByZXR1cm4gcyB8fCBJbihlKTtcbiAgICBjYXNlIFwicXVhcnRlcmx5XCI6XG4gICAgICByZXR1cm4gcyB8fCBvO1xuICAgIGNhc2UgXCJ5ZWFybHlcIjpcbiAgICAgIHJldHVybiAhMTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3J9IGlzIG5vdCBhIHZhbGlkIHRpbWUgaW50ZXJ2YWwuYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGtsKGUsIHQsIG4sIHIsIGksIHMpIHtcbiAgY29uc3QgYSA9IGkuc2hvd0RheU5hbWUsIG8gPSByID09PSBcImRhaWx5XCIgJiYgYSA/IFwid2Vla2x5XCIgOiByLCBsID0gbmV3IERhdGUoZSksIGMgPSB5KGksIFwidGltZUludGVydmFsRm9ybWF0c1wiKVtvXSwgdSA9IHkoYywgXCJwcmltYXJ5XCIpLCBkID0geShjLCBcInNlY29uZGFyeVwiKSwgaCA9IEdtKGUsIHQsIG4sIHIsIGEpO1xuICBsZXQgcCA9IGggPyB1IDogZDtcbiAgciA9PT0gXCIxNXNlY29uZHNcIiAmJiBsLmdldE1pbGxpc2Vjb25kcygpICE9PSAwICYmIChwID0gcC5yZXBsYWNlKFwicHBcIiwgXCJoOm1tOnNzLlNTUyBhXCIpKTtcbiAgY29uc3QgZiA9IGkubG9jYWxlT2JqZWN0LCB7IGNvZGU6IGcsIG9wdGlvbnNPYmplY3Q6IG0gfSA9IHMsIHYgPSBtW3JdLnR5cGUsIHggPSBtW3JdW2ggPyBcInByaW1hcnlcIiA6IFwic2Vjb25kYXJ5XCJdW3BdO1xuICBpZiAociA9PT0gXCJxdWFydGVybHlcIiB8fCAheCkge1xuICAgIGNvbnN0IF8gPSBMbChsLCBwLCB7IGxvY2FsZTogZiB9KS5zcGxpdChcIlwiKS5tYXAoKEUpID0+IHtcbiAgICAgIHZhciBiO1xuICAgICAgY29uc3QgUyA9IE51bWJlcihFKTtcbiAgICAgIHJldHVybiBFICE9PSBcIiBcIiAmJiAhTnVtYmVyLmlzTmFOKFMpID8gKGIgPSBTID09IG51bGwgPyB2b2lkIDAgOiBTLnRvTG9jYWxlU3RyaW5nKSA9PSBudWxsID8gdm9pZCAwIDogYi5jYWxsKFMsIGcpIDogRTtcbiAgICB9KTtcbiAgICByZXR1cm4gc1t2XShsLCBnLCB7fSwgXy5qb2luKFwiXCIpKTtcbiAgfSBlbHNlXG4gICAgcmV0dXJuIHNbdl0obCwgZywgeCk7XG59XG5mdW5jdGlvbiB4YShlKSB7XG4gIGNvbnN0IHQgPSBuZXcgRGF0ZShlKTtcbiAgcmV0dXJuIHtcbiAgICBNOiB0LmdldE1vbnRoKCkgKyAxLFxuICAgIC8vIG1vbnRoOiAxLTEyXG4gICAgZDogdC5nZXREYXRlKCksXG4gICAgLy8gZGF5IG9mIHRoZSBtb250aDogMS0zMVxuICAgIEg6IHQuZ2V0SG91cnMoKSxcbiAgICAvLyAyNC1ob3VyIGNsb2NrOiAwLTIzXG4gICAgbTogdC5nZXRNaW51dGVzKCksXG4gICAgLy8gbWludXRlOiAwLTU5XG4gICAgczogdC5nZXRTZWNvbmRzKClcbiAgICAvLyBzZWNvbmRzOiAwLTU5XG4gIH07XG59XG5mdW5jdGlvbiBNdyhlKSB7XG4gIGlmIChlKVxuICAgIHJldHVybiBlLnNsaWNlKDEpLm1hcCgodCwgbikgPT4gdCAtIGVbbl0pO1xufVxuZnVuY3Rpb24gQ3coZSkge1xuICBjb25zdCB0ID0ga28ucmVkdWNlKChuLCBbLCByXSwgaSkgPT4ge1xuICAgIGNvbnN0IHMgPSBrb1tuXVsxXSwgYSA9IE1hdGguYWJzKHMgLSBlKSwgbyA9IE1hdGguYWJzKHIgLSBlKTtcbiAgICByZXR1cm4gYSA8IG8gPyBuIDogaTtcbiAgfSwgMCk7XG4gIHJldHVybiBrb1t0XVswXTtcbn1cbmZ1bmN0aW9uIERsKGUsIHQpIHtcbiAgaWYgKGxmW3RdKVxuICAgIHJldHVybiB0O1xuICBpZiAoZS5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuIFwiMTVzZWNvbmRzXCI7XG4gIGNvbnN0IG4gPSBNdyhlKSwgciA9IEJuKG4pO1xuICByZXR1cm4gQ3cocik7XG59XG5mdW5jdGlvbiBBcyhlKSB7XG4gIGNvbnN0IHsgczogdCwgbTogbiwgSDogciB9ID0geGEoZSk7XG4gIHJldHVybiByID09PSAwICYmIG4gPT09IDAgJiYgdCA9PT0gMDtcbn1cbmZ1bmN0aW9uIGZpKGUsIHQpIHtcbiAgY29uc3QgbiA9IHhhKGUpLk0sIHIgPSB4YSh0KS5NO1xuICByZXR1cm4gbiAhPT0gcjtcbn1cbmZ1bmN0aW9uIEluKGUpIHtcbiAgY29uc3QgeyBNOiB0LCBkOiBuLCBzOiByLCBtOiBpLCBIOiBzIH0gPSB4YShlKTtcbiAgcmV0dXJuIHQgPT09IDEgJiYgbiA9PT0gMSAmJiBzID09PSAwICYmIGkgPT09IDAgJiYgciA9PT0gMDtcbn1cbmZ1bmN0aW9uIHpoKGUpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCA/IFwiXCIgOiBlLnRvSVNPU3RyaW5nKCk7XG59XG5mdW5jdGlvbiB6bShlKSB7XG4gIGNvbnN0IHQgPSB6ZShlLCAocikgPT4gci52YWx1ZSksIG4gPSBGZSgpLmRvbWFpbih0KS5uaWNlKCkuZG9tYWluKCk7XG4gIGlmIChuWzBdID4gMClcbiAgICBuWzBdID0gMDtcbiAgZWxzZSBpZiAoblswXSA9PT0gMCAmJiBuWzFdID09PSAwKVxuICAgIHJldHVybiBbMCwgMV07XG4gIHJldHVybiBuWzBdIDwgMCAmJiBuWzFdID4gMCAmJiAoTWF0aC5hYnMoblswXSkgPiBuWzFdID8gblsxXSA9IE1hdGguYWJzKG5bMF0pIDogblswXSA9IC1uWzFdKSwgbjtcbn1cbmZ1bmN0aW9uIEZtKGUsIHQpIHtcbiAgY29uc3QgbiA9IHkodCwgXCJncmFkaWVudFwiLCBcImNvbG9yc1wiKSwgciA9ICFCZShuKTtcbiAgbGV0IGkgPSB5KHQsIFwicGFpcmluZ1wiLCBcIm9wdGlvblwiKTtcbiAgY29uc3QgcyA9IHptKGUpLCBhID0gc1swXSA8IDAgJiYgc1sxXSA+IDAgPyBcImRpdmVyZ2VcIiA6IFwibW9ub1wiO1xuICAoaSA8IDEgJiYgaSA+IDQgJiYgYSA9PT0gXCJtb25vXCIgfHwgaSA8IDEgJiYgaSA+IDIgJiYgYSA9PT0gXCJkaXZlcmdlXCIpICYmIChpID0gMSk7XG4gIGNvbnN0IG8gPSByID8gbiA6IFtdO1xuICBpZiAoIXIpIHtcbiAgICBjb25zdCBsID0gYSA9PT0gXCJkaXZlcmdlXCIgPyAxNyA6IDExO1xuICAgIGZvciAobGV0IGMgPSAxOyBjIDwgbCArIDE7IGMrKylcbiAgICAgIG8ucHVzaChgZmlsbC0ke2F9LSR7aX0tJHtjfWApO1xuICB9XG4gIHJldHVybiBHYygpLmRvbWFpbihzKS5yYW5nZShvKTtcbn1cbnZhciBodCA9IC8qIEBfX1BVUkVfXyAqLyAoKGUpID0+IChlLkdSQVBISUNTX0RPQ1VNRU5UID0gXCJncmFwaGljcy1kb2N1bWVudFwiLCBlLkdSQVBISUNTX09CSkVDVCA9IFwiZ3JhcGhpY3Mtb2JqZWN0XCIsIGUuR1JBUEhJQ1NfU1lNQk9MID0gXCJncmFwaGljcy1zeW1ib2xcIiwgZS5HUk9VUCA9IFwiZ3JvdXBcIiwgZS5ET0NVTUVOVCA9IFwiZG9jdW1lbnRcIiwgZS5DSEVDS0JPWCA9IFwiY2hlY2tib3hcIiwgZS5CVVRUT04gPSBcImJ1dHRvblwiLCBlLk1FTlUgPSBcIm1lbnVcIiwgZS5NRU5VX0lURU0gPSBcIm1lbnVpdGVtXCIsIGUuSU1HID0gXCJpbWdcIiwgZSkpKGh0IHx8IHt9KTtcbmZ1bmN0aW9uIEF3KGUsIHQpIHtcbiAgcmV0dXJuIGUgJiYgRmYoZSwgdCwgbHMpO1xufVxuZnVuY3Rpb24gTHcoZSwgdCkge1xuICByZXR1cm4gZnVuY3Rpb24obiwgcikge1xuICAgIGlmIChuID09IG51bGwpXG4gICAgICByZXR1cm4gbjtcbiAgICBpZiAoIWZyKG4pKVxuICAgICAgcmV0dXJuIGUobiwgcik7XG4gICAgZm9yICh2YXIgaSA9IG4ubGVuZ3RoLCBzID0gLTEsIGEgPSBPYmplY3Qobik7ICsrcyA8IGkgJiYgcihhW3NdLCBzLCBhKSAhPT0gITE7IClcbiAgICAgIDtcbiAgICByZXR1cm4gbjtcbiAgfTtcbn1cbnZhciBqYyA9IEx3KEF3KTtcbmZ1bmN0aW9uIGR0KGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlO1xuICB9O1xufVxudmFyIGt3ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuZnVuY3Rpb24gc28oZSkge1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBcImxlbmd0aFwiIGluIGUgPyBlIDogQXJyYXkuZnJvbShlKTtcbn1cbmZ1bmN0aW9uIER3KGUsIHQsIG4sIHIpIHtcbiAgZm9yICh2YXIgaSA9IC0xLCBzID0gZSA9PSBudWxsID8gMCA6IGUubGVuZ3RoOyArK2kgPCBzOyApIHtcbiAgICB2YXIgYSA9IGVbaV07XG4gICAgdChyLCBhLCBuKGEpLCBlKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIFJ3KGUsIHQsIG4sIHIpIHtcbiAgcmV0dXJuIGpjKGUsIGZ1bmN0aW9uKGksIHMsIGEpIHtcbiAgICB0KHIsIGksIG4oaSksIGEpO1xuICB9KSwgcjtcbn1cbmZ1bmN0aW9uIEl3KGUsIHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG4sIHIpIHtcbiAgICB2YXIgaSA9IEt0KG4pID8gRHcgOiBSdywgcyA9IHt9O1xuICAgIHJldHVybiBpKG4sIGUsIEphKHIpLCBzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIE53KGUpIHtcbiAgZm9yICh2YXIgdCA9IC0xLCBuID0gZSA9PSBudWxsID8gMCA6IGUubGVuZ3RoLCByID0ge307ICsrdCA8IG47ICkge1xuICAgIHZhciBpID0gZVt0XTtcbiAgICByW2lbMF1dID0gaVsxXTtcbiAgfVxuICByZXR1cm4gcjtcbn1cbnZhciBQdyA9IE9iamVjdC5wcm90b3R5cGUsIFV3ID0gUHcuaGFzT3duUHJvcGVydHksIEJ3ID0gSXcoZnVuY3Rpb24oZSwgdCwgbikge1xuICBVdy5jYWxsKGUsIG4pID8gZVtuXS5wdXNoKHQpIDogamEoZSwgbiwgW3RdKTtcbn0pO1xuZnVuY3Rpb24gSHcoZSwgdCkge1xuICBsZXQgbiA9IDA7XG4gIGZvciAobGV0IHIgb2YgZSlcbiAgICByICE9IG51bGwgJiYgKHIgPSArcikgPj0gciAmJiArK247XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gVncoZSkge1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIEd3KGUgPSBKbikge1xuICBpZiAoZSA9PT0gSm4pIHJldHVybiBqbTtcbiAgaWYgKHR5cGVvZiBlICE9IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNvbXBhcmUgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gIHJldHVybiAodCwgbikgPT4ge1xuICAgIGNvbnN0IHIgPSBlKHQsIG4pO1xuICAgIHJldHVybiByIHx8IHIgPT09IDAgPyByIDogKGUobiwgbikgPT09IDApIC0gKGUodCwgdCkgPT09IDApO1xuICB9O1xufVxuZnVuY3Rpb24gam0oZSwgdCkge1xuICByZXR1cm4gKGUgPT0gbnVsbCB8fCAhKGUgPj0gZSkpIC0gKHQgPT0gbnVsbCB8fCAhKHQgPj0gdCkpIHx8IChlIDwgdCA/IC0xIDogZSA+IHQgPyAxIDogMCk7XG59XG52YXIgencgPSBBcnJheS5wcm90b3R5cGUsIEZ3ID0gencuc2xpY2U7XG5mdW5jdGlvbiBEbyhlKSB7XG4gIHJldHVybiAoKSA9PiBlO1xufVxuZnVuY3Rpb24gancoZSwgdCwgbikge1xuICBsZXQgcjtcbiAgZm9yICg7IDsgKSB7XG4gICAgY29uc3QgaSA9IFlyKGUsIHQsIG4pO1xuICAgIGlmIChpID09PSByIHx8IGkgPT09IDAgfHwgIWlzRmluaXRlKGkpKVxuICAgICAgcmV0dXJuIFtlLCB0XTtcbiAgICBpID4gMCA/IChlID0gTWF0aC5mbG9vcihlIC8gaSkgKiBpLCB0ID0gTWF0aC5jZWlsKHQgLyBpKSAqIGkpIDogaSA8IDAgJiYgKGUgPSBNYXRoLmNlaWwoZSAqIGkpIC8gaSwgdCA9IE1hdGguZmxvb3IodCAqIGkpIC8gaSksIHIgPSBpO1xuICB9XG59XG5mdW5jdGlvbiBXdyhlKSB7XG4gIHJldHVybiBNYXRoLm1heCgxLCBNYXRoLmNlaWwoTWF0aC5sb2coSHcoZSkpIC8gTWF0aC5MTjIpICsgMSk7XG59XG5mdW5jdGlvbiBxdygpIHtcbiAgdmFyIGUgPSBWdywgdCA9IHplLCBuID0gV3c7XG4gIGZ1bmN0aW9uIHIoaSkge1xuICAgIEFycmF5LmlzQXJyYXkoaSkgfHwgKGkgPSBBcnJheS5mcm9tKGkpKTtcbiAgICB2YXIgcywgYSA9IGkubGVuZ3RoLCBvLCBsLCBjID0gbmV3IEFycmF5KGEpO1xuICAgIGZvciAocyA9IDA7IHMgPCBhOyArK3MpXG4gICAgICBjW3NdID0gZShpW3NdLCBzLCBpKTtcbiAgICB2YXIgdSA9IHQoYyksIGQgPSB1WzBdLCBoID0gdVsxXSwgcCA9IG4oYywgZCwgaCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHApKSB7XG4gICAgICBjb25zdCBfID0gaCwgRSA9ICtwO1xuICAgICAgaWYgKHQgPT09IHplICYmIChbZCwgaF0gPSBqdyhkLCBoLCBFKSksIHAgPSBjYShkLCBoLCBFKSwgcFswXSA8PSBkICYmIChsID0gWXIoZCwgaCwgRSkpLCBwW3AubGVuZ3RoIC0gMV0gPj0gaClcbiAgICAgICAgaWYgKF8gPj0gaCAmJiB0ID09PSB6ZSkge1xuICAgICAgICAgIGNvbnN0IGIgPSBZcihkLCBoLCBFKTtcbiAgICAgICAgICBpc0Zpbml0ZShiKSAmJiAoYiA+IDAgPyBoID0gKE1hdGguZmxvb3IoaCAvIGIpICsgMSkgKiBiIDogYiA8IDAgJiYgKGggPSAoTWF0aC5jZWlsKGggKiAtYikgKyAxKSAvIC1iKSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHAucG9wKCk7XG4gICAgfVxuICAgIGZvciAodmFyIGYgPSBwLmxlbmd0aCwgZyA9IDAsIG0gPSBmOyBwW2ddIDw9IGQ7ICkgKytnO1xuICAgIGZvciAoOyBwW20gLSAxXSA+IGg7ICkgLS1tO1xuICAgIChnIHx8IG0gPCBmKSAmJiAocCA9IHAuc2xpY2UoZywgbSksIGYgPSBtIC0gZyk7XG4gICAgdmFyIHYgPSBuZXcgQXJyYXkoZiArIDEpLCB4O1xuICAgIGZvciAocyA9IDA7IHMgPD0gZjsgKytzKVxuICAgICAgeCA9IHZbc10gPSBbXSwgeC54MCA9IHMgPiAwID8gcFtzIC0gMV0gOiBkLCB4LngxID0gcyA8IGYgPyBwW3NdIDogaDtcbiAgICBpZiAoaXNGaW5pdGUobCkpIHtcbiAgICAgIGlmIChsID4gMClcbiAgICAgICAgZm9yIChzID0gMDsgcyA8IGE7ICsrcylcbiAgICAgICAgICAobyA9IGNbc10pICE9IG51bGwgJiYgZCA8PSBvICYmIG8gPD0gaCAmJiB2W01hdGgubWluKGYsIE1hdGguZmxvb3IoKG8gLSBkKSAvIGwpKV0ucHVzaChpW3NdKTtcbiAgICAgIGVsc2UgaWYgKGwgPCAwKSB7XG4gICAgICAgIGZvciAocyA9IDA7IHMgPCBhOyArK3MpXG4gICAgICAgICAgaWYgKChvID0gY1tzXSkgIT0gbnVsbCAmJiBkIDw9IG8gJiYgbyA8PSBoKSB7XG4gICAgICAgICAgICBjb25zdCBfID0gTWF0aC5mbG9vcigoZCAtIG8pICogbCk7XG4gICAgICAgICAgICB2W01hdGgubWluKGYsIF8gKyAocFtfXSA8PSBvKSldLnB1c2goaVtzXSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgZm9yIChzID0gMDsgcyA8IGE7ICsrcylcbiAgICAgICAgKG8gPSBjW3NdKSAhPSBudWxsICYmIGQgPD0gbyAmJiBvIDw9IGggJiYgdltBYyhwLCBvLCAwLCBmKV0ucHVzaChpW3NdKTtcbiAgICByZXR1cm4gdjtcbiAgfVxuICByZXR1cm4gci52YWx1ZSA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlID0gdHlwZW9mIGkgPT0gXCJmdW5jdGlvblwiID8gaSA6IERvKGkpLCByKSA6IGU7XG4gIH0sIHIuZG9tYWluID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQgPSB0eXBlb2YgaSA9PSBcImZ1bmN0aW9uXCIgPyBpIDogRG8oW2lbMF0sIGlbMV1dKSwgcikgOiB0O1xuICB9LCByLnRocmVzaG9sZHMgPSBmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9IHR5cGVvZiBpID09IFwiZnVuY3Rpb25cIiA/IGkgOiBEbyhBcnJheS5pc0FycmF5KGkpID8gRncuY2FsbChpKSA6IGkpLCByKSA6IG47XG4gIH0sIHI7XG59XG5mdW5jdGlvbiBXbShlLCB0LCBuID0gMCwgciA9IDEgLyAwLCBpKSB7XG4gIGlmICh0ID0gTWF0aC5mbG9vcih0KSwgbiA9IE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgbikpLCByID0gTWF0aC5mbG9vcihNYXRoLm1pbihlLmxlbmd0aCAtIDEsIHIpKSwgIShuIDw9IHQgJiYgdCA8PSByKSkgcmV0dXJuIGU7XG4gIGZvciAoaSA9IGkgPT09IHZvaWQgMCA/IGptIDogR3coaSk7IHIgPiBuOyApIHtcbiAgICBpZiAociAtIG4gPiA2MDApIHtcbiAgICAgIGNvbnN0IGwgPSByIC0gbiArIDEsIGMgPSB0IC0gbiArIDEsIHUgPSBNYXRoLmxvZyhsKSwgZCA9IDAuNSAqIE1hdGguZXhwKDIgKiB1IC8gMyksIGggPSAwLjUgKiBNYXRoLnNxcnQodSAqIGQgKiAobCAtIGQpIC8gbCkgKiAoYyAtIGwgLyAyIDwgMCA/IC0xIDogMSksIHAgPSBNYXRoLm1heChuLCBNYXRoLmZsb29yKHQgLSBjICogZCAvIGwgKyBoKSksIGYgPSBNYXRoLm1pbihyLCBNYXRoLmZsb29yKHQgKyAobCAtIGMpICogZCAvIGwgKyBoKSk7XG4gICAgICBXbShlLCB0LCBwLCBmLCBpKTtcbiAgICB9XG4gICAgY29uc3QgcyA9IGVbdF07XG4gICAgbGV0IGEgPSBuLCBvID0gcjtcbiAgICBmb3IgKG1pKGUsIG4sIHQpLCBpKGVbcl0sIHMpID4gMCAmJiBtaShlLCBuLCByKTsgYSA8IG87ICkge1xuICAgICAgZm9yIChtaShlLCBhLCBvKSwgKythLCAtLW87IGkoZVthXSwgcykgPCAwOyApICsrYTtcbiAgICAgIGZvciAoOyBpKGVbb10sIHMpID4gMDsgKSAtLW87XG4gICAgfVxuICAgIGkoZVtuXSwgcykgPT09IDAgPyBtaShlLCBuLCBvKSA6ICgrK28sIG1pKGUsIG8sIHIpKSwgbyA8PSB0ICYmIChuID0gbyArIDEpLCB0IDw9IG8gJiYgKHIgPSBvIC0gMSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBtaShlLCB0LCBuKSB7XG4gIGNvbnN0IHIgPSBlW3RdO1xuICBlW3RdID0gZVtuXSwgZVtuXSA9IHI7XG59XG5mdW5jdGlvbiBSbyhlLCB0LCBuKSB7XG4gIGlmIChlID0gRmxvYXQ2NEFycmF5LmZyb20oel8oZSkpLCAhKCEociA9IGUubGVuZ3RoKSB8fCBpc05hTih0ID0gK3QpKSkge1xuICAgIGlmICh0IDw9IDAgfHwgciA8IDIpIHJldHVybiBCbihlKTtcbiAgICBpZiAodCA+PSAxKSByZXR1cm4gbnIoZSk7XG4gICAgdmFyIHIsIGkgPSAociAtIDEpICogdCwgcyA9IE1hdGguZmxvb3IoaSksIGEgPSBucihXbShlLCBzKS5zdWJhcnJheSgwLCBzICsgMSkpLCBvID0gQm4oZS5zdWJhcnJheShzICsgMSkpO1xuICAgIHJldHVybiBhICsgKG8gLSBhKSAqIChpIC0gcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIEZoKGUsIHQpIHtcbiAgaWYgKChhID0gZS5sZW5ndGgpID4gMSlcbiAgICBmb3IgKHZhciBuID0gMSwgciwgaSwgcyA9IGVbdFswXV0sIGEsIG8gPSBzLmxlbmd0aDsgbiA8IGE7ICsrbilcbiAgICAgIGZvciAoaSA9IHMsIHMgPSBlW3Rbbl1dLCByID0gMDsgciA8IG87ICsrcilcbiAgICAgICAgc1tyXVsxXSArPSBzW3JdWzBdID0gaXNOYU4oaVtyXVsxXSkgPyBpW3JdWzBdIDogaVtyXVsxXTtcbn1cbmZ1bmN0aW9uIGpoKGUpIHtcbiAgZm9yICh2YXIgdCA9IGUubGVuZ3RoLCBuID0gbmV3IEFycmF5KHQpOyAtLXQgPj0gMDsgKSBuW3RdID0gdDtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBZdyhlLCB0KSB7XG4gIHJldHVybiBlW3RdO1xufVxuZnVuY3Rpb24gWHcoZSkge1xuICBjb25zdCB0ID0gW107XG4gIHJldHVybiB0LmtleSA9IGUsIHQ7XG59XG5mdW5jdGlvbiBJbygpIHtcbiAgdmFyIGUgPSBkdChbXSksIHQgPSBqaCwgbiA9IEZoLCByID0gWXc7XG4gIGZ1bmN0aW9uIGkocykge1xuICAgIHZhciBhID0gQXJyYXkuZnJvbShlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIFh3KSwgbywgbCA9IGEubGVuZ3RoLCBjID0gLTEsIHU7XG4gICAgZm9yIChjb25zdCBkIG9mIHMpXG4gICAgICBmb3IgKG8gPSAwLCArK2M7IG8gPCBsOyArK28pXG4gICAgICAgIChhW29dW2NdID0gWzAsICtyKGQsIGFbb10ua2V5LCBjLCBzKV0pLmRhdGEgPSBkO1xuICAgIGZvciAobyA9IDAsIHUgPSBzbyh0KGEpKTsgbyA8IGw7ICsrbylcbiAgICAgIGFbdVtvXV0uaW5kZXggPSBvO1xuICAgIHJldHVybiBuKGEsIHUpLCBhO1xuICB9XG4gIHJldHVybiBpLmtleXMgPSBmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZSA9IHR5cGVvZiBzID09IFwiZnVuY3Rpb25cIiA/IHMgOiBkdChBcnJheS5mcm9tKHMpKSwgaSkgOiBlO1xuICB9LCBpLnZhbHVlID0gZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHIgPSB0eXBlb2YgcyA9PSBcImZ1bmN0aW9uXCIgPyBzIDogZHQoK3MpLCBpKSA6IHI7XG4gIH0sIGkub3JkZXIgPSBmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodCA9IHMgPT0gbnVsbCA/IGpoIDogdHlwZW9mIHMgPT0gXCJmdW5jdGlvblwiID8gcyA6IGR0KEFycmF5LmZyb20ocykpLCBpKSA6IHQ7XG4gIH0sIGkub2Zmc2V0ID0gZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4gPSBzID8/IEZoLCBpKSA6IG47XG4gIH0sIGk7XG59XG5mdW5jdGlvbiBadyhlLCB0KSB7XG4gIGlmICgobCA9IGUubGVuZ3RoKSA+IDApXG4gICAgZm9yICh2YXIgbiwgciA9IDAsIGksIHMsIGEsIG8sIGwsIGMgPSBlW3RbMF1dLmxlbmd0aDsgciA8IGM7ICsrcilcbiAgICAgIGZvciAoYSA9IG8gPSAwLCBuID0gMDsgbiA8IGw7ICsrbilcbiAgICAgICAgKHMgPSAoaSA9IGVbdFtuXV1bcl0pWzFdIC0gaVswXSkgPiAwID8gKGlbMF0gPSBhLCBpWzFdID0gYSArPSBzKSA6IHMgPCAwID8gKGlbMV0gPSBvLCBpWzBdID0gbyArPSBzKSA6IChpWzBdID0gMCwgaVsxXSA9IHMpO1xufVxuZnVuY3Rpb24gS3coZSkge1xuICBjb25zdCB0ID0gZS50cmltKCk7XG4gIHJldHVybiBbXCI9XCIsIFwiK1wiLCBcIi1cIiwgXCJAXCIsIFwiXHRcIiwgXCJcXHJcIl0uaW5jbHVkZXModC5jaGFyQXQoMCkpID8gYMKgJHt0fWAgOiAvWyxcXFwiXFxuXS8udGVzdCh0KSA/IGBcIiR7dH1cImAgOiB0O1xufVxuY2xhc3MgYW4ge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG9wdGlvbnM6IHt9XG4gICAgfSwgdGhpcy5jb2xvclNjYWxlID0ge30sIHRoaXMuY29sb3JDbGFzc05hbWVzID0ge30sIHRoaXMuc2VydmljZXMgPSB0O1xuICB9XG4gIGZvcm1hdFRhYmxlKHsgaGVhZGVyczogdCwgY2VsbHM6IG4gfSkge1xuICAgIGNvbnN0IHIgPSB0aGlzLmdldE9wdGlvbnMoKSwge1xuICAgICAgY29kZTogaSxcbiAgICAgIGRhdGU6IHMsXG4gICAgICBudW1iZXI6IGFcbiAgICB9ID0geShyLCBcImxvY2FsZVwiKSwgbyA9IHkociwgXCJ0YWJ1bGFyUmVwTW9kYWxcIiwgXCJ0YWJsZUhlYWRpbmdGb3JtYXR0ZXJcIiksIGwgPSB5KHIsIFwidGFidWxhclJlcE1vZGFsXCIsIFwidGFibGVDZWxsRm9ybWF0dGVyXCIpLCB7IGNhcnRlc2lhblNjYWxlczogYyB9ID0gdGhpcy5zZXJ2aWNlcywgdSA9IGMgPT0gbnVsbCA/IHZvaWQgMCA6IGMuZ2V0RG9tYWluQXhpc1NjYWxlVHlwZSgpO1xuICAgIGxldCBkO1xuICAgIHJldHVybiB1ID09PSBldC5USU1FICYmIChkID0gKGgpID0+IHMoaCwgaSwgeyBtb250aDogXCJzaG9ydFwiLCBkYXk6IFwibnVtZXJpY1wiLCB5ZWFyOiBcIm51bWVyaWNcIiB9KSksIFtcbiAgICAgIHR5cGVvZiBvID09IFwiZnVuY3Rpb25cIiA/IG8odCkgOiB0LFxuICAgICAgLi4udHlwZW9mIGwgPT0gXCJmdW5jdGlvblwiID8gbChuKSA6IG4ubWFwKChoKSA9PiB7XG4gICAgICAgIGQgJiYgKGhbMV0gPSBkKGhbMV0pKTtcbiAgICAgICAgZm9yIChjb25zdCBwIGluIGgpIHtcbiAgICAgICAgICBjb25zdCBmID0gaFtwXTtcbiAgICAgICAgICB0eXBlb2YgZiA9PSBcIm51bWJlclwiICYmIChoW3BdID0gYShmLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGg7XG4gICAgICB9KVxuICAgIF07XG4gIH1cbiAgZ2V0QWxsRGF0YUZyb21Eb21haW4odCkge1xuICAgIGlmICghdGhpcy5nZXREYXRhKCkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgbGV0IHIgPSB0aGlzLmdldERhdGEoKTtcbiAgICBjb25zdCBpID0gdGhpcy5nZXREYXRhR3JvdXBzKCksIHsgZ3JvdXBNYXBzVG86IHMgfSA9IHkobiwgXCJkYXRhXCIpLCBhID0geShuLCBcImF4ZXNcIik7XG4gICAgcmV0dXJuIHQgJiYgKHIgPSByLmZpbHRlcigobykgPT4gdC5pbmNsdWRlcyhvW3NdKSkpLCBhICYmIE9iamVjdC5rZXlzKGEpLmZvckVhY2goKG8pID0+IHtcbiAgICAgIGNvbnN0IGwgPSBhW29dLm1hcHNUbywgYyA9IGFbb10uc2NhbGVUeXBlO1xuICAgICAgaWYgKChjID09PSBldC5MSU5FQVIgfHwgYyA9PT0gZXQuTE9HKSAmJiAociA9IHIubWFwKCh1KSA9PiAoe1xuICAgICAgICAuLi51LFxuICAgICAgICBbbF06IHVbbF0gPT09IG51bGwgPyB1W2xdIDogTnVtYmVyKHVbbF0pXG4gICAgICB9KSkpLCBsICYmIGFbb10uZG9tYWluKVxuICAgICAgICBpZiAoYyA9PT0gZXQuTEFCRUxTKVxuICAgICAgICAgIHIgPSByLmZpbHRlcihcbiAgICAgICAgICAgICh1KSA9PiBhW29dLmRvbWFpbi5pbmNsdWRlcyh1W2xdKVxuICAgICAgICAgICk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnN0IFt1LCBkXSA9IGFbb10uZG9tYWluO1xuICAgICAgICAgIHIgPSByLmZpbHRlcihcbiAgICAgICAgICAgIChoKSA9PiAhKGwgaW4gaCkgfHwgaFtsXSA+PSB1ICYmIGhbbF0gPD0gZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9KSwgci5maWx0ZXIoKG8pID0+IGkuZmluZCgobCkgPT4gbC5uYW1lID09PSBvW3NdKSk7XG4gIH1cbiAgLyoqXG4gICAqIENoYXJ0cyB0aGF0IGhhdmUgZ3JvdXAgY29uZmlncyBwYXNzZWQgaW50byB0aGVtLCBvbmx5IHdhbnQgdG8gcmV0cmlldmUgdGhlIGRpc3BsYXkgZGF0YSByZWxldmFudCB0byB0aGF0IGNoYXJ0XG4gICAqIEBwYXJhbSBncm91cHMgdGhlIGluY2x1ZGVkIGRhdGFzZXRzIGZvciB0aGUgcGFydGljdWxhciBjaGFydFxuICAgKi9cbiAgZ2V0RGlzcGxheURhdGEodCkge1xuICAgIGlmICghdGhpcy5nZXQoXCJkYXRhXCIpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgeyBBQ1RJVkU6IG4gfSA9IEl0Lml0ZW1zLnN0YXR1cywgciA9IHRoaXMuZ2V0RGF0YUdyb3Vwcyh0KSwgeyBncm91cE1hcHNUbzogaSB9ID0gdGhpcy5nZXRPcHRpb25zKCkuZGF0YTtcbiAgICByZXR1cm4gdGhpcy5nZXRBbGxEYXRhRnJvbURvbWFpbih0KS5maWx0ZXIoKHMpID0+IHIuZmluZChcbiAgICAgIChhKSA9PiBhLm5hbWUgPT09IHNbaV0gJiYgYS5zdGF0dXMgPT09IG5cbiAgICApKTtcbiAgfVxuICBnZXREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImRhdGFcIik7XG4gIH1cbiAgaXNEYXRhRW1wdHkoKSB7XG4gICAgcmV0dXJuICF0aGlzLmdldERhdGEoKS5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRhdGEgZm9yIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBzYW5pdGl6ZXMgdGhlIHByb3ZpZGVkIGRhdGEsIGdlbmVyYXRlcyBkYXRhIGdyb3VwcyxcbiAgICogYW5kIHVwZGF0ZXMgdGhlIGluc3RhbmNlJ3Mgc3RhdGUgd2l0aCB0aGUgc2FuaXRpemVkIGRhdGEgYW5kIGRhdGEgZ3JvdXBzLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gbmV3RGF0YSAtIFRoZSBuZXcgZGF0YSB0byBiZSBzZXQuIFRoaXMgZGF0YSB3aWxsIGJlIGNsb25lZCBhbmQgc2FuaXRpemVkLlxuICAgKiBAcmV0dXJucyB7YW55fSAtIFRoZSBzYW5pdGl6ZWQgdmVyc2lvbiBvZiB0aGUgcHJvdmlkZWQgZGF0YS5cbiAgICovXG4gIHNldERhdGEodCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLnNhbml0aXplKFNuKHQpKSwgciA9IHRoaXMuZ2VuZXJhdGVEYXRhR3JvdXBzKG4pO1xuICAgIHJldHVybiB0aGlzLnNldCh7XG4gICAgICBkYXRhOiBuLFxuICAgICAgZGF0YUdyb3VwczogclxuICAgIH0pLCBuO1xuICB9XG4gIGdldERhdGFHcm91cHModCkge1xuICAgIHJldHVybiB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcImRhdGFcIiwgXCJsb2FkaW5nXCIpID8gW10gOiB0ID8gdGhpcy5nZXQoXCJkYXRhR3JvdXBzXCIpLmZpbHRlcigobikgPT4gdC5pbmNsdWRlcyhuLm5hbWUpKSA6IHRoaXMuZ2V0KFwiZGF0YUdyb3Vwc1wiKTtcbiAgfVxuICBnZXRBY3RpdmVEYXRhR3JvdXBzKHQpIHtcbiAgICBjb25zdCB7IEFDVElWRTogbiB9ID0gSXQuaXRlbXMuc3RhdHVzO1xuICAgIHJldHVybiB0aGlzLmdldERhdGFHcm91cHModCkuZmlsdGVyKChyKSA9PiByLnN0YXR1cyA9PT0gbik7XG4gIH1cbiAgZ2V0RGF0YUdyb3VwTmFtZXModCkge1xuICAgIHJldHVybiB0aGlzLmdldERhdGFHcm91cHModCkubWFwKChuKSA9PiBuLm5hbWUpO1xuICB9XG4gIGdldEFjdGl2ZURhdGFHcm91cE5hbWVzKHQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBY3RpdmVEYXRhR3JvdXBzKHQpLm1hcCgobikgPT4gbi5uYW1lKTtcbiAgfVxuICBhZ2dyZWdhdGVCaW5EYXRhQnlHcm91cCh0KSB7XG4gICAgcmV0dXJuIEJ3KHQsIFwiZ3JvdXBcIik7XG4gIH1cbiAgZ2V0QmluQ29uZmlndXJhdGlvbnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0RGlzcGxheURhdGEoKSwgbiA9IHRoaXMuZ2V0T3B0aW9ucygpLCByID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0TWFpblhBeGlzUG9zaXRpb24oKSwgaSA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpbklkZW50aWZpZXIoKSwgcyA9IG4uYXhlc1tyXSwgeyBncm91cE1hcHNUbzogYSB9ID0gbi5kYXRhLCB7IGJpbnM6IG8gPSBMVC5kZWZhdWx0QmlucyB9ID0gcywgbCA9IEFycmF5LmlzQXJyYXkobyksIGMgPSBxdygpLnZhbHVlKChwKSA9PiBwW2ldKS50aHJlc2hvbGRzKG8pKHQpO1xuICAgIGlmIChsKVxuICAgICAgY1tjLmxlbmd0aCAtIDFdLngxID0gb1tvLmxlbmd0aCAtIDFdO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgcCA9IGNbMF0ueDEgLSBjWzBdLngwO1xuICAgICAgY1tjLmxlbmd0aCAtIDFdLngxID0gK2NbYy5sZW5ndGggLSAxXS54MCArIHA7XG4gICAgfVxuICAgIGNvbnN0IHUgPSBsID8gW29bMF0sIG9bby5sZW5ndGggLSAxXV0gOiBbY1swXS54MCwgY1tjLmxlbmd0aCAtIDFdLngxXSwgZCA9IEFycmF5LmZyb20obmV3IFNldCh0Lm1hcCgocCkgPT4gcFthXSkpKSwgaCA9IFtdO1xuICAgIHJldHVybiBjLmZvckVhY2goKHApID0+IHtcbiAgICAgIGNvbnN0IGYgPSBgJHtwLngwfS0ke3AueDF9YCwgZyA9IHRoaXMuYWdncmVnYXRlQmluRGF0YUJ5R3JvdXAocCk7XG4gICAgICBkLmZvckVhY2goKG0pID0+IHtcbiAgICAgICAgaC5wdXNoKHtcbiAgICAgICAgICBncm91cDogbSxcbiAgICAgICAgICBrZXk6IGYsXG4gICAgICAgICAgdmFsdWU6IGdbbV0gfHwgMCxcbiAgICAgICAgICBiaW46IHAueDBcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KSwge1xuICAgICAgYmluczogYyxcbiAgICAgIGJpbnNEb21haW46IHVcbiAgICB9O1xuICB9XG4gIGdldEJpbm5lZFN0YWNrZWREYXRhKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldE9wdGlvbnMoKSwgeyBncm91cE1hcHNUbzogbiB9ID0gdC5kYXRhLCByID0gdGhpcy5nZXRBY3RpdmVEYXRhR3JvdXBOYW1lcygpLCB7IGJpbnM6IGkgfSA9IHRoaXMuZ2V0QmluQ29uZmlndXJhdGlvbnMoKSwgcyA9IHRoaXMuZ2V0RGF0YVZhbHVlc0dyb3VwZWRCeUtleXMoe1xuICAgICAgYmluczogaVxuICAgIH0pO1xuICAgIHJldHVybiBJbygpLmtleXMocikocykubWFwKChhLCBvKSA9PiBPYmplY3Qua2V5cyhhKS5maWx0ZXIoKGwpID0+ICFpc05hTihsKSkubWFwKChsKSA9PiB7XG4gICAgICBjb25zdCBjID0gYVtsXTtcbiAgICAgIHJldHVybiBjW25dID0gcltvXSwgYztcbiAgICB9KSk7XG4gIH1cbiAgZ2V0R3JvdXBlZERhdGEodCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldERpc3BsYXlEYXRhKHQpLCByID0ge30sIHsgZ3JvdXBNYXBzVG86IGkgfSA9IHRoaXMuZ2V0T3B0aW9ucygpLmRhdGE7XG4gICAgcmV0dXJuIG4ubWFwKChzKSA9PiB7XG4gICAgICBjb25zdCBhID0gc1tpXTtcbiAgICAgIHJbYV0gIT09IG51bGwgJiYgclthXSAhPT0gdm9pZCAwID8gclthXS5wdXNoKHMpIDogclthXSA9IFtzXTtcbiAgICB9KSwgT2JqZWN0LmtleXMocikubWFwKChzKSA9PiAoe1xuICAgICAgbmFtZTogcyxcbiAgICAgIGRhdGE6IHJbc11cbiAgICB9KSk7XG4gIH1cbiAgZ2V0U3RhY2tLZXlzKHsgYmluczogdCA9IG51bGwsIGdyb3VwczogbiA9IG51bGwgfSA9IHsgYmluczogbnVsbCwgZ3JvdXBzOiBudWxsIH0pIHtcbiAgICBjb25zdCByID0gdGhpcy5nZXRPcHRpb25zKCksIGkgPSB0aGlzLmdldERpc3BsYXlEYXRhKG4pO1xuICAgIGxldCBzO1xuICAgIHQgPyBzID0gdC5tYXAoKGwpID0+IGAke2wueDB9OiR7bC54MX1gKSA6IHMgPSBaaShcbiAgICAgIGkubWFwKChsKSA9PiB7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXREb21haW5JZGVudGlmaWVyKGwpO1xuICAgICAgICByZXR1cm4gbFtjXSBpbnN0YW5jZW9mIERhdGUgPyB6aChsW2NdKSA6IGxbY10gJiYgdHlwZW9mIGxbY10udG9TdHJpbmcgPT0gXCJmdW5jdGlvblwiID8gbFtjXS50b1N0cmluZygpIDogbFtjXTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICBjb25zdCBhID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZG9tYWluQXhpc1Bvc2l0aW9uLCBvID0gci5heGVzW2FdLnNjYWxlVHlwZTtcbiAgICByZXR1cm4gbyA9PT0gZXQuVElNRSA/IHMuc29ydCgobCwgYykgPT4ge1xuICAgICAgY29uc3QgdSA9IG5ldyBEYXRlKGwpLCBkID0gbmV3IERhdGUoYyk7XG4gICAgICByZXR1cm4gdSAtIGQ7XG4gICAgfSkgOiAobyA9PT0gZXQuTE9HIHx8IG8gPT09IGV0LkxJTkVBUikgJiYgcy5zb3J0KChsLCBjKSA9PiBsIC0gYyksIHM7XG4gIH1cbiAgZ2V0RGF0YVZhbHVlc0dyb3VwZWRCeUtleXMoeyBiaW5zOiB0ID0gbnVsbCwgZ3JvdXBzOiBuID0gbnVsbCB9KSB7XG4gICAgY29uc3QgciA9IHRoaXMuZ2V0T3B0aW9ucygpLCB7IGdyb3VwTWFwc1RvOiBpIH0gPSByLmRhdGEsIHMgPSB0aGlzLmdldERpc3BsYXlEYXRhKG4pLCBhID0gdGhpcy5nZXREYXRhR3JvdXBOYW1lcygpLCBvID0gdGhpcy5nZXRTdGFja0tleXMoeyBiaW5zOiB0LCBncm91cHM6IG4gfSk7XG4gICAgcmV0dXJuIHQgPyBvLm1hcCgobCkgPT4ge1xuICAgICAgY29uc3QgW2MsIHVdID0gbC5zcGxpdChcIjpcIiksIGQgPSB7IHgwOiBjLCB4MTogdSB9LCBoID0gdC5maW5kKChwKSA9PiBwLngwLnRvU3RyaW5nKCkgPT09IGMudG9TdHJpbmcoKSk7XG4gICAgICByZXR1cm4gYS5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgIGRbcF0gPSBoLmZpbHRlcihcbiAgICAgICAgICAoZikgPT4gZltpXSA9PT0gcFxuICAgICAgICApLmxlbmd0aDtcbiAgICAgIH0pLCBkO1xuICAgIH0pIDogby5tYXAoKGwpID0+IHtcbiAgICAgIGNvbnN0IGMgPSB7IHNoYXJlZFN0YWNrS2V5OiBsIH07XG4gICAgICByZXR1cm4gYS5mb3JFYWNoKCh1KSA9PiB7XG4gICAgICAgIGNvbnN0IGQgPSBzLmZpbmQoKHApID0+IHtcbiAgICAgICAgICBjb25zdCBmID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0RG9tYWluSWRlbnRpZmllcihwKTtcbiAgICAgICAgICByZXR1cm4gcFtpXSA9PT0gdSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocCwgZikgJiYgKHBbZl0gaW5zdGFuY2VvZiBEYXRlID8gemgocFtmXSkgPT09IGwgOiBwW2ZdLnRvU3RyaW5nKCkgPT09IGwpO1xuICAgICAgICB9KSwgaCA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlSWRlbnRpZmllcihjKTtcbiAgICAgICAgY1t1XSA9IGQgPyBkW2hdIDogbnVsbDtcbiAgICAgIH0pLCBjO1xuICAgIH0pO1xuICB9XG4gIGdldFN0YWNrZWREYXRhKHsgcGVyY2VudGFnZTogdCA9ICExLCBncm91cHM6IG4gPSBudWxsLCBkaXZlcmdlbnQ6IHIgPSAhMSB9KSB7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0T3B0aW9ucygpLCB7IGdyb3VwTWFwc1RvOiBzIH0gPSBpLmRhdGEsIGEgPSB0aGlzLmdldEFjdGl2ZURhdGFHcm91cE5hbWVzKG4pLCBvID0gdGhpcy5nZXREYXRhVmFsdWVzR3JvdXBlZEJ5S2V5cyh7XG4gICAgICBncm91cHM6IG5cbiAgICB9KTtcbiAgICBpZiAodCkge1xuICAgICAgY29uc3QgbCA9IE53KG8ubWFwKChjKSA9PiBbYy5zaGFyZWRTdGFja0tleSwgMF0pKTtcbiAgICAgIG8uZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICBhLmZvckVhY2goKHUpID0+IHtcbiAgICAgICAgICBsW2Muc2hhcmVkU3RhY2tLZXldICs9IGNbdV07XG4gICAgICAgIH0pO1xuICAgICAgfSksIG8uZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICBhLmZvckVhY2goKHUpID0+IHtcbiAgICAgICAgICBjb25zdCBkID0gbFtjLnNoYXJlZFN0YWNrS2V5XTtcbiAgICAgICAgICBsW2Muc2hhcmVkU3RhY2tLZXldID8gY1t1XSA9IGNbdV0gLyBkICogMTAwIDogY1t1XSA9IDA7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAociA/IElvKCkub2Zmc2V0KFp3KSA6IElvKCkpLmtleXMoYSkobykubWFwKChsLCBjKSA9PiBPYmplY3Qua2V5cyhsKS5maWx0ZXIoKHUpID0+ICFpc05hTih1KSkubWFwKCh1KSA9PiB7XG4gICAgICBjb25zdCBkID0gbFt1XTtcbiAgICAgIHJldHVybiBkW3NdID0gYVtjXSwgZDtcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBvcHRpb25zIGZyb20gdGhlIGluc3RhbmNlJ3Mgc3RhdGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHthbnl9IC0gVGhlIGN1cnJlbnQgb3B0aW9ucyBzdG9yZWQgaW4gdGhlIGluc3RhbmNlJ3Mgc3RhdGUuXG4gICAqL1xuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLm9wdGlvbnM7XG4gIH1cbiAgc2V0KHQsIG4pIHtcbiAgICB0aGlzLnN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZSwgdCk7XG4gICAgY29uc3QgciA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7IHNraXBVcGRhdGU6ICExLCBhbmltYXRlOiAhMCB9LFxuICAgICAgLy8gZGVmYXVsdCBjb25maWdzXG4gICAgICBuXG4gICAgKTtcbiAgICByLnNraXBVcGRhdGUgfHwgdGhpcy51cGRhdGUoci5hbmltYXRlKTtcbiAgfVxuICBnZXQodCkge1xuICAgIHJldHVybiB0ID8gdGhpcy5zdGF0ZVt0XSA6IHRoaXMuc3RhdGU7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgb3B0aW9ucyBmb3IgdGhlIGluc3RhbmNlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCByZXRyaWV2ZXMgdGhlIGV4aXN0aW5nIG9wdGlvbnMsIHVwZGF0ZXMgdGhlIGxlZ2VuZCBhZGRpdGlvbmFsIGl0ZW1zLFxuICAgKiBhbmQgbWVyZ2VzIHRoZSBuZXcgb3B0aW9ucyB3aXRoIHRoZSBleGlzdGluZyBvbmVzLiBUaGUgaW5zdGFuY2UncyBzdGF0ZSBpcyB0aGVuIHVwZGF0ZWRcbiAgICogd2l0aCB0aGUgbWVyZ2VkIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBuZXdPcHRpb25zIC0gVGhlIG5ldyBvcHRpb25zIHRvIGJlIHNldC4gVGhlc2Ugb3B0aW9ucyB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZSBleGlzdGluZyBvcHRpb25zLlxuICAgKi9cbiAgc2V0T3B0aW9ucyh0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgIEZjKG4sIHQpLCB0aGlzLnNldCh7XG4gICAgICBvcHRpb25zOiBhdChuLCB0KVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBVcGRhdGVzIG1pc2NlbGxhbm91cyBpbmZvcm1hdGlvbiB3aXRoaW4gdGhlIG1vZGVsXG4gICAqIHN1Y2ggYXMgdGhlIGNvbG9yIHNjYWxlcywgb3IgdGhlIGxlZ2VuZCBkYXRhIGxhYmVsc1xuICAgKi9cbiAgdXBkYXRlKHQgPSAhMCkge1xuICAgIHRoaXMuZ2V0RGlzcGxheURhdGEoKSAmJiAodGhpcy51cGRhdGVBbGxEYXRhR3JvdXBzKCksIHRoaXMuc2V0Q3VzdG9tQ29sb3JTY2FsZSgpLCB0aGlzLnNldENvbG9yQ2xhc3NOYW1lcygpLCB0aGlzLnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuTW9kZWwuVVBEQVRFLCB7IGFuaW1hdGU6IHQgfSkpO1xuICB9XG4gIC8qXG4gICAqIERhdGEgbGFiZWxzXG4gICAqL1xuICB0b2dnbGVEYXRhTGFiZWwodCkge1xuICAgIGNvbnN0IHsgQUNUSVZFOiBuLCBESVNBQkxFRDogciB9ID0gSXQuaXRlbXMuc3RhdHVzLCBpID0gdGhpcy5nZXREYXRhR3JvdXBzKCksIHMgPSBpLnNvbWUoKGMpID0+IGMuc3RhdHVzID09PSByKSwgYSA9IGkuZmlsdGVyKChjKSA9PiBjLnN0YXR1cyA9PT0gbik7XG4gICAgaWYgKHMpXG4gICAgICBpZiAoYS5sZW5ndGggPT09IDEgJiYgYVswXS5uYW1lID09PSB0KVxuICAgICAgICBpLmZvckVhY2goKGMsIHUpID0+IHtcbiAgICAgICAgICBpW3VdLnN0YXR1cyA9IG47XG4gICAgICAgIH0pO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGMgPSBpLmZpbmRJbmRleCgodSkgPT4gdS5uYW1lID09PSB0KTtcbiAgICAgICAgaVtjXS5zdGF0dXMgPSBpW2NdLnN0YXR1cyA9PT0gciA/IG4gOiByO1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIGkuZm9yRWFjaCgoYywgdSkgPT4ge1xuICAgICAgICBpW3VdLnN0YXR1cyA9IGMubmFtZSA9PT0gdCA/IG4gOiByO1xuICAgICAgfSk7XG4gICAgY29uc3QgbyA9IGkuZmlsdGVyKChjKSA9PiBjLnN0YXR1cyA9PT0gbiksIGwgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICBpLnNvbWUoKGMpID0+IGMuc3RhdHVzID09PSByKSA/IGwuZGF0YS5zZWxlY3RlZEdyb3VwcyA9IG8ubWFwKChjKSA9PiBjLm5hbWUpIDogbC5kYXRhLnNlbGVjdGVkR3JvdXBzID0gW10sIHRoaXMuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5MZWdlbmQuSVRFTVNfVVBEQVRFLCB7XG4gICAgICBkYXRhR3JvdXBzOiBpXG4gICAgfSksIHRoaXMuc2V0KHtcbiAgICAgIGRhdGFHcm91cHM6IGlcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2hvdWxkIHRoZSBkYXRhIHBvaW50IGJlIGZpbGxlZD9cbiAgICogQHBhcmFtIGdyb3VwXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHBhcmFtIGRhdGFcbiAgICogQHBhcmFtIGRlZmF1bHRGaWxsZWQgdGhlIGRlZmF1bHQgZm9yIHRoaXMgY2hhcnRcbiAgICovXG4gIGdldElzRmlsbGVkKHQsIG4sIHIsIGkpIHtcbiAgICBjb25zdCBzID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgcmV0dXJuIHMuZ2V0SXNGaWxsZWQgPyBzLmdldElzRmlsbGVkKHQsIG4sIHIsIGkpIDogaTtcbiAgfVxuICBnZXRGaWxsQ29sb3IodCwgbiwgcikge1xuICAgIGNvbnN0IGkgPSB0aGlzLmdldE9wdGlvbnMoKSwgcyA9IHkodGhpcy5jb2xvclNjYWxlLCB0KTtcbiAgICByZXR1cm4gaS5nZXRGaWxsQ29sb3IgPyBpLmdldEZpbGxDb2xvcih0LCBuLCByLCBzKSA6IHM7XG4gIH1cbiAgZ2V0U3Ryb2tlQ29sb3IodCwgbiwgcikge1xuICAgIGNvbnN0IGkgPSB0aGlzLmdldE9wdGlvbnMoKSwgcyA9IHkodGhpcy5jb2xvclNjYWxlLCB0KTtcbiAgICByZXR1cm4gaS5nZXRTdHJva2VDb2xvciA/IGkuZ2V0U3Ryb2tlQ29sb3IodCwgbiwgciwgcykgOiBzO1xuICB9XG4gIGlzVXNlclByb3ZpZGVkQ29sb3JTY2FsZVZhbGlkKCkge1xuICAgIGNvbnN0IHQgPSB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcImNvbG9yXCIsIFwic2NhbGVcIiksIG4gPSB0aGlzLmdldERhdGFHcm91cHMoKTtcbiAgICByZXR1cm4gdCA9PSBudWxsIHx8IE9iamVjdC5rZXlzKHQpLmxlbmd0aCA9PSAwID8gITEgOiBuLnNvbWUoXG4gICAgICAocikgPT4gT2JqZWN0LmtleXModCkuaW5jbHVkZXMoci5uYW1lKVxuICAgICk7XG4gIH1cbiAgZ2V0Q29sb3JDbGFzc05hbWUodCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmNvbG9yQ2xhc3NOYW1lcyh0LmRhdGFHcm91cE5hbWUpO1xuICAgIGxldCByID0gdC5vcmlnaW5hbENsYXNzTmFtZTtcbiAgICByZXR1cm4gdC5jbGFzc05hbWVUeXBlcy5mb3JFYWNoKFxuICAgICAgKGkpID0+IHIgPSB0Lm9yaWdpbmFsQ2xhc3NOYW1lID8gYCR7cn0gJHtpfS0ke259YCA6IGAke2l9LSR7bn1gXG4gICAgKSwgciB8fCBcIlwiO1xuICB9XG4gIC8qKlxuICAgKiBGb3IgY2hhcnRzIHRoYXQgbWlnaHQgaG9sZCBhbiBhc3NvY2lhdGVkIHN0YXR1cyBmb3IgdGhlaXIgZGF0YXNldFxuICAgKi9cbiAgZ2V0U3RhdHVzKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldEFsbERhdGFHcm91cHNOYW1lcygpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxEYXRhR3JvdXBzO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBkYXRhIHByb3ZpZGVkIGluIHRoZSBvbGRlciBmb3JtYXQgdG8gdGFidWxhclxuICAgKlxuICAgKi9cbiAgdHJhbnNmb3JtVG9UYWJ1bGFyRGF0YSh0KSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJXZSd2ZSB1cGRhdGVkIHRoZSBjaGFydGluZyBkYXRhIGZvcm1hdCB0byBiZSB0YWJ1bGFyIGJ5IGRlZmF1bHQuIFRoZSBjdXJyZW50IGZvcm1hdCB5b3UncmUgdXNpbmcgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHYxLjAsIHJlYWQgbW9yZSBoZXJlIGh0dHBzOi8vY2hhcnRzLmNhcmJvbmRlc2lnbnN5c3RlbS5jb20vXCJcbiAgICApO1xuICAgIGNvbnN0IG4gPSBbXSwgeyBkYXRhc2V0czogciwgbGFiZWxzOiBpIH0gPSB0O1xuICAgIHJldHVybiByLmZvckVhY2goKHMpID0+IHtcbiAgICAgIHMuZGF0YS5mb3JFYWNoKChhLCBvKSA9PiB7XG4gICAgICAgIGxldCBsO1xuICAgICAgICBjb25zdCBjID0geShzLCBcImxhYmVsXCIpO1xuICAgICAgICBpZiAoYyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGQgPSB5KGksIG8pO1xuICAgICAgICAgIGQgPyBsID0gZCA6IGwgPSBcIlVuZ3JvdXBlZFwiO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBsID0gYztcbiAgICAgICAgY29uc3QgdSA9IHtcbiAgICAgICAgICBncm91cDogbCxcbiAgICAgICAgICBrZXk6IGlbb11cbiAgICAgICAgfTtcbiAgICAgICAgaXNOYU4oYSkgPyAodS52YWx1ZSA9IGEudmFsdWUsIHUuZGF0ZSA9IGEuZGF0ZSkgOiB1LnZhbHVlID0gYSwgbi5wdXNoKHUpO1xuICAgICAgfSk7XG4gICAgfSksIG47XG4gIH1cbiAgZ2V0VGFidWxhckRhdGFBcnJheSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZXhwb3J0VG9DU1YoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0VGFidWxhckRhdGFBcnJheSgpLm1hcChcbiAgICAgIChzKSA9PiBzLm1hcCgoYSkgPT4gYFwiJHsoYSA9PT0gXCImbmRhc2g7XCIgPyBcIuKAk1wiIDogYSkuc3BsaXQoL1ssOydcImBdLykubWFwKChvKSA9PiBLdyhvKSkuam9pbihcIlwiKX1cImApXG4gICAgKS5tYXAoKHMpID0+IHMuam9pbihcIixcIikpLmpvaW4oYFxuYCksIG4gPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICBsZXQgciA9IFwibXlDaGFydFwiO1xuICAgIGNvbnN0IGkgPSB5KG4sIFwiZmlsZURvd25sb2FkXCIsIFwiZmlsZU5hbWVcIik7XG4gICAgdHlwZW9mIGkgPT0gXCJmdW5jdGlvblwiID8gciA9IGkoXCJjc3ZcIikgOiB0eXBlb2YgaSA9PSBcInN0cmluZ1wiICYmIChyID0gaSksIHRoaXMuc2VydmljZXMuZmlsZXMuZG93bmxvYWRDU1YodCwgYCR7cn0uY3N2YCk7XG4gIH1cbiAgZ2V0VGFidWxhckRhdGEodCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHQpID8gdCA6IHRoaXMudHJhbnNmb3JtVG9UYWJ1bGFyRGF0YSh0KTtcbiAgfVxuICBzYW5pdGl6ZSh0KSB7XG4gICAgcmV0dXJuIHQgPSB0aGlzLmdldFRhYnVsYXJEYXRhKHQpLCB0O1xuICB9XG4gIC8qXG4gICAqIERhdGEgZ3JvdXBzXG4gICAqL1xuICB1cGRhdGVBbGxEYXRhR3JvdXBzKCkge1xuICAgIHRoaXMuYWxsRGF0YUdyb3VwcyA/IHRoaXMuZ2V0RGF0YUdyb3VwTmFtZXMoKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0aGlzLmFsbERhdGFHcm91cHMuaW5kZXhPZih0KSA9PT0gLTEgJiYgdGhpcy5hbGxEYXRhR3JvdXBzLnB1c2godCk7XG4gICAgfSkgOiB0aGlzLmFsbERhdGFHcm91cHMgPSB0aGlzLmdldERhdGFHcm91cE5hbWVzKCk7XG4gIH1cbiAgZ2VuZXJhdGVEYXRhR3JvdXBzKHQpIHtcbiAgICBjb25zdCB7IGdyb3VwTWFwc1RvOiBuIH0gPSB0aGlzLmdldE9wdGlvbnMoKS5kYXRhLCB7IEFDVElWRTogciwgRElTQUJMRUQ6IGkgfSA9IEl0Lml0ZW1zLnN0YXR1cywgcyA9IHRoaXMuZ2V0T3B0aW9ucygpLCBhID0gWmkodC5tYXAoKGwpID0+IGxbbl0pKTtcbiAgICBzLmRhdGEuc2VsZWN0ZWRHcm91cHMubGVuZ3RoICYmIChzLmRhdGEuc2VsZWN0ZWRHcm91cHMuZXZlcnkoXG4gICAgICAobCkgPT4gYS5pbmNsdWRlcyhsKVxuICAgICkgfHwgKHMuZGF0YS5zZWxlY3RlZEdyb3VwcyA9IFtdKSk7XG4gICAgY29uc3QgbyA9IChsKSA9PiAhcy5kYXRhLnNlbGVjdGVkR3JvdXBzLmxlbmd0aCB8fCBzLmRhdGEuc2VsZWN0ZWRHcm91cHMuaW5jbHVkZXMobCkgPyByIDogaTtcbiAgICByZXR1cm4gYS5tYXAoKGwpID0+ICh7XG4gICAgICBuYW1lOiBsLFxuICAgICAgc3RhdHVzOiBvKGwpXG4gICAgfSkpO1xuICB9XG4gIC8qXG4gICAqIEZpbGwgc2NhbGVzXG4gICAqL1xuICBzZXRDdXN0b21Db2xvclNjYWxlKCkge1xuICAgIGlmICghdGhpcy5pc1VzZXJQcm92aWRlZENvbG9yU2NhbGVWYWxpZCgpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldE9wdGlvbnMoKSwgbiA9IHkodCwgXCJjb2xvclwiLCBcInNjYWxlXCIpO1xuICAgIE9iamVjdC5rZXlzKG4pLmZvckVhY2goKHIpID0+IHtcbiAgICAgIHRoaXMuYWxsRGF0YUdyb3Vwcy5pbmNsdWRlcyhyKSB8fCBjb25zb2xlLndhcm4oYFwiJHtyfVwiIGRvZXMgbm90IGV4aXN0IGluIGRhdGEgZ3JvdXBzLmApO1xuICAgIH0pLCB0aGlzLmFsbERhdGFHcm91cHMuZmlsdGVyKChyKSA9PiBuW3JdKS5mb3JFYWNoKFxuICAgICAgKHIpID0+IHRoaXMuY29sb3JTY2FsZVtyXSA9IG5bcl1cbiAgICApO1xuICB9XG4gIC8qXG4gICAqIENvbG9yIHBhbGV0dGVcbiAgICovXG4gIHNldENvbG9yQ2xhc3NOYW1lcygpIHtcbiAgICBjb25zdCB0ID0geSh0aGlzLmdldE9wdGlvbnMoKSwgXCJjb2xvclwiLCBcInBhaXJpbmdcIik7XG4gICAgbGV0IG4gPSB5KHQsIFwibnVtYmVyT2ZWYXJpYW50c1wiKTtcbiAgICAoIW4gfHwgbiA8IHRoaXMuYWxsRGF0YUdyb3Vwcy5sZW5ndGgpICYmIChuID0gdGhpcy5hbGxEYXRhR3JvdXBzLmxlbmd0aCk7XG4gICAgbGV0IHIgPSB5KHQsIFwib3B0aW9uXCIpO1xuICAgIGNvbnN0IGkgPSBNbS5wYWlyaW5nT3B0aW9ucywgcyA9IG4gPiA1ID8gMTQgOiBuLCBhID0gYCR7c30tY29sb3JgO1xuICAgIHIgPSByIDw9IGlbYV0gPyByIDogMTtcbiAgICBjb25zdCBvID0gdGhpcy5hbGxEYXRhR3JvdXBzLm1hcChcbiAgICAgIChsLCBjKSA9PiBgJHtzfS0ke3J9LSR7YyAlIDE0ICsgMX1gXG4gICAgKTtcbiAgICB0aGlzLmNvbG9yQ2xhc3NOYW1lcyA9IHJvKCkucmFuZ2UobykuZG9tYWluKHRoaXMuYWxsRGF0YUdyb3Vwcyk7XG4gIH1cbn1cbmNsYXNzIG1yIGV4dGVuZHMgYW4ge1xuICAvLyBjYW4ndCBiZSBwcm90ZWN0ZWQgYXMgaXQncyB1c2VkIGJ5IHR3by1kaW1lbnNpb25hbC1heGVzLnRzXG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5heGlzRmxhdm9yID0gR2EuREVGQVVMVDtcbiAgfVxuICAvLyBnZXQgdGhlIHNjYWxlcyBpbmZvcm1hdGlvblxuICAvLyBuZWVkZWQgZm9yIGdldFRhYnVsYXJBcnJheSgpXG4gIGFzc2lnblJhbmdlQW5kRG9tYWlucygpIHtcbiAgICBjb25zdCB7IGNhcnRlc2lhblNjYWxlczogdCB9ID0gdGhpcy5zZXJ2aWNlcywgbiA9IHRoaXMuZ2V0T3B0aW9ucygpLCByID0gdC5pc0R1YWxBeGVzKCksIGkgPSB7XG4gICAgICBwcmltYXJ5RG9tYWluOiB0LmRvbWFpbkF4aXNQb3NpdGlvbixcbiAgICAgIHByaW1hcnlSYW5nZTogdC5yYW5nZUF4aXNQb3NpdGlvbixcbiAgICAgIHNlY29uZGFyeURvbWFpbjogbnVsbCxcbiAgICAgIHNlY29uZGFyeVJhbmdlOiBudWxsXG4gICAgfTtcbiAgICByZXR1cm4gciAmJiAoaS5zZWNvbmRhcnlEb21haW4gPSB0LnNlY29uZGFyeURvbWFpbkF4aXNQb3NpdGlvbiwgaS5zZWNvbmRhcnlSYW5nZSA9IHQuc2Vjb25kYXJ5UmFuZ2VBeGlzUG9zaXRpb24pLCBPYmplY3Qua2V5cyhpKS5mb3JFYWNoKFxuICAgICAgKHMpID0+IHtcbiAgICAgICAgY29uc3QgYSA9IGlbc107XG4gICAgICAgIHQuc2NhbGVzW2FdID8gaVtzXSA9IHtcbiAgICAgICAgICBwb3NpdGlvbjogYSxcbiAgICAgICAgICBsYWJlbDogdC5nZXRTY2FsZUxhYmVsKGEpLFxuICAgICAgICAgIGlkZW50aWZpZXI6IHkobiwgXCJheGVzXCIsIGEsIFwibWFwc1RvXCIpXG4gICAgICAgIH0gOiBpW3NdID0gbnVsbDtcbiAgICAgIH1cbiAgICApLCBpO1xuICB9XG4gIGdldFRhYnVsYXJEYXRhQXJyYXkoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0RGlzcGxheURhdGEoKSwgbiA9IHRoaXMuZ2V0T3B0aW9ucygpLCB7IGdyb3VwTWFwc1RvOiByIH0gPSBuLmRhdGEsIHsgcHJpbWFyeURvbWFpbjogaSwgcHJpbWFyeVJhbmdlOiBzLCBzZWNvbmRhcnlEb21haW46IGEsIHNlY29uZGFyeVJhbmdlOiBvIH0gPSB0aGlzLmFzc2lnblJhbmdlQW5kRG9tYWlucygpLCB7IG51bWJlcjogbCwgY29kZTogYyB9ID0geSh0aGlzLmdldE9wdGlvbnMoKSwgXCJsb2NhbGVcIiksIHUgPSBbXG4gICAgICBcIkdyb3VwXCIsXG4gICAgICBpLmxhYmVsLFxuICAgICAgcy5sYWJlbCxcbiAgICAgIC4uLmEgPyBbYS5sYWJlbF0gOiBbXSxcbiAgICAgIC4uLm8gPyBbby5sYWJlbF0gOiBbXVxuICAgIF0sIGQgPSB0Lm1hcCgoaCkgPT4gW1xuICAgICAgaFtyXSxcbiAgICAgIGhbaS5pZGVudGlmaWVyXSA9PT0gbnVsbCA/IFwiJm5kYXNoO1wiIDogaFtpLmlkZW50aWZpZXJdLFxuICAgICAgaFtzLmlkZW50aWZpZXJdID09PSBudWxsIHx8IGlzTmFOKGhbcy5pZGVudGlmaWVyXSkgPyBcIiZuZGFzaDtcIiA6IGwoaFtzLmlkZW50aWZpZXJdLCBjKSxcbiAgICAgIC4uLmEgPyBbXG4gICAgICAgIGhbYS5pZGVudGlmaWVyXSA9PT0gbnVsbCA/IFwiJm5kYXNoO1wiIDogaFthLmlkZW50aWZpZXJdXG4gICAgICBdIDogW10sXG4gICAgICAuLi5vID8gW1xuICAgICAgICBoW28uaWRlbnRpZmllcl0gPT09IG51bGwgfHwgaXNOYU4oaFtvLmlkZW50aWZpZXJdKSA/IFwiJm5kYXNoO1wiIDogaFtvLmlkZW50aWZpZXJdXG4gICAgICBdIDogW11cbiAgICBdKTtcbiAgICByZXR1cm4gc3VwZXIuZm9ybWF0VGFibGUoeyBoZWFkZXJzOiB1LCBjZWxsczogZCB9KTtcbiAgfVxuICBzZXREYXRhKHQpIHtcbiAgICBsZXQgbjtcbiAgICBpZiAodCAmJiAobiA9IHN1cGVyLnNldERhdGEodCksIHkodGhpcy5nZXRPcHRpb25zKCksIFwiem9vbUJhclwiLCBHLlRPUCwgXCJlbmFibGVkXCIpKSkge1xuICAgICAgY29uc3QgciA9IHkoXG4gICAgICAgIHRoaXMuZ2V0T3B0aW9ucygpLFxuICAgICAgICBcInpvb21CYXJcIixcbiAgICAgICAgRy5UT1AsXG4gICAgICAgIFwiZGF0YVwiXG4gICAgICApO1xuICAgICAgdGhpcy5zZXRab29tQmFyRGF0YShyKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHpvb20gYmFyIGRhdGEgZm9yIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBzYW5pdGl6ZXMgdGhlIHByb3ZpZGVkIHpvb20gYmFyIGRhdGEgb3IgdXNlcyB0aGUgZGlzcGxheSBkYXRhIGlmIG5vIGV4cGxpY2l0XG4gICAqIHpvb20gZGF0YSBpcyBwcm92aWRlZC4gSXQgbm9ybWFsaXplcyB0aGUgem9vbSBiYXIgZGF0YSBieSBhZ2dyZWdhdGluZyB2YWx1ZXMgYmFzZWQgb24gdW5pcXVlXG4gICAqIGRhdGVzIGFuZCB1cGRhdGVzIHRoZSBpbnN0YW5jZSdzIHN0YXRlIHdpdGggdGhlIG5vcm1hbGl6ZWQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IFtuZXdab29tQmFyRGF0YV0gLSBUaGUgbmV3IHpvb20gYmFyIGRhdGEgdG8gYmUgc2V0LiBJZiBub3QgcHJvdmlkZWQsIHRoZSBkaXNwbGF5IGRhdGEgd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgc2V0Wm9vbUJhckRhdGEodCkge1xuICAgIGNvbnN0IG4gPSB0ID8gdGhpcy5zYW5pdGl6ZShTbih0KSkgOiB0aGlzLmdldERpc3BsYXlEYXRhKCk7XG4gICAgbGV0IHIgPSBuO1xuICAgIGNvbnN0IHsgY2FydGVzaWFuU2NhbGVzOiBpIH0gPSB0aGlzLnNlcnZpY2VzO1xuICAgIGlmIChuICYmIGkuZG9tYWluQXhpc1Bvc2l0aW9uICYmIGkucmFuZ2VBeGlzUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHMgPSBpLmdldERvbWFpbklkZW50aWZpZXIoKSwgYSA9IGkuZ2V0UmFuZ2VJZGVudGlmaWVyKCk7XG4gICAgICBsZXQgbyA9IG4ubWFwKChsKSA9PiBsW3NdLmdldFRpbWUoKSk7XG4gICAgICBvID0gWmkobykuc29ydCgpLCByID0gby5tYXAoKGwpID0+IHtcbiAgICAgICAgbGV0IGMgPSAwO1xuICAgICAgICBjb25zdCB1ID0ge307XG4gICAgICAgIHJldHVybiBuLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgICBkW3NdLmdldFRpbWUoKSA9PT0gbCAmJiAoYyArPSBkW2FdKTtcbiAgICAgICAgfSksIHVbc10gPSBuZXcgRGF0ZShsKSwgdVthXSA9IGMsIHU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5zZXQoeyB6b29tQmFyRGF0YTogciB9KTtcbiAgfVxuICBnZXRab29tQmFyRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJ6b29tQmFyRGF0YVwiKTtcbiAgfVxuICBzYW5pdGl6ZURhdGVWYWx1ZXModCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICBpZiAoIW4uYXhlcylcbiAgICAgIHJldHVybiB0O1xuICAgIGNvbnN0IHIgPSBbXTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoRykuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgY29uc3QgcyA9IEdbaV0sIGEgPSBuLmF4ZXNbc107XG4gICAgICBpZiAoYSAmJiBhLnNjYWxlVHlwZSA9PT0gZXQuVElNRSkge1xuICAgICAgICBjb25zdCBvID0gYS5tYXBzVG87XG4gICAgICAgIChvICE9PSBudWxsIHx8IG8gIT09IHZvaWQgMCkgJiYgci5wdXNoKG8pO1xuICAgICAgfVxuICAgIH0pLCByLmxlbmd0aCA+IDAgJiYgdC5mb3JFYWNoKChpKSA9PiB7XG4gICAgICByLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgeShpLCBzLCBcImdldFRpbWVcIikgPT09IG51bGwgJiYgKGlbc10gPSBuZXcgRGF0ZShpW3NdKSk7XG4gICAgICB9KTtcbiAgICB9KSwgdDtcbiAgfVxuICBzYW5pdGl6ZSh0KSB7XG4gICAgcmV0dXJuIHQgPSBzdXBlci5zYW5pdGl6ZSh0KSwgdCA9IHRoaXMuc2FuaXRpemVEYXRlVmFsdWVzKHQpLCB0O1xuICB9XG59XG5sZXQgUXcgPSBjbGFzcyBleHRlbmRzIG1yIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHN1cGVyKHQpO1xuICB9XG4gIGdldFRhYnVsYXJEYXRhQXJyYXkoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0RGlzcGxheURhdGEoKSwgeyBudW1iZXI6IG4sIGNvZGU6IHIgfSA9IHkodGhpcy5nZXRPcHRpb25zKCksIFwibG9jYWxlXCIpO1xuICAgIHQuc29ydCgoYSwgbykgPT4gYS5zb3VyY2UubG9jYWxlQ29tcGFyZShvLnNvdXJjZSkpO1xuICAgIGNvbnN0IGkgPSBbXCJTb3VyY2VcIiwgXCJUYXJnZXRcIiwgXCJWYWx1ZVwiXSwgcyA9IFtcbiAgICAgIC4uLnQubWFwKChhKSA9PiBbXG4gICAgICAgIGEuc291cmNlLFxuICAgICAgICBhLnRhcmdldCxcbiAgICAgICAgYS52YWx1ZSA9PT0gbnVsbCA/IFwiJm5kYXNoO1wiIDogbihhLnZhbHVlLCByKVxuICAgICAgXSlcbiAgICBdO1xuICAgIHJldHVybiBzdXBlci5mb3JtYXRUYWJsZSh7IGhlYWRlcnM6IGksIGNlbGxzOiBzIH0pO1xuICB9XG59LCBKdyA9IGNsYXNzIGV4dGVuZHMgbXIge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIodCk7XG4gIH1cbiAgZ2V0Qm94UXVhcnRpbGVzKHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcV8yNTogUm8odCwgMC4yNSksXG4gICAgICBxXzUwOiBSbyh0LCAwLjUpLFxuICAgICAgcV83NTogUm8odCwgMC43NSlcbiAgICB9O1xuICB9XG4gIGdldEJveHBsb3REYXRhKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldE9wdGlvbnMoKSwgeyBncm91cE1hcHNUbzogbiB9ID0gdC5kYXRhLCByID0gdGhpcy5nZXRHcm91cGVkRGF0YSgpLCBpID0gW107XG4gICAgZm9yIChjb25zdCB7IG5hbWU6IHMsIGRhdGE6IGEgfSBvZiByKSB7XG4gICAgICBjb25zdCBvID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0UmFuZ2VJZGVudGlmaWVyKCksIGwgPSBhLm1hcCgoXykgPT4gX1tvXSkuc29ydChKbiksIGMgPSB7XG4gICAgICAgIFtuXTogcyxcbiAgICAgICAgY291bnRzOiBsLFxuICAgICAgICBxdWFydGlsZXM6IHRoaXMuZ2V0Qm94UXVhcnRpbGVzKGwpLFxuICAgICAgICBvdXRsaWVyczogbnVsbCxcbiAgICAgICAgd2hpc2tlcnM6IG51bGxcbiAgICAgIH0sIHUgPSBjLnF1YXJ0aWxlcy5xXzI1LCBkID0gYy5xdWFydGlsZXMucV83NSwgaCA9IChkIC0gdSkgKiAxLjUsIHAgPSB1IC0gaCwgZiA9IGQgKyBoLCBnID0gW10sIG0gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgXyBvZiBsKVxuICAgICAgICBfIDwgcCB8fCBfID4gZiA/IGcucHVzaChfKSA6IG0ucHVzaChfKTtcbiAgICAgIGMub3V0bGllcnMgPSBnO1xuICAgICAgY29uc3QgdiA9IEJuKG0pLCB4ID0gbnIobSk7XG4gICAgICBjLndoaXNrZXJzID0ge1xuICAgICAgICBtaW46IHYgfHwgQm4oW2MucXVhcnRpbGVzLnFfMjUsIGMucXVhcnRpbGVzLnFfNTAsIGMucXVhcnRpbGVzLnFfNzVdKSxcbiAgICAgICAgbWF4OiB4IHx8IG5yKFtjLnF1YXJ0aWxlcy5xXzI1LCBjLnF1YXJ0aWxlcy5xXzUwLCBjLnF1YXJ0aWxlcy5xXzc1XSlcbiAgICAgIH0sIGkucHVzaChjKTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgZ2V0VGFidWxhckRhdGFBcnJheSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRPcHRpb25zKCksIHsgZ3JvdXBNYXBzVG86IG4gfSA9IHQuZGF0YSwgciA9IHRoaXMuZ2V0Qm94cGxvdERhdGEoKSwgeyBudW1iZXI6IGksIGNvZGU6IHMgfSA9IHkodCwgXCJsb2NhbGVcIiksIGEgPSBbXCJHcm91cFwiLCBcIk1pbmltdW1cIiwgXCJRMVwiLCBcIk1lZGlhblwiLCBcIlEzXCIsIFwiTWF4aW11bVwiLCBcIklRUlwiLCBcIk91dGxpZXIocylcIl0sIG8gPSBbXG4gICAgICAuLi5yLm1hcCgobCkgPT4ge1xuICAgICAgICBsZXQgYyA9IHkobCwgXCJvdXRsaWVyc1wiKTtcbiAgICAgICAgcmV0dXJuIChjID09PSBudWxsIHx8IGMubGVuZ3RoID09PSAwKSAmJiAoYyA9IFtcIiZuZGFzaDtcIl0pLCBbXG4gICAgICAgICAgbFtuXSxcbiAgICAgICAgICB5KGwsIFwid2hpc2tlcnNcIiwgXCJtaW5cIikgIT09IG51bGwgPyBpKHkobCwgXCJ3aGlza2Vyc1wiLCBcIm1pblwiKSwgcykgOiBcIiZuZGFzaDtcIixcbiAgICAgICAgICB5KGwsIFwicXVhcnRpbGVzXCIsIFwicV8yNVwiKSAhPT0gbnVsbCA/IGkoeShsLCBcInF1YXJ0aWxlc1wiLCBcInFfMjVcIiksIHMpIDogXCImbmRhc2g7XCIsXG4gICAgICAgICAgeShsLCBcInF1YXJ0aWxlc1wiLCBcInFfNTBcIikgIT09IG51bGwgPyBpKHkobCwgXCJxdWFydGlsZXNcIiwgXCJxXzUwXCIpLCBzKSA6IFwiJm5kYXNoO1wiLFxuICAgICAgICAgIHkobCwgXCJxdWFydGlsZXNcIiwgXCJxXzc1XCIpICE9PSBudWxsID8gaSh5KGwsIFwicXVhcnRpbGVzXCIsIFwicV83NVwiKSwgcykgOiBcIiZuZGFzaDtcIixcbiAgICAgICAgICB5KGwsIFwid2hpc2tlcnNcIiwgXCJtYXhcIikgIT09IG51bGwgPyBpKHkobCwgXCJ3aGlza2Vyc1wiLCBcIm1heFwiKSwgcykgOiBcIiZuZGFzaDtcIixcbiAgICAgICAgICB5KGwsIFwicXVhcnRpbGVzXCIsIFwicV83NVwiKSAhPT0gbnVsbCAmJiB5KGwsIFwicXVhcnRpbGVzXCIsIFwicV8yNVwiKSAhPT0gbnVsbCA/IChpKFxuICAgICAgICAgICAgeShsLCBcInF1YXJ0aWxlc1wiLCBcInFfNzVcIikgLSB5KGwsIFwicXVhcnRpbGVzXCIsIFwicV8yNVwiKVxuICAgICAgICAgICksIHMpIDogXCImbmRhc2g7XCIsXG4gICAgICAgICAgYy5tYXAoKHUpID0+IGkodSwgcykpLmpvaW4oXCIsXCIpXG4gICAgICAgIF07XG4gICAgICB9KVxuICAgIF07XG4gICAgcmV0dXJuIHN1cGVyLmZvcm1hdFRhYmxlKHsgaGVhZGVyczogYSwgY2VsbHM6IG8gfSk7XG4gIH1cbiAgc2V0Q29sb3JDbGFzc05hbWVzKCkge1xuICAgIGNvbnN0IHQgPSB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcImNvbG9yXCIsIFwicGFpcmluZ1wiKTtcbiAgICBsZXQgbiA9IHkodCwgXCJvcHRpb25cIik7XG4gICAgY29uc3QgciA9IE1tLnBhaXJpbmdPcHRpb25zO1xuICAgIG4gPSBuIDw9IHJbXCIxLWNvbG9yXCJdID8gbiA6IDE7XG4gICAgY29uc3QgaSA9IHRoaXMuYWxsRGF0YUdyb3Vwcy5tYXAoKCkgPT4gYDEtJHtufS0xYCk7XG4gICAgdGhpcy5jb2xvckNsYXNzTmFtZXMgPSBybygpLnJhbmdlKGkpLmRvbWFpbih0aGlzLmFsbERhdGFHcm91cHMpO1xuICB9XG59LCB0JCA9IGNsYXNzIGV4dGVuZHMgbXIge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIodCk7XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIGluZGV4IG9mIHRoZSBwZXJmb3JtYW5jZSBhcmVhIHRpdGxlcyB0byB1c2VcbiAgICogQHBhcmFtIGRhdHVtXG4gICAqIEByZXR1cm5zIG51bWJlclxuICAgKi9cbiAgZ2V0TWF0Y2hpbmdSYW5nZUluZGV4Rm9yRGF0YXBvaW50KHQpIHtcbiAgICBsZXQgbjtcbiAgICBmb3IgKGxldCByID0gdC5yYW5nZXMubGVuZ3RoIC0gMTsgciA+IDA7IHItLSkge1xuICAgICAgY29uc3QgaSA9IHQucmFuZ2VzW3JdO1xuICAgICAgaWYgKHQudmFsdWUgPj0gaSlcbiAgICAgICAgcmV0dXJuIG4gPSByLCBuO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXRUYWJ1bGFyRGF0YUFycmF5KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldERpc3BsYXlEYXRhKCksIG4gPSB0aGlzLmdldE9wdGlvbnMoKSwgeyBncm91cE1hcHNUbzogciB9ID0gbi5kYXRhLCBpID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0UmFuZ2VJZGVudGlmaWVyKCksIHsgbnVtYmVyOiBzLCBjb2RlOiBhIH0gPSB5KG4sIFwibG9jYWxlXCIpLCBvID0geShuLCBcImJ1bGxldFwiLCBcInBlcmZvcm1hbmNlQXJlYVRpdGxlc1wiKSwgbCA9IFtcIlRpdGxlXCIsIFwiR3JvdXBcIiwgXCJWYWx1ZVwiLCBcIlRhcmdldFwiLCBcIlBlcmNlbnRhZ2VcIiwgXCJQZXJmb3JtYW5jZVwiXSwgYyA9IFtcbiAgICAgIC4uLnQubWFwKCh1KSA9PiBbXG4gICAgICAgIHUudGl0bGUsXG4gICAgICAgIHVbcl0sXG4gICAgICAgIHUudmFsdWUgPT09IG51bGwgPyBcIiZuZGFzaDtcIiA6IHModS52YWx1ZSwgYSksXG4gICAgICAgIHkodSwgXCJtYXJrZXJcIikgPT09IG51bGwgPyBcIiZuZGFzaDtcIiA6IHModS5tYXJrZXIsIGEpLFxuICAgICAgICB5KHUsIFwibWFya2VyXCIpID09PSBudWxsID8gXCImbmRhc2g7XCIgOiBgJHtzKE1hdGguZmxvb3IodVtpXSAvIHUubWFya2VyICogMTAwKSwgYSl9JWAsXG4gICAgICAgIG9bdGhpcy5nZXRNYXRjaGluZ1JhbmdlSW5kZXhGb3JEYXRhcG9pbnQodSldXG4gICAgICBdKVxuICAgIF07XG4gICAgcmV0dXJuIHN1cGVyLmZvcm1hdFRhYmxlKHsgaGVhZGVyczogbCwgY2VsbHM6IGMgfSk7XG4gIH1cbn0sIGUkID0gY2xhc3MgZXh0ZW5kcyBhbiB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fY29sb3JTY2FsZSA9IHZvaWQgMCwgdGhpcy5fbWF0cml4ID0ge307XG4gIH1cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHJldHVybnMgc3RyaW5nXG4gICAqL1xuICBnZXRGaWxsQ29sb3IodCkge1xuICAgIHJldHVybiB0aGlzLl9jb2xvclNjYWxlKHQpO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCB3aWxsIGdlbmVyYXRlIGEgZGljdGlvbmFyeVxuICAgKi9cbiAgZ2V0Q29tYmluZWREYXRhKCkge1xuICAgIGlmIChCZSh0aGlzLl9tYXRyaXgpKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5nZXRPcHRpb25zKCksIG4gPSB0aGlzLmdldERpc3BsYXlEYXRhKCk7XG4gICAgICAhQmUobikgJiYgIUJlKHQuZ2VvRGF0YS5vYmplY3RzLmNvdW50cmllcykgJiYgKHQuZ2VvRGF0YS5vYmplY3RzLmNvdW50cmllcy5nZW9tZXRyaWVzLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgdGhpcy5fbWF0cml4W3IucHJvcGVydGllcy5OQU1FXSA9IHI7XG4gICAgICB9KSwgbi5mb3JFYWNoKChyKSA9PiB7XG4gICAgICAgIHRoaXMuX21hdHJpeFtyLm5hbWVdID8gdGhpcy5fbWF0cml4W3IubmFtZV0udmFsdWUgPSByLnZhbHVlIHx8IG51bGwgOiBjb25zb2xlLndhcm4oYERhdGEgcG9pbnQgJHtyfSBpcyBtaXNzaW5nIGdlb2dyYXBoaWNhbCBkYXRhLmApO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbWF0cml4O1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSB0YWJ1bGFyIGRhdGEgZnJvbSBkaXNwbGF5IGRhdGFcbiAgICogQHJldHVybnMgQXJyYXk8T2JqZWN0PlxuICAgKi9cbiAgZ2V0VGFidWxhckRhdGFBcnJheSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXREaXNwbGF5RGF0YSgpLCB7IG51bWJlcjogbiwgY29kZTogciB9ID0geSh0aGlzLmdldE9wdGlvbnMoKSwgXCJsb2NhbGVcIiksIGkgPSBbXCJDb3VudHJ5IElEXCIsIFwiQ291bnRyeSBOYW1lXCIsIFwiVmFsdWVcIl0sIHMgPSBbXG4gICAgICAuLi50Lm1hcCgoYSkgPT4gW1xuICAgICAgICBhLmlkID09PSBudWxsID8gXCImbmRhc2g7XCIgOiBhLmlkLFxuICAgICAgICBhLm5hbWUsXG4gICAgICAgIGEudmFsdWUgPT09IG51bGwgPyBcIiZuZGFzaDtcIiA6IG4oYS52YWx1ZSwgcilcbiAgICAgIF0pXG4gICAgXTtcbiAgICByZXR1cm4gc3VwZXIuZm9ybWF0VGFibGUoeyBoZWFkZXJzOiBpLCBjZWxsczogcyB9KTtcbiAgfVxuICAvLyBVc2VzIHF1YW50aXplIHNjYWxlIHRvIHJldHVybiBjbGFzcyBuYW1lc1xuICBnZXRDb2xvckNsYXNzTmFtZSh0KSB7XG4gICAgcmV0dXJuIGAke3Qub3JpZ2luYWxDbGFzc05hbWUgfHwgXCJcIn0gJHt0aGlzLl9jb2xvclNjYWxlKHQudmFsdWUpfWA7XG4gIH1cbiAgc2V0Q29sb3JDbGFzc05hbWVzKCkge1xuICAgIGNvbnN0IHQgPSB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcImNvbG9yXCIpO1xuICAgIHRoaXMuX2NvbG9yU2NhbGUgPSBGbSh0aGlzLmdldERpc3BsYXlEYXRhKCksIHQpO1xuICB9XG59LCBuJCA9IGNsYXNzIGV4dGVuZHMgYW4ge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIodCksIHRoaXMucGFyZW50Tm9kZSA9ICExLCB0aGlzLnNldCh7IGRlcHRoOiAyIH0sIHsgc2tpcFVwZGF0ZTogITAgfSk7XG4gIH1cbiAgc2V0RGF0YSh0KSB7XG4gICAgc3VwZXIuc2V0RGF0YSh0KSwgdGhpcy5zZXREYXRhR3JvdXBzKCksIHQubGVuZ3RoID09PSAxICYmICh0aGlzLnBhcmVudE5vZGUgPSAhMCksIHRoaXMuc2V0Wm9vbSgpO1xuICB9XG4gIHNldE9wdGlvbnModCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldE9wdGlvbnMoKSwgciA9IGF0KHt9LCB0LCB0aGlzLmdldFpvb21PcHRpb25zKHQpKTtcbiAgICBGYyhuLCByKTtcbiAgICBjb25zdCBpID0gdGhpcy5nZXRIaWVyYXJjaHlMZXZlbCgpLCBzID0geShuLCBcImNpcmNsZVBhY2tcIiwgXCJkZXB0aFwiKTtcbiAgICB0aGlzLnNldCh7XG4gICAgICBvcHRpb25zOiBhdChuLCByKSxcbiAgICAgIGRlcHRoOiBzICYmIHMgPCA0ID8gcyA6IGlcbiAgICB9KTtcbiAgfVxuICBnZXRab29tT3B0aW9ucyh0KSB7XG4gICAgaWYgKCF0aGlzLmdldERpc3BsYXlEYXRhKCkpXG4gICAgICByZXR1cm4ge307XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0RGlzcGxheURhdGEoKSwgciA9IHQgfHwgdGhpcy5nZXRPcHRpb25zKCksIGkgPSBuLmxlbmd0aCA9PT0gMSAmJiB5KG4sIDAsIFwiY2hpbGRyZW5cIikgPyB5KG4sIDAsIFwiY2hpbGRyZW5cIikgOiBuO1xuICAgIGxldCBzID0gdGhpcy5nZXRIaWVyYXJjaHlMZXZlbCgpO1xuICAgIHJldHVybiBpLnNvbWUoKGEpID0+IHtcbiAgICAgIGlmIChhLmNoaWxkcmVuICYmIGEuY2hpbGRyZW4uc29tZSgobykgPT4gby5jaGlsZHJlbikpXG4gICAgICAgIHJldHVybiBzID0gMywgITE7XG4gICAgfSksIHkociwgXCJjYW52YXNab29tXCIsIFwiZW5hYmxlZFwiKSA9PT0gITAgJiYgcyA+IDIgPyB7XG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgYWRkaXRpb25hbEl0ZW1zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogR3QuWk9PTSxcbiAgICAgICAgICAgIG5hbWU6IFwiQ2xpY2sgdG8gem9vbVwiXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfSA6IG51bGw7XG4gIH1cbiAgc2V0Wm9vbSh0KSB7XG4gICAgdGhpcy5zZXRPcHRpb25zKHRoaXMuZ2V0Wm9vbU9wdGlvbnModCkpO1xuICB9XG4gIC8vIHVwZGF0ZSB0aGUgaGllcmFyY2h5IGxldmVsXG4gIHVwZGF0ZUhpZXJhcmNoeUxldmVsKHQpIHtcbiAgICB0aGlzLnNldCh7IGRlcHRoOiB0IH0pO1xuICB9XG4gIGdldEhpZXJhcmNoeUxldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImRlcHRoXCIpO1xuICB9XG4gIGhhc1BhcmVudE5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZTtcbiAgfVxuICAvLyBzZXQgdGhlIGRhdGFncm91cCBuYW1lIG9uIHRoZSBpdGVtcyB0aGF0IGFyZSBpdCdzIGNoaWxkcmVuXG4gIHNldERhdGFHcm91cHMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0RGF0YSgpLCBuID0gdGhpcy5nZXRPcHRpb25zKCksIHsgZ3JvdXBNYXBzVG86IHIgfSA9IG4uZGF0YSwgaSA9IHQubWFwKChzKSA9PiB7XG4gICAgICBjb25zdCBhID0gc1tyXTtcbiAgICAgIHJldHVybiB0aGlzLnNldENoaWxkcmVuRGF0YUdyb3VwKHMsIGEpO1xuICAgIH0pO1xuICAgIHRoaXMuc2V0KFxuICAgICAge1xuICAgICAgICBkYXRhOiBpXG4gICAgICB9LFxuICAgICAgeyBza2lwVXBkYXRlOiAhMCB9XG4gICAgKTtcbiAgfVxuICAvLyBzZXRzIG5hbWUgcmVjdXJzaXZlbHkgZG93biB0aGUgbm9kZSB0cmVlXG4gIHNldENoaWxkcmVuRGF0YUdyb3VwKHQsIG4pIHtcbiAgICByZXR1cm4gdC5jaGlsZHJlbiA/IHtcbiAgICAgIC4uLnQsXG4gICAgICBkYXRhR3JvdXBOYW1lOiBuLFxuICAgICAgY2hpbGRyZW46IHQuY2hpbGRyZW4ubWFwKChyKSA9PiB0aGlzLnNldENoaWxkcmVuRGF0YUdyb3VwKHIsIG4pKVxuICAgIH0gOiB7IC4uLnQsIGRhdGFHcm91cE5hbWU6IG4gfTtcbiAgfVxuICBnZXRUYWJ1bGFyRGF0YUFycmF5KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldERpc3BsYXlEYXRhKCksIHsgbnVtYmVyOiBuLCBjb2RlOiByIH0gPSB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcImxvY2FsZVwiKSwgaSA9IFtcIkNoaWxkXCIsIFwiUGFyZW50XCIsIFwiVmFsdWVcIl0sIHMgPSBbXTtcbiAgICByZXR1cm4gdC5mb3JFYWNoKChhKSA9PiB7XG4gICAgICBsZXQgbyA9IGEudmFsdWUgPyBhLnZhbHVlIDogMDtcbiAgICAgIGEuY2hpbGRyZW4gJiYgKG8gKz0gdGhpcy5nZXRDaGlsZHJlbkRhdHVtcyhhLmNoaWxkcmVuLCBhLm5hbWUsIHMsIDApKSwgcy5wdXNoKFtcIiZuZGFzaDtcIiwgYS5uYW1lLCBuKG8sIHIpXSk7XG4gICAgfSksIHN1cGVyLmZvcm1hdFRhYmxlKHsgaGVhZGVyczogaSwgY2VsbHM6IHMgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGRldGVybWluZSB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW4gYWxsIHRoZSBuZXN0ZWQgZWxlbWVudHMgaW4gdGhlIGNoaWxkXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7YW55fSBjaGlsZHJlbiAtIFRoZSBjaGlsZHJlbiBub2RlcyB0byBwcm9jZXNzLlxuICAgKiBAcGFyYW0ge2FueX0gcGFyZW50IC0gVGhlIHBhcmVudCBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2hpbGRyZW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nW11bXX0gW3Jlc3VsdD1bXV0gLSBBbiBhcnJheSB0byBhY2N1bXVsYXRlIHRoZSByZXN1bHRpbmcgZGF0YS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0b3RhbFN1bT0wXSAtIFRoZSBydW5uaW5nIHRvdGFsIHN1bSBvZiB2YWx1ZXMgcHJvY2Vzc2VkLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTdW0uXG4gICAqL1xuICBnZXRDaGlsZHJlbkRhdHVtcyh0LCBuLCByID0gW10sIGkgPSAwKSB7XG4gICAgY29uc3QgcyA9IG4sIHsgbnVtYmVyOiBhLCBjb2RlOiBvIH0gPSB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcImxvY2FsZVwiKTtcbiAgICByZXR1cm4gdC5mb3JFYWNoKChsKSA9PiB7XG4gICAgICBjb25zdCBjID0gbC5uYW1lO1xuICAgICAgbGV0IHUgPSAwO1xuICAgICAgaWYgKGwuY2hpbGRyZW4pXG4gICAgICAgIGwuY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiAodHlwZW9mIGwudmFsdWUgPT0gXCJudW1iZXJcIiAmJiAoaSArPSBsLnZhbHVlKSwgdSArPSB0aGlzLmdldENoaWxkcmVuRGF0dW1zKGwuY2hpbGRyZW4sIGMsIHIsIHUpLCByLnB1c2goW2MsIHMsIGEodSwgbyldKSwgaSArPSB1KTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBsZXQgZCA9IDA7XG4gICAgICAgIHR5cGVvZiBsLnZhbHVlID09IFwibnVtYmVyXCIgJiYgKGQgPSBsLnZhbHVlLCBpICs9IGwudmFsdWUpLCByLnB1c2goW2wubmFtZSwgcywgYShkLCBvKV0pO1xuICAgICAgfVxuICAgIH0pLCBpO1xuICB9XG59LCByJCA9IGNsYXNzIGV4dGVuZHMgYW4ge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIodCk7XG4gIH1cbiAgZ2V0VGFidWxhckRhdGEodCkge1xuICAgIGNvbnN0IG4gPSBzdXBlci5nZXRUYWJ1bGFyRGF0YSh0KTtcbiAgICByZXR1cm4gdCAhPT0gbiAmJiBuLmZvckVhY2goKHIpID0+IHtcbiAgICAgIHIua2V5ICYmIHIua2V5ICE9PSByLmdyb3VwICYmIChyLmdyb3VwID0gci5rZXkpO1xuICAgIH0pLCBuO1xuICB9XG4gIGdldFRhYnVsYXJEYXRhQXJyYXkoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0RGlzcGxheURhdGEoKSwgbiA9IHRoaXMuZ2V0T3B0aW9ucygpLCB7IGdyb3VwTWFwc1RvOiByIH0gPSBuLmRhdGEsIHsgdmFsdWVNYXBzVG86IGkgfSA9IG4ucGllLCB7IG51bWJlcjogcywgY29kZTogYSB9ID0geShuLCBcImxvY2FsZVwiKSwgbyA9IFtcIkdyb3VwXCIsIFwiVmFsdWVcIl0sIGwgPSBbXG4gICAgICAuLi50Lm1hcCgoYykgPT4gW1xuICAgICAgICBjW3JdLFxuICAgICAgICBjW2ldID09PSBudWxsID8gXCImbmRhc2g7XCIgOiBzKGNbaV0sIGEpXG4gICAgICBdKVxuICAgIF07XG4gICAgcmV0dXJuIHN1cGVyLmZvcm1hdFRhYmxlKHsgaGVhZGVyczogbywgY2VsbHM6IGwgfSk7XG4gIH1cbiAgc2FuaXRpemUodCkge1xuICAgIHJldHVybiB0aGlzLmdldFRhYnVsYXJEYXRhKHQpLnNvcnQoKG4sIHIpID0+IHIudmFsdWUgLSBuLnZhbHVlKTtcbiAgfVxufSwgaSQgPSBjbGFzcyBleHRlbmRzIGFuIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHN1cGVyKHQpO1xuICB9XG4gIGdldERhdGFHcm91cHMoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldERhdGFHcm91cHMoKS5maWx0ZXIoKHQpID0+IHQubmFtZSAhPT0gXCJkZWx0YVwiKTtcbiAgfVxuICBnZXRUYWJ1bGFyRGF0YUFycmF5KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldERpc3BsYXlEYXRhKCksIG4gPSB0aGlzLmdldE9wdGlvbnMoKSwgeyBncm91cE1hcHNUbzogciB9ID0gbi5kYXRhLCB7IG51bWJlcjogaSwgY29kZTogcyB9ID0geSh0aGlzLmdldE9wdGlvbnMoKSwgXCJsb2NhbGVcIiksIGEgPSBbXCJHcm91cFwiLCBcIlZhbHVlXCJdLCBvID0gW1xuICAgICAgLi4udC5tYXAoKGwpID0+IFtcbiAgICAgICAgbFtyXSxcbiAgICAgICAgbC52YWx1ZSA9PT0gbnVsbCA/IFwiJm5kYXNoO1wiIDogaShsLnZhbHVlLCBzKVxuICAgICAgXSlcbiAgICBdO1xuICAgIHJldHVybiBzdXBlci5mb3JtYXRUYWJsZSh7IGhlYWRlcnM6IGEsIGNlbGxzOiBvIH0pO1xuICB9XG59LCBzJCA9IGNsYXNzIGV4dGVuZHMgbXIge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIodCksIHRoaXMuYXhpc0ZsYXZvciA9IEdhLkhPVkVSQUJMRSwgdGhpcy5fY29sb3JTY2FsZSA9IHZvaWQgMCwgdGhpcy5fZG9tYWlucyA9IFtdLCB0aGlzLl9yYW5nZXMgPSBbXSwgdGhpcy5fbWF0cml4ID0ge307XG4gICAgY29uc3QgbiA9IHkodGhpcy5nZXRPcHRpb25zKCksIFwiYXhlc1wiKTtcbiAgICBpZiAoeShuLCBcImxlZnRcIiwgXCJzY2FsZVR5cGVcIikgJiYgeShuLCBcImxlZnRcIiwgXCJzY2FsZVR5cGVcIikgIT09IGV0LkxBQkVMUyB8fCB5KG4sIFwicmlnaHRcIiwgXCJzY2FsZVR5cGVcIikgJiYgeShuLCBcInJpZ2h0XCIsIFwic2NhbGVUeXBlXCIpICE9PSBldC5MQUJFTFMgfHwgeShuLCBcInRvcFwiLCBcInNjYWxlVHlwZVwiKSAmJiB5KG4sIFwidG9wXCIsIFwic2NhbGVUeXBlXCIpICE9PSBldC5MQUJFTFMgfHwgeShuLCBcImJvdHRvbVwiLCBcInNjYWxlVHlwZVwiKSAmJiB5KG4sIFwiYm90dG9tXCIsIFwic2NhbGVUeXBlXCIpICE9PSBldC5MQUJFTFMpXG4gICAgICB0aHJvdyBFcnJvcihcIkhlYXRtYXAgb25seSBzdXBwb3J0cyBsYWJlbCBzY2FsZXR5cGVzLlwiKTtcbiAgfVxuICAvKipcbiAgICogR2V0IG1pbiBhbmQgbWF4aW11bSB2YWx1ZSBvZiB0aGUgZGlzcGxheSBkYXRhXG4gICAqIEByZXR1cm5zIEFycmF5IGNvbnNpc3Rpbmcgb2Ygc21hbGxlc3QgYW5kIGxhcmdlc3QgdmFsdWVzIGluICBkYXRhXG4gICAqL1xuICBnZXRWYWx1ZURvbWFpbigpIHtcbiAgICBjb25zdCB0ID0gemUodGhpcy5nZXREaXNwbGF5RGF0YSgpLCAocikgPT4gci52YWx1ZSksIG4gPSBGZSgpLmRvbWFpbih0KS5uaWNlKCkuZG9tYWluKCk7XG4gICAgaWYgKG5bMF0gPiAwKVxuICAgICAgblswXSA9IDA7XG4gICAgZWxzZSBpZiAoblswXSA9PT0gMCAmJiBuWzFdID09PSAwKVxuICAgICAgcmV0dXJuIFswLCAxXTtcbiAgICByZXR1cm4gblswXSA8IDAgJiYgblsxXSA+IDAgJiYgKE1hdGguYWJzKG5bMF0pID4gblsxXSA/IG5bMV0gPSBNYXRoLmFicyhuWzBdKSA6IG5bMF0gPSAtblsxXSksIG47XG4gIH1cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHJldHVybnMgc3RyaW5nXG4gICAqL1xuICBnZXRGaWxsQ29sb3IodCkge1xuICAgIHJldHVybiB0aGlzLl9jb2xvclNjYWxlKHQpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIGxpc3Qgb2YgYWxsIHVuaXF1ZSBkb21haW5zXG4gICAqIEByZXR1cm5zIFN0cmluZ1tdXG4gICAqL1xuICBnZXRVbmlxdWVEb21haW4oKSB7XG4gICAgaWYgKEJlKHRoaXMuX2RvbWFpbnMpKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5nZXREaXNwbGF5RGF0YSgpLCB7IGNhcnRlc2lhblNjYWxlczogbiB9ID0gdGhpcy5zZXJ2aWNlcywgciA9IG4uZ2V0RG9tYWluSWRlbnRpZmllcigpLCBpID0gbi5nZXRNYWluWEF4aXNQb3NpdGlvbigpLCBzID0gbi5nZXRDdXN0b21Eb21haW5WYWx1ZXNCeXBvc2l0aW9uKGkpO1xuICAgICAgaWYgKHMpXG4gICAgICAgIHJldHVybiBzO1xuICAgICAgdGhpcy5fZG9tYWlucyA9IEFycmF5LmZyb20oXG4gICAgICAgIG5ldyBTZXQoXG4gICAgICAgICAgdC5tYXAoKGEpID0+IGFbcl0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9kb21haW5zO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBsaXN0IG9mIGFsbCB1bmlxdWUgcmFuZ2VzXG4gICAqIEByZXR1cm5zIFN0cmluZ1tdXG4gICAqL1xuICBnZXRVbmlxdWVSYW5nZXMoKSB7XG4gICAgaWYgKEJlKHRoaXMuX3JhbmdlcykpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLmdldERpc3BsYXlEYXRhKCksIHsgY2FydGVzaWFuU2NhbGVzOiBuIH0gPSB0aGlzLnNlcnZpY2VzLCByID0gbi5nZXRSYW5nZUlkZW50aWZpZXIoKSwgaSA9IG4uZ2V0TWFpbllBeGlzUG9zaXRpb24oKSwgcyA9IG4uZ2V0Q3VzdG9tRG9tYWluVmFsdWVzQnlwb3NpdGlvbihpKTtcbiAgICAgIGlmIChzKVxuICAgICAgICByZXR1cm4gcztcbiAgICAgIHRoaXMuX3JhbmdlcyA9IEFycmF5LmZyb20oXG4gICAgICAgIG5ldyBTZXQoXG4gICAgICAgICAgdC5tYXAoKGEpID0+IGFbcl0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yYW5nZXM7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIG1hdHJpeCAoSWYgZG9lc24ndCBleGlzdCkgYW5kIHJldHVybnMgaXRcbiAgICogQHJldHVybnMgT2JqZWN0XG4gICAqL1xuICBnZXRNYXRyaXgoKSB7XG4gICAgaWYgKEJlKHRoaXMuX21hdHJpeCkpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLmdldFVuaXF1ZURvbWFpbigpLCBuID0gdGhpcy5nZXRVbmlxdWVSYW5nZXMoKSwgciA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpbklkZW50aWZpZXIoKSwgaSA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlSWRlbnRpZmllcigpLCBzID0ge307XG4gICAgICBuLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgc1thXSA9IHtcbiAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICBpbmRleDogLTFcbiAgICAgICAgfTtcbiAgICAgIH0pLCB0LmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgdGhpcy5fbWF0cml4W2FdID0gU24ocyk7XG4gICAgICB9KSwgdGhpcy5nZXREaXNwbGF5RGF0YSgpLmZvckVhY2goKGEsIG8pID0+IHtcbiAgICAgICAgdGhpcy5fbWF0cml4W2Fbcl1dW2FbaV1dID0ge1xuICAgICAgICAgIHZhbHVlOiBhLnZhbHVlLFxuICAgICAgICAgIGluZGV4OiBvXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX21hdHJpeDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGF0YSBmb3IgdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHNhbml0aXplcyB0aGUgcHJvdmlkZWQgZGF0YSwgZ2VuZXJhdGVzIGRhdGEgZ3JvdXBzLFxuICAgKiBhbmQgdXBkYXRlcyB0aGUgaW5zdGFuY2UncyBzdGF0ZSB3aXRoIHRoZSBzYW5pdGl6ZWQgZGF0YSBhbmQgZGF0YSBncm91cHMuXG4gICAqIEl0IGFsc28gcmVzZXRzIHRoZSBgX2RvbWFpbnNgLCBgX3Jhbmdlc2AsIGFuZCBgX21hdHJpeGAgYXR0cmlidXRlcyB0byB0aGVpciBlbXB0eSBzdGF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBuZXdEYXRhIC0gVGhlIG5ldyBkYXRhIHRvIGJlIHNldC4gVGhpcyBkYXRhIHdpbGwgYmUgY2xvbmVkIGFuZCBzYW5pdGl6ZWQuXG4gICAqIEByZXR1cm5zIHthbnl9IC0gVGhlIHNhbml0aXplZCB2ZXJzaW9uIG9mIHRoZSBwcm92aWRlZCBkYXRhLlxuICAgKi9cbiAgc2V0RGF0YSh0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMuc2FuaXRpemUoU24odCkpLCByID0gdGhpcy5nZW5lcmF0ZURhdGFHcm91cHMobik7XG4gICAgcmV0dXJuIHRoaXMuc2V0KHtcbiAgICAgIGRhdGE6IG4sXG4gICAgICBkYXRhR3JvdXBzOiByXG4gICAgfSksIHRoaXMuX2RvbWFpbnMgPSBbXSwgdGhpcy5fcmFuZ2VzID0gW10sIHRoaXMuX21hdHJpeCA9IHt9LCBuO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBPYmplY3QgbWF0cml4IGludG8gYSBzaW5nbGUgYXJyYXlcbiAgICogQHJldHVybnMgb2JqZWN0W11cbiAgICovXG4gIGdldE1hdHJpeEFzQXJyYXkoKSB7XG4gICAgQmUodGhpcy5fbWF0cml4KSAmJiB0aGlzLmdldE1hdHJpeCgpO1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldFVuaXF1ZURvbWFpbigpLCBuID0gdGhpcy5nZXRVbmlxdWVSYW5nZXMoKSwgciA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpbklkZW50aWZpZXIoKSwgaSA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlSWRlbnRpZmllcigpLCBzID0gW107XG4gICAgcmV0dXJuIHQuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgbi5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgIGNvbnN0IGwgPSB7XG4gICAgICAgICAgdmFsdWU6IHRoaXMuX21hdHJpeFthXVtvXS52YWx1ZSxcbiAgICAgICAgICBpbmRleDogdGhpcy5fbWF0cml4W2FdW29dLmluZGV4XG4gICAgICAgIH07XG4gICAgICAgIGxbcl0gPSBhLCBsW2ldID0gbywgcy5wdXNoKGwpO1xuICAgICAgfSk7XG4gICAgfSksIHM7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHRhYnVsYXIgZGF0YSBmcm9tIGRpc3BsYXkgZGF0YVxuICAgKiBAcmV0dXJucyBBcnJheTxPYmplY3Q+XG4gICAqL1xuICBnZXRUYWJ1bGFyRGF0YUFycmF5KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldERpc3BsYXlEYXRhKCksIHsgcHJpbWFyeURvbWFpbjogbiwgcHJpbWFyeVJhbmdlOiByIH0gPSB0aGlzLmFzc2lnblJhbmdlQW5kRG9tYWlucygpLCB7IG51bWJlcjogaSwgY29kZTogcyB9ID0geSh0aGlzLmdldE9wdGlvbnMoKSwgXCJsb2NhbGVcIiksIGEgPSBbbi5sYWJlbCwgci5sYWJlbCwgXCJWYWx1ZVwiXSwgbyA9IFtcbiAgICAgIC4uLnQubWFwKChsKSA9PiBbXG4gICAgICAgIGxbbi5pZGVudGlmaWVyXSA9PT0gbnVsbCA/IFwiJm5kYXNoO1wiIDogbFtuLmlkZW50aWZpZXJdLFxuICAgICAgICBsW3IuaWRlbnRpZmllcl0gPT09IG51bGwgPyBcIiZuZGFzaDtcIiA6IGxbci5pZGVudGlmaWVyXSxcbiAgICAgICAgbC52YWx1ZSA9PT0gbnVsbCA/IFwiJm5kYXNoO1wiIDogaShsLnZhbHVlLCBzKVxuICAgICAgXSlcbiAgICBdO1xuICAgIHJldHVybiBzdXBlci5mb3JtYXRUYWJsZSh7IGhlYWRlcnM6IGEsIGNlbGxzOiBvIH0pO1xuICB9XG4gIC8vIFVzZXMgcXVhbnRpemUgc2NhbGUgdG8gcmV0dXJuIGNsYXNzIG5hbWVzXG4gIGdldENvbG9yQ2xhc3NOYW1lKHQpIHtcbiAgICByZXR1cm4gYCR7dC5vcmlnaW5hbENsYXNzTmFtZX0gJHt0aGlzLl9jb2xvclNjYWxlKHQudmFsdWUpfWA7XG4gIH1cbiAgc2V0Q29sb3JDbGFzc05hbWVzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldE9wdGlvbnMoKSwgbiA9IHkodCwgXCJjb2xvclwiLCBcImdyYWRpZW50XCIsIFwiY29sb3JzXCIpLCByID0gIUJlKG4pO1xuICAgIGxldCBpID0geSh0LCBcImNvbG9yXCIsIFwicGFpcmluZ1wiLCBcIm9wdGlvblwiKTtcbiAgICBjb25zdCBzID0gdGhpcy5nZXRWYWx1ZURvbWFpbigpLCBhID0gc1swXSA8IDAgJiYgc1sxXSA+IDAgPyBcImRpdmVyZ2VcIiA6IFwibW9ub1wiO1xuICAgIChpIDwgMSAmJiBpID4gNCAmJiBhID09PSBcIm1vbm9cIiB8fCBpIDwgMSAmJiBpID4gMiAmJiBhID09PSBcImRpdmVyZ2VcIikgJiYgKGkgPSAxKTtcbiAgICBjb25zdCBvID0gciA/IG4gOiBbXTtcbiAgICBpZiAoIXIpIHtcbiAgICAgIGNvbnN0IGMgPSBhID09PSBcImRpdmVyZ2VcIiA/IDE3IDogMTE7XG4gICAgICBmb3IgKGxldCB1ID0gMTsgdSA8IGMgKyAxOyB1KyspXG4gICAgICAgIG8ucHVzaChgZmlsbC0ke2F9LSR7aX0tJHt1fWApO1xuICAgIH1cbiAgICB0aGlzLl9jb2xvclNjYWxlID0gR2MoKS5kb21haW4ocykucmFuZ2Uobyk7XG4gICAgY29uc3QgbCA9IHkodGhpcy5nZXRPcHRpb25zKCksIFwiY29sb3JcIik7XG4gICAgdGhpcy5fY29sb3JTY2FsZSA9IEZtKHRoaXMuZ2V0RGlzcGxheURhdGEoKSwgbCk7XG4gIH1cbn0sIGEkID0gY2xhc3MgZXh0ZW5kcyBtciB7XG4gIGdldFRhYnVsYXJEYXRhQXJyYXkoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0T3B0aW9ucygpLCB7IGdyb3VwTWFwc1RvOiBuIH0gPSB0LmRhdGEsIHsgbnVtYmVyOiByLCBjb2RlOiBpIH0gPSB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcImxvY2FsZVwiKSwgcyA9IHRoaXMuZ2V0QmlubmVkU3RhY2tlZERhdGEoKSwgYSA9IFtcbiAgICAgIGd0KHQsIFwiYmlucy5yYW5nZUxhYmVsXCIpIHx8IFwiUmFuZ2VcIixcbiAgICAgIC4uLnMubWFwKChsKSA9PiBndChsLCBgMC4ke259YCkpXG4gICAgXSwgbyA9IFtcbiAgICAgIC4uLmd0KHMsIDApLm1hcCgobCwgYykgPT4gW1xuICAgICAgICBgJHtyKE51bWJlcihndChsLCBcImRhdGEueDBcIikpLCBpKX0g4oCTICR7cihcbiAgICAgICAgICBOdW1iZXIoZ3QobCwgXCJkYXRhLngxXCIpKSxcbiAgICAgICAgICBpXG4gICAgICAgICl9YCxcbiAgICAgICAgLi4ucy5tYXAoXG4gICAgICAgICAgKHUpID0+IHIoZ3QodVtjXSwgYGRhdGEuJHtndCh1W2NdLCBuKX1gKSwgaSlcbiAgICAgICAgKVxuICAgICAgXSlcbiAgICBdO1xuICAgIHJldHVybiBzdXBlci5mb3JtYXRUYWJsZSh7IGhlYWRlcnM6IGEsIGNlbGxzOiBvIH0pO1xuICB9XG59O1xuY2xhc3MgbyQgZXh0ZW5kcyBhbiB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcih0KTtcbiAgfVxuICBnZXRNYXhpbXVtRG9tYWluKHQpIHtcbiAgICByZXR1cm4gdC5yZWR1Y2UoKG4sIHIpID0+IG4gKyByLnZhbHVlLCAwKTtcbiAgfVxuICAvKipcbiAgICogVXNlIGEgcHJvdmlkZWQgY29sb3IgZm9yIHRoZSBiYXIgb3IgZGVmYXVsdCB0byBjYXJib24gY29sb3IgaWYgbm8gc3RhdHVzIHByb3ZpZGVkLlxuICAgKiBEZWZhdWx0cyB0byBjYXJib24gY29sb3Igb3RoZXJ3aXNlLlxuICAgKiBAcGFyYW0gZ3JvdXAgZGF0YXNldCBncm91cCBsYWJlbFxuICAgKi9cbiAgZ2V0RmlsbENvbG9yKHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRPcHRpb25zKCksIHIgPSB5KG4sIFwiY29sb3JcIiwgXCJzY2FsZVwiKSwgaSA9IHRoaXMuZ2V0U3RhdHVzKCk7XG4gICAgcmV0dXJuIHIgfHwgIWkgPyBzdXBlci5nZXRGaWxsQ29sb3IodCkgOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGFzc29jaWF0ZWQgc3RhdHVzIGZvciB0aGUgZGF0YSBieSBjaGVja2luZyB0aGUgcmFuZ2VzXG4gICAqL1xuICBnZXRTdGF0dXMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0T3B0aW9ucygpLCBuID0geSh0aGlzLmdldERpc3BsYXlEYXRhKCkpLCByID0gKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4ucmVkdWNlKChhLCBvKSA9PiBhICsgby52YWx1ZSwgMCkpID8/IDAsIGkgPSB5KHQsIFwibWV0ZXJcIiwgXCJwcm9wb3J0aW9uYWxcIikgPyByIDogciA+IDEwMCA/IDEwMCA6IHIsIHMgPSB5KHQsIFwibWV0ZXJcIiwgXCJzdGF0dXNcIiwgXCJyYW5nZXNcIik7XG4gICAgaWYgKHMpIHtcbiAgICAgIGNvbnN0IGEgPSBzLmZpbHRlcihcbiAgICAgICAgKG8pID0+IG8ucmFuZ2VbMF0gPD0gaSAmJiBpIDw9IG8ucmFuZ2VbMV1cbiAgICAgICk7XG4gICAgICBpZiAoYS5sZW5ndGggPiAwKVxuICAgICAgICByZXR1cm4gYVswXS5zdGF0dXM7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldFRhYnVsYXJEYXRhQXJyYXkoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0RGlzcGxheURhdGEoKSwgbiA9IHRoaXMuZ2V0T3B0aW9ucygpLCB7IGdyb3VwTWFwc1RvOiByIH0gPSBuLmRhdGEsIGkgPSB0aGlzLmdldFN0YXR1cygpLCBzID0geShuLCBcIm1ldGVyXCIsIFwicHJvcG9ydGlvbmFsXCIpLCB7IG51bWJlcjogYSwgY29kZTogbyB9ID0geSh0aGlzLmdldE9wdGlvbnMoKSwgXCJsb2NhbGVcIik7XG4gICAgbGV0IGwgPSBbXSwgYyA9IFtdLCB1O1xuICAgIGlmIChzID09PSBudWxsKSB7XG4gICAgICB1ID0gMTAwO1xuICAgICAgY29uc3QgZCA9IHRbMF07XG4gICAgICBsID0gW1wiR3JvdXBcIiwgXCJWYWx1ZVwiLCAuLi5pID8gW1wiU3RhdHVzXCJdIDogW11dLCBjID0gW1xuICAgICAgICBbXG4gICAgICAgICAgZFtyXSxcbiAgICAgICAgICBkLnZhbHVlID09PSBudWxsID8gXCImbmRhc2g7XCIgOiBhKGQudmFsdWUsIG8pLFxuICAgICAgICAgIC4uLmkgPyBbaV0gOiBbXVxuICAgICAgICBdXG4gICAgICBdO1xuICAgIH0gZWxzZVxuICAgICAgdSA9IHkocywgXCJ0b3RhbFwiKSB8fCB0aGlzLmdldE1heGltdW1Eb21haW4odCksIGwgPSBbXCJHcm91cFwiLCBcIlZhbHVlXCIsIFwiUGVyY2VudGFnZSBvZiB0b3RhbFwiXSwgYyA9IFtcbiAgICAgICAgLi4udC5tYXAoKGgpID0+IHtcbiAgICAgICAgICBsZXQgcDtcbiAgICAgICAgICBoLnZhbHVlICE9PSBudWxsICYmIGgudmFsdWUgIT09IHZvaWQgMCA/IHAgPSBOdW1iZXIoaC52YWx1ZSkgOiBwID0gMDtcbiAgICAgICAgICBjb25zdCBmID0gTnVtYmVyKChoLnZhbHVlIC8gdSAqIDEwMCkudG9GaXhlZCgyKSk7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGhbcl0sXG4gICAgICAgICAgICBoLnZhbHVlID09PSBudWxsID8gXCImbmRhc2g7XCIgOiBhKHAsIG8pLFxuICAgICAgICAgICAgYShmLCBvKSArIFwiICVcIlxuICAgICAgICAgIF07XG4gICAgICAgIH0pXG4gICAgICBdO1xuICAgIHJldHVybiBzdXBlci5mb3JtYXRUYWJsZSh7IGhlYWRlcnM6IGwsIGNlbGxzOiBjIH0pO1xuICB9XG59XG5jbGFzcyBsJCBleHRlbmRzIG1yIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHN1cGVyKHQpO1xuICB9XG4gIGdldFRhYnVsYXJEYXRhQXJyYXkoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0T3B0aW9ucygpLCBuID0gdGhpcy5nZXRHcm91cGVkRGF0YSgpLCB7IGFuZ2xlOiByLCB2YWx1ZTogaSB9ID0geSh0LCBcInJhZGFyXCIsIFwiYXhlc1wiKSwgeyBudW1iZXI6IHMsIGNvZGU6IGEgfSA9IHkodCwgXCJsb2NhbGVcIiksIG8gPSB5KG4sIFwiMFwiLCBcImRhdGFcIikubWFwKCh1KSA9PiB1W3JdKSwgbCA9IFtcIkdyb3VwXCIsIC4uLm9dLCBjID0gW1xuICAgICAgLi4ubi5tYXAoKHUpID0+IFtcbiAgICAgICAgdS5uYW1lLFxuICAgICAgICAuLi5vLm1hcChcbiAgICAgICAgICAoZCwgaCkgPT4geSh1LCBcImRhdGFcIiwgaCwgaSkgIT09IG51bGwgPyBzKHkodSwgXCJkYXRhXCIsIGgsIGkpLCBhKSA6IFwiJm5kYXNoO1wiXG4gICAgICAgIClcbiAgICAgIF0pXG4gICAgXTtcbiAgICByZXR1cm4gc3VwZXIuZm9ybWF0VGFibGUoeyBoZWFkZXJzOiBsLCBjZWxsczogYyB9KTtcbiAgfVxufVxubGV0IGMkID0gY2xhc3MgZXh0ZW5kcyBhbiB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcih0KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIGFuZCBmb3JtYXRzIHRhYnVsYXIgZGF0YSBmcm9tIHRoZSBkaXNwbGF5IGRhdGEuXG4gICAqXG4gICAqIEByZXR1cm5zIHthbnlbXX0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGhlYWRlcnMgYW5kIGNlbGxzIG9mIHRoZSB0YWJ1bGFyIGRhdGEuXG4gICAqL1xuICBnZXRUYWJ1bGFyRGF0YUFycmF5KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldERpc3BsYXlEYXRhKCksIG4gPSBbXCJDaGlsZFwiLCBcIlBhcmVudFwiXSwgciA9IFtdO1xuICAgIHJldHVybiB0LmZvckVhY2goKGkpID0+IHtcbiAgICAgIHRoaXMuZ2V0Q2hpbGRyZW5EYXR1bXMoaSwgciksIHIucHVzaChbaS5uYW1lLCBcIiZuZGFzaDtcIl0pO1xuICAgIH0pLCBzdXBlci5mb3JtYXRUYWJsZSh7IGhlYWRlcnM6IG4sIGNlbGxzOiByIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIGNoaWxkIHBhcmVudCByZWxhdGlvbnNoaXAgaW4gbmVzdGVkIGRhdGFcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHthbnl9IGRhdHVtIC0gVGhlIGRhdHVtIG5vZGUgdG8gcHJvY2Vzcy5cbiAgICogQHBhcmFtIHthbnlbXX0gW3Jlc3VsdD1bXV0gLSBBbiBhcnJheSB0byBhY2N1bXVsYXRlIHRoZSByZXN1bHRpbmcgZGF0YS5cbiAgICogQHJldHVybnMge2FueVtdfSBUaGUgYWNjdW11bGF0ZWQgcmVzdWx0IGFycmF5LlxuICAgKi9cbiAgZ2V0Q2hpbGRyZW5EYXR1bXModCwgbiA9IFtdKSB7XG4gICAgdC5jaGlsZHJlbiAmJiB0LmNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgdC5jaGlsZHJlbi5mb3JFYWNoKChyKSA9PiB7XG4gICAgICB0aGlzLmdldENoaWxkcmVuRGF0dW1zKHIsIG4pLCBuLnB1c2goW3IubmFtZSwgdC5uYW1lXSk7XG4gICAgfSk7XG4gIH1cbn07XG5jbGFzcyB1JCBleHRlbmRzIGFuIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHN1cGVyKHQpO1xuICB9XG4gIGdldFRhYnVsYXJEYXRhQXJyYXkoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0RGlzcGxheURhdGEoKSwgeyBudW1iZXI6IG4sIGNvZGU6IHIgfSA9IHkodGhpcy5nZXRPcHRpb25zKCksIFwibG9jYWxlXCIpLCBpID0gW1wiQ2hpbGRcIiwgXCJHcm91cFwiLCBcIlZhbHVlXCJdLCBzID0gW107XG4gICAgcmV0dXJuIHQuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgQXJyYXkuaXNBcnJheShhLmNoaWxkcmVuKSA/IGEuY2hpbGRyZW4uZm9yRWFjaCgobykgPT4ge1xuICAgICAgICBzLnB1c2goW1xuICAgICAgICAgIG8ubmFtZSxcbiAgICAgICAgICBhLm5hbWUsXG4gICAgICAgICAgby52YWx1ZSA9PT0gbnVsbCA/IFwiJm5kYXNoO1wiIDogbihvLnZhbHVlLCByKVxuICAgICAgICBdKTtcbiAgICAgIH0pIDogeShhLm5hbWUpICE9PSBudWxsICYmIHkoYS52YWx1ZSkgJiYgcy5wdXNoKFtcIuKAk1wiLCBhLm5hbWUsIG4oYS52YWx1ZSwgcildKTtcbiAgICB9KSwgc3VwZXIuZm9ybWF0VGFibGUoeyBoZWFkZXJzOiBpLCBjZWxsczogcyB9KTtcbiAgfVxufVxubGV0IGgkID0gY2xhc3MgZXh0ZW5kcyBhbiB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcih0KTtcbiAgfVxuICBnZXRUYWJ1bGFyRGF0YUFycmF5KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldERpc3BsYXlEYXRhKCksIG4gPSB0aGlzLmdldE9wdGlvbnMoKSwgeyBmb250U2l6ZU1hcHNUbzogciwgd29yZE1hcHNUbzogaSB9ID0gbi53b3JkQ2xvdWQsIHsgZ3JvdXBNYXBzVG86IHMgfSA9IG4uZGF0YSwgeyBjb2RlOiBhLCBudW1iZXI6IG8gfSA9IHkobiwgXCJsb2NhbGVcIiksIGwgPSBbbi50b29sdGlwLndvcmRMYWJlbCwgXCJHcm91cFwiLCBuLnRvb2x0aXAudmFsdWVMYWJlbF0sIGMgPSBbXG4gICAgICAuLi50Lm1hcCgodSkgPT4gW1xuICAgICAgICB1W2ldLFxuICAgICAgICB1W3NdLFxuICAgICAgICBvKHVbcl0sIGEpXG4gICAgICBdKVxuICAgIF07XG4gICAgcmV0dXJuIHN1cGVyLmZvcm1hdFRhYmxlKHsgaGVhZGVyczogbCwgY2VsbHM6IGMgfSk7XG4gIH1cbn07XG52YXIgZCQgPSAvXFxzLztcbmZ1bmN0aW9uIHAkKGUpIHtcbiAgZm9yICh2YXIgdCA9IGUubGVuZ3RoOyB0LS0gJiYgZCQudGVzdChlLmNoYXJBdCh0KSk7IClcbiAgICA7XG4gIHJldHVybiB0O1xufVxudmFyIGYkID0gL15cXHMrLztcbmZ1bmN0aW9uIG0kKGUpIHtcbiAgcmV0dXJuIGUgJiYgZS5zbGljZSgwLCBwJChlKSArIDEpLnJlcGxhY2UoZiQsIFwiXCIpO1xufVxudmFyIFdoID0gTmFOLCBnJCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pLCB2JCA9IC9eMGJbMDFdKyQvaSwgeSQgPSAvXjBvWzAtN10rJC9pLCB4JCA9IHBhcnNlSW50O1xuZnVuY3Rpb24genIoZSkge1xuICBpZiAodHlwZW9mIGUgPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gZTtcbiAgaWYgKEZhKGUpKVxuICAgIHJldHVybiBXaDtcbiAgaWYgKERlKGUpKSB7XG4gICAgdmFyIHQgPSB0eXBlb2YgZS52YWx1ZU9mID09IFwiZnVuY3Rpb25cIiA/IGUudmFsdWVPZigpIDogZTtcbiAgICBlID0gRGUodCkgPyB0ICsgXCJcIiA6IHQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBlICE9IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGUgPT09IDAgPyBlIDogK2U7XG4gIGUgPSBtJChlKTtcbiAgdmFyIG4gPSB2JC50ZXN0KGUpO1xuICByZXR1cm4gbiB8fCB5JC50ZXN0KGUpID8geCQoZS5zbGljZSgyKSwgbiA/IDIgOiA4KSA6IGckLnRlc3QoZSkgPyBXaCA6ICtlO1xufVxudmFyIE5vID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBXZS5EYXRlLm5vdygpO1xufSwgYiQgPSBcIkV4cGVjdGVkIGEgZnVuY3Rpb25cIiwgXyQgPSBNYXRoLm1heCwgRSQgPSBNYXRoLm1pbjtcbmZ1bmN0aW9uIGJhKGUsIHQsIG4pIHtcbiAgdmFyIHIsIGksIHMsIGEsIG8sIGwsIGMgPSAwLCB1ID0gITEsIGQgPSAhMSwgaCA9ICEwO1xuICBpZiAodHlwZW9mIGUgIT0gXCJmdW5jdGlvblwiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYiQpO1xuICB0ID0genIodCkgfHwgMCwgRGUobikgJiYgKHUgPSAhIW4ubGVhZGluZywgZCA9IFwibWF4V2FpdFwiIGluIG4sIHMgPSBkID8gXyQoenIobi5tYXhXYWl0KSB8fCAwLCB0KSA6IHMsIGggPSBcInRyYWlsaW5nXCIgaW4gbiA/ICEhbi50cmFpbGluZyA6IGgpO1xuICBmdW5jdGlvbiBwKFMpIHtcbiAgICB2YXIgTSA9IHIsIEQgPSBpO1xuICAgIHJldHVybiByID0gaSA9IHZvaWQgMCwgYyA9IFMsIGEgPSBlLmFwcGx5KEQsIE0pLCBhO1xuICB9XG4gIGZ1bmN0aW9uIGYoUykge1xuICAgIHJldHVybiBjID0gUywgbyA9IHNldFRpbWVvdXQodiwgdCksIHUgPyBwKFMpIDogYTtcbiAgfVxuICBmdW5jdGlvbiBnKFMpIHtcbiAgICB2YXIgTSA9IFMgLSBsLCBEID0gUyAtIGMsIEEgPSB0IC0gTTtcbiAgICByZXR1cm4gZCA/IEUkKEEsIHMgLSBEKSA6IEE7XG4gIH1cbiAgZnVuY3Rpb24gbShTKSB7XG4gICAgdmFyIE0gPSBTIC0gbCwgRCA9IFMgLSBjO1xuICAgIHJldHVybiBsID09PSB2b2lkIDAgfHwgTSA+PSB0IHx8IE0gPCAwIHx8IGQgJiYgRCA+PSBzO1xuICB9XG4gIGZ1bmN0aW9uIHYoKSB7XG4gICAgdmFyIFMgPSBObygpO1xuICAgIGlmIChtKFMpKVxuICAgICAgcmV0dXJuIHgoUyk7XG4gICAgbyA9IHNldFRpbWVvdXQodiwgZyhTKSk7XG4gIH1cbiAgZnVuY3Rpb24geChTKSB7XG4gICAgcmV0dXJuIG8gPSB2b2lkIDAsIGggJiYgciA/IHAoUykgOiAociA9IGkgPSB2b2lkIDAsIGEpO1xuICB9XG4gIGZ1bmN0aW9uIF8oKSB7XG4gICAgbyAhPT0gdm9pZCAwICYmIGNsZWFyVGltZW91dChvKSwgYyA9IDAsIHIgPSBsID0gaSA9IG8gPSB2b2lkIDA7XG4gIH1cbiAgZnVuY3Rpb24gRSgpIHtcbiAgICByZXR1cm4gbyA9PT0gdm9pZCAwID8gYSA6IHgoTm8oKSk7XG4gIH1cbiAgZnVuY3Rpb24gYigpIHtcbiAgICB2YXIgUyA9IE5vKCksIE0gPSBtKFMpO1xuICAgIGlmIChyID0gYXJndW1lbnRzLCBpID0gdGhpcywgbCA9IFMsIE0pIHtcbiAgICAgIGlmIChvID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybiBmKGwpO1xuICAgICAgaWYgKGQpXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobyksIG8gPSBzZXRUaW1lb3V0KHYsIHQpLCBwKGwpO1xuICAgIH1cbiAgICByZXR1cm4gbyA9PT0gdm9pZCAwICYmIChvID0gc2V0VGltZW91dCh2LCB0KSksIGE7XG4gIH1cbiAgcmV0dXJuIGIuY2FuY2VsID0gXywgYi5mbHVzaCA9IEUsIGI7XG59XG5mdW5jdGlvbiBPJChlLCB0LCBuKSB7XG4gIGUgPSArZSwgdCA9ICt0LCBuID0gKGkgPSBhcmd1bWVudHMubGVuZ3RoKSA8IDIgPyAodCA9IGUsIGUgPSAwLCAxKSA6IGkgPCAzID8gMSA6ICtuO1xuICBmb3IgKHZhciByID0gLTEsIGkgPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKHQgLSBlKSAvIG4pKSB8IDAsIHMgPSBuZXcgQXJyYXkoaSk7ICsrciA8IGk7IClcbiAgICBzW3JdID0gZSArIHIgKiBuO1xuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIEkoZSkge1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IG5ldyBfZShbW2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZSldXSwgW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0pIDogbmV3IF9lKFtbZV1dLCBzbSk7XG59XG5mdW5jdGlvbiBncygpIHtcbiAgdmFyIGUgPSBybygpLnVua25vd24odm9pZCAwKSwgdCA9IGUuZG9tYWluLCBuID0gZS5yYW5nZSwgciA9IDAsIGkgPSAxLCBzLCBhLCBvID0gITEsIGwgPSAwLCBjID0gMCwgdSA9IDAuNTtcbiAgZGVsZXRlIGUudW5rbm93bjtcbiAgZnVuY3Rpb24gZCgpIHtcbiAgICB2YXIgaCA9IHQoKS5sZW5ndGgsIHAgPSBpIDwgciwgZiA9IHAgPyBpIDogciwgZyA9IHAgPyByIDogaTtcbiAgICBzID0gKGcgLSBmKSAvIE1hdGgubWF4KDEsIGggLSBsICsgYyAqIDIpLCBvICYmIChzID0gTWF0aC5mbG9vcihzKSksIGYgKz0gKGcgLSBmIC0gcyAqIChoIC0gbCkpICogdSwgYSA9IHMgKiAoMSAtIGwpLCBvICYmIChmID0gTWF0aC5yb3VuZChmKSwgYSA9IE1hdGgucm91bmQoYSkpO1xuICAgIHZhciBtID0gTyQoaCkubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBmICsgcyAqIHY7XG4gICAgfSk7XG4gICAgcmV0dXJuIG4ocCA/IG0ucmV2ZXJzZSgpIDogbSk7XG4gIH1cbiAgcmV0dXJuIGUuZG9tYWluID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQoaCksIGQoKSkgOiB0KCk7XG4gIH0sIGUucmFuZ2UgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoW3IsIGldID0gaCwgciA9ICtyLCBpID0gK2ksIGQoKSkgOiBbciwgaV07XG4gIH0sIGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gW3IsIGldID0gaCwgciA9ICtyLCBpID0gK2ksIG8gPSAhMCwgZCgpO1xuICB9LCBlLmJhbmR3aWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhO1xuICB9LCBlLnN0ZXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcztcbiAgfSwgZS5yb3VuZCA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvID0gISFoLCBkKCkpIDogbztcbiAgfSwgZS5wYWRkaW5nID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGwgPSBNYXRoLm1pbigxLCBjID0gK2gpLCBkKCkpIDogbDtcbiAgfSwgZS5wYWRkaW5nSW5uZXIgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobCA9IE1hdGgubWluKDEsIGgpLCBkKCkpIDogbDtcbiAgfSwgZS5wYWRkaW5nT3V0ZXIgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYyA9ICtoLCBkKCkpIDogYztcbiAgfSwgZS5hbGlnbiA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgaCkpLCBkKCkpIDogdTtcbiAgfSwgZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGdzKHQoKSwgW3IsIGldKS5yb3VuZChvKS5wYWRkaW5nSW5uZXIobCkucGFkZGluZ091dGVyKGMpLmFsaWduKHUpO1xuICB9LCBpaS5hcHBseShkKCksIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBxbShlLCB0KSB7XG4gIGUgPSBlLnNsaWNlKCk7XG4gIHZhciBuID0gMCwgciA9IGUubGVuZ3RoIC0gMSwgaSA9IGVbbl0sIHMgPSBlW3JdLCBhO1xuICByZXR1cm4gcyA8IGkgJiYgKGEgPSBuLCBuID0gciwgciA9IGEsIGEgPSBpLCBpID0gcywgcyA9IGEpLCBlW25dID0gdC5mbG9vcihpKSwgZVtyXSA9IHQuY2VpbChzKSwgZTtcbn1cbmNvbnN0IFBvID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIFVvID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG5mdW5jdGlvbiBXdChlLCB0LCBuLCByKSB7XG4gIGZ1bmN0aW9uIGkocykge1xuICAgIHJldHVybiBlKHMgPSBhcmd1bWVudHMubGVuZ3RoID09PSAwID8gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkgOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoK3MpKSwgcztcbiAgfVxuICByZXR1cm4gaS5mbG9vciA9IChzKSA9PiAoZShzID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCtzKSksIHMpLCBpLmNlaWwgPSAocykgPT4gKGUocyA9IG5ldyBEYXRlKHMgLSAxKSksIHQocywgMSksIGUocyksIHMpLCBpLnJvdW5kID0gKHMpID0+IHtcbiAgICBjb25zdCBhID0gaShzKSwgbyA9IGkuY2VpbChzKTtcbiAgICByZXR1cm4gcyAtIGEgPCBvIC0gcyA/IGEgOiBvO1xuICB9LCBpLm9mZnNldCA9IChzLCBhKSA9PiAodChzID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCtzKSwgYSA9PSBudWxsID8gMSA6IE1hdGguZmxvb3IoYSkpLCBzKSwgaS5yYW5nZSA9IChzLCBhLCBvKSA9PiB7XG4gICAgY29uc3QgbCA9IFtdO1xuICAgIGlmIChzID0gaS5jZWlsKHMpLCBvID0gbyA9PSBudWxsID8gMSA6IE1hdGguZmxvb3IobyksICEocyA8IGEpIHx8ICEobyA+IDApKSByZXR1cm4gbDtcbiAgICBsZXQgYztcbiAgICBkb1xuICAgICAgbC5wdXNoKGMgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoK3MpKSwgdChzLCBvKSwgZShzKTtcbiAgICB3aGlsZSAoYyA8IHMgJiYgcyA8IGEpO1xuICAgIHJldHVybiBsO1xuICB9LCBpLmZpbHRlciA9IChzKSA9PiBXdCgoYSkgPT4ge1xuICAgIGlmIChhID49IGEpIGZvciAoOyBlKGEpLCAhcyhhKTsgKSBhLnNldFRpbWUoYSAtIDEpO1xuICB9LCAoYSwgbykgPT4ge1xuICAgIGlmIChhID49IGEpXG4gICAgICBpZiAobyA8IDApIGZvciAoOyArK28gPD0gMDsgKVxuICAgICAgICBmb3IgKDsgdChhLCAtMSksICFzKGEpOyApXG4gICAgICAgICAgO1xuICAgICAgZWxzZSBmb3IgKDsgLS1vID49IDA7IClcbiAgICAgICAgZm9yICg7IHQoYSwgMSksICFzKGEpOyApXG4gICAgICAgICAgO1xuICB9KSwgbiAmJiAoaS5jb3VudCA9IChzLCBhKSA9PiAoUG8uc2V0VGltZSgrcyksIFVvLnNldFRpbWUoK2EpLCBlKFBvKSwgZShVbyksIE1hdGguZmxvb3IobihQbywgVW8pKSksIGkuZXZlcnkgPSAocykgPT4gKHMgPSBNYXRoLmZsb29yKHMpLCAhaXNGaW5pdGUocykgfHwgIShzID4gMCkgPyBudWxsIDogcyA+IDEgPyBpLmZpbHRlcihyID8gKGEpID0+IHIoYSkgJSBzID09PSAwIDogKGEpID0+IGkuY291bnQoMCwgYSkgJSBzID09PSAwKSA6IGkpKSwgaTtcbn1cbmNvbnN0IF9hID0gV3QoKCkgPT4ge1xufSwgKGUsIHQpID0+IHtcbiAgZS5zZXRUaW1lKCtlICsgdCk7XG59LCAoZSwgdCkgPT4gdCAtIGUpO1xuX2EuZXZlcnkgPSAoZSkgPT4gKGUgPSBNYXRoLmZsb29yKGUpLCAhaXNGaW5pdGUoZSkgfHwgIShlID4gMCkgPyBudWxsIDogZSA+IDEgPyBXdCgodCkgPT4ge1xuICB0LnNldFRpbWUoTWF0aC5mbG9vcih0IC8gZSkgKiBlKTtcbn0sICh0LCBuKSA9PiB7XG4gIHQuc2V0VGltZSgrdCArIG4gKiBlKTtcbn0sICh0LCBuKSA9PiAobiAtIHQpIC8gZSkgOiBfYSk7XG5fYS5yYW5nZTtcbmNvbnN0IGJuID0gMWUzLCBDZSA9IGJuICogNjAsIF9uID0gQ2UgKiA2MCwgJG4gPSBfbiAqIDI0LCBXYyA9ICRuICogNywgcWggPSAkbiAqIDMwLCBCbyA9ICRuICogMzY1LCBVciA9IFd0KChlKSA9PiB7XG4gIGUuc2V0VGltZShlIC0gZS5nZXRNaWxsaXNlY29uZHMoKSk7XG59LCAoZSwgdCkgPT4ge1xuICBlLnNldFRpbWUoK2UgKyB0ICogYm4pO1xufSwgKGUsIHQpID0+ICh0IC0gZSkgLyBibiwgKGUpID0+IGUuZ2V0VVRDU2Vjb25kcygpKTtcblVyLnJhbmdlO1xuY29uc3QgcWMgPSBXdCgoZSkgPT4ge1xuICBlLnNldFRpbWUoZSAtIGUuZ2V0TWlsbGlzZWNvbmRzKCkgLSBlLmdldFNlY29uZHMoKSAqIGJuKTtcbn0sIChlLCB0KSA9PiB7XG4gIGUuc2V0VGltZSgrZSArIHQgKiBDZSk7XG59LCAoZSwgdCkgPT4gKHQgLSBlKSAvIENlLCAoZSkgPT4gZS5nZXRNaW51dGVzKCkpO1xucWMucmFuZ2U7XG5jb25zdCBTJCA9IFd0KChlKSA9PiB7XG4gIGUuc2V0VVRDU2Vjb25kcygwLCAwKTtcbn0sIChlLCB0KSA9PiB7XG4gIGUuc2V0VGltZSgrZSArIHQgKiBDZSk7XG59LCAoZSwgdCkgPT4gKHQgLSBlKSAvIENlLCAoZSkgPT4gZS5nZXRVVENNaW51dGVzKCkpO1xuUyQucmFuZ2U7XG5jb25zdCBZYyA9IFd0KChlKSA9PiB7XG4gIGUuc2V0VGltZShlIC0gZS5nZXRNaWxsaXNlY29uZHMoKSAtIGUuZ2V0U2Vjb25kcygpICogYm4gLSBlLmdldE1pbnV0ZXMoKSAqIENlKTtcbn0sIChlLCB0KSA9PiB7XG4gIGUuc2V0VGltZSgrZSArIHQgKiBfbik7XG59LCAoZSwgdCkgPT4gKHQgLSBlKSAvIF9uLCAoZSkgPT4gZS5nZXRIb3VycygpKTtcblljLnJhbmdlO1xuY29uc3QgVCQgPSBXdCgoZSkgPT4ge1xuICBlLnNldFVUQ01pbnV0ZXMoMCwgMCwgMCk7XG59LCAoZSwgdCkgPT4ge1xuICBlLnNldFRpbWUoK2UgKyB0ICogX24pO1xufSwgKGUsIHQpID0+ICh0IC0gZSkgLyBfbiwgKGUpID0+IGUuZ2V0VVRDSG91cnMoKSk7XG5UJC5yYW5nZTtcbmNvbnN0IHZzID0gV3QoXG4gIChlKSA9PiBlLnNldEhvdXJzKDAsIDAsIDAsIDApLFxuICAoZSwgdCkgPT4gZS5zZXREYXRlKGUuZ2V0RGF0ZSgpICsgdCksXG4gIChlLCB0KSA9PiAodCAtIGUgLSAodC5nZXRUaW1lem9uZU9mZnNldCgpIC0gZS5nZXRUaW1lem9uZU9mZnNldCgpKSAqIENlKSAvICRuLFxuICAoZSkgPT4gZS5nZXREYXRlKCkgLSAxXG4pO1xudnMucmFuZ2U7XG5jb25zdCBYYyA9IFd0KChlKSA9PiB7XG4gIGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG59LCAoZSwgdCkgPT4ge1xuICBlLnNldFVUQ0RhdGUoZS5nZXRVVENEYXRlKCkgKyB0KTtcbn0sIChlLCB0KSA9PiAodCAtIGUpIC8gJG4sIChlKSA9PiBlLmdldFVUQ0RhdGUoKSAtIDEpO1xuWGMucmFuZ2U7XG5jb25zdCB3JCA9IFd0KChlKSA9PiB7XG4gIGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG59LCAoZSwgdCkgPT4ge1xuICBlLnNldFVUQ0RhdGUoZS5nZXRVVENEYXRlKCkgKyB0KTtcbn0sIChlLCB0KSA9PiAodCAtIGUpIC8gJG4sIChlKSA9PiBNYXRoLmZsb29yKGUgLyAkbikpO1xudyQucmFuZ2U7XG5mdW5jdGlvbiBncihlKSB7XG4gIHJldHVybiBXdCgodCkgPT4ge1xuICAgIHQuc2V0RGF0ZSh0LmdldERhdGUoKSAtICh0LmdldERheSgpICsgNyAtIGUpICUgNyksIHQuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sICh0LCBuKSA9PiB7XG4gICAgdC5zZXREYXRlKHQuZ2V0RGF0ZSgpICsgbiAqIDcpO1xuICB9LCAodCwgbikgPT4gKG4gLSB0IC0gKG4uZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHQuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiBDZSkgLyBXYyk7XG59XG5jb25zdCBhbyA9IGdyKDApLCBFYSA9IGdyKDEpLCAkJCA9IGdyKDIpLCBNJCA9IGdyKDMpLCBRciA9IGdyKDQpLCBDJCA9IGdyKDUpLCBBJCA9IGdyKDYpO1xuYW8ucmFuZ2U7XG5FYS5yYW5nZTtcbiQkLnJhbmdlO1xuTSQucmFuZ2U7XG5Rci5yYW5nZTtcbkMkLnJhbmdlO1xuQSQucmFuZ2U7XG5mdW5jdGlvbiB2cihlKSB7XG4gIHJldHVybiBXdCgodCkgPT4ge1xuICAgIHQuc2V0VVRDRGF0ZSh0LmdldFVUQ0RhdGUoKSAtICh0LmdldFVUQ0RheSgpICsgNyAtIGUpICUgNyksIHQuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sICh0LCBuKSA9PiB7XG4gICAgdC5zZXRVVENEYXRlKHQuZ2V0VVRDRGF0ZSgpICsgbiAqIDcpO1xuICB9LCAodCwgbikgPT4gKG4gLSB0KSAvIFdjKTtcbn1cbmNvbnN0IFltID0gdnIoMCksIE9hID0gdnIoMSksIEwkID0gdnIoMiksIGskID0gdnIoMyksIEpyID0gdnIoNCksIEQkID0gdnIoNSksIFIkID0gdnIoNik7XG5ZbS5yYW5nZTtcbk9hLnJhbmdlO1xuTCQucmFuZ2U7XG5rJC5yYW5nZTtcbkpyLnJhbmdlO1xuRCQucmFuZ2U7XG5SJC5yYW5nZTtcbmNvbnN0IFpjID0gV3QoKGUpID0+IHtcbiAgZS5zZXREYXRlKDEpLCBlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xufSwgKGUsIHQpID0+IHtcbiAgZS5zZXRNb250aChlLmdldE1vbnRoKCkgKyB0KTtcbn0sIChlLCB0KSA9PiB0LmdldE1vbnRoKCkgLSBlLmdldE1vbnRoKCkgKyAodC5nZXRGdWxsWWVhcigpIC0gZS5nZXRGdWxsWWVhcigpKSAqIDEyLCAoZSkgPT4gZS5nZXRNb250aCgpKTtcblpjLnJhbmdlO1xuY29uc3QgSSQgPSBXdCgoZSkgPT4ge1xuICBlLnNldFVUQ0RhdGUoMSksIGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG59LCAoZSwgdCkgPT4ge1xuICBlLnNldFVUQ01vbnRoKGUuZ2V0VVRDTW9udGgoKSArIHQpO1xufSwgKGUsIHQpID0+IHQuZ2V0VVRDTW9udGgoKSAtIGUuZ2V0VVRDTW9udGgoKSArICh0LmdldFVUQ0Z1bGxZZWFyKCkgLSBlLmdldFVUQ0Z1bGxZZWFyKCkpICogMTIsIChlKSA9PiBlLmdldFVUQ01vbnRoKCkpO1xuSSQucmFuZ2U7XG5jb25zdCBNbiA9IFd0KChlKSA9PiB7XG4gIGUuc2V0TW9udGgoMCwgMSksIGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59LCAoZSwgdCkgPT4ge1xuICBlLnNldEZ1bGxZZWFyKGUuZ2V0RnVsbFllYXIoKSArIHQpO1xufSwgKGUsIHQpID0+IHQuZ2V0RnVsbFllYXIoKSAtIGUuZ2V0RnVsbFllYXIoKSwgKGUpID0+IGUuZ2V0RnVsbFllYXIoKSk7XG5Nbi5ldmVyeSA9IChlKSA9PiAhaXNGaW5pdGUoZSA9IE1hdGguZmxvb3IoZSkpIHx8ICEoZSA+IDApID8gbnVsbCA6IFd0KCh0KSA9PiB7XG4gIHQuc2V0RnVsbFllYXIoTWF0aC5mbG9vcih0LmdldEZ1bGxZZWFyKCkgLyBlKSAqIGUpLCB0LnNldE1vbnRoKDAsIDEpLCB0LnNldEhvdXJzKDAsIDAsIDAsIDApO1xufSwgKHQsIG4pID0+IHtcbiAgdC5zZXRGdWxsWWVhcih0LmdldEZ1bGxZZWFyKCkgKyBuICogZSk7XG59KTtcbk1uLnJhbmdlO1xuY29uc3QgYXIgPSBXdCgoZSkgPT4ge1xuICBlLnNldFVUQ01vbnRoKDAsIDEpLCBlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xufSwgKGUsIHQpID0+IHtcbiAgZS5zZXRVVENGdWxsWWVhcihlLmdldFVUQ0Z1bGxZZWFyKCkgKyB0KTtcbn0sIChlLCB0KSA9PiB0LmdldFVUQ0Z1bGxZZWFyKCkgLSBlLmdldFVUQ0Z1bGxZZWFyKCksIChlKSA9PiBlLmdldFVUQ0Z1bGxZZWFyKCkpO1xuYXIuZXZlcnkgPSAoZSkgPT4gIWlzRmluaXRlKGUgPSBNYXRoLmZsb29yKGUpKSB8fCAhKGUgPiAwKSA/IG51bGwgOiBXdCgodCkgPT4ge1xuICB0LnNldFVUQ0Z1bGxZZWFyKE1hdGguZmxvb3IodC5nZXRVVENGdWxsWWVhcigpIC8gZSkgKiBlKSwgdC5zZXRVVENNb250aCgwLCAxKSwgdC5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbn0sICh0LCBuKSA9PiB7XG4gIHQuc2V0VVRDRnVsbFllYXIodC5nZXRVVENGdWxsWWVhcigpICsgbiAqIGUpO1xufSk7XG5hci5yYW5nZTtcbmZ1bmN0aW9uIE4kKGUsIHQsIG4sIHIsIGksIHMpIHtcbiAgY29uc3QgYSA9IFtcbiAgICBbVXIsIDEsIGJuXSxcbiAgICBbVXIsIDUsIDUgKiBibl0sXG4gICAgW1VyLCAxNSwgMTUgKiBibl0sXG4gICAgW1VyLCAzMCwgMzAgKiBibl0sXG4gICAgW3MsIDEsIENlXSxcbiAgICBbcywgNSwgNSAqIENlXSxcbiAgICBbcywgMTUsIDE1ICogQ2VdLFxuICAgIFtzLCAzMCwgMzAgKiBDZV0sXG4gICAgW2ksIDEsIF9uXSxcbiAgICBbaSwgMywgMyAqIF9uXSxcbiAgICBbaSwgNiwgNiAqIF9uXSxcbiAgICBbaSwgMTIsIDEyICogX25dLFxuICAgIFtyLCAxLCAkbl0sXG4gICAgW3IsIDIsIDIgKiAkbl0sXG4gICAgW24sIDEsIFdjXSxcbiAgICBbdCwgMSwgcWhdLFxuICAgIFt0LCAzLCAzICogcWhdLFxuICAgIFtlLCAxLCBCb11cbiAgXTtcbiAgZnVuY3Rpb24gbyhjLCB1LCBkKSB7XG4gICAgY29uc3QgaCA9IHUgPCBjO1xuICAgIGggJiYgKFtjLCB1XSA9IFt1LCBjXSk7XG4gICAgY29uc3QgcCA9IGQgJiYgdHlwZW9mIGQucmFuZ2UgPT0gXCJmdW5jdGlvblwiID8gZCA6IGwoYywgdSwgZCksIGYgPSBwID8gcC5yYW5nZShjLCArdSArIDEpIDogW107XG4gICAgcmV0dXJuIGggPyBmLnJldmVyc2UoKSA6IGY7XG4gIH1cbiAgZnVuY3Rpb24gbChjLCB1LCBkKSB7XG4gICAgY29uc3QgaCA9IE1hdGguYWJzKHUgLSBjKSAvIGQsIHAgPSBDYygoWywgLCBtXSkgPT4gbSkucmlnaHQoYSwgaCk7XG4gICAgaWYgKHAgPT09IGEubGVuZ3RoKSByZXR1cm4gZS5ldmVyeShFbChjIC8gQm8sIHUgLyBCbywgZCkpO1xuICAgIGlmIChwID09PSAwKSByZXR1cm4gX2EuZXZlcnkoTWF0aC5tYXgoRWwoYywgdSwgZCksIDEpKTtcbiAgICBjb25zdCBbZiwgZ10gPSBhW2ggLyBhW3AgLSAxXVsyXSA8IGFbcF1bMl0gLyBoID8gcCAtIDEgOiBwXTtcbiAgICByZXR1cm4gZi5ldmVyeShnKTtcbiAgfVxuICByZXR1cm4gW28sIGxdO1xufVxuY29uc3QgW1AkLCBVJF0gPSBOJChNbiwgWmMsIGFvLCB2cywgWWMsIHFjKTtcbmZ1bmN0aW9uIEhvKGUpIHtcbiAgaWYgKDAgPD0gZS55ICYmIGUueSA8IDEwMCkge1xuICAgIHZhciB0ID0gbmV3IERhdGUoLTEsIGUubSwgZS5kLCBlLkgsIGUuTSwgZS5TLCBlLkwpO1xuICAgIHJldHVybiB0LnNldEZ1bGxZZWFyKGUueSksIHQ7XG4gIH1cbiAgcmV0dXJuIG5ldyBEYXRlKGUueSwgZS5tLCBlLmQsIGUuSCwgZS5NLCBlLlMsIGUuTCk7XG59XG5mdW5jdGlvbiBWbyhlKSB7XG4gIGlmICgwIDw9IGUueSAmJiBlLnkgPCAxMDApIHtcbiAgICB2YXIgdCA9IG5ldyBEYXRlKERhdGUuVVRDKC0xLCBlLm0sIGUuZCwgZS5ILCBlLk0sIGUuUywgZS5MKSk7XG4gICAgcmV0dXJuIHQuc2V0VVRDRnVsbFllYXIoZS55KSwgdDtcbiAgfVxuICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoZS55LCBlLm0sIGUuZCwgZS5ILCBlLk0sIGUuUywgZS5MKSk7XG59XG5mdW5jdGlvbiBnaShlLCB0LCBuKSB7XG4gIHJldHVybiB7IHk6IGUsIG06IHQsIGQ6IG4sIEg6IDAsIE06IDAsIFM6IDAsIEw6IDAgfTtcbn1cbmZ1bmN0aW9uIEIkKGUpIHtcbiAgdmFyIHQgPSBlLmRhdGVUaW1lLCBuID0gZS5kYXRlLCByID0gZS50aW1lLCBpID0gZS5wZXJpb2RzLCBzID0gZS5kYXlzLCBhID0gZS5zaG9ydERheXMsIG8gPSBlLm1vbnRocywgbCA9IGUuc2hvcnRNb250aHMsIGMgPSB2aShpKSwgdSA9IHlpKGkpLCBkID0gdmkocyksIGggPSB5aShzKSwgcCA9IHZpKGEpLCBmID0geWkoYSksIGcgPSB2aShvKSwgbSA9IHlpKG8pLCB2ID0gdmkobCksIHggPSB5aShsKSwgXyA9IHtcbiAgICBhOiBMLFxuICAgIEE6IGssXG4gICAgYjogVSxcbiAgICBCOiBaLFxuICAgIGM6IG51bGwsXG4gICAgZDogSmgsXG4gICAgZTogSmgsXG4gICAgZjogbE0sXG4gICAgZzogeU0sXG4gICAgRzogYk0sXG4gICAgSDogc00sXG4gICAgSTogYU0sXG4gICAgajogb00sXG4gICAgTDogWG0sXG4gICAgbTogY00sXG4gICAgTTogdU0sXG4gICAgcDogaixcbiAgICBxOiBGLFxuICAgIFE6IG5kLFxuICAgIHM6IHJkLFxuICAgIFM6IGhNLFxuICAgIHU6IGRNLFxuICAgIFU6IHBNLFxuICAgIFY6IGZNLFxuICAgIHc6IG1NLFxuICAgIFc6IGdNLFxuICAgIHg6IG51bGwsXG4gICAgWDogbnVsbCxcbiAgICB5OiB2TSxcbiAgICBZOiB4TSxcbiAgICBaOiBfTSxcbiAgICBcIiVcIjogZWRcbiAgfSwgRSA9IHtcbiAgICBhOiBZLFxuICAgIEE6IG90LFxuICAgIGI6IFEsXG4gICAgQjogcSxcbiAgICBjOiBudWxsLFxuICAgIGQ6IHRkLFxuICAgIGU6IHRkLFxuICAgIGY6IFRNLFxuICAgIGc6IElNLFxuICAgIEc6IFBNLFxuICAgIEg6IEVNLFxuICAgIEk6IE9NLFxuICAgIGo6IFNNLFxuICAgIEw6IEttLFxuICAgIG06IHdNLFxuICAgIE06ICRNLFxuICAgIHA6IHR0LFxuICAgIHE6IGx0LFxuICAgIFE6IG5kLFxuICAgIHM6IHJkLFxuICAgIFM6IE1NLFxuICAgIHU6IENNLFxuICAgIFU6IEFNLFxuICAgIFY6IExNLFxuICAgIHc6IGtNLFxuICAgIFc6IERNLFxuICAgIHg6IG51bGwsXG4gICAgWDogbnVsbCxcbiAgICB5OiBSTSxcbiAgICBZOiBOTSxcbiAgICBaOiBVTSxcbiAgICBcIiVcIjogZWRcbiAgfSwgYiA9IHtcbiAgICBhOiBSLFxuICAgIEE6ICQsXG4gICAgYjogSCxcbiAgICBCOiBQLFxuICAgIGM6IEIsXG4gICAgZDogS2gsXG4gICAgZTogS2gsXG4gICAgZjogZU0sXG4gICAgZzogWmgsXG4gICAgRzogWGgsXG4gICAgSDogUWgsXG4gICAgSTogUWgsXG4gICAgajogSyQsXG4gICAgTDogdE0sXG4gICAgbTogWiQsXG4gICAgTTogUSQsXG4gICAgcDogQSxcbiAgICBxOiBYJCxcbiAgICBROiByTSxcbiAgICBzOiBpTSxcbiAgICBTOiBKJCxcbiAgICB1OiBGJCxcbiAgICBVOiBqJCxcbiAgICBWOiBXJCxcbiAgICB3OiB6JCxcbiAgICBXOiBxJCxcbiAgICB4OiBPLFxuICAgIFg6IHcsXG4gICAgeTogWmgsXG4gICAgWTogWGgsXG4gICAgWjogWSQsXG4gICAgXCIlXCI6IG5NXG4gIH07XG4gIF8ueCA9IFMobiwgXyksIF8uWCA9IFMociwgXyksIF8uYyA9IFModCwgXyksIEUueCA9IFMobiwgRSksIEUuWCA9IFMociwgRSksIEUuYyA9IFModCwgRSk7XG4gIGZ1bmN0aW9uIFMoeiwgVykge1xuICAgIHJldHVybiBmdW5jdGlvbihYKSB7XG4gICAgICB2YXIgViA9IFtdLCB1dCA9IC0xLCBzdCA9IDAsIER0ID0gei5sZW5ndGgsIE50LCBudCwgeXQ7XG4gICAgICBmb3IgKFggaW5zdGFuY2VvZiBEYXRlIHx8IChYID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCtYKSk7ICsrdXQgPCBEdDsgKVxuICAgICAgICB6LmNoYXJDb2RlQXQodXQpID09PSAzNyAmJiAoVi5wdXNoKHouc2xpY2Uoc3QsIHV0KSksIChudCA9IFloW050ID0gei5jaGFyQXQoKyt1dCldKSAhPSBudWxsID8gTnQgPSB6LmNoYXJBdCgrK3V0KSA6IG50ID0gTnQgPT09IFwiZVwiID8gXCIgXCIgOiBcIjBcIiwgKHl0ID0gV1tOdF0pICYmIChOdCA9IHl0KFgsIG50KSksIFYucHVzaChOdCksIHN0ID0gdXQgKyAxKTtcbiAgICAgIHJldHVybiBWLnB1c2goei5zbGljZShzdCwgdXQpKSwgVi5qb2luKFwiXCIpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gTSh6LCBXKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKFgpIHtcbiAgICAgIHZhciBWID0gZ2koMTkwMCwgdm9pZCAwLCAxKSwgdXQgPSBEKFYsIHosIFggKz0gXCJcIiwgMCksIHN0LCBEdDtcbiAgICAgIGlmICh1dCAhPSBYLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoXCJRXCIgaW4gVikgcmV0dXJuIG5ldyBEYXRlKFYuUSk7XG4gICAgICBpZiAoXCJzXCIgaW4gVikgcmV0dXJuIG5ldyBEYXRlKFYucyAqIDFlMyArIChcIkxcIiBpbiBWID8gVi5MIDogMCkpO1xuICAgICAgaWYgKFcgJiYgIShcIlpcIiBpbiBWKSAmJiAoVi5aID0gMCksIFwicFwiIGluIFYgJiYgKFYuSCA9IFYuSCAlIDEyICsgVi5wICogMTIpLCBWLm0gPT09IHZvaWQgMCAmJiAoVi5tID0gXCJxXCIgaW4gViA/IFYucSA6IDApLCBcIlZcIiBpbiBWKSB7XG4gICAgICAgIGlmIChWLlYgPCAxIHx8IFYuViA+IDUzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgXCJ3XCIgaW4gViB8fCAoVi53ID0gMSksIFwiWlwiIGluIFYgPyAoc3QgPSBWbyhnaShWLnksIDAsIDEpKSwgRHQgPSBzdC5nZXRVVENEYXkoKSwgc3QgPSBEdCA+IDQgfHwgRHQgPT09IDAgPyBPYS5jZWlsKHN0KSA6IE9hKHN0KSwgc3QgPSBYYy5vZmZzZXQoc3QsIChWLlYgLSAxKSAqIDcpLCBWLnkgPSBzdC5nZXRVVENGdWxsWWVhcigpLCBWLm0gPSBzdC5nZXRVVENNb250aCgpLCBWLmQgPSBzdC5nZXRVVENEYXRlKCkgKyAoVi53ICsgNikgJSA3KSA6IChzdCA9IEhvKGdpKFYueSwgMCwgMSkpLCBEdCA9IHN0LmdldERheSgpLCBzdCA9IER0ID4gNCB8fCBEdCA9PT0gMCA/IEVhLmNlaWwoc3QpIDogRWEoc3QpLCBzdCA9IHZzLm9mZnNldChzdCwgKFYuViAtIDEpICogNyksIFYueSA9IHN0LmdldEZ1bGxZZWFyKCksIFYubSA9IHN0LmdldE1vbnRoKCksIFYuZCA9IHN0LmdldERhdGUoKSArIChWLncgKyA2KSAlIDcpO1xuICAgICAgfSBlbHNlIChcIldcIiBpbiBWIHx8IFwiVVwiIGluIFYpICYmIChcIndcIiBpbiBWIHx8IChWLncgPSBcInVcIiBpbiBWID8gVi51ICUgNyA6IFwiV1wiIGluIFYgPyAxIDogMCksIER0ID0gXCJaXCIgaW4gViA/IFZvKGdpKFYueSwgMCwgMSkpLmdldFVUQ0RheSgpIDogSG8oZ2koVi55LCAwLCAxKSkuZ2V0RGF5KCksIFYubSA9IDAsIFYuZCA9IFwiV1wiIGluIFYgPyAoVi53ICsgNikgJSA3ICsgVi5XICogNyAtIChEdCArIDUpICUgNyA6IFYudyArIFYuVSAqIDcgLSAoRHQgKyA2KSAlIDcpO1xuICAgICAgcmV0dXJuIFwiWlwiIGluIFYgPyAoVi5IICs9IFYuWiAvIDEwMCB8IDAsIFYuTSArPSBWLlogJSAxMDAsIFZvKFYpKSA6IEhvKFYpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gRCh6LCBXLCBYLCBWKSB7XG4gICAgZm9yICh2YXIgdXQgPSAwLCBzdCA9IFcubGVuZ3RoLCBEdCA9IFgubGVuZ3RoLCBOdCwgbnQ7IHV0IDwgc3Q7ICkge1xuICAgICAgaWYgKFYgPj0gRHQpIHJldHVybiAtMTtcbiAgICAgIGlmIChOdCA9IFcuY2hhckNvZGVBdCh1dCsrKSwgTnQgPT09IDM3KSB7XG4gICAgICAgIGlmIChOdCA9IFcuY2hhckF0KHV0KyspLCBudCA9IGJbTnQgaW4gWWggPyBXLmNoYXJBdCh1dCsrKSA6IE50XSwgIW50IHx8IChWID0gbnQoeiwgWCwgVikpIDwgMCkgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChOdCAhPSBYLmNoYXJDb2RlQXQoVisrKSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gVjtcbiAgfVxuICBmdW5jdGlvbiBBKHosIFcsIFgpIHtcbiAgICB2YXIgViA9IGMuZXhlYyhXLnNsaWNlKFgpKTtcbiAgICByZXR1cm4gViA/ICh6LnAgPSB1LmdldChWWzBdLnRvTG93ZXJDYXNlKCkpLCBYICsgVlswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gUih6LCBXLCBYKSB7XG4gICAgdmFyIFYgPSBwLmV4ZWMoVy5zbGljZShYKSk7XG4gICAgcmV0dXJuIFYgPyAoei53ID0gZi5nZXQoVlswXS50b0xvd2VyQ2FzZSgpKSwgWCArIFZbMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uICQoeiwgVywgWCkge1xuICAgIHZhciBWID0gZC5leGVjKFcuc2xpY2UoWCkpO1xuICAgIHJldHVybiBWID8gKHoudyA9IGguZ2V0KFZbMF0udG9Mb3dlckNhc2UoKSksIFggKyBWWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBIKHosIFcsIFgpIHtcbiAgICB2YXIgViA9IHYuZXhlYyhXLnNsaWNlKFgpKTtcbiAgICByZXR1cm4gViA/ICh6Lm0gPSB4LmdldChWWzBdLnRvTG93ZXJDYXNlKCkpLCBYICsgVlswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gUCh6LCBXLCBYKSB7XG4gICAgdmFyIFYgPSBnLmV4ZWMoVy5zbGljZShYKSk7XG4gICAgcmV0dXJuIFYgPyAoei5tID0gbS5nZXQoVlswXS50b0xvd2VyQ2FzZSgpKSwgWCArIFZbMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIEIoeiwgVywgWCkge1xuICAgIHJldHVybiBEKHosIHQsIFcsIFgpO1xuICB9XG4gIGZ1bmN0aW9uIE8oeiwgVywgWCkge1xuICAgIHJldHVybiBEKHosIG4sIFcsIFgpO1xuICB9XG4gIGZ1bmN0aW9uIHcoeiwgVywgWCkge1xuICAgIHJldHVybiBEKHosIHIsIFcsIFgpO1xuICB9XG4gIGZ1bmN0aW9uIEwoeikge1xuICAgIHJldHVybiBhW3ouZ2V0RGF5KCldO1xuICB9XG4gIGZ1bmN0aW9uIGsoeikge1xuICAgIHJldHVybiBzW3ouZ2V0RGF5KCldO1xuICB9XG4gIGZ1bmN0aW9uIFUoeikge1xuICAgIHJldHVybiBsW3ouZ2V0TW9udGgoKV07XG4gIH1cbiAgZnVuY3Rpb24gWih6KSB7XG4gICAgcmV0dXJuIG9bei5nZXRNb250aCgpXTtcbiAgfVxuICBmdW5jdGlvbiBqKHopIHtcbiAgICByZXR1cm4gaVsrKHouZ2V0SG91cnMoKSA+PSAxMildO1xuICB9XG4gIGZ1bmN0aW9uIEYoeikge1xuICAgIHJldHVybiAxICsgfn4oei5nZXRNb250aCgpIC8gMyk7XG4gIH1cbiAgZnVuY3Rpb24gWSh6KSB7XG4gICAgcmV0dXJuIGFbei5nZXRVVENEYXkoKV07XG4gIH1cbiAgZnVuY3Rpb24gb3Qoeikge1xuICAgIHJldHVybiBzW3ouZ2V0VVRDRGF5KCldO1xuICB9XG4gIGZ1bmN0aW9uIFEoeikge1xuICAgIHJldHVybiBsW3ouZ2V0VVRDTW9udGgoKV07XG4gIH1cbiAgZnVuY3Rpb24gcSh6KSB7XG4gICAgcmV0dXJuIG9bei5nZXRVVENNb250aCgpXTtcbiAgfVxuICBmdW5jdGlvbiB0dCh6KSB7XG4gICAgcmV0dXJuIGlbKyh6LmdldFVUQ0hvdXJzKCkgPj0gMTIpXTtcbiAgfVxuICBmdW5jdGlvbiBsdCh6KSB7XG4gICAgcmV0dXJuIDEgKyB+fih6LmdldFVUQ01vbnRoKCkgLyAzKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZvcm1hdDogZnVuY3Rpb24oeikge1xuICAgICAgdmFyIFcgPSBTKHogKz0gXCJcIiwgXyk7XG4gICAgICByZXR1cm4gVy50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gejtcbiAgICAgIH0sIFc7XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24oeikge1xuICAgICAgdmFyIFcgPSBNKHogKz0gXCJcIiwgITEpO1xuICAgICAgcmV0dXJuIFcudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHo7XG4gICAgICB9LCBXO1xuICAgIH0sXG4gICAgdXRjRm9ybWF0OiBmdW5jdGlvbih6KSB7XG4gICAgICB2YXIgVyA9IFMoeiArPSBcIlwiLCBFKTtcbiAgICAgIHJldHVybiBXLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB6O1xuICAgICAgfSwgVztcbiAgICB9LFxuICAgIHV0Y1BhcnNlOiBmdW5jdGlvbih6KSB7XG4gICAgICB2YXIgVyA9IE0oeiArPSBcIlwiLCAhMCk7XG4gICAgICByZXR1cm4gVy50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gejtcbiAgICAgIH0sIFc7XG4gICAgfVxuICB9O1xufVxudmFyIFloID0geyBcIi1cIjogXCJcIiwgXzogXCIgXCIsIDA6IFwiMFwiIH0sIFl0ID0gL15cXHMqXFxkKy8sIEgkID0gL14lLywgViQgPSAvW1xcXFxeJCorP3xbXFxdKCkue31dL2c7XG5mdW5jdGlvbiB2dChlLCB0LCBuKSB7XG4gIHZhciByID0gZSA8IDAgPyBcIi1cIiA6IFwiXCIsIGkgPSAociA/IC1lIDogZSkgKyBcIlwiLCBzID0gaS5sZW5ndGg7XG4gIHJldHVybiByICsgKHMgPCBuID8gbmV3IEFycmF5KG4gLSBzICsgMSkuam9pbih0KSArIGkgOiBpKTtcbn1cbmZ1bmN0aW9uIEckKGUpIHtcbiAgcmV0dXJuIGUucmVwbGFjZShWJCwgXCJcXFxcJCZcIik7XG59XG5mdW5jdGlvbiB2aShlKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgZS5tYXAoRyQpLmpvaW4oXCJ8XCIpICsgXCIpXCIsIFwiaVwiKTtcbn1cbmZ1bmN0aW9uIHlpKGUpIHtcbiAgcmV0dXJuIG5ldyBNYXAoZS5tYXAoKHQsIG4pID0+IFt0LnRvTG93ZXJDYXNlKCksIG5dKSk7XG59XG5mdW5jdGlvbiB6JChlLCB0LCBuKSB7XG4gIHZhciByID0gWXQuZXhlYyh0LnNsaWNlKG4sIG4gKyAxKSk7XG4gIHJldHVybiByID8gKGUudyA9ICtyWzBdLCBuICsgclswXS5sZW5ndGgpIDogLTE7XG59XG5mdW5jdGlvbiBGJChlLCB0LCBuKSB7XG4gIHZhciByID0gWXQuZXhlYyh0LnNsaWNlKG4sIG4gKyAxKSk7XG4gIHJldHVybiByID8gKGUudSA9ICtyWzBdLCBuICsgclswXS5sZW5ndGgpIDogLTE7XG59XG5mdW5jdGlvbiBqJChlLCB0LCBuKSB7XG4gIHZhciByID0gWXQuZXhlYyh0LnNsaWNlKG4sIG4gKyAyKSk7XG4gIHJldHVybiByID8gKGUuVSA9ICtyWzBdLCBuICsgclswXS5sZW5ndGgpIDogLTE7XG59XG5mdW5jdGlvbiBXJChlLCB0LCBuKSB7XG4gIHZhciByID0gWXQuZXhlYyh0LnNsaWNlKG4sIG4gKyAyKSk7XG4gIHJldHVybiByID8gKGUuViA9ICtyWzBdLCBuICsgclswXS5sZW5ndGgpIDogLTE7XG59XG5mdW5jdGlvbiBxJChlLCB0LCBuKSB7XG4gIHZhciByID0gWXQuZXhlYyh0LnNsaWNlKG4sIG4gKyAyKSk7XG4gIHJldHVybiByID8gKGUuVyA9ICtyWzBdLCBuICsgclswXS5sZW5ndGgpIDogLTE7XG59XG5mdW5jdGlvbiBYaChlLCB0LCBuKSB7XG4gIHZhciByID0gWXQuZXhlYyh0LnNsaWNlKG4sIG4gKyA0KSk7XG4gIHJldHVybiByID8gKGUueSA9ICtyWzBdLCBuICsgclswXS5sZW5ndGgpIDogLTE7XG59XG5mdW5jdGlvbiBaaChlLCB0LCBuKSB7XG4gIHZhciByID0gWXQuZXhlYyh0LnNsaWNlKG4sIG4gKyAyKSk7XG4gIHJldHVybiByID8gKGUueSA9ICtyWzBdICsgKCtyWzBdID4gNjggPyAxOTAwIDogMmUzKSwgbiArIHJbMF0ubGVuZ3RoKSA6IC0xO1xufVxuZnVuY3Rpb24gWSQoZSwgdCwgbikge1xuICB2YXIgciA9IC9eKFopfChbKy1dXFxkXFxkKSg/Ojo/KFxcZFxcZCkpPy8uZXhlYyh0LnNsaWNlKG4sIG4gKyA2KSk7XG4gIHJldHVybiByID8gKGUuWiA9IHJbMV0gPyAwIDogLShyWzJdICsgKHJbM10gfHwgXCIwMFwiKSksIG4gKyByWzBdLmxlbmd0aCkgOiAtMTtcbn1cbmZ1bmN0aW9uIFgkKGUsIHQsIG4pIHtcbiAgdmFyIHIgPSBZdC5leGVjKHQuc2xpY2UobiwgbiArIDEpKTtcbiAgcmV0dXJuIHIgPyAoZS5xID0gclswXSAqIDMgLSAzLCBuICsgclswXS5sZW5ndGgpIDogLTE7XG59XG5mdW5jdGlvbiBaJChlLCB0LCBuKSB7XG4gIHZhciByID0gWXQuZXhlYyh0LnNsaWNlKG4sIG4gKyAyKSk7XG4gIHJldHVybiByID8gKGUubSA9IHJbMF0gLSAxLCBuICsgclswXS5sZW5ndGgpIDogLTE7XG59XG5mdW5jdGlvbiBLaChlLCB0LCBuKSB7XG4gIHZhciByID0gWXQuZXhlYyh0LnNsaWNlKG4sIG4gKyAyKSk7XG4gIHJldHVybiByID8gKGUuZCA9ICtyWzBdLCBuICsgclswXS5sZW5ndGgpIDogLTE7XG59XG5mdW5jdGlvbiBLJChlLCB0LCBuKSB7XG4gIHZhciByID0gWXQuZXhlYyh0LnNsaWNlKG4sIG4gKyAzKSk7XG4gIHJldHVybiByID8gKGUubSA9IDAsIGUuZCA9ICtyWzBdLCBuICsgclswXS5sZW5ndGgpIDogLTE7XG59XG5mdW5jdGlvbiBRaChlLCB0LCBuKSB7XG4gIHZhciByID0gWXQuZXhlYyh0LnNsaWNlKG4sIG4gKyAyKSk7XG4gIHJldHVybiByID8gKGUuSCA9ICtyWzBdLCBuICsgclswXS5sZW5ndGgpIDogLTE7XG59XG5mdW5jdGlvbiBRJChlLCB0LCBuKSB7XG4gIHZhciByID0gWXQuZXhlYyh0LnNsaWNlKG4sIG4gKyAyKSk7XG4gIHJldHVybiByID8gKGUuTSA9ICtyWzBdLCBuICsgclswXS5sZW5ndGgpIDogLTE7XG59XG5mdW5jdGlvbiBKJChlLCB0LCBuKSB7XG4gIHZhciByID0gWXQuZXhlYyh0LnNsaWNlKG4sIG4gKyAyKSk7XG4gIHJldHVybiByID8gKGUuUyA9ICtyWzBdLCBuICsgclswXS5sZW5ndGgpIDogLTE7XG59XG5mdW5jdGlvbiB0TShlLCB0LCBuKSB7XG4gIHZhciByID0gWXQuZXhlYyh0LnNsaWNlKG4sIG4gKyAzKSk7XG4gIHJldHVybiByID8gKGUuTCA9ICtyWzBdLCBuICsgclswXS5sZW5ndGgpIDogLTE7XG59XG5mdW5jdGlvbiBlTShlLCB0LCBuKSB7XG4gIHZhciByID0gWXQuZXhlYyh0LnNsaWNlKG4sIG4gKyA2KSk7XG4gIHJldHVybiByID8gKGUuTCA9IE1hdGguZmxvb3IoclswXSAvIDFlMyksIG4gKyByWzBdLmxlbmd0aCkgOiAtMTtcbn1cbmZ1bmN0aW9uIG5NKGUsIHQsIG4pIHtcbiAgdmFyIHIgPSBIJC5leGVjKHQuc2xpY2UobiwgbiArIDEpKTtcbiAgcmV0dXJuIHIgPyBuICsgclswXS5sZW5ndGggOiAtMTtcbn1cbmZ1bmN0aW9uIHJNKGUsIHQsIG4pIHtcbiAgdmFyIHIgPSBZdC5leGVjKHQuc2xpY2UobikpO1xuICByZXR1cm4gciA/IChlLlEgPSArclswXSwgbiArIHJbMF0ubGVuZ3RoKSA6IC0xO1xufVxuZnVuY3Rpb24gaU0oZSwgdCwgbikge1xuICB2YXIgciA9IFl0LmV4ZWModC5zbGljZShuKSk7XG4gIHJldHVybiByID8gKGUucyA9ICtyWzBdLCBuICsgclswXS5sZW5ndGgpIDogLTE7XG59XG5mdW5jdGlvbiBKaChlLCB0KSB7XG4gIHJldHVybiB2dChlLmdldERhdGUoKSwgdCwgMik7XG59XG5mdW5jdGlvbiBzTShlLCB0KSB7XG4gIHJldHVybiB2dChlLmdldEhvdXJzKCksIHQsIDIpO1xufVxuZnVuY3Rpb24gYU0oZSwgdCkge1xuICByZXR1cm4gdnQoZS5nZXRIb3VycygpICUgMTIgfHwgMTIsIHQsIDIpO1xufVxuZnVuY3Rpb24gb00oZSwgdCkge1xuICByZXR1cm4gdnQoMSArIHZzLmNvdW50KE1uKGUpLCBlKSwgdCwgMyk7XG59XG5mdW5jdGlvbiBYbShlLCB0KSB7XG4gIHJldHVybiB2dChlLmdldE1pbGxpc2Vjb25kcygpLCB0LCAzKTtcbn1cbmZ1bmN0aW9uIGxNKGUsIHQpIHtcbiAgcmV0dXJuIFhtKGUsIHQpICsgXCIwMDBcIjtcbn1cbmZ1bmN0aW9uIGNNKGUsIHQpIHtcbiAgcmV0dXJuIHZ0KGUuZ2V0TW9udGgoKSArIDEsIHQsIDIpO1xufVxuZnVuY3Rpb24gdU0oZSwgdCkge1xuICByZXR1cm4gdnQoZS5nZXRNaW51dGVzKCksIHQsIDIpO1xufVxuZnVuY3Rpb24gaE0oZSwgdCkge1xuICByZXR1cm4gdnQoZS5nZXRTZWNvbmRzKCksIHQsIDIpO1xufVxuZnVuY3Rpb24gZE0oZSkge1xuICB2YXIgdCA9IGUuZ2V0RGF5KCk7XG4gIHJldHVybiB0ID09PSAwID8gNyA6IHQ7XG59XG5mdW5jdGlvbiBwTShlLCB0KSB7XG4gIHJldHVybiB2dChhby5jb3VudChNbihlKSAtIDEsIGUpLCB0LCAyKTtcbn1cbmZ1bmN0aW9uIFptKGUpIHtcbiAgdmFyIHQgPSBlLmdldERheSgpO1xuICByZXR1cm4gdCA+PSA0IHx8IHQgPT09IDAgPyBRcihlKSA6IFFyLmNlaWwoZSk7XG59XG5mdW5jdGlvbiBmTShlLCB0KSB7XG4gIHJldHVybiBlID0gWm0oZSksIHZ0KFFyLmNvdW50KE1uKGUpLCBlKSArIChNbihlKS5nZXREYXkoKSA9PT0gNCksIHQsIDIpO1xufVxuZnVuY3Rpb24gbU0oZSkge1xuICByZXR1cm4gZS5nZXREYXkoKTtcbn1cbmZ1bmN0aW9uIGdNKGUsIHQpIHtcbiAgcmV0dXJuIHZ0KEVhLmNvdW50KE1uKGUpIC0gMSwgZSksIHQsIDIpO1xufVxuZnVuY3Rpb24gdk0oZSwgdCkge1xuICByZXR1cm4gdnQoZS5nZXRGdWxsWWVhcigpICUgMTAwLCB0LCAyKTtcbn1cbmZ1bmN0aW9uIHlNKGUsIHQpIHtcbiAgcmV0dXJuIGUgPSBabShlKSwgdnQoZS5nZXRGdWxsWWVhcigpICUgMTAwLCB0LCAyKTtcbn1cbmZ1bmN0aW9uIHhNKGUsIHQpIHtcbiAgcmV0dXJuIHZ0KGUuZ2V0RnVsbFllYXIoKSAlIDFlNCwgdCwgNCk7XG59XG5mdW5jdGlvbiBiTShlLCB0KSB7XG4gIHZhciBuID0gZS5nZXREYXkoKTtcbiAgcmV0dXJuIGUgPSBuID49IDQgfHwgbiA9PT0gMCA/IFFyKGUpIDogUXIuY2VpbChlKSwgdnQoZS5nZXRGdWxsWWVhcigpICUgMWU0LCB0LCA0KTtcbn1cbmZ1bmN0aW9uIF9NKGUpIHtcbiAgdmFyIHQgPSBlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIHJldHVybiAodCA+IDAgPyBcIi1cIiA6ICh0ICo9IC0xLCBcIitcIikpICsgdnQodCAvIDYwIHwgMCwgXCIwXCIsIDIpICsgdnQodCAlIDYwLCBcIjBcIiwgMik7XG59XG5mdW5jdGlvbiB0ZChlLCB0KSB7XG4gIHJldHVybiB2dChlLmdldFVUQ0RhdGUoKSwgdCwgMik7XG59XG5mdW5jdGlvbiBFTShlLCB0KSB7XG4gIHJldHVybiB2dChlLmdldFVUQ0hvdXJzKCksIHQsIDIpO1xufVxuZnVuY3Rpb24gT00oZSwgdCkge1xuICByZXR1cm4gdnQoZS5nZXRVVENIb3VycygpICUgMTIgfHwgMTIsIHQsIDIpO1xufVxuZnVuY3Rpb24gU00oZSwgdCkge1xuICByZXR1cm4gdnQoMSArIFhjLmNvdW50KGFyKGUpLCBlKSwgdCwgMyk7XG59XG5mdW5jdGlvbiBLbShlLCB0KSB7XG4gIHJldHVybiB2dChlLmdldFVUQ01pbGxpc2Vjb25kcygpLCB0LCAzKTtcbn1cbmZ1bmN0aW9uIFRNKGUsIHQpIHtcbiAgcmV0dXJuIEttKGUsIHQpICsgXCIwMDBcIjtcbn1cbmZ1bmN0aW9uIHdNKGUsIHQpIHtcbiAgcmV0dXJuIHZ0KGUuZ2V0VVRDTW9udGgoKSArIDEsIHQsIDIpO1xufVxuZnVuY3Rpb24gJE0oZSwgdCkge1xuICByZXR1cm4gdnQoZS5nZXRVVENNaW51dGVzKCksIHQsIDIpO1xufVxuZnVuY3Rpb24gTU0oZSwgdCkge1xuICByZXR1cm4gdnQoZS5nZXRVVENTZWNvbmRzKCksIHQsIDIpO1xufVxuZnVuY3Rpb24gQ00oZSkge1xuICB2YXIgdCA9IGUuZ2V0VVRDRGF5KCk7XG4gIHJldHVybiB0ID09PSAwID8gNyA6IHQ7XG59XG5mdW5jdGlvbiBBTShlLCB0KSB7XG4gIHJldHVybiB2dChZbS5jb3VudChhcihlKSAtIDEsIGUpLCB0LCAyKTtcbn1cbmZ1bmN0aW9uIFFtKGUpIHtcbiAgdmFyIHQgPSBlLmdldFVUQ0RheSgpO1xuICByZXR1cm4gdCA+PSA0IHx8IHQgPT09IDAgPyBKcihlKSA6IEpyLmNlaWwoZSk7XG59XG5mdW5jdGlvbiBMTShlLCB0KSB7XG4gIHJldHVybiBlID0gUW0oZSksIHZ0KEpyLmNvdW50KGFyKGUpLCBlKSArIChhcihlKS5nZXRVVENEYXkoKSA9PT0gNCksIHQsIDIpO1xufVxuZnVuY3Rpb24ga00oZSkge1xuICByZXR1cm4gZS5nZXRVVENEYXkoKTtcbn1cbmZ1bmN0aW9uIERNKGUsIHQpIHtcbiAgcmV0dXJuIHZ0KE9hLmNvdW50KGFyKGUpIC0gMSwgZSksIHQsIDIpO1xufVxuZnVuY3Rpb24gUk0oZSwgdCkge1xuICByZXR1cm4gdnQoZS5nZXRVVENGdWxsWWVhcigpICUgMTAwLCB0LCAyKTtcbn1cbmZ1bmN0aW9uIElNKGUsIHQpIHtcbiAgcmV0dXJuIGUgPSBRbShlKSwgdnQoZS5nZXRVVENGdWxsWWVhcigpICUgMTAwLCB0LCAyKTtcbn1cbmZ1bmN0aW9uIE5NKGUsIHQpIHtcbiAgcmV0dXJuIHZ0KGUuZ2V0VVRDRnVsbFllYXIoKSAlIDFlNCwgdCwgNCk7XG59XG5mdW5jdGlvbiBQTShlLCB0KSB7XG4gIHZhciBuID0gZS5nZXRVVENEYXkoKTtcbiAgcmV0dXJuIGUgPSBuID49IDQgfHwgbiA9PT0gMCA/IEpyKGUpIDogSnIuY2VpbChlKSwgdnQoZS5nZXRVVENGdWxsWWVhcigpICUgMWU0LCB0LCA0KTtcbn1cbmZ1bmN0aW9uIFVNKCkge1xuICByZXR1cm4gXCIrMDAwMFwiO1xufVxuZnVuY3Rpb24gZWQoKSB7XG4gIHJldHVybiBcIiVcIjtcbn1cbmZ1bmN0aW9uIG5kKGUpIHtcbiAgcmV0dXJuICtlO1xufVxuZnVuY3Rpb24gcmQoZSkge1xuICByZXR1cm4gTWF0aC5mbG9vcigrZSAvIDFlMyk7XG59XG52YXIgU3IsIEptO1xuQk0oe1xuICBkYXRlVGltZTogXCIleCwgJVhcIixcbiAgZGF0ZTogXCIlLW0vJS1kLyVZXCIsXG4gIHRpbWU6IFwiJS1JOiVNOiVTICVwXCIsXG4gIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gIGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxuICBzaG9ydERheXM6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgbW9udGhzOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSxcbiAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXVxufSk7XG5mdW5jdGlvbiBCTShlKSB7XG4gIHJldHVybiBTciA9IEIkKGUpLCBKbSA9IFNyLmZvcm1hdCwgU3IucGFyc2UsIFNyLnV0Y0Zvcm1hdCwgU3IudXRjUGFyc2UsIFNyO1xufVxuZnVuY3Rpb24gSE0oZSkge1xuICByZXR1cm4gbmV3IERhdGUoZSk7XG59XG5mdW5jdGlvbiBWTShlKSB7XG4gIHJldHVybiBlIGluc3RhbmNlb2YgRGF0ZSA/ICtlIDogKy8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgrZSk7XG59XG5mdW5jdGlvbiB0ZyhlLCB0LCBuLCByLCBpLCBzLCBhLCBvLCBsLCBjKSB7XG4gIHZhciB1ID0gd20oKSwgZCA9IHUuaW52ZXJ0LCBoID0gdS5kb21haW4sIHAgPSBjKFwiLiVMXCIpLCBmID0gYyhcIjolU1wiKSwgZyA9IGMoXCIlSTolTVwiKSwgbSA9IGMoXCIlSSAlcFwiKSwgdiA9IGMoXCIlYSAlZFwiKSwgeCA9IGMoXCIlYiAlZFwiKSwgXyA9IGMoXCIlQlwiKSwgRSA9IGMoXCIlWVwiKTtcbiAgZnVuY3Rpb24gYihTKSB7XG4gICAgcmV0dXJuIChsKFMpIDwgUyA/IHAgOiBvKFMpIDwgUyA/IGYgOiBhKFMpIDwgUyA/IGcgOiBzKFMpIDwgUyA/IG0gOiByKFMpIDwgUyA/IGkoUykgPCBTID8gdiA6IHggOiBuKFMpIDwgUyA/IF8gOiBFKShTKTtcbiAgfVxuICByZXR1cm4gdS5pbnZlcnQgPSBmdW5jdGlvbihTKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGQoUykpO1xuICB9LCB1LmRvbWFpbiA9IGZ1bmN0aW9uKFMpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGgoQXJyYXkuZnJvbShTLCBWTSkpIDogaCgpLm1hcChITSk7XG4gIH0sIHUudGlja3MgPSBmdW5jdGlvbihTKSB7XG4gICAgdmFyIE0gPSBoKCk7XG4gICAgcmV0dXJuIGUoTVswXSwgTVtNLmxlbmd0aCAtIDFdLCBTID8/IDEwKTtcbiAgfSwgdS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oUywgTSkge1xuICAgIHJldHVybiBNID09IG51bGwgPyBiIDogYyhNKTtcbiAgfSwgdS5uaWNlID0gZnVuY3Rpb24oUykge1xuICAgIHZhciBNID0gaCgpO1xuICAgIHJldHVybiAoIVMgfHwgdHlwZW9mIFMucmFuZ2UgIT0gXCJmdW5jdGlvblwiKSAmJiAoUyA9IHQoTVswXSwgTVtNLmxlbmd0aCAtIDFdLCBTID8/IDEwKSksIFMgPyBoKHFtKE0sIFMpKSA6IHU7XG4gIH0sIHUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBWYyh1LCB0ZyhlLCB0LCBuLCByLCBpLCBzLCBhLCBvLCBsLCBjKSk7XG4gIH0sIHU7XG59XG5mdW5jdGlvbiBlZygpIHtcbiAgcmV0dXJuIGlpLmFwcGx5KHRnKFAkLCBVJCwgTW4sIFpjLCBhbywgdnMsIFljLCBxYywgVXIsIEptKS5kb21haW4oW25ldyBEYXRlKDJlMywgMCwgMSksIG5ldyBEYXRlKDJlMywgMCwgMildKSwgYXJndW1lbnRzKTtcbn1cbmNvbnN0IGlkID0gTWF0aC5hYnMsIEp0ID0gTWF0aC5hdGFuMiwgcW4gPSBNYXRoLmNvcywgR00gPSBNYXRoLm1heCwgR28gPSBNYXRoLm1pbiwgWmUgPSBNYXRoLnNpbiwgQnIgPSBNYXRoLnNxcnQsIG5lID0gMWUtMTIsIG5zID0gTWF0aC5QSSwgU2EgPSBucyAvIDIsIEtzID0gMiAqIG5zO1xuZnVuY3Rpb24gek0oZSkge1xuICByZXR1cm4gZSA+IDEgPyAwIDogZSA8IC0xID8gbnMgOiBNYXRoLmFjb3MoZSk7XG59XG5mdW5jdGlvbiBzZChlKSB7XG4gIHJldHVybiBlID49IDEgPyBTYSA6IGUgPD0gLTEgPyAtU2EgOiBNYXRoLmFzaW4oZSk7XG59XG5mdW5jdGlvbiBuZyhlKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBlO1xufVxubmcucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgKHRoaXMuX2xpbmUgfHwgdGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkgJiYgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKSwgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oZSwgdCkge1xuICAgIHN3aXRjaCAoZSA9ICtlLCB0ID0gK3QsIHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMSwgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKGUsIHQpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oZSwgdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB0aGlzLl9wb2ludCA9IDI7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyhlLCB0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gb28oZSkge1xuICByZXR1cm4gbmV3IG5nKGUpO1xufVxuZnVuY3Rpb24gSG4oKSB7XG59XG5mdW5jdGlvbiByZyhlKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBlO1xufVxucmcucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IEhuLFxuICBhcmVhRW5kOiBIbixcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ICYmIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgZSA9ICtlLCB0ID0gK3QsIHRoaXMuX3BvaW50ID8gdGhpcy5fY29udGV4dC5saW5lVG8oZSwgdCkgOiAodGhpcy5fcG9pbnQgPSAxLCB0aGlzLl9jb250ZXh0Lm1vdmVUbyhlLCB0KSk7XG4gIH1cbn07XG5mdW5jdGlvbiBpZyhlKSB7XG4gIHJldHVybiBuZXcgcmcoZSk7XG59XG5mdW5jdGlvbiBGTShlLCB0KSB7XG4gIGlmIChlLm1hdGNoKC9eW2Etel0rOlxcL1xcLy9pKSlcbiAgICByZXR1cm4gZTtcbiAgaWYgKGUubWF0Y2goL15cXC9cXC8vKSlcbiAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgZTtcbiAgaWYgKGUubWF0Y2goL15bYS16XSs6L2kpKVxuICAgIHJldHVybiBlO1xuICBjb25zdCBuID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCksIHIgPSBuLmNyZWF0ZUVsZW1lbnQoXCJiYXNlXCIpLCBpID0gbi5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgcmV0dXJuIG4uaGVhZC5hcHBlbmRDaGlsZChyKSwgbi5ib2R5LmFwcGVuZENoaWxkKGkpLCB0ICYmIChyLmhyZWYgPSB0KSwgaS5ocmVmID0gZSwgaS5ocmVmO1xufVxuY29uc3Qgak0gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgbGV0IGUgPSAwO1xuICBjb25zdCB0ID0gKCkgPT4gKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgYDAwMDAkeyhNYXRoLnJhbmRvbSgpICogMzYgKiogNCA8PCAwKS50b1N0cmluZygzNil9YC5zbGljZSgtNClcbiAgKTtcbiAgcmV0dXJuICgpID0+IChlICs9IDEsIGB1JHt0KCl9JHtlfWApO1xufSkoKTtcbmZ1bmN0aW9uIE9uKGUpIHtcbiAgY29uc3QgdCA9IFtdO1xuICBmb3IgKGxldCBuID0gMCwgciA9IGUubGVuZ3RoOyBuIDwgcjsgbisrKVxuICAgIHQucHVzaChlW25dKTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBUYShlLCB0KSB7XG4gIGNvbnN0IG4gPSAoZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdykuZ2V0Q29tcHV0ZWRTdHlsZShlKS5nZXRQcm9wZXJ0eVZhbHVlKHQpO1xuICByZXR1cm4gbiA/IHBhcnNlRmxvYXQobi5yZXBsYWNlKFwicHhcIiwgXCJcIikpIDogMDtcbn1cbmZ1bmN0aW9uIFdNKGUpIHtcbiAgY29uc3QgdCA9IFRhKGUsIFwiYm9yZGVyLWxlZnQtd2lkdGhcIiksIG4gPSBUYShlLCBcImJvcmRlci1yaWdodC13aWR0aFwiKTtcbiAgcmV0dXJuIGUuY2xpZW50V2lkdGggKyB0ICsgbjtcbn1cbmZ1bmN0aW9uIHFNKGUpIHtcbiAgY29uc3QgdCA9IFRhKGUsIFwiYm9yZGVyLXRvcC13aWR0aFwiKSwgbiA9IFRhKGUsIFwiYm9yZGVyLWJvdHRvbS13aWR0aFwiKTtcbiAgcmV0dXJuIGUuY2xpZW50SGVpZ2h0ICsgdCArIG47XG59XG5mdW5jdGlvbiBzZyhlLCB0ID0ge30pIHtcbiAgY29uc3QgbiA9IHQud2lkdGggfHwgV00oZSksIHIgPSB0LmhlaWdodCB8fCBxTShlKTtcbiAgcmV0dXJuIHsgd2lkdGg6IG4sIGhlaWdodDogciB9O1xufVxuZnVuY3Rpb24gWU0oKSB7XG4gIGxldCBlLCB0O1xuICB0cnkge1xuICAgIHQgPSBwcm9jZXNzO1xuICB9IGNhdGNoIHtcbiAgfVxuICBjb25zdCBuID0gdCAmJiB0LmVudiA/IHQuZW52LmRldmljZVBpeGVsUmF0aW8gOiBudWxsO1xuICByZXR1cm4gbiAmJiAoZSA9IHBhcnNlSW50KG4sIDEwKSwgTnVtYmVyLmlzTmFOKGUpICYmIChlID0gMSkpLCBlIHx8IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG59XG5jb25zdCB2ZSA9IDE2Mzg0O1xuZnVuY3Rpb24gWE0oZSkge1xuICAoZS53aWR0aCA+IHZlIHx8IGUuaGVpZ2h0ID4gdmUpICYmIChlLndpZHRoID4gdmUgJiYgZS5oZWlnaHQgPiB2ZSA/IGUud2lkdGggPiBlLmhlaWdodCA/IChlLmhlaWdodCAqPSB2ZSAvIGUud2lkdGgsIGUud2lkdGggPSB2ZSkgOiAoZS53aWR0aCAqPSB2ZSAvIGUuaGVpZ2h0LCBlLmhlaWdodCA9IHZlKSA6IGUud2lkdGggPiB2ZSA/IChlLmhlaWdodCAqPSB2ZSAvIGUud2lkdGgsIGUud2lkdGggPSB2ZSkgOiAoZS53aWR0aCAqPSB2ZSAvIGUuaGVpZ2h0LCBlLmhlaWdodCA9IHZlKSk7XG59XG5mdW5jdGlvbiB3YShlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgodCwgbikgPT4ge1xuICAgIGNvbnN0IHIgPSBuZXcgSW1hZ2UoKTtcbiAgICByLmRlY29kZSA9ICgpID0+IHQociksIHIub25sb2FkID0gKCkgPT4gdChyKSwgci5vbmVycm9yID0gbiwgci5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCIsIHIuZGVjb2RpbmcgPSBcImFzeW5jXCIsIHIuc3JjID0gZTtcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBaTShlKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoZSkpLnRoZW4oZW5jb2RlVVJJQ29tcG9uZW50KS50aGVuKCh0KSA9PiBgZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsJHt0fWApO1xufVxuYXN5bmMgZnVuY3Rpb24gS00oZSwgdCwgbikge1xuICBjb25zdCByID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHIsIFwic3ZnXCIpLCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHIsIFwiZm9yZWlnbk9iamVjdFwiKTtcbiAgcmV0dXJuIGkuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgYCR7dH1gKSwgaS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgYCR7bn1gKSwgaS5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIGAwIDAgJHt0fSAke259YCksIHMuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIxMDAlXCIpLCBzLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjEwMCVcIiksIHMuc2V0QXR0cmlidXRlKFwieFwiLCBcIjBcIiksIHMuc2V0QXR0cmlidXRlKFwieVwiLCBcIjBcIiksIHMuc2V0QXR0cmlidXRlKFwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiLCBcInRydWVcIiksIGkuYXBwZW5kQ2hpbGQocyksIHMuYXBwZW5kQ2hpbGQoZSksIFpNKGkpO1xufVxuY29uc3QgcGUgPSAoZSwgdCkgPT4ge1xuICBpZiAoZSBpbnN0YW5jZW9mIHQpXG4gICAgcmV0dXJuICEwO1xuICBjb25zdCBuID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGUpO1xuICByZXR1cm4gbiA9PT0gbnVsbCA/ICExIDogbi5jb25zdHJ1Y3Rvci5uYW1lID09PSB0Lm5hbWUgfHwgcGUobiwgdCk7XG59O1xuZnVuY3Rpb24gUU0oZSkge1xuICBjb25zdCB0ID0gZS5nZXRQcm9wZXJ0eVZhbHVlKFwiY29udGVudFwiKTtcbiAgcmV0dXJuIGAke2UuY3NzVGV4dH0gY29udGVudDogJyR7dC5yZXBsYWNlKC8nfFwiL2csIFwiXCIpfSc7YDtcbn1cbmZ1bmN0aW9uIEpNKGUpIHtcbiAgcmV0dXJuIE9uKGUpLm1hcCgodCkgPT4ge1xuICAgIGNvbnN0IG4gPSBlLmdldFByb3BlcnR5VmFsdWUodCksIHIgPSBlLmdldFByb3BlcnR5UHJpb3JpdHkodCk7XG4gICAgcmV0dXJuIGAke3R9OiAke259JHtyID8gXCIgIWltcG9ydGFudFwiIDogXCJcIn07YDtcbiAgfSkuam9pbihcIiBcIik7XG59XG5mdW5jdGlvbiB0MihlLCB0LCBuKSB7XG4gIGNvbnN0IHIgPSBgLiR7ZX06JHt0fWAsIGkgPSBuLmNzc1RleHQgPyBRTShuKSA6IEpNKG4pO1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYCR7cn17JHtpfX1gKTtcbn1cbmZ1bmN0aW9uIGFkKGUsIHQsIG4pIHtcbiAgY29uc3QgciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUsIG4pLCBpID0gci5nZXRQcm9wZXJ0eVZhbHVlKFwiY29udGVudFwiKTtcbiAgaWYgKGkgPT09IFwiXCIgfHwgaSA9PT0gXCJub25lXCIpXG4gICAgcmV0dXJuO1xuICBjb25zdCBzID0gak0oKTtcbiAgdHJ5IHtcbiAgICB0LmNsYXNzTmFtZSA9IGAke3QuY2xhc3NOYW1lfSAke3N9YDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIGEuYXBwZW5kQ2hpbGQodDIocywgbiwgcikpLCB0LmFwcGVuZENoaWxkKGEpO1xufVxuZnVuY3Rpb24gZTIoZSwgdCkge1xuICBhZChlLCB0LCBcIjpiZWZvcmVcIiksIGFkKGUsIHQsIFwiOmFmdGVyXCIpO1xufVxuY29uc3Qgb2QgPSBcImFwcGxpY2F0aW9uL2ZvbnQtd29mZlwiLCBsZCA9IFwiaW1hZ2UvanBlZ1wiLCBuMiA9IHtcbiAgd29mZjogb2QsXG4gIHdvZmYyOiBvZCxcbiAgdHRmOiBcImFwcGxpY2F0aW9uL2ZvbnQtdHJ1ZXR5cGVcIixcbiAgZW90OiBcImFwcGxpY2F0aW9uL3ZuZC5tcy1mb250b2JqZWN0XCIsXG4gIHBuZzogXCJpbWFnZS9wbmdcIixcbiAganBnOiBsZCxcbiAganBlZzogbGQsXG4gIGdpZjogXCJpbWFnZS9naWZcIixcbiAgdGlmZjogXCJpbWFnZS90aWZmXCIsXG4gIHN2ZzogXCJpbWFnZS9zdmcreG1sXCIsXG4gIHdlYnA6IFwiaW1hZ2Uvd2VicFwiXG59O1xuZnVuY3Rpb24gcjIoZSkge1xuICBjb25zdCB0ID0gL1xcLihbXi4vXSo/KSQvZy5leGVjKGUpO1xuICByZXR1cm4gdCA/IHRbMV0gOiBcIlwiO1xufVxuZnVuY3Rpb24gS2MoZSkge1xuICBjb25zdCB0ID0gcjIoZSkudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG4yW3RdIHx8IFwiXCI7XG59XG5mdW5jdGlvbiBpMihlKSB7XG4gIHJldHVybiBlLnNwbGl0KC8sLylbMV07XG59XG5mdW5jdGlvbiBSbChlKSB7XG4gIHJldHVybiBlLnNlYXJjaCgvXihkYXRhOikvKSAhPT0gLTE7XG59XG5mdW5jdGlvbiBzMihlLCB0KSB7XG4gIHJldHVybiBgZGF0YToke3R9O2Jhc2U2NCwke2V9YDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFnKGUsIHQsIG4pIHtcbiAgY29uc3QgciA9IGF3YWl0IGZldGNoKGUsIHQpO1xuICBpZiAoci5zdGF0dXMgPT09IDQwNClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFJlc291cmNlIFwiJHtyLnVybH1cIiBub3QgZm91bmRgKTtcbiAgY29uc3QgaSA9IGF3YWl0IHIuYmxvYigpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHMsIGEpID0+IHtcbiAgICBjb25zdCBvID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBvLm9uZXJyb3IgPSBhLCBvLm9ubG9hZGVuZCA9ICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHMobih7IHJlczogciwgcmVzdWx0OiBvLnJlc3VsdCB9KSk7XG4gICAgICB9IGNhdGNoIChsKSB7XG4gICAgICAgIGEobCk7XG4gICAgICB9XG4gICAgfSwgby5yZWFkQXNEYXRhVVJMKGkpO1xuICB9KTtcbn1cbmNvbnN0IHpvID0ge307XG5mdW5jdGlvbiBhMihlLCB0LCBuKSB7XG4gIGxldCByID0gZS5yZXBsYWNlKC9cXD8uKi8sIFwiXCIpO1xuICByZXR1cm4gbiAmJiAociA9IGUpLCAvdHRmfG90Znxlb3R8d29mZjI/L2kudGVzdChyKSAmJiAociA9IHIucmVwbGFjZSgvLipcXC8vLCBcIlwiKSksIHQgPyBgWyR7dH1dJHtyfWAgOiByO1xufVxuYXN5bmMgZnVuY3Rpb24gUWMoZSwgdCwgbikge1xuICBjb25zdCByID0gYTIoZSwgdCwgbi5pbmNsdWRlUXVlcnlQYXJhbXMpO1xuICBpZiAoem9bcl0gIT0gbnVsbClcbiAgICByZXR1cm4gem9bcl07XG4gIG4uY2FjaGVCdXN0ICYmIChlICs9ICgvXFw/Ly50ZXN0KGUpID8gXCImXCIgOiBcIj9cIikgKyAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKSk7XG4gIGxldCBpO1xuICB0cnkge1xuICAgIGNvbnN0IHMgPSBhd2FpdCBhZyhlLCBuLmZldGNoUmVxdWVzdEluaXQsICh7IHJlczogYSwgcmVzdWx0OiBvIH0pID0+ICh0IHx8ICh0ID0gYS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKSB8fCBcIlwiKSwgaTIobykpKTtcbiAgICBpID0gczIocywgdCk7XG4gIH0gY2F0Y2ggKHMpIHtcbiAgICBpID0gbi5pbWFnZVBsYWNlaG9sZGVyIHx8IFwiXCI7XG4gICAgbGV0IGEgPSBgRmFpbGVkIHRvIGZldGNoIHJlc291cmNlOiAke2V9YDtcbiAgICBzICYmIChhID0gdHlwZW9mIHMgPT0gXCJzdHJpbmdcIiA/IHMgOiBzLm1lc3NhZ2UpLCBhICYmIGNvbnNvbGUud2FybihhKTtcbiAgfVxuICByZXR1cm4gem9bcl0gPSBpLCBpO1xufVxuYXN5bmMgZnVuY3Rpb24gbzIoZSkge1xuICBjb25zdCB0ID0gZS50b0RhdGFVUkwoKTtcbiAgcmV0dXJuIHQgPT09IFwiZGF0YTosXCIgPyBlLmNsb25lTm9kZSghMSkgOiB3YSh0KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGwyKGUsIHQpIHtcbiAgaWYgKGUuY3VycmVudFNyYykge1xuICAgIGNvbnN0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLCBhID0gcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgcy53aWR0aCA9IGUuY2xpZW50V2lkdGgsIHMuaGVpZ2h0ID0gZS5jbGllbnRIZWlnaHQsIGEgPT0gbnVsbCB8fCBhLmRyYXdJbWFnZShlLCAwLCAwLCBzLndpZHRoLCBzLmhlaWdodCk7XG4gICAgY29uc3QgbyA9IHMudG9EYXRhVVJMKCk7XG4gICAgcmV0dXJuIHdhKG8pO1xuICB9XG4gIGNvbnN0IG4gPSBlLnBvc3RlciwgciA9IEtjKG4pLCBpID0gYXdhaXQgUWMobiwgciwgdCk7XG4gIHJldHVybiB3YShpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGMyKGUpIHtcbiAgdmFyIHQ7XG4gIHRyeSB7XG4gICAgaWYgKCEoKHQgPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLmNvbnRlbnREb2N1bWVudCkgPT09IG51bGwgfHwgdCA9PT0gdm9pZCAwKSAmJiB0LmJvZHkpXG4gICAgICByZXR1cm4gYXdhaXQgbG8oZS5jb250ZW50RG9jdW1lbnQuYm9keSwge30sICEwKTtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIGUuY2xvbmVOb2RlKCExKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHUyKGUsIHQpIHtcbiAgcmV0dXJuIHBlKGUsIEhUTUxDYW52YXNFbGVtZW50KSA/IG8yKGUpIDogcGUoZSwgSFRNTFZpZGVvRWxlbWVudCkgPyBsMihlLCB0KSA6IHBlKGUsIEhUTUxJRnJhbWVFbGVtZW50KSA/IGMyKGUpIDogZS5jbG9uZU5vZGUoITEpO1xufVxuY29uc3QgaDIgPSAoZSkgPT4gZS50YWdOYW1lICE9IG51bGwgJiYgZS50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiU0xPVFwiO1xuYXN5bmMgZnVuY3Rpb24gZDIoZSwgdCwgbikge1xuICB2YXIgciwgaTtcbiAgbGV0IHMgPSBbXTtcbiAgcmV0dXJuIGgyKGUpICYmIGUuYXNzaWduZWROb2RlcyA/IHMgPSBPbihlLmFzc2lnbmVkTm9kZXMoKSkgOiBwZShlLCBIVE1MSUZyYW1lRWxlbWVudCkgJiYgISgociA9IGUuY29udGVudERvY3VtZW50KSA9PT0gbnVsbCB8fCByID09PSB2b2lkIDApICYmIHIuYm9keSA/IHMgPSBPbihlLmNvbnRlbnREb2N1bWVudC5ib2R5LmNoaWxkTm9kZXMpIDogcyA9IE9uKCgoaSA9IGUuc2hhZG93Um9vdCkgIT09IG51bGwgJiYgaSAhPT0gdm9pZCAwID8gaSA6IGUpLmNoaWxkTm9kZXMpLCBzLmxlbmd0aCA9PT0gMCB8fCBwZShlLCBIVE1MVmlkZW9FbGVtZW50KSB8fCBhd2FpdCBzLnJlZHVjZSgoYSwgbykgPT4gYS50aGVuKCgpID0+IGxvKG8sIG4pKS50aGVuKChsKSA9PiB7XG4gICAgbCAmJiB0LmFwcGVuZENoaWxkKGwpO1xuICB9KSwgUHJvbWlzZS5yZXNvbHZlKCkpLCB0O1xufVxuZnVuY3Rpb24gcDIoZSwgdCkge1xuICBjb25zdCBuID0gdC5zdHlsZTtcbiAgaWYgKCFuKVxuICAgIHJldHVybjtcbiAgY29uc3QgciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUpO1xuICByLmNzc1RleHQgPyAobi5jc3NUZXh0ID0gci5jc3NUZXh0LCBuLnRyYW5zZm9ybU9yaWdpbiA9IHIudHJhbnNmb3JtT3JpZ2luKSA6IE9uKHIpLmZvckVhY2goKGkpID0+IHtcbiAgICBsZXQgcyA9IHIuZ2V0UHJvcGVydHlWYWx1ZShpKTtcbiAgICBpID09PSBcImZvbnQtc2l6ZVwiICYmIHMuZW5kc1dpdGgoXCJweFwiKSAmJiAocyA9IGAke01hdGguZmxvb3IocGFyc2VGbG9hdChzLnN1YnN0cmluZygwLCBzLmxlbmd0aCAtIDIpKSkgLSAwLjF9cHhgKSwgcGUoZSwgSFRNTElGcmFtZUVsZW1lbnQpICYmIGkgPT09IFwiZGlzcGxheVwiICYmIHMgPT09IFwiaW5saW5lXCIgJiYgKHMgPSBcImJsb2NrXCIpLCBpID09PSBcImRcIiAmJiB0LmdldEF0dHJpYnV0ZShcImRcIikgJiYgKHMgPSBgcGF0aCgke3QuZ2V0QXR0cmlidXRlKFwiZFwiKX0pYCksIG4uc2V0UHJvcGVydHkoaSwgcywgci5nZXRQcm9wZXJ0eVByaW9yaXR5KGkpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBmMihlLCB0KSB7XG4gIHBlKGUsIEhUTUxUZXh0QXJlYUVsZW1lbnQpICYmICh0LmlubmVySFRNTCA9IGUudmFsdWUpLCBwZShlLCBIVE1MSW5wdXRFbGVtZW50KSAmJiB0LnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIGUudmFsdWUpO1xufVxuZnVuY3Rpb24gbTIoZSwgdCkge1xuICBpZiAocGUoZSwgSFRNTFNlbGVjdEVsZW1lbnQpKSB7XG4gICAgY29uc3QgbiA9IHQsIHIgPSBBcnJheS5mcm9tKG4uY2hpbGRyZW4pLmZpbmQoKGkpID0+IGUudmFsdWUgPT09IGkuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikpO1xuICAgIHIgJiYgci5zZXRBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiLCBcIlwiKTtcbiAgfVxufVxuZnVuY3Rpb24gZzIoZSwgdCkge1xuICByZXR1cm4gcGUodCwgRWxlbWVudCkgJiYgKHAyKGUsIHQpLCBlMihlLCB0KSwgZjIoZSwgdCksIG0yKGUsIHQpKSwgdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHYyKGUsIHQpIHtcbiAgY29uc3QgbiA9IGUucXVlcnlTZWxlY3RvckFsbCA/IGUucXVlcnlTZWxlY3RvckFsbChcInVzZVwiKSA6IFtdO1xuICBpZiAobi5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIGU7XG4gIGNvbnN0IHIgPSB7fTtcbiAgZm9yIChsZXQgcyA9IDA7IHMgPCBuLmxlbmd0aDsgcysrKSB7XG4gICAgY29uc3QgYSA9IG5bc10uZ2V0QXR0cmlidXRlKFwieGxpbms6aHJlZlwiKTtcbiAgICBpZiAoYSkge1xuICAgICAgY29uc3QgbyA9IGUucXVlcnlTZWxlY3RvcihhKSwgbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYSk7XG4gICAgICAhbyAmJiBsICYmICFyW2FdICYmIChyW2FdID0gYXdhaXQgbG8obCwgdCwgITApKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaSA9IE9iamVjdC52YWx1ZXMocik7XG4gIGlmIChpLmxlbmd0aCkge1xuICAgIGNvbnN0IHMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiwgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzLCBcInN2Z1wiKTtcbiAgICBhLnNldEF0dHJpYnV0ZShcInhtbG5zXCIsIHMpLCBhLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiLCBhLnN0eWxlLndpZHRoID0gXCIwXCIsIGEuc3R5bGUuaGVpZ2h0ID0gXCIwXCIsIGEuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiLCBhLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICBjb25zdCBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHMsIFwiZGVmc1wiKTtcbiAgICBhLmFwcGVuZENoaWxkKG8pO1xuICAgIGZvciAobGV0IGwgPSAwOyBsIDwgaS5sZW5ndGg7IGwrKylcbiAgICAgIG8uYXBwZW5kQ2hpbGQoaVtsXSk7XG4gICAgZS5hcHBlbmRDaGlsZChhKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvKGUsIHQsIG4pIHtcbiAgcmV0dXJuICFuICYmIHQuZmlsdGVyICYmICF0LmZpbHRlcihlKSA/IG51bGwgOiBQcm9taXNlLnJlc29sdmUoZSkudGhlbigocikgPT4gdTIociwgdCkpLnRoZW4oKHIpID0+IGQyKGUsIHIsIHQpKS50aGVuKChyKSA9PiBnMihlLCByKSkudGhlbigocikgPT4gdjIociwgdCkpO1xufVxuY29uc3Qgb2cgPSAvdXJsXFwoKFsnXCJdPykoW14nXCJdKz8pXFwxXFwpL2csIHkyID0gL3VybFxcKFteKV0rXFwpXFxzKmZvcm1hdFxcKChbXCInXT8pKFteXCInXSspXFwxXFwpL2csIHgyID0gL3NyYzpcXHMqKD86dXJsXFwoW14pXStcXClcXHMqZm9ybWF0XFwoW14pXStcXClbLDtdXFxzKikrL2c7XG5mdW5jdGlvbiBiMihlKSB7XG4gIGNvbnN0IHQgPSBlLnJlcGxhY2UoLyhbLiorP14ke30oKXxcXFtcXF1cXC9cXFxcXSkvZywgXCJcXFxcJDFcIik7XG4gIHJldHVybiBuZXcgUmVnRXhwKGAodXJsXFxcXChbJ1wiXT8pKCR7dH0pKFsnXCJdP1xcXFwpKWAsIFwiZ1wiKTtcbn1cbmZ1bmN0aW9uIF8yKGUpIHtcbiAgY29uc3QgdCA9IFtdO1xuICByZXR1cm4gZS5yZXBsYWNlKG9nLCAobiwgciwgaSkgPT4gKHQucHVzaChpKSwgbikpLCB0LmZpbHRlcigobikgPT4gIVJsKG4pKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIEUyKGUsIHQsIG4sIHIsIGkpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzID0gbiA/IEZNKHQsIG4pIDogdCwgYSA9IEtjKHQpO1xuICAgIGxldCBvO1xuICAgIHJldHVybiBpIHx8IChvID0gYXdhaXQgUWMocywgYSwgcikpLCBlLnJlcGxhY2UoYjIodCksIGAkMSR7b30kM2ApO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIE8yKGUsIHsgcHJlZmVycmVkRm9udEZvcm1hdDogdCB9KSB7XG4gIHJldHVybiB0ID8gZS5yZXBsYWNlKHgyLCAobikgPT4ge1xuICAgIGZvciAoOyA7ICkge1xuICAgICAgY29uc3QgW3IsICwgaV0gPSB5Mi5leGVjKG4pIHx8IFtdO1xuICAgICAgaWYgKCFpKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIGlmIChpID09PSB0KVxuICAgICAgICByZXR1cm4gYHNyYzogJHtyfTtgO1xuICAgIH1cbiAgfSkgOiBlO1xufVxuZnVuY3Rpb24gbGcoZSkge1xuICByZXR1cm4gZS5zZWFyY2gob2cpICE9PSAtMTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNnKGUsIHQsIG4pIHtcbiAgaWYgKCFsZyhlKSlcbiAgICByZXR1cm4gZTtcbiAgY29uc3QgciA9IE8yKGUsIG4pO1xuICByZXR1cm4gXzIocikucmVkdWNlKChpLCBzKSA9PiBpLnRoZW4oKGEpID0+IEUyKGEsIHMsIHQsIG4pKSwgUHJvbWlzZS5yZXNvbHZlKHIpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIExzKGUsIHQsIG4pIHtcbiAgdmFyIHI7XG4gIGNvbnN0IGkgPSAociA9IHQuc3R5bGUpID09PSBudWxsIHx8IHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHIuZ2V0UHJvcGVydHlWYWx1ZShlKTtcbiAgaWYgKGkpIHtcbiAgICBjb25zdCBzID0gYXdhaXQgY2coaSwgbnVsbCwgbik7XG4gICAgcmV0dXJuIHQuc3R5bGUuc2V0UHJvcGVydHkoZSwgcywgdC5zdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KGUpKSwgITA7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuYXN5bmMgZnVuY3Rpb24gUzIoZSwgdCkge1xuICBhd2FpdCBMcyhcImJhY2tncm91bmRcIiwgZSwgdCkgfHwgYXdhaXQgTHMoXCJiYWNrZ3JvdW5kLWltYWdlXCIsIGUsIHQpLCBhd2FpdCBMcyhcIm1hc2tcIiwgZSwgdCkgfHwgYXdhaXQgTHMoXCJtYXNrLWltYWdlXCIsIGUsIHQpO1xufVxuYXN5bmMgZnVuY3Rpb24gVDIoZSwgdCkge1xuICBjb25zdCBuID0gcGUoZSwgSFRNTEltYWdlRWxlbWVudCk7XG4gIGlmICghKG4gJiYgIVJsKGUuc3JjKSkgJiYgIShwZShlLCBTVkdJbWFnZUVsZW1lbnQpICYmICFSbChlLmhyZWYuYmFzZVZhbCkpKVxuICAgIHJldHVybjtcbiAgY29uc3QgciA9IG4gPyBlLnNyYyA6IGUuaHJlZi5iYXNlVmFsLCBpID0gYXdhaXQgUWMociwgS2MociksIHQpO1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocywgYSkgPT4ge1xuICAgIGUub25sb2FkID0gcywgZS5vbmVycm9yID0gYTtcbiAgICBjb25zdCBvID0gZTtcbiAgICBvLmRlY29kZSAmJiAoby5kZWNvZGUgPSBzKSwgby5sb2FkaW5nID09PSBcImxhenlcIiAmJiAoby5sb2FkaW5nID0gXCJlYWdlclwiKSwgbiA/IChlLnNyY3NldCA9IFwiXCIsIGUuc3JjID0gaSkgOiBlLmhyZWYuYmFzZVZhbCA9IGk7XG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gdzIoZSwgdCkge1xuICBjb25zdCBuID0gT24oZS5jaGlsZE5vZGVzKS5tYXAoKHIpID0+IHVnKHIsIHQpKTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwobikudGhlbigoKSA9PiBlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVnKGUsIHQpIHtcbiAgcGUoZSwgRWxlbWVudCkgJiYgKGF3YWl0IFMyKGUsIHQpLCBhd2FpdCBUMihlLCB0KSwgYXdhaXQgdzIoZSwgdCkpO1xufVxuZnVuY3Rpb24gJDIoZSwgdCkge1xuICBjb25zdCB7IHN0eWxlOiBuIH0gPSBlO1xuICB0LmJhY2tncm91bmRDb2xvciAmJiAobi5iYWNrZ3JvdW5kQ29sb3IgPSB0LmJhY2tncm91bmRDb2xvciksIHQud2lkdGggJiYgKG4ud2lkdGggPSBgJHt0LndpZHRofXB4YCksIHQuaGVpZ2h0ICYmIChuLmhlaWdodCA9IGAke3QuaGVpZ2h0fXB4YCk7XG4gIGNvbnN0IHIgPSB0LnN0eWxlO1xuICByZXR1cm4gciAhPSBudWxsICYmIE9iamVjdC5rZXlzKHIpLmZvckVhY2goKGkpID0+IHtcbiAgICBuW2ldID0gcltpXTtcbiAgfSksIGU7XG59XG5jb25zdCBjZCA9IHt9O1xuYXN5bmMgZnVuY3Rpb24gdWQoZSkge1xuICBsZXQgdCA9IGNkW2VdO1xuICBpZiAodCAhPSBudWxsKVxuICAgIHJldHVybiB0O1xuICBjb25zdCBuID0gYXdhaXQgKGF3YWl0IGZldGNoKGUpKS50ZXh0KCk7XG4gIHJldHVybiB0ID0geyB1cmw6IGUsIGNzc1RleHQ6IG4gfSwgY2RbZV0gPSB0LCB0O1xufVxuYXN5bmMgZnVuY3Rpb24gaGQoZSwgdCkge1xuICBsZXQgbiA9IGUuY3NzVGV4dDtcbiAgY29uc3QgciA9IC91cmxcXChbXCInXT8oW15cIicpXSspW1wiJ10/XFwpL2csIGkgPSAobi5tYXRjaCgvdXJsXFwoW14pXStcXCkvZykgfHwgW10pLm1hcChhc3luYyAocykgPT4ge1xuICAgIGxldCBhID0gcy5yZXBsYWNlKHIsIFwiJDFcIik7XG4gICAgcmV0dXJuIGEuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpIHx8IChhID0gbmV3IFVSTChhLCBlLnVybCkuaHJlZiksIGFnKGEsIHQuZmV0Y2hSZXF1ZXN0SW5pdCwgKHsgcmVzdWx0OiBvIH0pID0+IChuID0gbi5yZXBsYWNlKHMsIGB1cmwoJHtvfSlgKSwgW3MsIG9dKSk7XG4gIH0pO1xuICByZXR1cm4gUHJvbWlzZS5hbGwoaSkudGhlbigoKSA9PiBuKTtcbn1cbmZ1bmN0aW9uIGRkKGUpIHtcbiAgaWYgKGUgPT0gbnVsbClcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IHQgPSBbXSwgbiA9IC8oXFwvXFwqW1xcc1xcU10qP1xcKlxcLykvZ2k7XG4gIGxldCByID0gZS5yZXBsYWNlKG4sIFwiXCIpO1xuICBjb25zdCBpID0gbmV3IFJlZ0V4cChcIigoQC4qP2tleWZyYW1lcyBbXFxcXHNcXFxcU10qPyl7KFtcXFxcc1xcXFxTXSo/fVxcXFxzKj8pfSlcIiwgXCJnaVwiKTtcbiAgZm9yICg7IDsgKSB7XG4gICAgY29uc3QgbCA9IGkuZXhlYyhyKTtcbiAgICBpZiAobCA9PT0gbnVsbClcbiAgICAgIGJyZWFrO1xuICAgIHQucHVzaChsWzBdKTtcbiAgfVxuICByID0gci5yZXBsYWNlKGksIFwiXCIpO1xuICBjb25zdCBzID0gL0BpbXBvcnRbXFxzXFxTXSo/dXJsXFwoW14pXSpcXClbXFxzXFxTXSo/Oy9naSwgYSA9IFwiKChcXFxccyo/KD86XFxcXC9cXFxcKltcXFxcc1xcXFxTXSo/XFxcXCpcXFxcLyk/XFxcXHMqP0BtZWRpYVtcXFxcc1xcXFxTXSo/KXsoW1xcXFxzXFxcXFNdKj8pfVxcXFxzKj99KXwoKFtcXFxcc1xcXFxTXSo/KXsoW1xcXFxzXFxcXFNdKj8pfSlcIiwgbyA9IG5ldyBSZWdFeHAoYSwgXCJnaVwiKTtcbiAgZm9yICg7IDsgKSB7XG4gICAgbGV0IGwgPSBzLmV4ZWMocik7XG4gICAgaWYgKGwgPT09IG51bGwpIHtcbiAgICAgIGlmIChsID0gby5leGVjKHIpLCBsID09PSBudWxsKVxuICAgICAgICBicmVhaztcbiAgICAgIHMubGFzdEluZGV4ID0gby5sYXN0SW5kZXg7XG4gICAgfSBlbHNlXG4gICAgICBvLmxhc3RJbmRleCA9IHMubGFzdEluZGV4O1xuICAgIHQucHVzaChsWzBdKTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIE0yKGUsIHQpIHtcbiAgY29uc3QgbiA9IFtdLCByID0gW107XG4gIHJldHVybiBlLmZvckVhY2goKGkpID0+IHtcbiAgICBpZiAoXCJjc3NSdWxlc1wiIGluIGkpXG4gICAgICB0cnkge1xuICAgICAgICBPbihpLmNzc1J1bGVzIHx8IFtdKS5mb3JFYWNoKChzLCBhKSA9PiB7XG4gICAgICAgICAgaWYgKHMudHlwZSA9PT0gQ1NTUnVsZS5JTVBPUlRfUlVMRSkge1xuICAgICAgICAgICAgbGV0IG8gPSBhICsgMTtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBzLmhyZWYsIGMgPSB1ZChsKS50aGVuKCh1KSA9PiBoZCh1LCB0KSkudGhlbigodSkgPT4gZGQodSkuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGkuaW5zZXJ0UnVsZShkLCBkLnN0YXJ0c1dpdGgoXCJAaW1wb3J0XCIpID8gbyArPSAxIDogaS5jc3NSdWxlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluc2VydGluZyBydWxlIGZyb20gcmVtb3RlIGNzc1wiLCB7XG4gICAgICAgICAgICAgICAgICBydWxlOiBkLFxuICAgICAgICAgICAgICAgICAgZXJyb3I6IGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpLmNhdGNoKCh1KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIHJlbW90ZSBjc3NcIiwgdS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgci5wdXNoKGMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgIGNvbnN0IGEgPSBlLmZpbmQoKG8pID0+IG8uaHJlZiA9PSBudWxsKSB8fCBkb2N1bWVudC5zdHlsZVNoZWV0c1swXTtcbiAgICAgICAgaS5ocmVmICE9IG51bGwgJiYgci5wdXNoKHVkKGkuaHJlZikudGhlbigobykgPT4gaGQobywgdCkpLnRoZW4oKG8pID0+IGRkKG8pLmZvckVhY2goKGwpID0+IHtcbiAgICAgICAgICBhLmluc2VydFJ1bGUobCwgaS5jc3NSdWxlcy5sZW5ndGgpO1xuICAgICAgICB9KSkuY2F0Y2goKG8pID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgbG9hZGluZyByZW1vdGUgc3R5bGVzaGVldFwiLCBvKTtcbiAgICAgICAgfSkpLCBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW5saW5pbmcgcmVtb3RlIGNzcyBmaWxlXCIsIHMpO1xuICAgICAgfVxuICB9KSwgUHJvbWlzZS5hbGwocikudGhlbigoKSA9PiAoZS5mb3JFYWNoKChpKSA9PiB7XG4gICAgaWYgKFwiY3NzUnVsZXNcIiBpbiBpKVxuICAgICAgdHJ5IHtcbiAgICAgICAgT24oaS5jc3NSdWxlcyB8fCBbXSkuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgIG4ucHVzaChzKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHdoaWxlIHJlYWRpbmcgQ1NTIHJ1bGVzIGZyb20gJHtpLmhyZWZ9YCwgcyk7XG4gICAgICB9XG4gIH0pLCBuKSk7XG59XG5mdW5jdGlvbiBDMihlKSB7XG4gIHJldHVybiBlLmZpbHRlcigodCkgPT4gdC50eXBlID09PSBDU1NSdWxlLkZPTlRfRkFDRV9SVUxFKS5maWx0ZXIoKHQpID0+IGxnKHQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcInNyY1wiKSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gQTIoZSwgdCkge1xuICBpZiAoZS5vd25lckRvY3VtZW50ID09IG51bGwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZWQgZWxlbWVudCBpcyBub3Qgd2l0aGluIGEgRG9jdW1lbnRcIik7XG4gIGNvbnN0IG4gPSBPbihlLm93bmVyRG9jdW1lbnQuc3R5bGVTaGVldHMpLCByID0gYXdhaXQgTTIobiwgdCk7XG4gIHJldHVybiBDMihyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIEwyKGUsIHQpIHtcbiAgY29uc3QgbiA9IGF3YWl0IEEyKGUsIHQpO1xuICByZXR1cm4gKGF3YWl0IFByb21pc2UuYWxsKG4ubWFwKChyKSA9PiB7XG4gICAgY29uc3QgaSA9IHIucGFyZW50U3R5bGVTaGVldCA/IHIucGFyZW50U3R5bGVTaGVldC5ocmVmIDogbnVsbDtcbiAgICByZXR1cm4gY2coci5jc3NUZXh0LCBpLCB0KTtcbiAgfSkpKS5qb2luKGBcbmApO1xufVxuYXN5bmMgZnVuY3Rpb24gazIoZSwgdCkge1xuICBjb25zdCBuID0gdC5mb250RW1iZWRDU1MgIT0gbnVsbCA/IHQuZm9udEVtYmVkQ1NTIDogdC5za2lwRm9udHMgPyBudWxsIDogYXdhaXQgTDIoZSwgdCk7XG4gIGlmIChuKSB7XG4gICAgY29uc3QgciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKSwgaSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG4pO1xuICAgIHIuYXBwZW5kQ2hpbGQoaSksIGUuZmlyc3RDaGlsZCA/IGUuaW5zZXJ0QmVmb3JlKHIsIGUuZmlyc3RDaGlsZCkgOiBlLmFwcGVuZENoaWxkKHIpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBEMihlLCB0ID0ge30pIHtcbiAgY29uc3QgeyB3aWR0aDogbiwgaGVpZ2h0OiByIH0gPSBzZyhlLCB0KSwgaSA9IGF3YWl0IGxvKGUsIHQsICEwKTtcbiAgcmV0dXJuIGF3YWl0IGsyKGksIHQpLCBhd2FpdCB1ZyhpLCB0KSwgJDIoaSwgdCksIGF3YWl0IEtNKGksIG4sIHIpO1xufVxuYXN5bmMgZnVuY3Rpb24gaGcoZSwgdCA9IHt9KSB7XG4gIGNvbnN0IHsgd2lkdGg6IG4sIGhlaWdodDogciB9ID0gc2coZSwgdCksIGkgPSBhd2FpdCBEMihlLCB0KSwgcyA9IGF3YWl0IHdhKGkpLCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSwgbyA9IGEuZ2V0Q29udGV4dChcIjJkXCIpLCBsID0gdC5waXhlbFJhdGlvIHx8IFlNKCksIGMgPSB0LmNhbnZhc1dpZHRoIHx8IG4sIHUgPSB0LmNhbnZhc0hlaWdodCB8fCByO1xuICByZXR1cm4gYS53aWR0aCA9IGMgKiBsLCBhLmhlaWdodCA9IHUgKiBsLCB0LnNraXBBdXRvU2NhbGUgfHwgWE0oYSksIGEuc3R5bGUud2lkdGggPSBgJHtjfWAsIGEuc3R5bGUuaGVpZ2h0ID0gYCR7dX1gLCB0LmJhY2tncm91bmRDb2xvciAmJiAoby5maWxsU3R5bGUgPSB0LmJhY2tncm91bmRDb2xvciwgby5maWxsUmVjdCgwLCAwLCBhLndpZHRoLCBhLmhlaWdodCkpLCBvLmRyYXdJbWFnZShzLCAwLCAwLCBhLndpZHRoLCBhLmhlaWdodCksIGE7XG59XG5hc3luYyBmdW5jdGlvbiBSMihlLCB0ID0ge30pIHtcbiAgcmV0dXJuIChhd2FpdCBoZyhlLCB0KSkudG9EYXRhVVJMKCk7XG59XG5hc3luYyBmdW5jdGlvbiBJMihlLCB0ID0ge30pIHtcbiAgcmV0dXJuIChhd2FpdCBoZyhlLCB0KSkudG9EYXRhVVJMKFwiaW1hZ2UvanBlZ1wiLCB0LnF1YWxpdHkgfHwgMSk7XG59XG5sZXQgRG4gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHQsIG4pIHtcbiAgICB0aGlzLm1vZGVsID0gdCwgdGhpcy5zZXJ2aWNlcyA9IG4sIHRoaXMuaW5pdCgpO1xuICB9XG4gIGluaXQoKSB7XG4gIH1cbiAgdXBkYXRlKCkge1xuICB9XG4gIC8vIFVzZWQgdG8gcGFzcyBkb3duIGluZm9ybWF0aW9uIHRvIHRoZSBjb21wb25lbnRzXG4gIHNldE1vZGVsKHQpIHtcbiAgICB0aGlzLm1vZGVsID0gdDtcbiAgfVxuICAvLyBVc2VkIHRvIHBhc3MgZG93biBzZXJ2aWNlcyB0byB0aGUgY29tcG9uZW50c1xuICBzZXRTZXJ2aWNlcyh0KSB7XG4gICAgdGhpcy5zZXJ2aWNlcyA9IHQ7XG4gIH1cbn07XG5jb25zdCBOMiA9IFwiRE9OVF9TVFlMRV9NRV9jc3Nfc3R5bGVzX3ZlcmlmaWVyXCI7XG5sZXQgTiA9IGNsYXNzIElsIGV4dGVuZHMgRG4ge1xuICAvLyBpbml0aWFsaXplZCBpbiBpbml0aWFsaXplSUQoKSBjYWxsZWQgYnkgaW5pdCgpXG4gIGNvbnN0cnVjdG9yKHQsIG4pIHtcbiAgICBzdXBlcih0LCBuKTtcbiAgfVxuICBzdGF0aWMgZ2V0SFRNTEVsZW1lbnRTaXplKHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHQuY2xpZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IHQuY2xpZW50SGVpZ2h0XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZ2V0U1ZHRWxlbWVudFNpemUodCwgbiA9IHtcbiAgICB1c2VBdHRyczogITEsXG4gICAgdXNlQ2xpZW50RGltZW5zaW9uczogITEsXG4gICAgdXNlQkJveDogITEsXG4gICAgdXNlQm91bmRpbmdSZWN0OiAhMVxuICB9KSB7XG4gICAgdC5hdHRyIHx8ICh0ID0gSSh0KSk7XG4gICAgY29uc3QgciA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfSwgaSA9IChoKSA9PiB7XG4gICAgICBoICYmIE9iamVjdC5rZXlzKHIpLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgaWYgKGhbcF0pIHtcbiAgICAgICAgICBjb25zdCBmID0gaFtwXSwgZyA9IHBhcnNlRmxvYXQoZik7XG4gICAgICAgICAgZiAmJiBnID4gcltwXSAmJiAoXCJcIiArIGYpLmluZGV4T2YoXCIlXCIpID09PSAtMSAmJiAocltwXSA9IGcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBzID0ge1xuICAgICAgd2lkdGg6IHQuYXR0cihcIndpZHRoXCIpLFxuICAgICAgaGVpZ2h0OiB0LmF0dHIoXCJoZWlnaHRcIilcbiAgICB9LCBhID0gdC5ub2RlKCk7XG4gICAgbGV0IG8sIGwsIGMsIHU7XG4gICAgdHJ5IHtcbiAgICAgIHR5cGVvZiBhLmdldEJCb3ggPT0gXCJmdW5jdGlvblwiICYmIChvID0gYS5nZXRCQm94KCksIGwgPSB7XG4gICAgICAgIHdpZHRoOiBvLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IG8uaGVpZ2h0XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChoKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGgpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdHlwZW9mIChhID09IG51bGwgPyB2b2lkIDAgOiBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkgPT0gXCJmdW5jdGlvblwiICYmIChjID0gYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdSA9IHtcbiAgICAgICAgd2lkdGg6IGMud2lkdGgsXG4gICAgICAgIGhlaWdodDogYy5oZWlnaHRcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGgpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoaCk7XG4gICAgfVxuICAgIGxldCBkO1xuICAgIGlmIChhIGluc3RhbmNlb2YgU1ZHU1ZHRWxlbWVudCAmJiAoZCA9IHtcbiAgICAgIHdpZHRoOiBhLmNsaWVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBhLmNsaWVudEhlaWdodFxuICAgIH0pLCBuKSB7XG4gICAgICBpZiAobi51c2VBdHRycyAmJiAoaShzKSwgci53aWR0aCA+IDAgJiYgci5oZWlnaHQgPiAwKSlcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICBpZiAobi51c2VDbGllbnREaW1lbnNpb25zICYmIChpKGQpLCByLndpZHRoID4gMCAmJiByLmhlaWdodCA+IDApKVxuICAgICAgICByZXR1cm4gZDtcbiAgICAgIGlmIChuLnVzZUJCb3ggJiYgKGkobCksIHIud2lkdGggPiAwICYmIHIuaGVpZ2h0ID4gMCkpXG4gICAgICAgIHJldHVybiBsO1xuICAgICAgaWYgKG4udXNlQm91bmRpbmdSZWN0ICYmIChpKHUpLCByLndpZHRoID4gMCAmJiByLmhlaWdodCA+IDApKVxuICAgICAgICByZXR1cm4gdTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGggPSB7XG4gICAgICAgIHdpZHRoOiB5KHQubm9kZSgpLCBcIndpZHRoXCIsIFwiYmFzZVZhbFwiLCBcInZhbHVlXCIpLFxuICAgICAgICBoZWlnaHQ6IHkodC5ub2RlKCksIFwiaGVpZ2h0XCIsIFwiYmFzZVZhbFwiLCBcInZhbHVlXCIpXG4gICAgICB9O1xuICAgICAgaShoKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGkoZCksIGkobCksIGkocyk7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHN0YXRpYyBhcHBlbmRPclNlbGVjdCh0LCBuKSB7XG4gICAgY29uc3QgciA9IHQuc2VsZWN0KGAke259YCk7XG4gICAgaWYgKHIuZW1wdHkoKSkge1xuICAgICAgbGV0IGkgPSBuLnNwbGl0KFwiI1wiKSwgcywgYTtcbiAgICAgIHJldHVybiBpLmxlbmd0aCA9PT0gMiA/IChzID0gaVswXSwgaSA9IGlbMV0uc3BsaXQoXCIuXCIpLCBhID0gaVswXSkgOiAoaSA9IG4uc3BsaXQoXCIuXCIpLCBzID0gaVswXSksIHQuYXBwZW5kKHMpLmF0dHIoXCJpZFwiLCBhKS5hdHRyKFwiY2xhc3NcIiwgaS5zbGljZSgxKS5qb2luKFwiIFwiKSk7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIGluaXQoKSB7XG4gICAgdGhpcy5pbml0aWFsaXplSUQoKSwgdGhpcy5zdHlsZUhvbGRlckVsZW1lbnQoKSwgdGhpcy5hZGRNYWluQ29udGFpbmVyKCksIHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLnJlc2l6YWJsZSAmJiB0aGlzLmFkZFJlc2l6ZUxpc3RlbmVyKCksIHRoaXMuYWRkSG9sZGVyTGlzdGVuZXJzKCksIHRoaXMuaGFuZGxlRnVsbHNjcmVlbkNoYW5nZSgpO1xuICB9XG4gIGdldENoYXJ0SUQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnRJRDtcbiAgfVxuICBnZXRFbGVtZW50T2Zmc2V0KHQsIG4gPSAhMSkge1xuICAgIGNvbnN0IHIgPSB7IGxlZnQ6IDAsIHRvcDogMCB9LCBpID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgcyA9IG4gPyB7IGxlZnQ6IDAsIHRvcDogMCB9IDogdGhpcy5nZXRIb2xkZXIoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB0cnkge1xuICAgICAgci5sZWZ0ID0gaS5sZWZ0IC0gcy5sZWZ0LCByLnRvcCA9IGkudG9wIC0gcy50b3A7XG4gICAgfSBjYXRjaCAoYSkge1xuICAgICAgY29uc29sZS5lcnJvcihhKTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgZ2VuZXJhdGVFbGVtZW50SURTdHJpbmcodCkge1xuICAgIHJldHVybiBgY2hhcnQtJHt0aGlzLmNoYXJ0SUR9LSR7dH1gO1xuICB9XG4gIGluaXRpYWxpemVJRCgpIHtcbiAgICB0aGlzLmNoYXJ0SUQgPSBNYXRoLmZsb29yKCgxICsgTWF0aC5yYW5kb20oKSkgKiAyODE0NzQ5NzY3MTA2NTYpLnRvU3RyaW5nKDE2KTtcbiAgfVxuICBhZGRNYWluQ29udGFpbmVyKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm1vZGVsLmdldE9wdGlvbnMoKSwgbiA9IHkodCwgXCJzdHlsZVwiLCBcInByZWZpeFwiKSwgciA9IEkodGhpcy5nZXRIb2xkZXIoKSkuYXBwZW5kKFwiZGl2XCIpLmNsYXNzZWQoYCR7dWV9LS0ke259LS1jaGFydC13cmFwcGVyYCwgITApLmF0dHIoXCJpZFwiLCBgY2hhcnQtJHt0aGlzLmdldENoYXJ0SUQoKX1gKS5zdHlsZShcImhlaWdodFwiLCBcIjEwMCVcIikuc3R5bGUoXCJ3aWR0aFwiLCBcIjEwMCVcIik7XG4gICAgci5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBOMiksIHRoaXMubWFpbkNvbnRhaW5lciA9IHIubm9kZSgpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLnN0eWxlSG9sZGVyRWxlbWVudCgpO1xuICB9XG4gIHN0eWxlSG9sZGVyRWxlbWVudCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRIb2xkZXIoKSwgeyB3aWR0aDogbiwgaGVpZ2h0OiByLCB0aGVtZTogaSB9ID0gdGhpcy5tb2RlbC5nZXRPcHRpb25zKCk7XG4gICAgbiAhPT0gdGhpcy53aWR0aCAmJiAodC5zdHlsZS53aWR0aCA9IG4sIHRoaXMud2lkdGggPSBuKSwgciAhPT0gdGhpcy5oZWlnaHQgJiYgKHQuc3R5bGUuaGVpZ2h0ID0gciwgdGhpcy5oZWlnaHQgPSByKSwgSSh0aGlzLmdldEhvbGRlcigpKS5jbGFzc2VkKGAke3VlfS0tY2hhcnQtaG9sZGVyYCwgITApLmF0dHIoXCJkYXRhLWNhcmJvbi10aGVtZVwiLCBpKTtcbiAgfVxuICBnZXRIb2xkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZWwuZ2V0KFwiaG9sZGVyXCIpO1xuICB9XG4gIGV4cG9ydFRvSlBHKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLCBuID0gdGhpcy5tb2RlbC5nZXRPcHRpb25zKCksIHIgPSB0aGlzLmdldEhvbGRlcigpLCBpID0gSShyKTtcbiAgICBpLmNsYXNzZWQoXCJmaWxsZWRcIiwgITApLCBJMih0aGlzLmdldE1haW5Db250YWluZXIoKSwge1xuICAgICAgcXVhbGl0eTogMSxcbiAgICAgIC8vIFJlbW92ZSB0b29sYmFyXG4gICAgICBmaWx0ZXI6IChzKSA9PiAhKHMuY2xhc3NMaXN0ICYmIHMuY2xhc3NMaXN0LmNvbnRhaW5zKFwiY2RzLS1jYy0tdG9vbGJhclwiKSlcbiAgICB9KS50aGVuKGZ1bmN0aW9uKHMpIHtcbiAgICAgIHZhciBhO1xuICAgICAgbGV0IG8gPSBcIm15Q2hhcnRcIjtcbiAgICAgIGNvbnN0IGwgPSB5KG4sIFwiZmlsZURvd25sb2FkXCIsIFwiZmlsZU5hbWVcIik7XG4gICAgICB0eXBlb2YgbCA9PSBcImZ1bmN0aW9uXCIgPyBvID0gbChcImpwZ1wiKSA6IHR5cGVvZiBsID09IFwic3RyaW5nXCIgJiYgKG8gPSBsKSwgKGEgPSB0LnNlcnZpY2VzLmZpbGVzKSA9PSBudWxsIHx8IGEuZG93bmxvYWRJbWFnZShzLCBgJHtvfS5qcGdgKSwgaS5jbGFzc2VkKFwiZmlsbGVkXCIsICExKTtcbiAgICB9KTtcbiAgfVxuICBleHBvcnRUb1BORygpIHtcbiAgICBjb25zdCB0ID0gdGhpcywgbiA9IHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLCByID0gdGhpcy5nZXRIb2xkZXIoKSwgaSA9IEkocik7XG4gICAgaS5jbGFzc2VkKFwiZmlsbGVkXCIsICEwKSwgUjIodGhpcy5nZXRNYWluQ29udGFpbmVyKCksIHtcbiAgICAgIHF1YWxpdHk6IDEsXG4gICAgICAvLyBSZW1vdmUgdG9vbGJhclxuICAgICAgZmlsdGVyOiAocykgPT4gIShzLmNsYXNzTGlzdCAmJiBzLmNsYXNzTGlzdC5jb250YWlucyhcImNkcy0tY2MtLXRvb2xiYXJcIikpXG4gICAgfSkudGhlbihmdW5jdGlvbihzKSB7XG4gICAgICB2YXIgYTtcbiAgICAgIGxldCBvID0gXCJteUNoYXJ0XCI7XG4gICAgICBjb25zdCBsID0geShuLCBcImZpbGVEb3dubG9hZFwiLCBcImZpbGVOYW1lXCIpO1xuICAgICAgdHlwZW9mIGwgPT0gXCJmdW5jdGlvblwiID8gbyA9IGwoXCJwbmdcIikgOiB0eXBlb2YgbCA9PSBcInN0cmluZ1wiICYmIChvID0gbCksIChhID0gdC5zZXJ2aWNlcy5maWxlcykgPT0gbnVsbCB8fCBhLmRvd25sb2FkSW1hZ2UocywgYCR7b30ucG5nYCksIGkuY2xhc3NlZChcImZpbGxlZFwiLCAhMSk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24ocykge1xuICAgICAgY29uc29sZS5lcnJvcihcIm9vcHMsIHNvbWV0aGluZyB3ZW50IHdyb25nIVwiLCBzKTtcbiAgICB9KTtcbiAgfVxuICBpc0Z1bGxTY3JlZW5Nb2RlKCkge1xuICAgIHJldHVybiBJKHRoaXMuZ2V0SG9sZGVyKCkpLmNsYXNzZWQoXCJmdWxsc2NyZWVuXCIpO1xuICB9XG4gIHRvZ2dsZUZ1bGxzY3JlZW4oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0SG9sZGVyKCk7XG4gICAgSSh0KS5jbGFzc2VkKFwiZnVsbHNjcmVlblwiKSAmJiAoZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQubW96RnVsbFNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQubXNGdWxsc2NyZWVuRWxlbWVudCkgPyBkb2N1bWVudC5leGl0RnVsbHNjcmVlbiA/IGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCkgOiBkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbiA/IGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKCkgOiBkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuID8gZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbigpIDogZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbiAmJiBkb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuKCkgOiB0LnJlcXVlc3RGdWxsc2NyZWVuID8gdC5yZXF1ZXN0RnVsbHNjcmVlbigpIDogdC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbiA/IHQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oKSA6IHQubW96UmVxdWVzdEZ1bGxTY3JlZW4gPyB0Lm1velJlcXVlc3RGdWxsU2NyZWVuKCkgOiB0Lm1zUmVxdWVzdEZ1bGxzY3JlZW4gJiYgdC5tc1JlcXVlc3RGdWxsc2NyZWVuKCk7XG4gIH1cbiAgaGFuZGxlRnVsbHNjcmVlbkNoYW5nZSgpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZnVsbHNjcmVlbmNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0ID0gSSh0aGlzLmdldEhvbGRlcigpKSwgbiA9IHQuY2xhc3NlZChcImZ1bGxzY3JlZW5cIik7XG4gICAgICB0LmNsYXNzZWQoXCJmdWxsc2NyZWVuXCIsICFuKTtcbiAgICB9KTtcbiAgfVxuICBzZXRTVkdNYXhIZWlnaHQoKSB7XG4gICAgaWYgKCF0aGlzLm1vZGVsLmdldE9wdGlvbnMoKS5oZWlnaHQpIHtcbiAgICAgIGNvbnN0IHsgaGVpZ2h0OiB0IH0gPSBJbC5nZXRTVkdFbGVtZW50U2l6ZShcbiAgICAgICAgSSh0aGlzLm1haW5Db250YWluZXIpLFxuICAgICAgICB7XG4gICAgICAgICAgdXNlQkJveDogITBcbiAgICAgICAgfVxuICAgICAgKSwgbiA9IEkodGhpcy5tYWluQ29udGFpbmVyKS5hdHRyKFwiY2xhc3NcIiksIHIgPSBJKHRoaXMubWFpbkNvbnRhaW5lcikuc2VsZWN0QWxsKGAuJHtufSA+IHN2Z2ApO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgci5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgICAgICBpICs9IE51bWJlcihcbiAgICAgICAgICBJbC5nZXRTVkdFbGVtZW50U2l6ZShJKHMpLCB7XG4gICAgICAgICAgICB1c2VCQm94OiAhMFxuICAgICAgICAgIH0pLmhlaWdodFxuICAgICAgICApO1xuICAgICAgfSksIGkgPD0gdCA/IEkodGhpcy5tYWluQ29udGFpbmVyKS5hdHRyKFwiaGVpZ2h0XCIsIGkpIDogSSh0aGlzLm1haW5Db250YWluZXIpLmF0dHIoXCJoZWlnaHRcIiwgXCIxMDAlXCIpO1xuICAgIH1cbiAgfVxuICBnZXRNYWluQ29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLm1haW5Db250YWluZXI7XG4gIH1cbiAgYWRkSG9sZGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldEhvbGRlcigpO1xuICAgIHQgJiYgSSh0KS5vbihcIm1vdXNlb3ZlclwiLCAoKSA9PiB7XG4gICAgICB2YXIgbjtcbiAgICAgIChuID0gdGhpcy5zZXJ2aWNlcy5ldmVudHMpID09IG51bGwgfHwgbi5kaXNwYXRjaEV2ZW50KFQuQ2hhcnQuTU9VU0VPVkVSKTtcbiAgICB9KS5vbihcIm1vdXNlb3V0XCIsICgpID0+IHtcbiAgICAgIHZhciBuO1xuICAgICAgKG4gPSB0aGlzLnNlcnZpY2VzLmV2ZW50cykgPT0gbnVsbCB8fCBuLmRpc3BhdGNoRXZlbnQoVC5DaGFydC5NT1VTRU9VVCk7XG4gICAgfSk7XG4gIH1cbiAgYWRkUmVzaXplTGlzdGVuZXIoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0SG9sZGVyKCk7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBuID0gdC5jbGllbnRXaWR0aCwgciA9IHQuY2xpZW50SGVpZ2h0O1xuICAgIGNvbnN0IGkgPSBiYSgoKSA9PiB7XG4gICAgICB2YXIgcztcbiAgICAgIHQgJiYgKE1hdGguYWJzKG4gLSB0LmNsaWVudFdpZHRoKSA+IDEgfHwgTWF0aC5hYnMociAtIHQuY2xpZW50SGVpZ2h0KSA+IDEpICYmIChuID0gdC5jbGllbnRXaWR0aCwgciA9IHQuY2xpZW50SGVpZ2h0LCAocyA9IHRoaXMuc2VydmljZXMuZXZlbnRzKSA9PSBudWxsIHx8IHMuZGlzcGF0Y2hFdmVudChULkNoYXJ0LlJFU0laRSkpO1xuICAgIH0sIDEyLjUpO1xuICAgIG5ldyBSZXNpemVPYnNlcnZlcihpKS5vYnNlcnZlKHQpO1xuICB9XG59LCBObCA9IGNsYXNzIGRnIGV4dGVuZHMgRG4ge1xuICBzdGF0aWMgYXBwZW5kT3JVcGRhdGVMaW5lYXJHcmFkaWVudCh0KSB7XG4gICAgbGV0IG4gPSB0LnN2Zy5zZWxlY3QoYGRlZnMgbGluZWFyR3JhZGllbnQjJHt0LmlkfWApO1xuICAgIG4uZW1wdHkoKSAmJiAobiA9IHQuc3ZnLmFwcGVuZChcImRlZnNcIikuYXBwZW5kKFwibGluZWFyR3JhZGllbnRcIikuYXR0cihcImlkXCIsIHQuaWQpLmF0dHIoXCJ4MVwiLCB0LngxKS5hdHRyKFwieDJcIiwgdC54MikuYXR0cihcInkxXCIsIHQueTEpLmF0dHIoXCJ5MlwiLCB0LnkyKSksIG4uc2VsZWN0QWxsKFwic3RvcFwiKS5yZW1vdmUoKSwgbi5zZWxlY3RBbGwoXCJzdG9wXCIpLmRhdGEodC5zdG9wcykuZW50ZXIoKS5hcHBlbmQoXCJzdG9wXCIpLmF0dHIoXCJvZmZzZXRcIiwgKHIpID0+IHIub2Zmc2V0KS5zdHlsZShcInN0b3AtY29sb3JcIiwgKHIpID0+IHIuY29sb3IpLnN0eWxlKFwic3RvcC1vcGFjaXR5XCIsIChyKSA9PiByLm9wYWNpdHkpO1xuICB9XG4gIHN0YXRpYyBnZXRPZmZzZXRSYXRpbyh0KSB7XG4gICAgcmV0dXJuIChNYXRoLmFicyh0WzFdKSAqIDEwMCAvIE1hdGguYWJzKHRbMF0gLSB0WzFdKSkudG9GaXhlZCgyKSArIFwiJVwiO1xuICB9XG4gIHN0YXRpYyBnZXRTdG9wcyh0LCBuKSB7XG4gICAgY29uc3QgciA9IHRbMF0gPCAwICYmIHRbMV0gPiAwO1xuICAgIGxldCBpID0gW1xuICAgICAge1xuICAgICAgICBvZmZzZXQ6IFwiMCVcIixcbiAgICAgICAgY29sb3I6IG4sXG4gICAgICAgIG9wYWNpdHk6IFwiMC42XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG9mZnNldDogXCI4MCVcIixcbiAgICAgICAgY29sb3I6IG4sXG4gICAgICAgIG9wYWNpdHk6IFwiMFwiXG4gICAgICB9XG4gICAgXTtcbiAgICByZXR1cm4gciAmJiAoaSA9IFtcbiAgICAgIHtcbiAgICAgICAgb2Zmc2V0OiBcIjAlXCIsXG4gICAgICAgIGNvbG9yOiBuLFxuICAgICAgICBvcGFjaXR5OiBcIjAuNlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBvZmZzZXQ6IGRnLmdldE9mZnNldFJhdGlvKHQpLFxuICAgICAgICBjb2xvcjogbixcbiAgICAgICAgb3BhY2l0eTogXCIwXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG9mZnNldDogXCIxMDAlXCIsXG4gICAgICAgIGNvbG9yOiBuLFxuICAgICAgICBvcGFjaXR5OiBcIjAuNlwiXG4gICAgICB9XG4gICAgXSksIGk7XG4gIH1cbn07XG5mdW5jdGlvbiBwZChlKSB7XG4gIGNvbnN0IHQgPSBQMihwZyhlKSwgMzYwKTtcbiAgcmV0dXJuIE5uKHQsIFswLCAxMF0pIHx8IE5uKHQsIFszNTAsIDBdKSA/IHtcbiAgICB0ZXh0QW5jaG9yOiBkbi5TVEFSVCxcbiAgICBkb21pbmFudEJhc2VsaW5lOiBwbi5NSURETEVcbiAgfSA6IE5uKHQsIFsxMCwgODBdKSA/IHtcbiAgICB0ZXh0QW5jaG9yOiBkbi5TVEFSVCxcbiAgICBkb21pbmFudEJhc2VsaW5lOiBwbi5IQU5HSU5HXG4gIH0gOiBObih0LCBbODAsIDEwMF0pID8ge1xuICAgIHRleHRBbmNob3I6IGRuLk1JRERMRSxcbiAgICBkb21pbmFudEJhc2VsaW5lOiBwbi5IQU5HSU5HXG4gIH0gOiBObih0LCBbMTAwLCAxNzBdKSA/IHtcbiAgICB0ZXh0QW5jaG9yOiBkbi5FTkQsXG4gICAgZG9taW5hbnRCYXNlbGluZTogcG4uSEFOR0lOR1xuICB9IDogTm4odCwgWzE3MCwgMTkwXSkgPyB7XG4gICAgdGV4dEFuY2hvcjogZG4uRU5ELFxuICAgIGRvbWluYW50QmFzZWxpbmU6IHBuLk1JRERMRVxuICB9IDogTm4odCwgWzE5MCwgMjYwXSkgPyB7XG4gICAgdGV4dEFuY2hvcjogZG4uRU5ELFxuICAgIGRvbWluYW50QmFzZWxpbmU6IHBuLkJBU0VMSU5FXG4gIH0gOiBObih0LCBbMjYwLCAyODBdKSA/IHtcbiAgICB0ZXh0QW5jaG9yOiBkbi5NSURETEUsXG4gICAgZG9taW5hbnRCYXNlbGluZTogcG4uQkFTRUxJTkVcbiAgfSA6IHtcbiAgICB0ZXh0QW5jaG9yOiBkbi5TVEFSVCxcbiAgICBkb21pbmFudEJhc2VsaW5lOiBwbi5CQVNFTElORVxuICB9O1xufVxuZnVuY3Rpb24gUDIoZSwgdCkge1xuICByZXR1cm4gKGUgJSB0ICsgdCkgJSB0O1xufVxuZnVuY3Rpb24gTm4oZSwgW3QsIG5dKSB7XG4gIHJldHVybiBlID49IHQgJiYgZSA8PSBuO1xufVxuZnVuY3Rpb24gcGcoZSkge1xuICByZXR1cm4gZSAqICgxODAgLyBNYXRoLlBJKTtcbn1cbmZ1bmN0aW9uIFV0KGUsIHQsIG4gPSB7IHg6IDAsIHk6IDAgfSkge1xuICBjb25zdCByID0gdCAqIE1hdGguY29zKGUpICsgbi54LCBpID0gdCAqIE1hdGguc2luKGUpICsgbi55O1xuICByZXR1cm4geyB4OiBpc05hTihyKSA/IDAgOiByLCB5OiBpc05hTihpKSA/IDAgOiBpIH07XG59XG5mdW5jdGlvbiBVMihlLCB0KSB7XG4gIHJldHVybiB0ICogTWF0aC5zaW4oZSAtIE1hdGguUEkgLyAyKTtcbn1cbmZ1bmN0aW9uIEIyKGUsIHQsIG4sIHIpIHtcbiAgZm9yICh2YXIgaSA9IC0xLCBzID0gZSA9PSBudWxsID8gMCA6IGUubGVuZ3RoOyArK2kgPCBzOyApXG4gICAgbiA9IHQobiwgZVtpXSwgaSwgZSk7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gSDIoZSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBlID09IG51bGwgPyB2b2lkIDAgOiBlW3RdO1xuICB9O1xufVxudmFyIFYyID0ge1xuICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2suXG4gIMOAOiBcIkFcIixcbiAgw4E6IFwiQVwiLFxuICDDgjogXCJBXCIsXG4gIMODOiBcIkFcIixcbiAgw4Q6IFwiQVwiLFxuICDDhTogXCJBXCIsXG4gIMOgOiBcImFcIixcbiAgw6E6IFwiYVwiLFxuICDDojogXCJhXCIsXG4gIMOjOiBcImFcIixcbiAgw6Q6IFwiYVwiLFxuICDDpTogXCJhXCIsXG4gIMOHOiBcIkNcIixcbiAgw6c6IFwiY1wiLFxuICDDkDogXCJEXCIsXG4gIMOwOiBcImRcIixcbiAgw4g6IFwiRVwiLFxuICDDiTogXCJFXCIsXG4gIMOKOiBcIkVcIixcbiAgw4s6IFwiRVwiLFxuICDDqDogXCJlXCIsXG4gIMOpOiBcImVcIixcbiAgw6o6IFwiZVwiLFxuICDDqzogXCJlXCIsXG4gIMOMOiBcIklcIixcbiAgw406IFwiSVwiLFxuICDDjjogXCJJXCIsXG4gIMOPOiBcIklcIixcbiAgw6w6IFwiaVwiLFxuICDDrTogXCJpXCIsXG4gIMOuOiBcImlcIixcbiAgw686IFwiaVwiLFxuICDDkTogXCJOXCIsXG4gIMOxOiBcIm5cIixcbiAgw5I6IFwiT1wiLFxuICDDkzogXCJPXCIsXG4gIMOUOiBcIk9cIixcbiAgw5U6IFwiT1wiLFxuICDDljogXCJPXCIsXG4gIMOYOiBcIk9cIixcbiAgw7I6IFwib1wiLFxuICDDszogXCJvXCIsXG4gIMO0OiBcIm9cIixcbiAgw7U6IFwib1wiLFxuICDDtjogXCJvXCIsXG4gIMO4OiBcIm9cIixcbiAgw5k6IFwiVVwiLFxuICDDmjogXCJVXCIsXG4gIMObOiBcIlVcIixcbiAgw5w6IFwiVVwiLFxuICDDuTogXCJ1XCIsXG4gIMO6OiBcInVcIixcbiAgw7s6IFwidVwiLFxuICDDvDogXCJ1XCIsXG4gIMOdOiBcIllcIixcbiAgw706IFwieVwiLFxuICDDvzogXCJ5XCIsXG4gIMOGOiBcIkFlXCIsXG4gIMOmOiBcImFlXCIsXG4gIMOeOiBcIlRoXCIsXG4gIMO+OiBcInRoXCIsXG4gIMOfOiBcInNzXCIsXG4gIC8vIExhdGluIEV4dGVuZGVkLUEgYmxvY2suXG4gIMSAOiBcIkFcIixcbiAgxII6IFwiQVwiLFxuICDEhDogXCJBXCIsXG4gIMSBOiBcImFcIixcbiAgxIM6IFwiYVwiLFxuICDEhTogXCJhXCIsXG4gIMSGOiBcIkNcIixcbiAgxIg6IFwiQ1wiLFxuICDEijogXCJDXCIsXG4gIMSMOiBcIkNcIixcbiAgxIc6IFwiY1wiLFxuICDEiTogXCJjXCIsXG4gIMSLOiBcImNcIixcbiAgxI06IFwiY1wiLFxuICDEjjogXCJEXCIsXG4gIMSQOiBcIkRcIixcbiAgxI86IFwiZFwiLFxuICDEkTogXCJkXCIsXG4gIMSSOiBcIkVcIixcbiAgxJQ6IFwiRVwiLFxuICDEljogXCJFXCIsXG4gIMSYOiBcIkVcIixcbiAgxJo6IFwiRVwiLFxuICDEkzogXCJlXCIsXG4gIMSVOiBcImVcIixcbiAgxJc6IFwiZVwiLFxuICDEmTogXCJlXCIsXG4gIMSbOiBcImVcIixcbiAgxJw6IFwiR1wiLFxuICDEnjogXCJHXCIsXG4gIMSgOiBcIkdcIixcbiAgxKI6IFwiR1wiLFxuICDEnTogXCJnXCIsXG4gIMSfOiBcImdcIixcbiAgxKE6IFwiZ1wiLFxuICDEozogXCJnXCIsXG4gIMSkOiBcIkhcIixcbiAgxKY6IFwiSFwiLFxuICDEpTogXCJoXCIsXG4gIMSnOiBcImhcIixcbiAgxKg6IFwiSVwiLFxuICDEqjogXCJJXCIsXG4gIMSsOiBcIklcIixcbiAgxK46IFwiSVwiLFxuICDEsDogXCJJXCIsXG4gIMSpOiBcImlcIixcbiAgxKs6IFwiaVwiLFxuICDErTogXCJpXCIsXG4gIMSvOiBcImlcIixcbiAgxLE6IFwiaVwiLFxuICDEtDogXCJKXCIsXG4gIMS1OiBcImpcIixcbiAgxLY6IFwiS1wiLFxuICDEtzogXCJrXCIsXG4gIMS4OiBcImtcIixcbiAgxLk6IFwiTFwiLFxuICDEuzogXCJMXCIsXG4gIMS9OiBcIkxcIixcbiAgxL86IFwiTFwiLFxuICDFgTogXCJMXCIsXG4gIMS6OiBcImxcIixcbiAgxLw6IFwibFwiLFxuICDEvjogXCJsXCIsXG4gIMWAOiBcImxcIixcbiAgxYI6IFwibFwiLFxuICDFgzogXCJOXCIsXG4gIMWFOiBcIk5cIixcbiAgxYc6IFwiTlwiLFxuICDFijogXCJOXCIsXG4gIMWEOiBcIm5cIixcbiAgxYY6IFwiblwiLFxuICDFiDogXCJuXCIsXG4gIMWLOiBcIm5cIixcbiAgxYw6IFwiT1wiLFxuICDFjjogXCJPXCIsXG4gIMWQOiBcIk9cIixcbiAgxY06IFwib1wiLFxuICDFjzogXCJvXCIsXG4gIMWROiBcIm9cIixcbiAgxZQ6IFwiUlwiLFxuICDFljogXCJSXCIsXG4gIMWYOiBcIlJcIixcbiAgxZU6IFwiclwiLFxuICDFlzogXCJyXCIsXG4gIMWZOiBcInJcIixcbiAgxZo6IFwiU1wiLFxuICDFnDogXCJTXCIsXG4gIMWeOiBcIlNcIixcbiAgxaA6IFwiU1wiLFxuICDFmzogXCJzXCIsXG4gIMWdOiBcInNcIixcbiAgxZ86IFwic1wiLFxuICDFoTogXCJzXCIsXG4gIMWiOiBcIlRcIixcbiAgxaQ6IFwiVFwiLFxuICDFpjogXCJUXCIsXG4gIMWjOiBcInRcIixcbiAgxaU6IFwidFwiLFxuICDFpzogXCJ0XCIsXG4gIMWoOiBcIlVcIixcbiAgxao6IFwiVVwiLFxuICDFrDogXCJVXCIsXG4gIMWuOiBcIlVcIixcbiAgxbA6IFwiVVwiLFxuICDFsjogXCJVXCIsXG4gIMWpOiBcInVcIixcbiAgxas6IFwidVwiLFxuICDFrTogXCJ1XCIsXG4gIMWvOiBcInVcIixcbiAgxbE6IFwidVwiLFxuICDFszogXCJ1XCIsXG4gIMW0OiBcIldcIixcbiAgxbU6IFwid1wiLFxuICDFtjogXCJZXCIsXG4gIMW3OiBcInlcIixcbiAgxbg6IFwiWVwiLFxuICDFuTogXCJaXCIsXG4gIMW7OiBcIlpcIixcbiAgxb06IFwiWlwiLFxuICDFujogXCJ6XCIsXG4gIMW8OiBcInpcIixcbiAgxb46IFwielwiLFxuICDEsjogXCJJSlwiLFxuICDEszogXCJpalwiLFxuICDFkjogXCJPZVwiLFxuICDFkzogXCJvZVwiLFxuICDFiTogXCInblwiLFxuICDFvzogXCJzXCJcbn0sIEcyID0gSDIoVjIpLCB6MiA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxceGZmXFx1MDEwMC1cXHUwMTdmXS9nLCBGMiA9IFwiXFxcXHUwMzAwLVxcXFx1MDM2ZlwiLCBqMiA9IFwiXFxcXHVmZTIwLVxcXFx1ZmUyZlwiLCBXMiA9IFwiXFxcXHUyMGQwLVxcXFx1MjBmZlwiLCBxMiA9IEYyICsgajIgKyBXMiwgWTIgPSBcIltcIiArIHEyICsgXCJdXCIsIFgyID0gUmVnRXhwKFkyLCBcImdcIik7XG5mdW5jdGlvbiBaMihlKSB7XG4gIHJldHVybiBlID0gdXMoZSksIGUgJiYgZS5yZXBsYWNlKHoyLCBHMikucmVwbGFjZShYMiwgXCJcIik7XG59XG52YXIgSzIgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG5mdW5jdGlvbiBRMihlKSB7XG4gIHJldHVybiBlLm1hdGNoKEsyKSB8fCBbXTtcbn1cbnZhciBKMiA9IC9bYS16XVtBLVpdfFtBLVpdezJ9W2Etel18WzAtOV1bYS16QS1aXXxbYS16QS1aXVswLTldfFteYS16QS1aMC05IF0vO1xuZnVuY3Rpb24gdEMoZSkge1xuICByZXR1cm4gSjIudGVzdChlKTtcbn1cbnZhciBmZyA9IFwiXFxcXHVkODAwLVxcXFx1ZGZmZlwiLCBlQyA9IFwiXFxcXHUwMzAwLVxcXFx1MDM2ZlwiLCBuQyA9IFwiXFxcXHVmZTIwLVxcXFx1ZmUyZlwiLCByQyA9IFwiXFxcXHUyMGQwLVxcXFx1MjBmZlwiLCBpQyA9IGVDICsgbkMgKyByQywgbWcgPSBcIlxcXFx1MjcwMC1cXFxcdTI3YmZcIiwgZ2cgPSBcImEtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZlwiLCBzQyA9IFwiXFxcXHhhY1xcXFx4YjFcXFxceGQ3XFxcXHhmN1wiLCBhQyA9IFwiXFxcXHgwMC1cXFxceDJmXFxcXHgzYS1cXFxceDQwXFxcXHg1Yi1cXFxceDYwXFxcXHg3Yi1cXFxceGJmXCIsIG9DID0gXCJcXFxcdTIwMDAtXFxcXHUyMDZmXCIsIGxDID0gXCIgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMFwiLCB2ZyA9IFwiQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlXCIsIGNDID0gXCJcXFxcdWZlMGVcXFxcdWZlMGZcIiwgeWcgPSBzQyArIGFDICsgb0MgKyBsQywgeGcgPSBcIlsn4oCZXVwiLCBmZCA9IFwiW1wiICsgeWcgKyBcIl1cIiwgdUMgPSBcIltcIiArIGlDICsgXCJdXCIsIGJnID0gXCJcXFxcZCtcIiwgaEMgPSBcIltcIiArIG1nICsgXCJdXCIsIF9nID0gXCJbXCIgKyBnZyArIFwiXVwiLCBFZyA9IFwiW15cIiArIGZnICsgeWcgKyBiZyArIG1nICsgZ2cgKyB2ZyArIFwiXVwiLCBkQyA9IFwiXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdXCIsIHBDID0gXCIoPzpcIiArIHVDICsgXCJ8XCIgKyBkQyArIFwiKVwiLCBmQyA9IFwiW15cIiArIGZnICsgXCJdXCIsIE9nID0gXCIoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9XCIsIFNnID0gXCJbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl1cIiwgQXIgPSBcIltcIiArIHZnICsgXCJdXCIsIG1DID0gXCJcXFxcdTIwMGRcIiwgbWQgPSBcIig/OlwiICsgX2cgKyBcInxcIiArIEVnICsgXCIpXCIsIGdDID0gXCIoPzpcIiArIEFyICsgXCJ8XCIgKyBFZyArIFwiKVwiLCBnZCA9IFwiKD86XCIgKyB4ZyArIFwiKD86ZHxsbHxtfHJlfHN8dHx2ZSkpP1wiLCB2ZCA9IFwiKD86XCIgKyB4ZyArIFwiKD86RHxMTHxNfFJFfFN8VHxWRSkpP1wiLCBUZyA9IHBDICsgXCI/XCIsIHdnID0gXCJbXCIgKyBjQyArIFwiXT9cIiwgdkMgPSBcIig/OlwiICsgbUMgKyBcIig/OlwiICsgW2ZDLCBPZywgU2ddLmpvaW4oXCJ8XCIpICsgXCIpXCIgKyB3ZyArIFRnICsgXCIpKlwiLCB5QyA9IFwiXFxcXGQqKD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxcXGR0aCkoPz1cXFxcYnxbQS1aX10pXCIsIHhDID0gXCJcXFxcZCooPzoxU1R8Mk5EfDNSRHwoPyFbMTIzXSlcXFxcZFRIKSg/PVxcXFxifFthLXpfXSlcIiwgYkMgPSB3ZyArIFRnICsgdkMsIF9DID0gXCIoPzpcIiArIFtoQywgT2csIFNnXS5qb2luKFwifFwiKSArIFwiKVwiICsgYkMsIEVDID0gUmVnRXhwKFtcbiAgQXIgKyBcIj9cIiArIF9nICsgXCIrXCIgKyBnZCArIFwiKD89XCIgKyBbZmQsIEFyLCBcIiRcIl0uam9pbihcInxcIikgKyBcIilcIixcbiAgZ0MgKyBcIitcIiArIHZkICsgXCIoPz1cIiArIFtmZCwgQXIgKyBtZCwgXCIkXCJdLmpvaW4oXCJ8XCIpICsgXCIpXCIsXG4gIEFyICsgXCI/XCIgKyBtZCArIFwiK1wiICsgZ2QsXG4gIEFyICsgXCIrXCIgKyB2ZCxcbiAgeEMsXG4gIHlDLFxuICBiZyxcbiAgX0Ncbl0uam9pbihcInxcIiksIFwiZ1wiKTtcbmZ1bmN0aW9uIE9DKGUpIHtcbiAgcmV0dXJuIGUubWF0Y2goRUMpIHx8IFtdO1xufVxuZnVuY3Rpb24gU0MoZSwgdCwgbikge1xuICByZXR1cm4gZSA9IHVzKGUpLCB0ID0gdCwgdCA9PT0gdm9pZCAwID8gdEMoZSkgPyBPQyhlKSA6IFEyKGUpIDogZS5tYXRjaCh0KSB8fCBbXTtcbn1cbnZhciBUQyA9IFwiWyfigJldXCIsIHdDID0gUmVnRXhwKFRDLCBcImdcIik7XG5mdW5jdGlvbiAkZyhlKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIEIyKFNDKFoyKHQpLnJlcGxhY2Uod0MsIFwiXCIpKSwgZSwgXCJcIik7XG4gIH07XG59XG5mdW5jdGlvbiAkQyhlLCB0LCBuKSB7XG4gIHJldHVybiBlID09PSBlICYmIChuICE9PSB2b2lkIDAgJiYgKGUgPSBlIDw9IG4gPyBlIDogbiksIHQgIT09IHZvaWQgMCAmJiAoZSA9IGUgPj0gdCA/IGUgOiB0KSksIGU7XG59XG5mdW5jdGlvbiBNZyhlLCB0LCBuKSB7XG4gIHJldHVybiBuID09PSB2b2lkIDAgJiYgKG4gPSB0LCB0ID0gdm9pZCAwKSwgbiAhPT0gdm9pZCAwICYmIChuID0genIobiksIG4gPSBuID09PSBuID8gbiA6IDApLCB0ICE9PSB2b2lkIDAgJiYgKHQgPSB6cih0KSwgdCA9IHQgPT09IHQgPyB0IDogMCksICRDKHpyKGUpLCB0LCBuKTtcbn1cbnZhciBNQyA9IFwiRXhwZWN0ZWQgYSBmdW5jdGlvblwiO1xuZnVuY3Rpb24gQ0MoZSwgdCwgbikge1xuICBpZiAodHlwZW9mIGUgIT0gXCJmdW5jdGlvblwiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoTUMpO1xuICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBlLmFwcGx5KHZvaWQgMCwgbik7XG4gIH0sIHQpO1xufVxudmFyIEFDID0geWMoZnVuY3Rpb24oZSwgdCwgbikge1xuICByZXR1cm4gQ0MoZSwgenIodCkgfHwgMCwgbik7XG59KTtcbmZ1bmN0aW9uIExDKGUsIHQpIHtcbiAgdmFyIG4gPSAtMSwgciA9IGZyKGUpID8gQXJyYXkoZS5sZW5ndGgpIDogW107XG4gIHJldHVybiBqYyhlLCBmdW5jdGlvbihpLCBzLCBhKSB7XG4gICAgclsrK25dID0gdChpLCBzLCBhKTtcbiAgfSksIHI7XG59XG5mdW5jdGlvbiBrQyhlLCB0KSB7XG4gIHZhciBuID0gS3QoZSkgPyBmYyA6IExDO1xuICByZXR1cm4gbihlLCBKYSh0KSk7XG59XG52YXIgREMgPSAxIC8gMDtcbmZ1bmN0aW9uIFJDKGUsIHQpIHtcbiAgcmV0dXJuIEthKGtDKGUsIHQpLCBEQyk7XG59XG5mdW5jdGlvbiBDZyhlLCB0KSB7XG4gIHJldHVybiBRYShlLCB0KTtcbn1cbnZhciBUciA9ICRnKGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgcmV0dXJuIGUgKyAobiA/IFwiLVwiIDogXCJcIikgKyB0LnRvTG93ZXJDYXNlKCk7XG59KTtcbmZ1bmN0aW9uIElDKGUsIHQpIHtcbiAgdmFyIG47XG4gIHJldHVybiBqYyhlLCBmdW5jdGlvbihyLCBpLCBzKSB7XG4gICAgcmV0dXJuIG4gPSB0KHIsIGksIHMpLCAhbjtcbiAgfSksICEhbjtcbn1cbmZ1bmN0aW9uIE5DKGUsIHQsIG4pIHtcbiAgdmFyIHIgPSBLdChlKSA/IEJmIDogSUM7XG4gIHJldHVybiByKGUsIEphKHQpKTtcbn1cbmNsYXNzIG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcGFydGlhbHMgPSBuZXcgRmxvYXQ2NEFycmF5KDMyKSwgdGhpcy5fbiA9IDA7XG4gIH1cbiAgYWRkKHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5fcGFydGlhbHM7XG4gICAgbGV0IHIgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbiAmJiBpIDwgMzI7IGkrKykge1xuICAgICAgY29uc3QgcyA9IG5baV0sIGEgPSB0ICsgcywgbyA9IE1hdGguYWJzKHQpIDwgTWF0aC5hYnMocykgPyB0IC0gKGEgLSBzKSA6IHMgLSAoYSAtIHQpO1xuICAgICAgbyAmJiAobltyKytdID0gbyksIHQgPSBhO1xuICAgIH1cbiAgICByZXR1cm4gbltyXSA9IHQsIHRoaXMuX24gPSByICsgMSwgdGhpcztcbiAgfVxuICB2YWx1ZU9mKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9wYXJ0aWFscztcbiAgICBsZXQgbiA9IHRoaXMuX24sIHIsIGksIHMsIGEgPSAwO1xuICAgIGlmIChuID4gMCkge1xuICAgICAgZm9yIChhID0gdFstLW5dOyBuID4gMCAmJiAociA9IGEsIGkgPSB0Wy0tbl0sIGEgPSByICsgaSwgcyA9IGkgLSAoYSAtIHIpLCAhcyk7IClcbiAgICAgICAgO1xuICAgICAgbiA+IDAgJiYgKHMgPCAwICYmIHRbbiAtIDFdIDwgMCB8fCBzID4gMCAmJiB0W24gLSAxXSA+IDApICYmIChpID0gcyAqIDIsIHIgPSBhICsgaSwgaSA9PSByIC0gYSAmJiAoYSA9IHIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cbn1cbmZ1bmN0aW9uKiBQQyhlKSB7XG4gIGZvciAoY29uc3QgdCBvZiBlKVxuICAgIHlpZWxkKiB0O1xufVxuZnVuY3Rpb24gQWcoZSkge1xuICByZXR1cm4gQXJyYXkuZnJvbShQQyhlKSk7XG59XG5mdW5jdGlvbiBVQyhlKSB7XG4gIHJldHVybiBlO1xufVxudmFyIFFzID0gMSwgSnMgPSAyLCBQbCA9IDMsIENpID0gNCwgeWQgPSAxZS02O1xuZnVuY3Rpb24gQkMoZSkge1xuICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyBlICsgXCIsMClcIjtcbn1cbmZ1bmN0aW9uIEhDKGUpIHtcbiAgcmV0dXJuIFwidHJhbnNsYXRlKDAsXCIgKyBlICsgXCIpXCI7XG59XG5mdW5jdGlvbiBWQyhlKSB7XG4gIHJldHVybiAodCkgPT4gK2UodCk7XG59XG5mdW5jdGlvbiBHQyhlLCB0KSB7XG4gIHJldHVybiB0ID0gTWF0aC5tYXgoMCwgZS5iYW5kd2lkdGgoKSAtIHQgKiAyKSAvIDIsIGUucm91bmQoKSAmJiAodCA9IE1hdGgucm91bmQodCkpLCAobikgPT4gK2UobikgKyB0O1xufVxuZnVuY3Rpb24gekMoKSB7XG4gIHJldHVybiAhdGhpcy5fX2F4aXM7XG59XG5mdW5jdGlvbiBjbyhlLCB0KSB7XG4gIHZhciBuID0gW10sIHIgPSBudWxsLCBpID0gbnVsbCwgcyA9IDYsIGEgPSA2LCBvID0gMywgbCA9IHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDEgPyAwIDogMC41LCBjID0gZSA9PT0gUXMgfHwgZSA9PT0gQ2kgPyAtMSA6IDEsIHUgPSBlID09PSBDaSB8fCBlID09PSBKcyA/IFwieFwiIDogXCJ5XCIsIGQgPSBlID09PSBRcyB8fCBlID09PSBQbCA/IEJDIDogSEM7XG4gIGZ1bmN0aW9uIGgocCkge1xuICAgIHZhciBmID0gciA/PyAodC50aWNrcyA/IHQudGlja3MuYXBwbHkodCwgbikgOiB0LmRvbWFpbigpKSwgZyA9IGkgPz8gKHQudGlja0Zvcm1hdCA/IHQudGlja0Zvcm1hdC5hcHBseSh0LCBuKSA6IFVDKSwgbSA9IE1hdGgubWF4KHMsIDApICsgbywgdiA9IHQucmFuZ2UoKSwgeCA9ICt2WzBdICsgbCwgXyA9ICt2W3YubGVuZ3RoIC0gMV0gKyBsLCBFID0gKHQuYmFuZHdpZHRoID8gR0MgOiBWQykodC5jb3B5KCksIGwpLCBiID0gcC5zZWxlY3Rpb24gPyBwLnNlbGVjdGlvbigpIDogcCwgUyA9IGIuc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5kYXRhKFtudWxsXSksIE0gPSBiLnNlbGVjdEFsbChcIi50aWNrXCIpLmRhdGEoZiwgdCkub3JkZXIoKSwgRCA9IE0uZXhpdCgpLCBBID0gTS5lbnRlcigpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIFwidGlja1wiKSwgUiA9IE0uc2VsZWN0KFwibGluZVwiKSwgJCA9IE0uc2VsZWN0KFwidGV4dFwiKTtcbiAgICBTID0gUy5tZXJnZShTLmVudGVyKCkuaW5zZXJ0KFwicGF0aFwiLCBcIi50aWNrXCIpLmF0dHIoXCJjbGFzc1wiLCBcImRvbWFpblwiKS5hdHRyKFwic3Ryb2tlXCIsIFwiY3VycmVudENvbG9yXCIpKSwgTSA9IE0ubWVyZ2UoQSksIFIgPSBSLm1lcmdlKEEuYXBwZW5kKFwibGluZVwiKS5hdHRyKFwic3Ryb2tlXCIsIFwiY3VycmVudENvbG9yXCIpLmF0dHIodSArIFwiMlwiLCBjICogcykpLCAkID0gJC5tZXJnZShBLmFwcGVuZChcInRleHRcIikuYXR0cihcImZpbGxcIiwgXCJjdXJyZW50Q29sb3JcIikuYXR0cih1LCBjICogbSkuYXR0cihcImR5XCIsIGUgPT09IFFzID8gXCIwZW1cIiA6IGUgPT09IFBsID8gXCIwLjcxZW1cIiA6IFwiMC4zMmVtXCIpKSwgcCAhPT0gYiAmJiAoUyA9IFMudHJhbnNpdGlvbihwKSwgTSA9IE0udHJhbnNpdGlvbihwKSwgUiA9IFIudHJhbnNpdGlvbihwKSwgJCA9ICQudHJhbnNpdGlvbihwKSwgRCA9IEQudHJhbnNpdGlvbihwKS5hdHRyKFwib3BhY2l0eVwiLCB5ZCkuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihIKSB7XG4gICAgICByZXR1cm4gaXNGaW5pdGUoSCA9IEUoSCkpID8gZChIICsgbCkgOiB0aGlzLmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICB9KSwgQS5hdHRyKFwib3BhY2l0eVwiLCB5ZCkuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihIKSB7XG4gICAgICB2YXIgUCA9IHRoaXMucGFyZW50Tm9kZS5fX2F4aXM7XG4gICAgICByZXR1cm4gZCgoUCAmJiBpc0Zpbml0ZShQID0gUChIKSkgPyBQIDogRShIKSkgKyBsKTtcbiAgICB9KSksIEQucmVtb3ZlKCksIFMuYXR0cihcImRcIiwgZSA9PT0gQ2kgfHwgZSA9PT0gSnMgPyBhID8gXCJNXCIgKyBjICogYSArIFwiLFwiICsgeCArIFwiSFwiICsgbCArIFwiVlwiICsgXyArIFwiSFwiICsgYyAqIGEgOiBcIk1cIiArIGwgKyBcIixcIiArIHggKyBcIlZcIiArIF8gOiBhID8gXCJNXCIgKyB4ICsgXCIsXCIgKyBjICogYSArIFwiVlwiICsgbCArIFwiSFwiICsgXyArIFwiVlwiICsgYyAqIGEgOiBcIk1cIiArIHggKyBcIixcIiArIGwgKyBcIkhcIiArIF8pLCBNLmF0dHIoXCJvcGFjaXR5XCIsIDEpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oSCkge1xuICAgICAgcmV0dXJuIGQoRShIKSArIGwpO1xuICAgIH0pLCBSLmF0dHIodSArIFwiMlwiLCBjICogcyksICQuYXR0cih1LCBjICogbSkudGV4dChnKSwgYi5maWx0ZXIoekMpLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKS5hdHRyKFwiZm9udC1zaXplXCIsIDEwKS5hdHRyKFwiZm9udC1mYW1pbHlcIiwgXCJzYW5zLXNlcmlmXCIpLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBlID09PSBKcyA/IFwic3RhcnRcIiA6IGUgPT09IENpID8gXCJlbmRcIiA6IFwibWlkZGxlXCIpLCBiLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9fYXhpcyA9IEU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGguc2NhbGUgPSBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodCA9IHAsIGgpIDogdDtcbiAgfSwgaC50aWNrcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuID0gQXJyYXkuZnJvbShhcmd1bWVudHMpLCBoO1xuICB9LCBoLnRpY2tBcmd1bWVudHMgPSBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9IHAgPT0gbnVsbCA/IFtdIDogQXJyYXkuZnJvbShwKSwgaCkgOiBuLnNsaWNlKCk7XG4gIH0sIGgudGlja1ZhbHVlcyA9IGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyID0gcCA9PSBudWxsID8gbnVsbCA6IEFycmF5LmZyb20ocCksIGgpIDogciAmJiByLnNsaWNlKCk7XG4gIH0sIGgudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpID0gcCwgaCkgOiBpO1xuICB9LCBoLnRpY2tTaXplID0gZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHMgPSBhID0gK3AsIGgpIDogcztcbiAgfSwgaC50aWNrU2l6ZUlubmVyID0gZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHMgPSArcCwgaCkgOiBzO1xuICB9LCBoLnRpY2tTaXplT3V0ZXIgPSBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYSA9ICtwLCBoKSA6IGE7XG4gIH0sIGgudGlja1BhZGRpbmcgPSBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobyA9ICtwLCBoKSA6IG87XG4gIH0sIGgub2Zmc2V0ID0gZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGwgPSArcCwgaCkgOiBsO1xuICB9LCBoO1xufVxuZnVuY3Rpb24gRkMoZSkge1xuICByZXR1cm4gY28oUXMsIGUpO1xufVxuZnVuY3Rpb24gakMoZSkge1xuICByZXR1cm4gY28oSnMsIGUpO1xufVxuZnVuY3Rpb24gSmMoZSkge1xuICByZXR1cm4gY28oUGwsIGUpO1xufVxuZnVuY3Rpb24gTGcoZSkge1xuICByZXR1cm4gY28oQ2ksIGUpO1xufVxuY29uc3QgVWwgPSB7IGNhcHR1cmU6ICEwLCBwYXNzaXZlOiAhMSB9O1xuZnVuY3Rpb24gQmwoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCksIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG5mdW5jdGlvbiBXQyhlKSB7XG4gIHZhciB0ID0gZS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG4gPSBJKGUpLm9uKFwiZHJhZ3N0YXJ0LmRyYWdcIiwgQmwsIFVsKTtcbiAgXCJvbnNlbGVjdHN0YXJ0XCIgaW4gdCA/IG4ub24oXCJzZWxlY3RzdGFydC5kcmFnXCIsIEJsLCBVbCkgOiAodC5fX25vc2VsZWN0ID0gdC5zdHlsZS5Nb3pVc2VyU2VsZWN0LCB0LnN0eWxlLk1velVzZXJTZWxlY3QgPSBcIm5vbmVcIik7XG59XG5mdW5jdGlvbiBxQyhlLCB0KSB7XG4gIHZhciBuID0gZS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHIgPSBJKGUpLm9uKFwiZHJhZ3N0YXJ0LmRyYWdcIiwgbnVsbCk7XG4gIHQgJiYgKHIub24oXCJjbGljay5kcmFnXCIsIEJsLCBVbCksIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgci5vbihcImNsaWNrLmRyYWdcIiwgbnVsbCk7XG4gIH0sIDApKSwgXCJvbnNlbGVjdHN0YXJ0XCIgaW4gbiA/IHIub24oXCJzZWxlY3RzdGFydC5kcmFnXCIsIG51bGwpIDogKG4uc3R5bGUuTW96VXNlclNlbGVjdCA9IG4uX19ub3NlbGVjdCwgZGVsZXRlIG4uX19ub3NlbGVjdCk7XG59XG5mdW5jdGlvbiBZQyhlLCB0KSB7XG4gIGZvciAodmFyIG4gPSBuZXcgQXJyYXkodCksIHIgPSAwOyByIDwgdDsgKytyKSBuW3JdID0gZShyIC8gKHQgLSAxKSk7XG4gIHJldHVybiBuO1xufVxuY29uc3QgWEMgPSAoZSkgPT4gK2UsIEZvID0gKGUpID0+ICgpID0+IGU7XG5mdW5jdGlvbiBaQyhlLCB7XG4gIHNvdXJjZUV2ZW50OiB0LFxuICB0YXJnZXQ6IG4sXG4gIHNlbGVjdGlvbjogcixcbiAgbW9kZTogaSxcbiAgZGlzcGF0Y2g6IHNcbn0pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIHR5cGU6IHsgdmFsdWU6IGUsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0sXG4gICAgc291cmNlRXZlbnQ6IHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0sXG4gICAgdGFyZ2V0OiB7IHZhbHVlOiBuLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9LFxuICAgIHNlbGVjdGlvbjogeyB2YWx1ZTogciwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAgfSxcbiAgICBtb2RlOiB7IHZhbHVlOiBpLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9LFxuICAgIF86IHsgdmFsdWU6IHMgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIEtDKGUpIHtcbiAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cbmZ1bmN0aW9uIGpvKGUpIHtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpLCBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxudmFyIHhkID0geyBuYW1lOiBcImRyYWdcIiB9LCBXbyA9IHsgbmFtZTogXCJzcGFjZVwiIH0sIHdyID0geyBuYW1lOiBcImhhbmRsZVwiIH0sICRyID0geyBuYW1lOiBcImNlbnRlclwiIH07XG5jb25zdCB7IGFiczogYmQsIG1heDogdGUsIG1pbjogZWUgfSA9IE1hdGg7XG5mdW5jdGlvbiBfZChlKSB7XG4gIHJldHVybiBbK2VbMF0sICtlWzFdXTtcbn1cbmZ1bmN0aW9uIEVkKGUpIHtcbiAgcmV0dXJuIFtfZChlWzBdKSwgX2QoZVsxXSldO1xufVxudmFyIHRhID0ge1xuICBuYW1lOiBcInhcIixcbiAgaGFuZGxlczogW1wid1wiLCBcImVcIl0ubWFwKEhsKSxcbiAgaW5wdXQ6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICByZXR1cm4gZSA9PSBudWxsID8gbnVsbCA6IFtbK2VbMF0sIHRbMF1bMV1dLCBbK2VbMV0sIHRbMV1bMV1dXTtcbiAgfSxcbiAgb3V0cHV0OiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIGUgJiYgW2VbMF1bMF0sIGVbMV1bMF1dO1xuICB9XG59LCBxbyA9IHt9LCBobiA9IHtcbiAgb3ZlcmxheTogXCJjcm9zc2hhaXJcIixcbiAgc2VsZWN0aW9uOiBcIm1vdmVcIixcbiAgbjogXCJucy1yZXNpemVcIixcbiAgZTogXCJldy1yZXNpemVcIixcbiAgczogXCJucy1yZXNpemVcIixcbiAgdzogXCJldy1yZXNpemVcIixcbiAgbnc6IFwibndzZS1yZXNpemVcIixcbiAgbmU6IFwibmVzdy1yZXNpemVcIixcbiAgc2U6IFwibndzZS1yZXNpemVcIixcbiAgc3c6IFwibmVzdy1yZXNpemVcIlxufSwgT2QgPSB7XG4gIGU6IFwid1wiLFxuICB3OiBcImVcIixcbiAgbnc6IFwibmVcIixcbiAgbmU6IFwibndcIixcbiAgc2U6IFwic3dcIixcbiAgc3c6IFwic2VcIlxufSwgU2QgPSB7XG4gIG46IFwic1wiLFxuICBzOiBcIm5cIixcbiAgbnc6IFwic3dcIixcbiAgbmU6IFwic2VcIixcbiAgc2U6IFwibmVcIixcbiAgc3c6IFwibndcIlxufSwgUUMgPSB7XG4gIG92ZXJsYXk6IDEsXG4gIHNlbGVjdGlvbjogMSxcbiAgbjogbnVsbCxcbiAgZTogMSxcbiAgczogbnVsbCxcbiAgdzogLTEsXG4gIG53OiAtMSxcbiAgbmU6IDEsXG4gIHNlOiAxLFxuICBzdzogLTFcbn0sIEpDID0ge1xuICBvdmVybGF5OiAxLFxuICBzZWxlY3Rpb246IDEsXG4gIG46IC0xLFxuICBlOiBudWxsLFxuICBzOiAxLFxuICB3OiBudWxsLFxuICBudzogLTEsXG4gIG5lOiAtMSxcbiAgc2U6IDEsXG4gIHN3OiAxXG59O1xuZnVuY3Rpb24gSGwoZSkge1xuICByZXR1cm4geyB0eXBlOiBlIH07XG59XG5mdW5jdGlvbiB0QShlKSB7XG4gIHJldHVybiAhZS5jdHJsS2V5ICYmICFlLmJ1dHRvbjtcbn1cbmZ1bmN0aW9uIGVBKCkge1xuICB2YXIgZSA9IHRoaXMub3duZXJTVkdFbGVtZW50IHx8IHRoaXM7XG4gIHJldHVybiBlLmhhc0F0dHJpYnV0ZShcInZpZXdCb3hcIikgPyAoZSA9IGUudmlld0JveC5iYXNlVmFsLCBbW2UueCwgZS55XSwgW2UueCArIGUud2lkdGgsIGUueSArIGUuaGVpZ2h0XV0pIDogW1swLCAwXSwgW2Uud2lkdGguYmFzZVZhbC52YWx1ZSwgZS5oZWlnaHQuYmFzZVZhbC52YWx1ZV1dO1xufVxuZnVuY3Rpb24gbkEoKSB7XG4gIHJldHVybiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgfHwgXCJvbnRvdWNoc3RhcnRcIiBpbiB0aGlzO1xufVxuZnVuY3Rpb24gWW8oZSkge1xuICBmb3IgKDsgIWUuX19icnVzaDsgKSBpZiAoIShlID0gZS5wYXJlbnROb2RlKSkgcmV0dXJuO1xuICByZXR1cm4gZS5fX2JydXNoO1xufVxuZnVuY3Rpb24gckEoZSkge1xuICByZXR1cm4gZVswXVswXSA9PT0gZVsxXVswXSB8fCBlWzBdWzFdID09PSBlWzFdWzFdO1xufVxuZnVuY3Rpb24ga2coKSB7XG4gIHJldHVybiBpQSh0YSk7XG59XG5mdW5jdGlvbiBpQShlKSB7XG4gIHZhciB0ID0gZUEsIG4gPSB0QSwgciA9IG5BLCBpID0gITAsIHMgPSBMYyhcInN0YXJ0XCIsIFwiYnJ1c2hcIiwgXCJlbmRcIiksIGEgPSA2LCBvO1xuICBmdW5jdGlvbiBsKG0pIHtcbiAgICB2YXIgdiA9IG0ucHJvcGVydHkoXCJfX2JydXNoXCIsIGcpLnNlbGVjdEFsbChcIi5vdmVybGF5XCIpLmRhdGEoW0hsKFwib3ZlcmxheVwiKV0pO1xuICAgIHYuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJjbGFzc1wiLCBcIm92ZXJsYXlcIikuYXR0cihcInBvaW50ZXItZXZlbnRzXCIsIFwiYWxsXCIpLmF0dHIoXCJjdXJzb3JcIiwgaG4ub3ZlcmxheSkubWVyZ2UodikuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfID0gWW8odGhpcykuZXh0ZW50O1xuICAgICAgSSh0aGlzKS5hdHRyKFwieFwiLCBfWzBdWzBdKS5hdHRyKFwieVwiLCBfWzBdWzFdKS5hdHRyKFwid2lkdGhcIiwgX1sxXVswXSAtIF9bMF1bMF0pLmF0dHIoXCJoZWlnaHRcIiwgX1sxXVsxXSAtIF9bMF1bMV0pO1xuICAgIH0pLCBtLnNlbGVjdEFsbChcIi5zZWxlY3Rpb25cIikuZGF0YShbSGwoXCJzZWxlY3Rpb25cIildKS5lbnRlcigpLmFwcGVuZChcInJlY3RcIikuYXR0cihcImNsYXNzXCIsIFwic2VsZWN0aW9uXCIpLmF0dHIoXCJjdXJzb3JcIiwgaG4uc2VsZWN0aW9uKS5hdHRyKFwiZmlsbFwiLCBcIiM3NzdcIikuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwLjMpLmF0dHIoXCJzdHJva2VcIiwgXCIjZmZmXCIpLmF0dHIoXCJzaGFwZS1yZW5kZXJpbmdcIiwgXCJjcmlzcEVkZ2VzXCIpO1xuICAgIHZhciB4ID0gbS5zZWxlY3RBbGwoXCIuaGFuZGxlXCIpLmRhdGEoZS5oYW5kbGVzLCBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gXy50eXBlO1xuICAgIH0pO1xuICAgIHguZXhpdCgpLnJlbW92ZSgpLCB4LmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKS5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIFwiaGFuZGxlIGhhbmRsZS0tXCIgKyBfLnR5cGU7XG4gICAgfSkuYXR0cihcImN1cnNvclwiLCBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gaG5bXy50eXBlXTtcbiAgICB9KSwgbS5lYWNoKGMpLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKS5hdHRyKFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIikub24oXCJtb3VzZWRvd24uYnJ1c2hcIiwgaCkuZmlsdGVyKHIpLm9uKFwidG91Y2hzdGFydC5icnVzaFwiLCBoKS5vbihcInRvdWNobW92ZS5icnVzaFwiLCBwKS5vbihcInRvdWNoZW5kLmJydXNoIHRvdWNoY2FuY2VsLmJydXNoXCIsIGYpLnN0eWxlKFwidG91Y2gtYWN0aW9uXCIsIFwibm9uZVwiKS5zdHlsZShcIi13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvclwiLCBcInJnYmEoMCwwLDAsMClcIik7XG4gIH1cbiAgbC5tb3ZlID0gZnVuY3Rpb24obSwgdiwgeCkge1xuICAgIG0udHdlZW4gPyBtLm9uKFwic3RhcnQuYnJ1c2hcIiwgZnVuY3Rpb24oXykge1xuICAgICAgdSh0aGlzLCBhcmd1bWVudHMpLmJlZm9yZXN0YXJ0KCkuc3RhcnQoXyk7XG4gICAgfSkub24oXCJpbnRlcnJ1cHQuYnJ1c2ggZW5kLmJydXNoXCIsIGZ1bmN0aW9uKF8pIHtcbiAgICAgIHUodGhpcywgYXJndW1lbnRzKS5lbmQoXyk7XG4gICAgfSkudHdlZW4oXCJicnVzaFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfID0gdGhpcywgRSA9IF8uX19icnVzaCwgYiA9IHUoXywgYXJndW1lbnRzKSwgUyA9IEUuc2VsZWN0aW9uLCBNID0gZS5pbnB1dCh0eXBlb2YgdiA9PSBcImZ1bmN0aW9uXCIgPyB2LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB2LCBFLmV4dGVudCksIEQgPSBmcyhTLCBNKTtcbiAgICAgIGZ1bmN0aW9uIEEoUikge1xuICAgICAgICBFLnNlbGVjdGlvbiA9IFIgPT09IDEgJiYgTSA9PT0gbnVsbCA/IG51bGwgOiBEKFIpLCBjLmNhbGwoXyksIGIuYnJ1c2goKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTICE9PSBudWxsICYmIE0gIT09IG51bGwgPyBBIDogQSgxKTtcbiAgICB9KSA6IG0uZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfID0gdGhpcywgRSA9IGFyZ3VtZW50cywgYiA9IF8uX19icnVzaCwgUyA9IGUuaW5wdXQodHlwZW9mIHYgPT0gXCJmdW5jdGlvblwiID8gdi5hcHBseShfLCBFKSA6IHYsIGIuZXh0ZW50KSwgTSA9IHUoXywgRSkuYmVmb3Jlc3RhcnQoKTtcbiAgICAgIENsKF8pLCBiLnNlbGVjdGlvbiA9IFMgPT09IG51bGwgPyBudWxsIDogUywgYy5jYWxsKF8pLCBNLnN0YXJ0KHgpLmJydXNoKHgpLmVuZCh4KTtcbiAgICB9KTtcbiAgfSwgbC5jbGVhciA9IGZ1bmN0aW9uKG0sIHYpIHtcbiAgICBsLm1vdmUobSwgbnVsbCwgdik7XG4gIH07XG4gIGZ1bmN0aW9uIGMoKSB7XG4gICAgdmFyIG0gPSBJKHRoaXMpLCB2ID0gWW8odGhpcykuc2VsZWN0aW9uO1xuICAgIHYgPyAobS5zZWxlY3RBbGwoXCIuc2VsZWN0aW9uXCIpLnN0eWxlKFwiZGlzcGxheVwiLCBudWxsKS5hdHRyKFwieFwiLCB2WzBdWzBdKS5hdHRyKFwieVwiLCB2WzBdWzFdKS5hdHRyKFwid2lkdGhcIiwgdlsxXVswXSAtIHZbMF1bMF0pLmF0dHIoXCJoZWlnaHRcIiwgdlsxXVsxXSAtIHZbMF1bMV0pLCBtLnNlbGVjdEFsbChcIi5oYW5kbGVcIikuc3R5bGUoXCJkaXNwbGF5XCIsIG51bGwpLmF0dHIoXCJ4XCIsIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4LnR5cGVbeC50eXBlLmxlbmd0aCAtIDFdID09PSBcImVcIiA/IHZbMV1bMF0gLSBhIC8gMiA6IHZbMF1bMF0gLSBhIC8gMjtcbiAgICB9KS5hdHRyKFwieVwiLCBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geC50eXBlWzBdID09PSBcInNcIiA/IHZbMV1bMV0gLSBhIC8gMiA6IHZbMF1bMV0gLSBhIC8gMjtcbiAgICB9KS5hdHRyKFwid2lkdGhcIiwgZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHgudHlwZSA9PT0gXCJuXCIgfHwgeC50eXBlID09PSBcInNcIiA/IHZbMV1bMF0gLSB2WzBdWzBdICsgYSA6IGE7XG4gICAgfSkuYXR0cihcImhlaWdodFwiLCBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geC50eXBlID09PSBcImVcIiB8fCB4LnR5cGUgPT09IFwid1wiID8gdlsxXVsxXSAtIHZbMF1bMV0gKyBhIDogYTtcbiAgICB9KSkgOiBtLnNlbGVjdEFsbChcIi5zZWxlY3Rpb24sLmhhbmRsZVwiKS5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpLmF0dHIoXCJ4XCIsIG51bGwpLmF0dHIoXCJ5XCIsIG51bGwpLmF0dHIoXCJ3aWR0aFwiLCBudWxsKS5hdHRyKFwiaGVpZ2h0XCIsIG51bGwpO1xuICB9XG4gIGZ1bmN0aW9uIHUobSwgdiwgeCkge1xuICAgIHZhciBfID0gbS5fX2JydXNoLmVtaXR0ZXI7XG4gICAgcmV0dXJuIF8gJiYgKCF4IHx8ICFfLmNsZWFuKSA/IF8gOiBuZXcgZChtLCB2LCB4KTtcbiAgfVxuICBmdW5jdGlvbiBkKG0sIHYsIHgpIHtcbiAgICB0aGlzLnRoYXQgPSBtLCB0aGlzLmFyZ3MgPSB2LCB0aGlzLnN0YXRlID0gbS5fX2JydXNoLCB0aGlzLmFjdGl2ZSA9IDAsIHRoaXMuY2xlYW4gPSB4O1xuICB9XG4gIGQucHJvdG90eXBlID0ge1xuICAgIGJlZm9yZXN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiArK3RoaXMuYWN0aXZlID09PSAxICYmICh0aGlzLnN0YXRlLmVtaXR0ZXIgPSB0aGlzLCB0aGlzLnN0YXJ0aW5nID0gITApLCB0aGlzO1xuICAgIH0sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKG0sIHYpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0aW5nID8gKHRoaXMuc3RhcnRpbmcgPSAhMSwgdGhpcy5lbWl0KFwic3RhcnRcIiwgbSwgdikpIDogdGhpcy5lbWl0KFwiYnJ1c2hcIiwgbSksIHRoaXM7XG4gICAgfSxcbiAgICBicnVzaDogZnVuY3Rpb24obSwgdikge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdChcImJydXNoXCIsIG0sIHYpLCB0aGlzO1xuICAgIH0sXG4gICAgZW5kOiBmdW5jdGlvbihtLCB2KSB7XG4gICAgICByZXR1cm4gLS10aGlzLmFjdGl2ZSA9PT0gMCAmJiAoZGVsZXRlIHRoaXMuc3RhdGUuZW1pdHRlciwgdGhpcy5lbWl0KFwiZW5kXCIsIG0sIHYpKSwgdGhpcztcbiAgICB9LFxuICAgIGVtaXQ6IGZ1bmN0aW9uKG0sIHYsIHgpIHtcbiAgICAgIHZhciBfID0gSSh0aGlzLnRoYXQpLmRhdHVtKCk7XG4gICAgICBzLmNhbGwoXG4gICAgICAgIG0sXG4gICAgICAgIHRoaXMudGhhdCxcbiAgICAgICAgbmV3IFpDKG0sIHtcbiAgICAgICAgICBzb3VyY2VFdmVudDogdixcbiAgICAgICAgICB0YXJnZXQ6IGwsXG4gICAgICAgICAgc2VsZWN0aW9uOiBlLm91dHB1dCh0aGlzLnN0YXRlLnNlbGVjdGlvbiksXG4gICAgICAgICAgbW9kZTogeCxcbiAgICAgICAgICBkaXNwYXRjaDogc1xuICAgICAgICB9KSxcbiAgICAgICAgX1xuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGgobSkge1xuICAgIGlmIChvICYmICFtLnRvdWNoZXMgfHwgIW4uYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciB2ID0gdGhpcywgeCA9IG0udGFyZ2V0Ll9fZGF0YV9fLnR5cGUsIF8gPSAoaSAmJiBtLm1ldGFLZXkgPyB4ID0gXCJvdmVybGF5XCIgOiB4KSA9PT0gXCJzZWxlY3Rpb25cIiA/IHhkIDogaSAmJiBtLmFsdEtleSA/ICRyIDogd3IsIEUgPSBlID09PSBxbyA/IG51bGwgOiBRQ1t4XSwgYiA9IGUgPT09IHRhID8gbnVsbCA6IEpDW3hdLCBTID0gWW8odiksIE0gPSBTLmV4dGVudCwgRCA9IFMuc2VsZWN0aW9uLCBBID0gTVswXVswXSwgUiwgJCwgSCA9IE1bMF1bMV0sIFAsIEIsIE8gPSBNWzFdWzBdLCB3LCBMLCBrID0gTVsxXVsxXSwgVSwgWiwgaiA9IDAsIEYgPSAwLCBZLCBvdCA9IEUgJiYgYiAmJiBpICYmIG0uc2hpZnRLZXksIFEsIHEsIHR0ID0gQXJyYXkuZnJvbShtLnRvdWNoZXMgfHwgW21dLCAobnQpID0+IHtcbiAgICAgIGNvbnN0IHl0ID0gbnQuaWRlbnRpZmllcjtcbiAgICAgIHJldHVybiBudCA9IHJyKG50LCB2KSwgbnQucG9pbnQwID0gbnQuc2xpY2UoKSwgbnQuaWRlbnRpZmllciA9IHl0LCBudDtcbiAgICB9KTtcbiAgICBDbCh2KTtcbiAgICB2YXIgbHQgPSB1KHYsIGFyZ3VtZW50cywgITApLmJlZm9yZXN0YXJ0KCk7XG4gICAgaWYgKHggPT09IFwib3ZlcmxheVwiKSB7XG4gICAgICBEICYmIChZID0gITApO1xuICAgICAgY29uc3QgbnQgPSBbdHRbMF0sIHR0WzFdIHx8IHR0WzBdXTtcbiAgICAgIFMuc2VsZWN0aW9uID0gRCA9IFtbXG4gICAgICAgIFIgPSBlID09PSBxbyA/IEEgOiBlZShudFswXVswXSwgbnRbMV1bMF0pLFxuICAgICAgICBQID0gZSA9PT0gdGEgPyBIIDogZWUobnRbMF1bMV0sIG50WzFdWzFdKVxuICAgICAgXSwgW1xuICAgICAgICB3ID0gZSA9PT0gcW8gPyBPIDogdGUobnRbMF1bMF0sIG50WzFdWzBdKSxcbiAgICAgICAgVSA9IGUgPT09IHRhID8gayA6IHRlKG50WzBdWzFdLCBudFsxXVsxXSlcbiAgICAgIF1dLCB0dC5sZW5ndGggPiAxICYmIHV0KG0pO1xuICAgIH0gZWxzZVxuICAgICAgUiA9IERbMF1bMF0sIFAgPSBEWzBdWzFdLCB3ID0gRFsxXVswXSwgVSA9IERbMV1bMV07XG4gICAgJCA9IFIsIEIgPSBQLCBMID0gdywgWiA9IFU7XG4gICAgdmFyIHogPSBJKHYpLmF0dHIoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIiksIFcgPSB6LnNlbGVjdEFsbChcIi5vdmVybGF5XCIpLmF0dHIoXCJjdXJzb3JcIiwgaG5beF0pO1xuICAgIGlmIChtLnRvdWNoZXMpXG4gICAgICBsdC5tb3ZlZCA9IFYsIGx0LmVuZGVkID0gc3Q7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgWCA9IEkobS52aWV3KS5vbihcIm1vdXNlbW92ZS5icnVzaFwiLCBWLCAhMCkub24oXCJtb3VzZXVwLmJydXNoXCIsIHN0LCAhMCk7XG4gICAgICBpICYmIFgub24oXCJrZXlkb3duLmJydXNoXCIsIER0LCAhMCkub24oXCJrZXl1cC5icnVzaFwiLCBOdCwgITApLCBXQyhtLnZpZXcpO1xuICAgIH1cbiAgICBjLmNhbGwodiksIGx0LnN0YXJ0KG0sIF8ubmFtZSk7XG4gICAgZnVuY3Rpb24gVihudCkge1xuICAgICAgZm9yIChjb25zdCB5dCBvZiBudC5jaGFuZ2VkVG91Y2hlcyB8fCBbbnRdKVxuICAgICAgICBmb3IgKGNvbnN0IFNlIG9mIHR0KVxuICAgICAgICAgIFNlLmlkZW50aWZpZXIgPT09IHl0LmlkZW50aWZpZXIgJiYgKFNlLmN1ciA9IHJyKHl0LCB2KSk7XG4gICAgICBpZiAob3QgJiYgIVEgJiYgIXEgJiYgdHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHl0ID0gdHRbMF07XG4gICAgICAgIGJkKHl0LmN1clswXSAtIHl0WzBdKSA+IGJkKHl0LmN1clsxXSAtIHl0WzFdKSA/IHEgPSAhMCA6IFEgPSAhMDtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgeXQgb2YgdHQpXG4gICAgICAgIHl0LmN1ciAmJiAoeXRbMF0gPSB5dC5jdXJbMF0sIHl0WzFdID0geXQuY3VyWzFdKTtcbiAgICAgIFkgPSAhMCwgam8obnQpLCB1dChudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHV0KG50KSB7XG4gICAgICBjb25zdCB5dCA9IHR0WzBdLCBTZSA9IHl0LnBvaW50MDtcbiAgICAgIHZhciBnZTtcbiAgICAgIHN3aXRjaCAoaiA9IHl0WzBdIC0gU2VbMF0sIEYgPSB5dFsxXSAtIFNlWzFdLCBfKSB7XG4gICAgICAgIGNhc2UgV286XG4gICAgICAgIGNhc2UgeGQ6IHtcbiAgICAgICAgICBFICYmIChqID0gdGUoQSAtIFIsIGVlKE8gLSB3LCBqKSksICQgPSBSICsgaiwgTCA9IHcgKyBqKSwgYiAmJiAoRiA9IHRlKEggLSBQLCBlZShrIC0gVSwgRikpLCBCID0gUCArIEYsIFogPSBVICsgRik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSB3cjoge1xuICAgICAgICAgIHR0WzFdID8gKEUgJiYgKCQgPSB0ZShBLCBlZShPLCB0dFswXVswXSkpLCBMID0gdGUoQSwgZWUoTywgdHRbMV1bMF0pKSwgRSA9IDEpLCBiICYmIChCID0gdGUoSCwgZWUoaywgdHRbMF1bMV0pKSwgWiA9IHRlKEgsIGVlKGssIHR0WzFdWzFdKSksIGIgPSAxKSkgOiAoRSA8IDAgPyAoaiA9IHRlKEEgLSBSLCBlZShPIC0gUiwgaikpLCAkID0gUiArIGosIEwgPSB3KSA6IEUgPiAwICYmIChqID0gdGUoQSAtIHcsIGVlKE8gLSB3LCBqKSksICQgPSBSLCBMID0gdyArIGopLCBiIDwgMCA/IChGID0gdGUoSCAtIFAsIGVlKGsgLSBQLCBGKSksIEIgPSBQICsgRiwgWiA9IFUpIDogYiA+IDAgJiYgKEYgPSB0ZShIIC0gVSwgZWUoayAtIFUsIEYpKSwgQiA9IFAsIFogPSBVICsgRikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJHI6IHtcbiAgICAgICAgICBFICYmICgkID0gdGUoQSwgZWUoTywgUiAtIGogKiBFKSksIEwgPSB0ZShBLCBlZShPLCB3ICsgaiAqIEUpKSksIGIgJiYgKEIgPSB0ZShILCBlZShrLCBQIC0gRiAqIGIpKSwgWiA9IHRlKEgsIGVlKGssIFUgKyBGICogYikpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgTCA8ICQgJiYgKEUgKj0gLTEsIGdlID0gUiwgUiA9IHcsIHcgPSBnZSwgZ2UgPSAkLCAkID0gTCwgTCA9IGdlLCB4IGluIE9kICYmIFcuYXR0cihcImN1cnNvclwiLCBoblt4ID0gT2RbeF1dKSksIFogPCBCICYmIChiICo9IC0xLCBnZSA9IFAsIFAgPSBVLCBVID0gZ2UsIGdlID0gQiwgQiA9IFosIFogPSBnZSwgeCBpbiBTZCAmJiBXLmF0dHIoXCJjdXJzb3JcIiwgaG5beCA9IFNkW3hdXSkpLCBTLnNlbGVjdGlvbiAmJiAoRCA9IFMuc2VsZWN0aW9uKSwgUSAmJiAoJCA9IERbMF1bMF0sIEwgPSBEWzFdWzBdKSwgcSAmJiAoQiA9IERbMF1bMV0sIFogPSBEWzFdWzFdKSwgKERbMF1bMF0gIT09ICQgfHwgRFswXVsxXSAhPT0gQiB8fCBEWzFdWzBdICE9PSBMIHx8IERbMV1bMV0gIT09IFopICYmIChTLnNlbGVjdGlvbiA9IFtbJCwgQl0sIFtMLCBaXV0sIGMuY2FsbCh2KSwgbHQuYnJ1c2gobnQsIF8ubmFtZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdChudCkge1xuICAgICAgaWYgKEtDKG50KSwgbnQudG91Y2hlcykge1xuICAgICAgICBpZiAobnQudG91Y2hlcy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgbyAmJiBjbGVhclRpbWVvdXQobyksIG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG8gPSBudWxsO1xuICAgICAgICB9LCA1MDApO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHFDKG50LnZpZXcsIFkpLCBYLm9uKFwia2V5ZG93bi5icnVzaCBrZXl1cC5icnVzaCBtb3VzZW1vdmUuYnJ1c2ggbW91c2V1cC5icnVzaFwiLCBudWxsKTtcbiAgICAgIHouYXR0cihcInBvaW50ZXItZXZlbnRzXCIsIFwiYWxsXCIpLCBXLmF0dHIoXCJjdXJzb3JcIiwgaG4ub3ZlcmxheSksIFMuc2VsZWN0aW9uICYmIChEID0gUy5zZWxlY3Rpb24pLCByQShEKSAmJiAoUy5zZWxlY3Rpb24gPSBudWxsLCBjLmNhbGwodikpLCBsdC5lbmQobnQsIF8ubmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIER0KG50KSB7XG4gICAgICBzd2l0Y2ggKG50LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSAxNjoge1xuICAgICAgICAgIG90ID0gRSAmJiBiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTg6IHtcbiAgICAgICAgICBfID09PSB3ciAmJiAoRSAmJiAodyA9IEwgLSBqICogRSwgUiA9ICQgKyBqICogRSksIGIgJiYgKFUgPSBaIC0gRiAqIGIsIFAgPSBCICsgRiAqIGIpLCBfID0gJHIsIHV0KG50KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAzMjoge1xuICAgICAgICAgIChfID09PSB3ciB8fCBfID09PSAkcikgJiYgKEUgPCAwID8gdyA9IEwgLSBqIDogRSA+IDAgJiYgKFIgPSAkIC0gaiksIGIgPCAwID8gVSA9IFogLSBGIDogYiA+IDAgJiYgKFAgPSBCIC0gRiksIF8gPSBXbywgVy5hdHRyKFwiY3Vyc29yXCIsIGhuLnNlbGVjdGlvbiksIHV0KG50KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBqbyhudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE50KG50KSB7XG4gICAgICBzd2l0Y2ggKG50LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSAxNjoge1xuICAgICAgICAgIG90ICYmIChRID0gcSA9IG90ID0gITEsIHV0KG50KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxODoge1xuICAgICAgICAgIF8gPT09ICRyICYmIChFIDwgMCA/IHcgPSBMIDogRSA+IDAgJiYgKFIgPSAkKSwgYiA8IDAgPyBVID0gWiA6IGIgPiAwICYmIChQID0gQiksIF8gPSB3ciwgdXQobnQpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDMyOiB7XG4gICAgICAgICAgXyA9PT0gV28gJiYgKG50LmFsdEtleSA/IChFICYmICh3ID0gTCAtIGogKiBFLCBSID0gJCArIGogKiBFKSwgYiAmJiAoVSA9IFogLSBGICogYiwgUCA9IEIgKyBGICogYiksIF8gPSAkcikgOiAoRSA8IDAgPyB3ID0gTCA6IEUgPiAwICYmIChSID0gJCksIGIgPCAwID8gVSA9IFogOiBiID4gMCAmJiAoUCA9IEIpLCBfID0gd3IpLCBXLmF0dHIoXCJjdXJzb3JcIiwgaG5beF0pLCB1dChudCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgam8obnQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwKG0pIHtcbiAgICB1KHRoaXMsIGFyZ3VtZW50cykubW92ZWQobSk7XG4gIH1cbiAgZnVuY3Rpb24gZihtKSB7XG4gICAgdSh0aGlzLCBhcmd1bWVudHMpLmVuZGVkKG0pO1xuICB9XG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdmFyIG0gPSB0aGlzLl9fYnJ1c2ggfHwgeyBzZWxlY3Rpb246IG51bGwgfTtcbiAgICByZXR1cm4gbS5leHRlbnQgPSBFZCh0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLCBtLmRpbSA9IGUsIG07XG4gIH1cbiAgcmV0dXJuIGwuZXh0ZW50ID0gZnVuY3Rpb24obSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQgPSB0eXBlb2YgbSA9PSBcImZ1bmN0aW9uXCIgPyBtIDogRm8oRWQobSkpLCBsKSA6IHQ7XG4gIH0sIGwuZmlsdGVyID0gZnVuY3Rpb24obSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4gPSB0eXBlb2YgbSA9PSBcImZ1bmN0aW9uXCIgPyBtIDogRm8oISFtKSwgbCkgOiBuO1xuICB9LCBsLnRvdWNoYWJsZSA9IGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyID0gdHlwZW9mIG0gPT0gXCJmdW5jdGlvblwiID8gbSA6IEZvKCEhbSksIGwpIDogcjtcbiAgfSwgbC5oYW5kbGVTaXplID0gZnVuY3Rpb24obSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGEgPSArbSwgbCkgOiBhO1xuICB9LCBsLmtleU1vZGlmaWVycyA9IGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpID0gISFtLCBsKSA6IGk7XG4gIH0sIGwub24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbSA9IHMub24uYXBwbHkocywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gbSA9PT0gcyA/IGwgOiBtO1xuICB9LCBsO1xufVxuY29uc3QgVmwgPSBNYXRoLlBJLCBHbCA9IDIgKiBWbCwgWG4gPSAxZS02LCBzQSA9IEdsIC0gWG47XG5mdW5jdGlvbiBEZyhlKSB7XG4gIHRoaXMuXyArPSBlWzBdO1xuICBmb3IgKGxldCB0ID0gMSwgbiA9IGUubGVuZ3RoOyB0IDwgbjsgKyt0KVxuICAgIHRoaXMuXyArPSBhcmd1bWVudHNbdF0gKyBlW3RdO1xufVxuZnVuY3Rpb24gYUEoZSkge1xuICBsZXQgdCA9IE1hdGguZmxvb3IoZSk7XG4gIGlmICghKHQgPj0gMCkpIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaWdpdHM6ICR7ZX1gKTtcbiAgaWYgKHQgPiAxNSkgcmV0dXJuIERnO1xuICBjb25zdCBuID0gMTAgKiogdDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHIpIHtcbiAgICB0aGlzLl8gKz0gclswXTtcbiAgICBmb3IgKGxldCBpID0gMSwgcyA9IHIubGVuZ3RoOyBpIDwgczsgKytpKVxuICAgICAgdGhpcy5fICs9IE1hdGgucm91bmQoYXJndW1lbnRzW2ldICogbikgLyBuICsgcltpXTtcbiAgfTtcbn1cbmxldCB0dSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feTAgPSAvLyBzdGFydCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgICB0aGlzLl94MSA9IHRoaXMuX3kxID0gbnVsbCwgdGhpcy5fID0gXCJcIiwgdGhpcy5fYXBwZW5kID0gdCA9PSBudWxsID8gRGcgOiBhQSh0KTtcbiAgfVxuICBtb3ZlVG8odCwgbikge1xuICAgIHRoaXMuX2FwcGVuZGBNJHt0aGlzLl94MCA9IHRoaXMuX3gxID0gK3R9LCR7dGhpcy5feTAgPSB0aGlzLl95MSA9ICtufWA7XG4gIH1cbiAgY2xvc2VQYXRoKCkge1xuICAgIHRoaXMuX3gxICE9PSBudWxsICYmICh0aGlzLl94MSA9IHRoaXMuX3gwLCB0aGlzLl95MSA9IHRoaXMuX3kwLCB0aGlzLl9hcHBlbmRgWmApO1xuICB9XG4gIGxpbmVUbyh0LCBuKSB7XG4gICAgdGhpcy5fYXBwZW5kYEwke3RoaXMuX3gxID0gK3R9LCR7dGhpcy5feTEgPSArbn1gO1xuICB9XG4gIHF1YWRyYXRpY0N1cnZlVG8odCwgbiwgciwgaSkge1xuICAgIHRoaXMuX2FwcGVuZGBRJHsrdH0sJHsrbn0sJHt0aGlzLl94MSA9ICtyfSwke3RoaXMuX3kxID0gK2l9YDtcbiAgfVxuICBiZXppZXJDdXJ2ZVRvKHQsIG4sIHIsIGksIHMsIGEpIHtcbiAgICB0aGlzLl9hcHBlbmRgQyR7K3R9LCR7K259LCR7K3J9LCR7K2l9LCR7dGhpcy5feDEgPSArc30sJHt0aGlzLl95MSA9ICthfWA7XG4gIH1cbiAgYXJjVG8odCwgbiwgciwgaSwgcykge1xuICAgIGlmICh0ID0gK3QsIG4gPSArbiwgciA9ICtyLCBpID0gK2ksIHMgPSArcywgcyA8IDApIHRocm93IG5ldyBFcnJvcihgbmVnYXRpdmUgcmFkaXVzOiAke3N9YCk7XG4gICAgbGV0IGEgPSB0aGlzLl94MSwgbyA9IHRoaXMuX3kxLCBsID0gciAtIHQsIGMgPSBpIC0gbiwgdSA9IGEgLSB0LCBkID0gbyAtIG4sIGggPSB1ICogdSArIGQgKiBkO1xuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbClcbiAgICAgIHRoaXMuX2FwcGVuZGBNJHt0aGlzLl94MSA9IHR9LCR7dGhpcy5feTEgPSBufWA7XG4gICAgZWxzZSBpZiAoaCA+IFhuKSBpZiAoIShNYXRoLmFicyhkICogbCAtIGMgKiB1KSA+IFhuKSB8fCAhcylcbiAgICAgIHRoaXMuX2FwcGVuZGBMJHt0aGlzLl94MSA9IHR9LCR7dGhpcy5feTEgPSBufWA7XG4gICAgZWxzZSB7XG4gICAgICBsZXQgcCA9IHIgLSBhLCBmID0gaSAtIG8sIGcgPSBsICogbCArIGMgKiBjLCBtID0gcCAqIHAgKyBmICogZiwgdiA9IE1hdGguc3FydChnKSwgeCA9IE1hdGguc3FydChoKSwgXyA9IHMgKiBNYXRoLnRhbigoVmwgLSBNYXRoLmFjb3MoKGcgKyBoIC0gbSkgLyAoMiAqIHYgKiB4KSkpIC8gMiksIEUgPSBfIC8geCwgYiA9IF8gLyB2O1xuICAgICAgTWF0aC5hYnMoRSAtIDEpID4gWG4gJiYgdGhpcy5fYXBwZW5kYEwke3QgKyBFICogdX0sJHtuICsgRSAqIGR9YCwgdGhpcy5fYXBwZW5kYEEke3N9LCR7c30sMCwwLCR7KyhkICogcCA+IHUgKiBmKX0sJHt0aGlzLl94MSA9IHQgKyBiICogbH0sJHt0aGlzLl95MSA9IG4gKyBiICogY31gO1xuICAgIH1cbiAgfVxuICBhcmModCwgbiwgciwgaSwgcywgYSkge1xuICAgIGlmICh0ID0gK3QsIG4gPSArbiwgciA9ICtyLCBhID0gISFhLCByIDwgMCkgdGhyb3cgbmV3IEVycm9yKGBuZWdhdGl2ZSByYWRpdXM6ICR7cn1gKTtcbiAgICBsZXQgbyA9IHIgKiBNYXRoLmNvcyhpKSwgbCA9IHIgKiBNYXRoLnNpbihpKSwgYyA9IHQgKyBvLCB1ID0gbiArIGwsIGQgPSAxIF4gYSwgaCA9IGEgPyBpIC0gcyA6IHMgLSBpO1xuICAgIHRoaXMuX3gxID09PSBudWxsID8gdGhpcy5fYXBwZW5kYE0ke2N9LCR7dX1gIDogKE1hdGguYWJzKHRoaXMuX3gxIC0gYykgPiBYbiB8fCBNYXRoLmFicyh0aGlzLl95MSAtIHUpID4gWG4pICYmIHRoaXMuX2FwcGVuZGBMJHtjfSwke3V9YCwgciAmJiAoaCA8IDAgJiYgKGggPSBoICUgR2wgKyBHbCksIGggPiBzQSA/IHRoaXMuX2FwcGVuZGBBJHtyfSwke3J9LDAsMSwke2R9LCR7dCAtIG99LCR7biAtIGx9QSR7cn0sJHtyfSwwLDEsJHtkfSwke3RoaXMuX3gxID0gY30sJHt0aGlzLl95MSA9IHV9YCA6IGggPiBYbiAmJiB0aGlzLl9hcHBlbmRgQSR7cn0sJHtyfSwwLCR7KyhoID49IFZsKX0sJHtkfSwke3RoaXMuX3gxID0gdCArIHIgKiBNYXRoLmNvcyhzKX0sJHt0aGlzLl95MSA9IG4gKyByICogTWF0aC5zaW4ocyl9YCk7XG4gIH1cbiAgcmVjdCh0LCBuLCByLCBpKSB7XG4gICAgdGhpcy5fYXBwZW5kYE0ke3RoaXMuX3gwID0gdGhpcy5feDEgPSArdH0sJHt0aGlzLl95MCA9IHRoaXMuX3kxID0gK259aCR7ciA9ICtyfXYkeytpfWgkey1yfVpgO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl87XG4gIH1cbn07XG5mdW5jdGlvbiBSZygpIHtcbiAgcmV0dXJuIG5ldyB0dSgpO1xufVxuUmcucHJvdG90eXBlID0gdHUucHJvdG90eXBlO1xudmFyIFR0ID0gMWUtNiwgb0EgPSAxZS0xMiwgZnQgPSBNYXRoLlBJLCBkZSA9IGZ0IC8gMiwgVGQgPSBmdCAvIDQsIEVlID0gZnQgKiAyLCBzZSA9IDE4MCAvIGZ0LCBCdCA9IGZ0IC8gMTgwLCBPdCA9IE1hdGguYWJzLCBJZyA9IE1hdGguYXRhbiwgbHIgPSBNYXRoLmF0YW4yLCBTdCA9IE1hdGguY29zLCBsQSA9IE1hdGguZXhwLCBjQSA9IE1hdGgubG9nLCB4dCA9IE1hdGguc2luLCBVbiA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlID4gMCA/IDEgOiBlIDwgMCA/IC0xIDogMDtcbn0sIGplID0gTWF0aC5zcXJ0LCB1QSA9IE1hdGgudGFuO1xuZnVuY3Rpb24gaEEoZSkge1xuICByZXR1cm4gZSA+IDEgPyAwIDogZSA8IC0xID8gZnQgOiBNYXRoLmFjb3MoZSk7XG59XG5mdW5jdGlvbiBDbihlKSB7XG4gIHJldHVybiBlID4gMSA/IGRlIDogZSA8IC0xID8gLWRlIDogTWF0aC5hc2luKGUpO1xufVxuZnVuY3Rpb24gQWUoKSB7XG59XG5mdW5jdGlvbiAkYShlLCB0KSB7XG4gIGUgJiYgJGQuaGFzT3duUHJvcGVydHkoZS50eXBlKSAmJiAkZFtlLnR5cGVdKGUsIHQpO1xufVxudmFyIHdkID0ge1xuICBGZWF0dXJlOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgJGEoZS5nZW9tZXRyeSwgdCk7XG4gIH0sXG4gIEZlYXR1cmVDb2xsZWN0aW9uOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgZm9yICh2YXIgbiA9IGUuZmVhdHVyZXMsIHIgPSAtMSwgaSA9IG4ubGVuZ3RoOyArK3IgPCBpOyApICRhKG5bcl0uZ2VvbWV0cnksIHQpO1xuICB9XG59LCAkZCA9IHtcbiAgU3BoZXJlOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgdC5zcGhlcmUoKTtcbiAgfSxcbiAgUG9pbnQ6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBlID0gZS5jb29yZGluYXRlcywgdC5wb2ludChlWzBdLCBlWzFdLCBlWzJdKTtcbiAgfSxcbiAgTXVsdGlQb2ludDogZnVuY3Rpb24oZSwgdCkge1xuICAgIGZvciAodmFyIG4gPSBlLmNvb3JkaW5hdGVzLCByID0gLTEsIGkgPSBuLmxlbmd0aDsgKytyIDwgaTsgKSBlID0gbltyXSwgdC5wb2ludChlWzBdLCBlWzFdLCBlWzJdKTtcbiAgfSxcbiAgTGluZVN0cmluZzogZnVuY3Rpb24oZSwgdCkge1xuICAgIHpsKGUuY29vcmRpbmF0ZXMsIHQsIDApO1xuICB9LFxuICBNdWx0aUxpbmVTdHJpbmc6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBmb3IgKHZhciBuID0gZS5jb29yZGluYXRlcywgciA9IC0xLCBpID0gbi5sZW5ndGg7ICsrciA8IGk7ICkgemwobltyXSwgdCwgMCk7XG4gIH0sXG4gIFBvbHlnb246IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBNZChlLmNvb3JkaW5hdGVzLCB0KTtcbiAgfSxcbiAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgZm9yICh2YXIgbiA9IGUuY29vcmRpbmF0ZXMsIHIgPSAtMSwgaSA9IG4ubGVuZ3RoOyArK3IgPCBpOyApIE1kKG5bcl0sIHQpO1xuICB9LFxuICBHZW9tZXRyeUNvbGxlY3Rpb246IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBmb3IgKHZhciBuID0gZS5nZW9tZXRyaWVzLCByID0gLTEsIGkgPSBuLmxlbmd0aDsgKytyIDwgaTsgKSAkYShuW3JdLCB0KTtcbiAgfVxufTtcbmZ1bmN0aW9uIHpsKGUsIHQsIG4pIHtcbiAgdmFyIHIgPSAtMSwgaSA9IGUubGVuZ3RoIC0gbiwgcztcbiAgZm9yICh0LmxpbmVTdGFydCgpOyArK3IgPCBpOyApIHMgPSBlW3JdLCB0LnBvaW50KHNbMF0sIHNbMV0sIHNbMl0pO1xuICB0LmxpbmVFbmQoKTtcbn1cbmZ1bmN0aW9uIE1kKGUsIHQpIHtcbiAgdmFyIG4gPSAtMSwgciA9IGUubGVuZ3RoO1xuICBmb3IgKHQucG9seWdvblN0YXJ0KCk7ICsrbiA8IHI7ICkgemwoZVtuXSwgdCwgMSk7XG4gIHQucG9seWdvbkVuZCgpO1xufVxuZnVuY3Rpb24gTHIoZSwgdCkge1xuICBlICYmIHdkLmhhc093blByb3BlcnR5KGUudHlwZSkgPyB3ZFtlLnR5cGVdKGUsIHQpIDogJGEoZSwgdCk7XG59XG5mdW5jdGlvbiBGbChlKSB7XG4gIHJldHVybiBbbHIoZVsxXSwgZVswXSksIENuKGVbMl0pXTtcbn1cbmZ1bmN0aW9uIHRpKGUpIHtcbiAgdmFyIHQgPSBlWzBdLCBuID0gZVsxXSwgciA9IFN0KG4pO1xuICByZXR1cm4gW3IgKiBTdCh0KSwgciAqIHh0KHQpLCB4dChuKV07XG59XG5mdW5jdGlvbiBrcyhlLCB0KSB7XG4gIHJldHVybiBlWzBdICogdFswXSArIGVbMV0gKiB0WzFdICsgZVsyXSAqIHRbMl07XG59XG5mdW5jdGlvbiBNYShlLCB0KSB7XG4gIHJldHVybiBbZVsxXSAqIHRbMl0gLSBlWzJdICogdFsxXSwgZVsyXSAqIHRbMF0gLSBlWzBdICogdFsyXSwgZVswXSAqIHRbMV0gLSBlWzFdICogdFswXV07XG59XG5mdW5jdGlvbiBYbyhlLCB0KSB7XG4gIGVbMF0gKz0gdFswXSwgZVsxXSArPSB0WzFdLCBlWzJdICs9IHRbMl07XG59XG5mdW5jdGlvbiBEcyhlLCB0KSB7XG4gIHJldHVybiBbZVswXSAqIHQsIGVbMV0gKiB0LCBlWzJdICogdF07XG59XG5mdW5jdGlvbiBqbChlKSB7XG4gIHZhciB0ID0gamUoZVswXSAqIGVbMF0gKyBlWzFdICogZVsxXSArIGVbMl0gKiBlWzJdKTtcbiAgZVswXSAvPSB0LCBlWzFdIC89IHQsIGVbMl0gLz0gdDtcbn1cbmZ1bmN0aW9uIFdsKGUsIHQpIHtcbiAgZnVuY3Rpb24gbihyLCBpKSB7XG4gICAgcmV0dXJuIHIgPSBlKHIsIGkpLCB0KHJbMF0sIHJbMV0pO1xuICB9XG4gIHJldHVybiBlLmludmVydCAmJiB0LmludmVydCAmJiAobi5pbnZlcnQgPSBmdW5jdGlvbihyLCBpKSB7XG4gICAgcmV0dXJuIHIgPSB0LmludmVydChyLCBpKSwgciAmJiBlLmludmVydChyWzBdLCByWzFdKTtcbiAgfSksIG47XG59XG5mdW5jdGlvbiBxbChlLCB0KSB7XG4gIHJldHVybiBPdChlKSA+IGZ0ICYmIChlIC09IE1hdGgucm91bmQoZSAvIEVlKSAqIEVlKSwgW2UsIHRdO1xufVxucWwuaW52ZXJ0ID0gcWw7XG5mdW5jdGlvbiBOZyhlLCB0LCBuKSB7XG4gIHJldHVybiAoZSAlPSBFZSkgPyB0IHx8IG4gPyBXbChBZChlKSwgTGQodCwgbikpIDogQWQoZSkgOiB0IHx8IG4gPyBMZCh0LCBuKSA6IHFsO1xufVxuZnVuY3Rpb24gQ2QoZSkge1xuICByZXR1cm4gZnVuY3Rpb24odCwgbikge1xuICAgIHJldHVybiB0ICs9IGUsIE90KHQpID4gZnQgJiYgKHQgLT0gTWF0aC5yb3VuZCh0IC8gRWUpICogRWUpLCBbdCwgbl07XG4gIH07XG59XG5mdW5jdGlvbiBBZChlKSB7XG4gIHZhciB0ID0gQ2QoZSk7XG4gIHJldHVybiB0LmludmVydCA9IENkKC1lKSwgdDtcbn1cbmZ1bmN0aW9uIExkKGUsIHQpIHtcbiAgdmFyIG4gPSBTdChlKSwgciA9IHh0KGUpLCBpID0gU3QodCksIHMgPSB4dCh0KTtcbiAgZnVuY3Rpb24gYShvLCBsKSB7XG4gICAgdmFyIGMgPSBTdChsKSwgdSA9IFN0KG8pICogYywgZCA9IHh0KG8pICogYywgaCA9IHh0KGwpLCBwID0gaCAqIG4gKyB1ICogcjtcbiAgICByZXR1cm4gW1xuICAgICAgbHIoZCAqIGkgLSBwICogcywgdSAqIG4gLSBoICogciksXG4gICAgICBDbihwICogaSArIGQgKiBzKVxuICAgIF07XG4gIH1cbiAgcmV0dXJuIGEuaW52ZXJ0ID0gZnVuY3Rpb24obywgbCkge1xuICAgIHZhciBjID0gU3QobCksIHUgPSBTdChvKSAqIGMsIGQgPSB4dChvKSAqIGMsIGggPSB4dChsKSwgcCA9IGggKiBpIC0gZCAqIHM7XG4gICAgcmV0dXJuIFtcbiAgICAgIGxyKGQgKiBpICsgaCAqIHMsIHUgKiBuICsgcCAqIHIpLFxuICAgICAgQ24ocCAqIG4gLSB1ICogcilcbiAgICBdO1xuICB9LCBhO1xufVxuZnVuY3Rpb24gZEEoZSkge1xuICBlID0gTmcoZVswXSAqIEJ0LCBlWzFdICogQnQsIGUubGVuZ3RoID4gMiA/IGVbMl0gKiBCdCA6IDApO1xuICBmdW5jdGlvbiB0KG4pIHtcbiAgICByZXR1cm4gbiA9IGUoblswXSAqIEJ0LCBuWzFdICogQnQpLCBuWzBdICo9IHNlLCBuWzFdICo9IHNlLCBuO1xuICB9XG4gIHJldHVybiB0LmludmVydCA9IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gbiA9IGUuaW52ZXJ0KG5bMF0gKiBCdCwgblsxXSAqIEJ0KSwgblswXSAqPSBzZSwgblsxXSAqPSBzZSwgbjtcbiAgfSwgdDtcbn1cbmZ1bmN0aW9uIHBBKGUsIHQsIG4sIHIsIGksIHMpIHtcbiAgaWYgKG4pIHtcbiAgICB2YXIgYSA9IFN0KHQpLCBvID0geHQodCksIGwgPSByICogbjtcbiAgICBpID09IG51bGwgPyAoaSA9IHQgKyByICogRWUsIHMgPSB0IC0gbCAvIDIpIDogKGkgPSBrZChhLCBpKSwgcyA9IGtkKGEsIHMpLCAociA+IDAgPyBpIDwgcyA6IGkgPiBzKSAmJiAoaSArPSByICogRWUpKTtcbiAgICBmb3IgKHZhciBjLCB1ID0gaTsgciA+IDAgPyB1ID4gcyA6IHUgPCBzOyB1IC09IGwpXG4gICAgICBjID0gRmwoW2EsIC1vICogU3QodSksIC1vICogeHQodSldKSwgZS5wb2ludChjWzBdLCBjWzFdKTtcbiAgfVxufVxuZnVuY3Rpb24ga2QoZSwgdCkge1xuICB0ID0gdGkodCksIHRbMF0gLT0gZSwgamwodCk7XG4gIHZhciBuID0gaEEoLXRbMV0pO1xuICByZXR1cm4gKCgtdFsyXSA8IDAgPyAtbiA6IG4pICsgRWUgLSBUdCkgJSBFZTtcbn1cbmZ1bmN0aW9uIFBnKCkge1xuICB2YXIgZSA9IFtdLCB0O1xuICByZXR1cm4ge1xuICAgIHBvaW50OiBmdW5jdGlvbihuLCByLCBpKSB7XG4gICAgICB0LnB1c2goW24sIHIsIGldKTtcbiAgICB9LFxuICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBlLnB1c2godCA9IFtdKTtcbiAgICB9LFxuICAgIGxpbmVFbmQ6IEFlLFxuICAgIHJlam9pbjogZnVuY3Rpb24oKSB7XG4gICAgICBlLmxlbmd0aCA+IDEgJiYgZS5wdXNoKGUucG9wKCkuY29uY2F0KGUuc2hpZnQoKSkpO1xuICAgIH0sXG4gICAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuID0gZTtcbiAgICAgIHJldHVybiBlID0gW10sIHQgPSBudWxsLCBuO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGVhKGUsIHQpIHtcbiAgcmV0dXJuIE90KGVbMF0gLSB0WzBdKSA8IFR0ICYmIE90KGVbMV0gLSB0WzFdKSA8IFR0O1xufVxuZnVuY3Rpb24gUnMoZSwgdCwgbiwgcikge1xuICB0aGlzLnggPSBlLCB0aGlzLnogPSB0LCB0aGlzLm8gPSBuLCB0aGlzLmUgPSByLCB0aGlzLnYgPSAhMSwgdGhpcy5uID0gdGhpcy5wID0gbnVsbDtcbn1cbmZ1bmN0aW9uIFVnKGUsIHQsIG4sIHIsIGkpIHtcbiAgdmFyIHMgPSBbXSwgYSA9IFtdLCBvLCBsO1xuICBpZiAoZS5mb3JFYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICBpZiAoISgoZyA9IGYubGVuZ3RoIC0gMSkgPD0gMCkpIHtcbiAgICAgIHZhciBnLCBtID0gZlswXSwgdiA9IGZbZ10sIHg7XG4gICAgICBpZiAoZWEobSwgdikpIHtcbiAgICAgICAgaWYgKCFtWzJdICYmICF2WzJdKSB7XG4gICAgICAgICAgZm9yIChpLmxpbmVTdGFydCgpLCBvID0gMDsgbyA8IGc7ICsrbykgaS5wb2ludCgobSA9IGZbb10pWzBdLCBtWzFdKTtcbiAgICAgICAgICBpLmxpbmVFbmQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdlswXSArPSAyICogVHQ7XG4gICAgICB9XG4gICAgICBzLnB1c2goeCA9IG5ldyBScyhtLCBmLCBudWxsLCAhMCkpLCBhLnB1c2goeC5vID0gbmV3IFJzKG0sIG51bGwsIHgsICExKSksIHMucHVzaCh4ID0gbmV3IFJzKHYsIGYsIG51bGwsICExKSksIGEucHVzaCh4Lm8gPSBuZXcgUnModiwgbnVsbCwgeCwgITApKTtcbiAgICB9XG4gIH0pLCAhIXMubGVuZ3RoKSB7XG4gICAgZm9yIChhLnNvcnQodCksIERkKHMpLCBEZChhKSwgbyA9IDAsIGwgPSBhLmxlbmd0aDsgbyA8IGw7ICsrbylcbiAgICAgIGFbb10uZSA9IG4gPSAhbjtcbiAgICBmb3IgKHZhciBjID0gc1swXSwgdSwgZDsgOyApIHtcbiAgICAgIGZvciAodmFyIGggPSBjLCBwID0gITA7IGgudjsgKSBpZiAoKGggPSBoLm4pID09PSBjKSByZXR1cm47XG4gICAgICB1ID0gaC56LCBpLmxpbmVTdGFydCgpO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoaC52ID0gaC5vLnYgPSAhMCwgaC5lKSB7XG4gICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICBmb3IgKG8gPSAwLCBsID0gdS5sZW5ndGg7IG8gPCBsOyArK28pIGkucG9pbnQoKGQgPSB1W29dKVswXSwgZFsxXSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcihoLngsIGgubi54LCAxLCBpKTtcbiAgICAgICAgICBoID0gaC5uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgZm9yICh1ID0gaC5wLnosIG8gPSB1Lmxlbmd0aCAtIDE7IG8gPj0gMDsgLS1vKSBpLnBvaW50KChkID0gdVtvXSlbMF0sIGRbMV0pO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHIoaC54LCBoLnAueCwgLTEsIGkpO1xuICAgICAgICAgIGggPSBoLnA7XG4gICAgICAgIH1cbiAgICAgICAgaCA9IGgubywgdSA9IGgueiwgcCA9ICFwO1xuICAgICAgfSB3aGlsZSAoIWgudik7XG4gICAgICBpLmxpbmVFbmQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIERkKGUpIHtcbiAgaWYgKHQgPSBlLmxlbmd0aCkge1xuICAgIGZvciAodmFyIHQsIG4gPSAwLCByID0gZVswXSwgaTsgKytuIDwgdDsgKVxuICAgICAgci5uID0gaSA9IGVbbl0sIGkucCA9IHIsIHIgPSBpO1xuICAgIHIubiA9IGkgPSBlWzBdLCBpLnAgPSByO1xuICB9XG59XG5mdW5jdGlvbiBabyhlKSB7XG4gIHJldHVybiBPdChlWzBdKSA8PSBmdCA/IGVbMF0gOiBVbihlWzBdKSAqICgoT3QoZVswXSkgKyBmdCkgJSBFZSAtIGZ0KTtcbn1cbmZ1bmN0aW9uIGZBKGUsIHQpIHtcbiAgdmFyIG4gPSBabyh0KSwgciA9IHRbMV0sIGkgPSB4dChyKSwgcyA9IFt4dChuKSwgLVN0KG4pLCAwXSwgYSA9IDAsIG8gPSAwLCBsID0gbmV3IG9yKCk7XG4gIGkgPT09IDEgPyByID0gZGUgKyBUdCA6IGkgPT09IC0xICYmIChyID0gLWRlIC0gVHQpO1xuICBmb3IgKHZhciBjID0gMCwgdSA9IGUubGVuZ3RoOyBjIDwgdTsgKytjKVxuICAgIGlmIChoID0gKGQgPSBlW2NdKS5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBkLCBoLCBwID0gZFtoIC0gMV0sIGYgPSBabyhwKSwgZyA9IHBbMV0gLyAyICsgVGQsIG0gPSB4dChnKSwgdiA9IFN0KGcpLCB4ID0gMDsgeCA8IGg7ICsreCwgZiA9IEUsIG0gPSBTLCB2ID0gTSwgcCA9IF8pIHtcbiAgICAgICAgdmFyIF8gPSBkW3hdLCBFID0gWm8oXyksIGIgPSBfWzFdIC8gMiArIFRkLCBTID0geHQoYiksIE0gPSBTdChiKSwgRCA9IEUgLSBmLCBBID0gRCA+PSAwID8gMSA6IC0xLCBSID0gQSAqIEQsICQgPSBSID4gZnQsIEggPSBtICogUztcbiAgICAgICAgaWYgKGwuYWRkKGxyKEggKiBBICogeHQoUiksIHYgKiBNICsgSCAqIFN0KFIpKSksIGEgKz0gJCA/IEQgKyBBICogRWUgOiBELCAkIF4gZiA+PSBuIF4gRSA+PSBuKSB7XG4gICAgICAgICAgdmFyIFAgPSBNYSh0aShwKSwgdGkoXykpO1xuICAgICAgICAgIGpsKFApO1xuICAgICAgICAgIHZhciBCID0gTWEocywgUCk7XG4gICAgICAgICAgamwoQik7XG4gICAgICAgICAgdmFyIE8gPSAoJCBeIEQgPj0gMCA/IC0xIDogMSkgKiBDbihCWzJdKTtcbiAgICAgICAgICAociA+IE8gfHwgciA9PT0gTyAmJiAoUFswXSB8fCBQWzFdKSkgJiYgKG8gKz0gJCBeIEQgPj0gMCA/IDEgOiAtMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgcmV0dXJuIChhIDwgLTFlLTYgfHwgYSA8IFR0ICYmIGwgPCAtMWUtMTIpIF4gbyAmIDE7XG59XG5mdW5jdGlvbiBCZyhlLCB0LCBuLCByKSB7XG4gIHJldHVybiBmdW5jdGlvbihpKSB7XG4gICAgdmFyIHMgPSB0KGkpLCBhID0gUGcoKSwgbyA9IHQoYSksIGwgPSAhMSwgYywgdSwgZCwgaCA9IHtcbiAgICAgIHBvaW50OiBwLFxuICAgICAgbGluZVN0YXJ0OiBnLFxuICAgICAgbGluZUVuZDogbSxcbiAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGgucG9pbnQgPSB2LCBoLmxpbmVTdGFydCA9IHgsIGgubGluZUVuZCA9IF8sIHUgPSBbXSwgYyA9IFtdO1xuICAgICAgfSxcbiAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBoLnBvaW50ID0gcCwgaC5saW5lU3RhcnQgPSBnLCBoLmxpbmVFbmQgPSBtLCB1ID0gQWcodSk7XG4gICAgICAgIHZhciBFID0gZkEoYywgcik7XG4gICAgICAgIHUubGVuZ3RoID8gKGwgfHwgKGkucG9seWdvblN0YXJ0KCksIGwgPSAhMCksIFVnKHUsIGdBLCBFLCBuLCBpKSkgOiBFICYmIChsIHx8IChpLnBvbHlnb25TdGFydCgpLCBsID0gITApLCBpLmxpbmVTdGFydCgpLCBuKG51bGwsIG51bGwsIDEsIGkpLCBpLmxpbmVFbmQoKSksIGwgJiYgKGkucG9seWdvbkVuZCgpLCBsID0gITEpLCB1ID0gYyA9IG51bGw7XG4gICAgICB9LFxuICAgICAgc3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaS5wb2x5Z29uU3RhcnQoKSwgaS5saW5lU3RhcnQoKSwgbihudWxsLCBudWxsLCAxLCBpKSwgaS5saW5lRW5kKCksIGkucG9seWdvbkVuZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gcChFLCBiKSB7XG4gICAgICBlKEUsIGIpICYmIGkucG9pbnQoRSwgYik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGYoRSwgYikge1xuICAgICAgcy5wb2ludChFLCBiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZygpIHtcbiAgICAgIGgucG9pbnQgPSBmLCBzLmxpbmVTdGFydCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtKCkge1xuICAgICAgaC5wb2ludCA9IHAsIHMubGluZUVuZCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2KEUsIGIpIHtcbiAgICAgIGQucHVzaChbRSwgYl0pLCBvLnBvaW50KEUsIGIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB4KCkge1xuICAgICAgby5saW5lU3RhcnQoKSwgZCA9IFtdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfKCkge1xuICAgICAgdihkWzBdWzBdLCBkWzBdWzFdKSwgby5saW5lRW5kKCk7XG4gICAgICB2YXIgRSA9IG8uY2xlYW4oKSwgYiA9IGEucmVzdWx0KCksIFMsIE0gPSBiLmxlbmd0aCwgRCwgQSwgUjtcbiAgICAgIGlmIChkLnBvcCgpLCBjLnB1c2goZCksIGQgPSBudWxsLCAhIU0pIHtcbiAgICAgICAgaWYgKEUgJiAxKSB7XG4gICAgICAgICAgaWYgKEEgPSBiWzBdLCAoRCA9IEEubGVuZ3RoIC0gMSkgPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGwgfHwgKGkucG9seWdvblN0YXJ0KCksIGwgPSAhMCksIGkubGluZVN0YXJ0KCksIFMgPSAwOyBTIDwgRDsgKytTKSBpLnBvaW50KChSID0gQVtTXSlbMF0sIFJbMV0pO1xuICAgICAgICAgICAgaS5saW5lRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBNID4gMSAmJiBFICYgMiAmJiBiLnB1c2goYi5wb3AoKS5jb25jYXQoYi5zaGlmdCgpKSksIHUucHVzaChiLmZpbHRlcihtQSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaDtcbiAgfTtcbn1cbmZ1bmN0aW9uIG1BKGUpIHtcbiAgcmV0dXJuIGUubGVuZ3RoID4gMTtcbn1cbmZ1bmN0aW9uIGdBKGUsIHQpIHtcbiAgcmV0dXJuICgoZSA9IGUueClbMF0gPCAwID8gZVsxXSAtIGRlIC0gVHQgOiBkZSAtIGVbMV0pIC0gKCh0ID0gdC54KVswXSA8IDAgPyB0WzFdIC0gZGUgLSBUdCA6IGRlIC0gdFsxXSk7XG59XG5jb25zdCBSZCA9IEJnKFxuICBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gITA7XG4gIH0sXG4gIHZBLFxuICB4QSxcbiAgWy1mdCwgLWRlXVxuKTtcbmZ1bmN0aW9uIHZBKGUpIHtcbiAgdmFyIHQgPSBOYU4sIG4gPSBOYU4sIHIgPSBOYU4sIGk7XG4gIHJldHVybiB7XG4gICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGUubGluZVN0YXJ0KCksIGkgPSAxO1xuICAgIH0sXG4gICAgcG9pbnQ6IGZ1bmN0aW9uKHMsIGEpIHtcbiAgICAgIHZhciBvID0gcyA+IDAgPyBmdCA6IC1mdCwgbCA9IE90KHMgLSB0KTtcbiAgICAgIE90KGwgLSBmdCkgPCBUdCA/IChlLnBvaW50KHQsIG4gPSAobiArIGEpIC8gMiA+IDAgPyBkZSA6IC1kZSksIGUucG9pbnQociwgbiksIGUubGluZUVuZCgpLCBlLmxpbmVTdGFydCgpLCBlLnBvaW50KG8sIG4pLCBlLnBvaW50KHMsIG4pLCBpID0gMCkgOiByICE9PSBvICYmIGwgPj0gZnQgJiYgKE90KHQgLSByKSA8IFR0ICYmICh0IC09IHIgKiBUdCksIE90KHMgLSBvKSA8IFR0ICYmIChzIC09IG8gKiBUdCksIG4gPSB5QSh0LCBuLCBzLCBhKSwgZS5wb2ludChyLCBuKSwgZS5saW5lRW5kKCksIGUubGluZVN0YXJ0KCksIGUucG9pbnQobywgbiksIGkgPSAwKSwgZS5wb2ludCh0ID0gcywgbiA9IGEpLCByID0gbztcbiAgICB9LFxuICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZS5saW5lRW5kKCksIHQgPSBuID0gTmFOO1xuICAgIH0sXG4gICAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDIgLSBpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHlBKGUsIHQsIG4sIHIpIHtcbiAgdmFyIGksIHMsIGEgPSB4dChlIC0gbik7XG4gIHJldHVybiBPdChhKSA+IFR0ID8gSWcoKHh0KHQpICogKHMgPSBTdChyKSkgKiB4dChuKSAtIHh0KHIpICogKGkgPSBTdCh0KSkgKiB4dChlKSkgLyAoaSAqIHMgKiBhKSkgOiAodCArIHIpIC8gMjtcbn1cbmZ1bmN0aW9uIHhBKGUsIHQsIG4sIHIpIHtcbiAgdmFyIGk7XG4gIGlmIChlID09IG51bGwpXG4gICAgaSA9IG4gKiBkZSwgci5wb2ludCgtZnQsIGkpLCByLnBvaW50KDAsIGkpLCByLnBvaW50KGZ0LCBpKSwgci5wb2ludChmdCwgMCksIHIucG9pbnQoZnQsIC1pKSwgci5wb2ludCgwLCAtaSksIHIucG9pbnQoLWZ0LCAtaSksIHIucG9pbnQoLWZ0LCAwKSwgci5wb2ludCgtZnQsIGkpO1xuICBlbHNlIGlmIChPdChlWzBdIC0gdFswXSkgPiBUdCkge1xuICAgIHZhciBzID0gZVswXSA8IHRbMF0gPyBmdCA6IC1mdDtcbiAgICBpID0gbiAqIHMgLyAyLCByLnBvaW50KC1zLCBpKSwgci5wb2ludCgwLCBpKSwgci5wb2ludChzLCBpKTtcbiAgfSBlbHNlXG4gICAgci5wb2ludCh0WzBdLCB0WzFdKTtcbn1cbmZ1bmN0aW9uIGJBKGUpIHtcbiAgdmFyIHQgPSBTdChlKSwgbiA9IDIgKiBCdCwgciA9IHQgPiAwLCBpID0gT3QodCkgPiBUdDtcbiAgZnVuY3Rpb24gcyh1LCBkLCBoLCBwKSB7XG4gICAgcEEocCwgZSwgbiwgaCwgdSwgZCk7XG4gIH1cbiAgZnVuY3Rpb24gYSh1LCBkKSB7XG4gICAgcmV0dXJuIFN0KHUpICogU3QoZCkgPiB0O1xuICB9XG4gIGZ1bmN0aW9uIG8odSkge1xuICAgIHZhciBkLCBoLCBwLCBmLCBnO1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmID0gcCA9ICExLCBnID0gMTtcbiAgICAgIH0sXG4gICAgICBwb2ludDogZnVuY3Rpb24obSwgdikge1xuICAgICAgICB2YXIgeCA9IFttLCB2XSwgXywgRSA9IGEobSwgdiksIGIgPSByID8gRSA/IDAgOiBjKG0sIHYpIDogRSA/IGMobSArIChtIDwgMCA/IGZ0IDogLWZ0KSwgdikgOiAwO1xuICAgICAgICBpZiAoIWQgJiYgKGYgPSBwID0gRSkgJiYgdS5saW5lU3RhcnQoKSwgRSAhPT0gcCAmJiAoXyA9IGwoZCwgeCksICghXyB8fCBlYShkLCBfKSB8fCBlYSh4LCBfKSkgJiYgKHhbMl0gPSAxKSksIEUgIT09IHApXG4gICAgICAgICAgZyA9IDAsIEUgPyAodS5saW5lU3RhcnQoKSwgXyA9IGwoeCwgZCksIHUucG9pbnQoX1swXSwgX1sxXSkpIDogKF8gPSBsKGQsIHgpLCB1LnBvaW50KF9bMF0sIF9bMV0sIDIpLCB1LmxpbmVFbmQoKSksIGQgPSBfO1xuICAgICAgICBlbHNlIGlmIChpICYmIGQgJiYgciBeIEUpIHtcbiAgICAgICAgICB2YXIgUztcbiAgICAgICAgICAhKGIgJiBoKSAmJiAoUyA9IGwoeCwgZCwgITApKSAmJiAoZyA9IDAsIHIgPyAodS5saW5lU3RhcnQoKSwgdS5wb2ludChTWzBdWzBdLCBTWzBdWzFdKSwgdS5wb2ludChTWzFdWzBdLCBTWzFdWzFdKSwgdS5saW5lRW5kKCkpIDogKHUucG9pbnQoU1sxXVswXSwgU1sxXVsxXSksIHUubGluZUVuZCgpLCB1LmxpbmVTdGFydCgpLCB1LnBvaW50KFNbMF1bMF0sIFNbMF1bMV0sIDMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgRSAmJiAoIWQgfHwgIWVhKGQsIHgpKSAmJiB1LnBvaW50KHhbMF0sIHhbMV0pLCBkID0geCwgcCA9IEUsIGggPSBiO1xuICAgICAgfSxcbiAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBwICYmIHUubGluZUVuZCgpLCBkID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICAvLyBSZWpvaW4gZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHMgaWYgdGhlcmUgd2VyZSBpbnRlcnNlY3Rpb25zIGFuZCB0aGUgZmlyc3RcbiAgICAgIC8vIGFuZCBsYXN0IHBvaW50cyB3ZXJlIHZpc2libGUuXG4gICAgICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnIHwgKGYgJiYgcCkgPDwgMTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGwodSwgZCwgaCkge1xuICAgIHZhciBwID0gdGkodSksIGYgPSB0aShkKSwgZyA9IFsxLCAwLCAwXSwgbSA9IE1hKHAsIGYpLCB2ID0ga3MobSwgbSksIHggPSBtWzBdLCBfID0gdiAtIHggKiB4O1xuICAgIGlmICghXykgcmV0dXJuICFoICYmIHU7XG4gICAgdmFyIEUgPSB0ICogdiAvIF8sIGIgPSAtdCAqIHggLyBfLCBTID0gTWEoZywgbSksIE0gPSBEcyhnLCBFKSwgRCA9IERzKG0sIGIpO1xuICAgIFhvKE0sIEQpO1xuICAgIHZhciBBID0gUywgUiA9IGtzKE0sIEEpLCAkID0ga3MoQSwgQSksIEggPSBSICogUiAtICQgKiAoa3MoTSwgTSkgLSAxKTtcbiAgICBpZiAoIShIIDwgMCkpIHtcbiAgICAgIHZhciBQID0gamUoSCksIEIgPSBEcyhBLCAoLVIgLSBQKSAvICQpO1xuICAgICAgaWYgKFhvKEIsIE0pLCBCID0gRmwoQiksICFoKSByZXR1cm4gQjtcbiAgICAgIHZhciBPID0gdVswXSwgdyA9IGRbMF0sIEwgPSB1WzFdLCBrID0gZFsxXSwgVTtcbiAgICAgIHcgPCBPICYmIChVID0gTywgTyA9IHcsIHcgPSBVKTtcbiAgICAgIHZhciBaID0gdyAtIE8sIGogPSBPdChaIC0gZnQpIDwgVHQsIEYgPSBqIHx8IFogPCBUdDtcbiAgICAgIGlmICghaiAmJiBrIDwgTCAmJiAoVSA9IEwsIEwgPSBrLCBrID0gVSksIEYgPyBqID8gTCArIGsgPiAwIF4gQlsxXSA8IChPdChCWzBdIC0gTykgPCBUdCA/IEwgOiBrKSA6IEwgPD0gQlsxXSAmJiBCWzFdIDw9IGsgOiBaID4gZnQgXiAoTyA8PSBCWzBdICYmIEJbMF0gPD0gdykpIHtcbiAgICAgICAgdmFyIFkgPSBEcyhBLCAoLVIgKyBQKSAvICQpO1xuICAgICAgICByZXR1cm4gWG8oWSwgTSksIFtCLCBGbChZKV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGModSwgZCkge1xuICAgIHZhciBoID0gciA/IGUgOiBmdCAtIGUsIHAgPSAwO1xuICAgIHJldHVybiB1IDwgLWggPyBwIHw9IDEgOiB1ID4gaCAmJiAocCB8PSAyKSwgZCA8IC1oID8gcCB8PSA0IDogZCA+IGggJiYgKHAgfD0gOCksIHA7XG4gIH1cbiAgcmV0dXJuIEJnKGEsIG8sIHMsIHIgPyBbMCwgLWVdIDogWy1mdCwgZSAtIGZ0XSk7XG59XG5mdW5jdGlvbiBfQShlLCB0LCBuLCByLCBpLCBzKSB7XG4gIHZhciBhID0gZVswXSwgbyA9IGVbMV0sIGwgPSB0WzBdLCBjID0gdFsxXSwgdSA9IDAsIGQgPSAxLCBoID0gbCAtIGEsIHAgPSBjIC0gbywgZjtcbiAgaWYgKGYgPSBuIC0gYSwgISghaCAmJiBmID4gMCkpIHtcbiAgICBpZiAoZiAvPSBoLCBoIDwgMCkge1xuICAgICAgaWYgKGYgPCB1KSByZXR1cm47XG4gICAgICBmIDwgZCAmJiAoZCA9IGYpO1xuICAgIH0gZWxzZSBpZiAoaCA+IDApIHtcbiAgICAgIGlmIChmID4gZCkgcmV0dXJuO1xuICAgICAgZiA+IHUgJiYgKHUgPSBmKTtcbiAgICB9XG4gICAgaWYgKGYgPSBpIC0gYSwgISghaCAmJiBmIDwgMCkpIHtcbiAgICAgIGlmIChmIC89IGgsIGggPCAwKSB7XG4gICAgICAgIGlmIChmID4gZCkgcmV0dXJuO1xuICAgICAgICBmID4gdSAmJiAodSA9IGYpO1xuICAgICAgfSBlbHNlIGlmIChoID4gMCkge1xuICAgICAgICBpZiAoZiA8IHUpIHJldHVybjtcbiAgICAgICAgZiA8IGQgJiYgKGQgPSBmKTtcbiAgICAgIH1cbiAgICAgIGlmIChmID0gciAtIG8sICEoIXAgJiYgZiA+IDApKSB7XG4gICAgICAgIGlmIChmIC89IHAsIHAgPCAwKSB7XG4gICAgICAgICAgaWYgKGYgPCB1KSByZXR1cm47XG4gICAgICAgICAgZiA8IGQgJiYgKGQgPSBmKTtcbiAgICAgICAgfSBlbHNlIGlmIChwID4gMCkge1xuICAgICAgICAgIGlmIChmID4gZCkgcmV0dXJuO1xuICAgICAgICAgIGYgPiB1ICYmICh1ID0gZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGYgPSBzIC0gbywgISghcCAmJiBmIDwgMCkpIHtcbiAgICAgICAgICBpZiAoZiAvPSBwLCBwIDwgMCkge1xuICAgICAgICAgICAgaWYgKGYgPiBkKSByZXR1cm47XG4gICAgICAgICAgICBmID4gdSAmJiAodSA9IGYpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA+IDApIHtcbiAgICAgICAgICAgIGlmIChmIDwgdSkgcmV0dXJuO1xuICAgICAgICAgICAgZiA8IGQgJiYgKGQgPSBmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHUgPiAwICYmIChlWzBdID0gYSArIHUgKiBoLCBlWzFdID0gbyArIHUgKiBwKSwgZCA8IDEgJiYgKHRbMF0gPSBhICsgZCAqIGgsIHRbMV0gPSBvICsgZCAqIHApLCAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxudmFyIElzID0gMWU5LCBOcyA9IC0xZTk7XG5mdW5jdGlvbiBFQShlLCB0LCBuLCByKSB7XG4gIGZ1bmN0aW9uIGkoYywgdSkge1xuICAgIHJldHVybiBlIDw9IGMgJiYgYyA8PSBuICYmIHQgPD0gdSAmJiB1IDw9IHI7XG4gIH1cbiAgZnVuY3Rpb24gcyhjLCB1LCBkLCBoKSB7XG4gICAgdmFyIHAgPSAwLCBmID0gMDtcbiAgICBpZiAoYyA9PSBudWxsIHx8IChwID0gYShjLCBkKSkgIT09IChmID0gYSh1LCBkKSkgfHwgbChjLCB1KSA8IDAgXiBkID4gMClcbiAgICAgIGRvXG4gICAgICAgIGgucG9pbnQocCA9PT0gMCB8fCBwID09PSAzID8gZSA6IG4sIHAgPiAxID8gciA6IHQpO1xuICAgICAgd2hpbGUgKChwID0gKHAgKyBkICsgNCkgJSA0KSAhPT0gZik7XG4gICAgZWxzZVxuICAgICAgaC5wb2ludCh1WzBdLCB1WzFdKTtcbiAgfVxuICBmdW5jdGlvbiBhKGMsIHUpIHtcbiAgICByZXR1cm4gT3QoY1swXSAtIGUpIDwgVHQgPyB1ID4gMCA/IDAgOiAzIDogT3QoY1swXSAtIG4pIDwgVHQgPyB1ID4gMCA/IDIgOiAxIDogT3QoY1sxXSAtIHQpIDwgVHQgPyB1ID4gMCA/IDEgOiAwIDogdSA+IDAgPyAzIDogMjtcbiAgfVxuICBmdW5jdGlvbiBvKGMsIHUpIHtcbiAgICByZXR1cm4gbChjLngsIHUueCk7XG4gIH1cbiAgZnVuY3Rpb24gbChjLCB1KSB7XG4gICAgdmFyIGQgPSBhKGMsIDEpLCBoID0gYSh1LCAxKTtcbiAgICByZXR1cm4gZCAhPT0gaCA/IGQgLSBoIDogZCA9PT0gMCA/IHVbMV0gLSBjWzFdIDogZCA9PT0gMSA/IGNbMF0gLSB1WzBdIDogZCA9PT0gMiA/IGNbMV0gLSB1WzFdIDogdVswXSAtIGNbMF07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKGMpIHtcbiAgICB2YXIgdSA9IGMsIGQgPSBQZygpLCBoLCBwLCBmLCBnLCBtLCB2LCB4LCBfLCBFLCBiLCBTLCBNID0ge1xuICAgICAgcG9pbnQ6IEQsXG4gICAgICBsaW5lU3RhcnQ6IEgsXG4gICAgICBsaW5lRW5kOiBQLFxuICAgICAgcG9seWdvblN0YXJ0OiBSLFxuICAgICAgcG9seWdvbkVuZDogJFxuICAgIH07XG4gICAgZnVuY3Rpb24gRChPLCB3KSB7XG4gICAgICBpKE8sIHcpICYmIHUucG9pbnQoTywgdyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEEoKSB7XG4gICAgICBmb3IgKHZhciBPID0gMCwgdyA9IDAsIEwgPSBwLmxlbmd0aDsgdyA8IEw7ICsrdylcbiAgICAgICAgZm9yICh2YXIgayA9IHBbd10sIFUgPSAxLCBaID0gay5sZW5ndGgsIGogPSBrWzBdLCBGLCBZLCBvdCA9IGpbMF0sIFEgPSBqWzFdOyBVIDwgWjsgKytVKVxuICAgICAgICAgIEYgPSBvdCwgWSA9IFEsIGogPSBrW1VdLCBvdCA9IGpbMF0sIFEgPSBqWzFdLCBZIDw9IHIgPyBRID4gciAmJiAob3QgLSBGKSAqIChyIC0gWSkgPiAoUSAtIFkpICogKGUgLSBGKSAmJiArK08gOiBRIDw9IHIgJiYgKG90IC0gRikgKiAociAtIFkpIDwgKFEgLSBZKSAqIChlIC0gRikgJiYgLS1PO1xuICAgICAgcmV0dXJuIE87XG4gICAgfVxuICAgIGZ1bmN0aW9uIFIoKSB7XG4gICAgICB1ID0gZCwgaCA9IFtdLCBwID0gW10sIFMgPSAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gJCgpIHtcbiAgICAgIHZhciBPID0gQSgpLCB3ID0gUyAmJiBPLCBMID0gKGggPSBBZyhoKSkubGVuZ3RoO1xuICAgICAgKHcgfHwgTCkgJiYgKGMucG9seWdvblN0YXJ0KCksIHcgJiYgKGMubGluZVN0YXJ0KCksIHMobnVsbCwgbnVsbCwgMSwgYyksIGMubGluZUVuZCgpKSwgTCAmJiBVZyhoLCBvLCBPLCBzLCBjKSwgYy5wb2x5Z29uRW5kKCkpLCB1ID0gYywgaCA9IHAgPSBmID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gSCgpIHtcbiAgICAgIE0ucG9pbnQgPSBCLCBwICYmIHAucHVzaChmID0gW10pLCBiID0gITAsIEUgPSAhMSwgeCA9IF8gPSBOYU47XG4gICAgfVxuICAgIGZ1bmN0aW9uIFAoKSB7XG4gICAgICBoICYmIChCKGcsIG0pLCB2ICYmIEUgJiYgZC5yZWpvaW4oKSwgaC5wdXNoKGQucmVzdWx0KCkpKSwgTS5wb2ludCA9IEQsIEUgJiYgdS5saW5lRW5kKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEIoTywgdykge1xuICAgICAgdmFyIEwgPSBpKE8sIHcpO1xuICAgICAgaWYgKHAgJiYgZi5wdXNoKFtPLCB3XSksIGIpXG4gICAgICAgIGcgPSBPLCBtID0gdywgdiA9IEwsIGIgPSAhMSwgTCAmJiAodS5saW5lU3RhcnQoKSwgdS5wb2ludChPLCB3KSk7XG4gICAgICBlbHNlIGlmIChMICYmIEUpIHUucG9pbnQoTywgdyk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGsgPSBbeCA9IE1hdGgubWF4KE5zLCBNYXRoLm1pbihJcywgeCkpLCBfID0gTWF0aC5tYXgoTnMsIE1hdGgubWluKElzLCBfKSldLCBVID0gW08gPSBNYXRoLm1heChOcywgTWF0aC5taW4oSXMsIE8pKSwgdyA9IE1hdGgubWF4KE5zLCBNYXRoLm1pbihJcywgdykpXTtcbiAgICAgICAgX0EoaywgVSwgZSwgdCwgbiwgcikgPyAoRSB8fCAodS5saW5lU3RhcnQoKSwgdS5wb2ludChrWzBdLCBrWzFdKSksIHUucG9pbnQoVVswXSwgVVsxXSksIEwgfHwgdS5saW5lRW5kKCksIFMgPSAhMSkgOiBMICYmICh1LmxpbmVTdGFydCgpLCB1LnBvaW50KE8sIHcpLCBTID0gITEpO1xuICAgICAgfVxuICAgICAgeCA9IE8sIF8gPSB3LCBFID0gTDtcbiAgICB9XG4gICAgcmV0dXJuIE07XG4gIH07XG59XG5jb25zdCBZbCA9IChlKSA9PiBlO1xudmFyIEtvID0gbmV3IG9yKCksIFhsID0gbmV3IG9yKCksIEhnLCBWZywgWmwsIEtsLCB4biA9IHtcbiAgcG9pbnQ6IEFlLFxuICBsaW5lU3RhcnQ6IEFlLFxuICBsaW5lRW5kOiBBZSxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB4bi5saW5lU3RhcnQgPSBPQSwgeG4ubGluZUVuZCA9IFRBO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICB4bi5saW5lU3RhcnQgPSB4bi5saW5lRW5kID0geG4ucG9pbnQgPSBBZSwgS28uYWRkKE90KFhsKSksIFhsID0gbmV3IG9yKCk7XG4gIH0sXG4gIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGUgPSBLbyAvIDI7XG4gICAgcmV0dXJuIEtvID0gbmV3IG9yKCksIGU7XG4gIH1cbn07XG5mdW5jdGlvbiBPQSgpIHtcbiAgeG4ucG9pbnQgPSBTQTtcbn1cbmZ1bmN0aW9uIFNBKGUsIHQpIHtcbiAgeG4ucG9pbnQgPSBHZywgSGcgPSBabCA9IGUsIFZnID0gS2wgPSB0O1xufVxuZnVuY3Rpb24gR2coZSwgdCkge1xuICBYbC5hZGQoS2wgKiBlIC0gWmwgKiB0KSwgWmwgPSBlLCBLbCA9IHQ7XG59XG5mdW5jdGlvbiBUQSgpIHtcbiAgR2coSGcsIFZnKTtcbn1cbnZhciBlaSA9IDEgLyAwLCBDYSA9IGVpLCBycyA9IC1laSwgQWEgPSBycywgTGEgPSB7XG4gIHBvaW50OiB3QSxcbiAgbGluZVN0YXJ0OiBBZSxcbiAgbGluZUVuZDogQWUsXG4gIHBvbHlnb25TdGFydDogQWUsXG4gIHBvbHlnb25FbmQ6IEFlLFxuICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlID0gW1tlaSwgQ2FdLCBbcnMsIEFhXV07XG4gICAgcmV0dXJuIHJzID0gQWEgPSAtKENhID0gZWkgPSAxIC8gMCksIGU7XG4gIH1cbn07XG5mdW5jdGlvbiB3QShlLCB0KSB7XG4gIGUgPCBlaSAmJiAoZWkgPSBlKSwgZSA+IHJzICYmIChycyA9IGUpLCB0IDwgQ2EgJiYgKENhID0gdCksIHQgPiBBYSAmJiAoQWEgPSB0KTtcbn1cbnZhciBRbCA9IDAsIEpsID0gMCwgQWkgPSAwLCBrYSA9IDAsIERhID0gMCwgSHIgPSAwLCB0YyA9IDAsIGVjID0gMCwgTGkgPSAwLCB6ZywgRmcsIFFlLCBKZSwgTWUgPSB7XG4gIHBvaW50OiBjcixcbiAgbGluZVN0YXJ0OiBJZCxcbiAgbGluZUVuZDogTmQsXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgTWUubGluZVN0YXJ0ID0gQ0EsIE1lLmxpbmVFbmQgPSBBQTtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgTWUucG9pbnQgPSBjciwgTWUubGluZVN0YXJ0ID0gSWQsIE1lLmxpbmVFbmQgPSBOZDtcbiAgfSxcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZSA9IExpID8gW3RjIC8gTGksIGVjIC8gTGldIDogSHIgPyBba2EgLyBIciwgRGEgLyBIcl0gOiBBaSA/IFtRbCAvIEFpLCBKbCAvIEFpXSA6IFtOYU4sIE5hTl07XG4gICAgcmV0dXJuIFFsID0gSmwgPSBBaSA9IGthID0gRGEgPSBIciA9IHRjID0gZWMgPSBMaSA9IDAsIGU7XG4gIH1cbn07XG5mdW5jdGlvbiBjcihlLCB0KSB7XG4gIFFsICs9IGUsIEpsICs9IHQsICsrQWk7XG59XG5mdW5jdGlvbiBJZCgpIHtcbiAgTWUucG9pbnQgPSAkQTtcbn1cbmZ1bmN0aW9uICRBKGUsIHQpIHtcbiAgTWUucG9pbnQgPSBNQSwgY3IoUWUgPSBlLCBKZSA9IHQpO1xufVxuZnVuY3Rpb24gTUEoZSwgdCkge1xuICB2YXIgbiA9IGUgLSBRZSwgciA9IHQgLSBKZSwgaSA9IGplKG4gKiBuICsgciAqIHIpO1xuICBrYSArPSBpICogKFFlICsgZSkgLyAyLCBEYSArPSBpICogKEplICsgdCkgLyAyLCBIciArPSBpLCBjcihRZSA9IGUsIEplID0gdCk7XG59XG5mdW5jdGlvbiBOZCgpIHtcbiAgTWUucG9pbnQgPSBjcjtcbn1cbmZ1bmN0aW9uIENBKCkge1xuICBNZS5wb2ludCA9IExBO1xufVxuZnVuY3Rpb24gQUEoKSB7XG4gIGpnKHpnLCBGZyk7XG59XG5mdW5jdGlvbiBMQShlLCB0KSB7XG4gIE1lLnBvaW50ID0gamcsIGNyKHpnID0gUWUgPSBlLCBGZyA9IEplID0gdCk7XG59XG5mdW5jdGlvbiBqZyhlLCB0KSB7XG4gIHZhciBuID0gZSAtIFFlLCByID0gdCAtIEplLCBpID0gamUobiAqIG4gKyByICogcik7XG4gIGthICs9IGkgKiAoUWUgKyBlKSAvIDIsIERhICs9IGkgKiAoSmUgKyB0KSAvIDIsIEhyICs9IGksIGkgPSBKZSAqIGUgLSBRZSAqIHQsIHRjICs9IGkgKiAoUWUgKyBlKSwgZWMgKz0gaSAqIChKZSArIHQpLCBMaSArPSBpICogMywgY3IoUWUgPSBlLCBKZSA9IHQpO1xufVxuZnVuY3Rpb24gV2coZSkge1xuICB0aGlzLl9jb250ZXh0ID0gZTtcbn1cbldnLnByb3RvdHlwZSA9IHtcbiAgX3JhZGl1czogNC41LFxuICBwb2ludFJhZGl1czogZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiB0aGlzLl9yYWRpdXMgPSBlLCB0aGlzO1xuICB9LFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9PT0gMCAmJiB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpLCB0aGlzLl9wb2ludCA9IE5hTjtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oZSwgdCksIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oZSwgdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyhlICsgdGhpcy5fcmFkaXVzLCB0KSwgdGhpcy5fY29udGV4dC5hcmMoZSwgdCwgdGhpcy5fcmFkaXVzLCAwLCBFZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcmVzdWx0OiBBZVxufTtcbnZhciBuYyA9IG5ldyBvcigpLCBRbywgcWcsIFlnLCBraSwgRGksIGlzID0ge1xuICBwb2ludDogQWUsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgaXMucG9pbnQgPSBrQTtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgUW8gJiYgWGcocWcsIFlnKSwgaXMucG9pbnQgPSBBZTtcbiAgfSxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBRbyA9ICEwO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICBRbyA9IG51bGw7XG4gIH0sXG4gIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGUgPSArbmM7XG4gICAgcmV0dXJuIG5jID0gbmV3IG9yKCksIGU7XG4gIH1cbn07XG5mdW5jdGlvbiBrQShlLCB0KSB7XG4gIGlzLnBvaW50ID0gWGcsIHFnID0ga2kgPSBlLCBZZyA9IERpID0gdDtcbn1cbmZ1bmN0aW9uIFhnKGUsIHQpIHtcbiAga2kgLT0gZSwgRGkgLT0gdCwgbmMuYWRkKGplKGtpICoga2kgKyBEaSAqIERpKSksIGtpID0gZSwgRGkgPSB0O1xufVxubGV0IFBkLCBSYSwgVWQsIEJkO1xuY2xhc3MgSGQge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdGhpcy5fYXBwZW5kID0gdCA9PSBudWxsID8gWmcgOiBEQSh0KSwgdGhpcy5fcmFkaXVzID0gNC41LCB0aGlzLl8gPSBcIlwiO1xuICB9XG4gIHBvaW50UmFkaXVzKHQpIHtcbiAgICByZXR1cm4gdGhpcy5fcmFkaXVzID0gK3QsIHRoaXM7XG4gIH1cbiAgcG9seWdvblN0YXJ0KCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9XG4gIHBvbHlnb25FbmQoKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfVxuICBsaW5lU3RhcnQoKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9XG4gIGxpbmVFbmQoKSB7XG4gICAgdGhpcy5fbGluZSA9PT0gMCAmJiAodGhpcy5fICs9IFwiWlwiKSwgdGhpcy5fcG9pbnQgPSBOYU47XG4gIH1cbiAgcG9pbnQodCwgbikge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDoge1xuICAgICAgICB0aGlzLl9hcHBlbmRgTSR7dH0sJHtufWAsIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fYXBwZW5kYEwke3R9LCR7bn1gO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgaWYgKHRoaXMuX2FwcGVuZGBNJHt0fSwke259YCwgdGhpcy5fcmFkaXVzICE9PSBVZCB8fCB0aGlzLl9hcHBlbmQgIT09IFJhKSB7XG4gICAgICAgICAgY29uc3QgciA9IHRoaXMuX3JhZGl1cywgaSA9IHRoaXMuXztcbiAgICAgICAgICB0aGlzLl8gPSBcIlwiLCB0aGlzLl9hcHBlbmRgbTAsJHtyfWEke3J9LCR7cn0gMCAxLDEgMCwkey0yICogcn1hJHtyfSwke3J9IDAgMSwxIDAsJHsyICogcn16YCwgVWQgPSByLCBSYSA9IHRoaXMuX2FwcGVuZCwgQmQgPSB0aGlzLl8sIHRoaXMuXyA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fICs9IEJkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVzdWx0KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl87XG4gICAgcmV0dXJuIHRoaXMuXyA9IFwiXCIsIHQubGVuZ3RoID8gdCA6IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIFpnKGUpIHtcbiAgbGV0IHQgPSAxO1xuICB0aGlzLl8gKz0gZVswXTtcbiAgZm9yIChjb25zdCBuID0gZS5sZW5ndGg7IHQgPCBuOyArK3QpXG4gICAgdGhpcy5fICs9IGFyZ3VtZW50c1t0XSArIGVbdF07XG59XG5mdW5jdGlvbiBEQShlKSB7XG4gIGNvbnN0IHQgPSBNYXRoLmZsb29yKGUpO1xuICBpZiAoISh0ID49IDApKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgaW52YWxpZCBkaWdpdHM6ICR7ZX1gKTtcbiAgaWYgKHQgPiAxNSkgcmV0dXJuIFpnO1xuICBpZiAodCAhPT0gUGQpIHtcbiAgICBjb25zdCBuID0gMTAgKiogdDtcbiAgICBQZCA9IHQsIFJhID0gZnVuY3Rpb24ocikge1xuICAgICAgbGV0IGkgPSAxO1xuICAgICAgdGhpcy5fICs9IHJbMF07XG4gICAgICBmb3IgKGNvbnN0IHMgPSByLmxlbmd0aDsgaSA8IHM7ICsraSlcbiAgICAgICAgdGhpcy5fICs9IE1hdGgucm91bmQoYXJndW1lbnRzW2ldICogbikgLyBuICsgcltpXTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBSYTtcbn1cbmZ1bmN0aW9uIFJBKGUsIHQpIHtcbiAgbGV0IG4gPSAzLCByID0gNC41LCBpLCBzO1xuICBmdW5jdGlvbiBhKG8pIHtcbiAgICByZXR1cm4gbyAmJiAodHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiICYmIHMucG9pbnRSYWRpdXMoK3IuYXBwbHkodGhpcywgYXJndW1lbnRzKSksIExyKG8sIGkocykpKSwgcy5yZXN1bHQoKTtcbiAgfVxuICByZXR1cm4gYS5hcmVhID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiBMcihvLCBpKHhuKSksIHhuLnJlc3VsdCgpO1xuICB9LCBhLm1lYXN1cmUgPSBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIExyKG8sIGkoaXMpKSwgaXMucmVzdWx0KCk7XG4gIH0sIGEuYm91bmRzID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiBMcihvLCBpKExhKSksIExhLnJlc3VsdCgpO1xuICB9LCBhLmNlbnRyb2lkID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiBMcihvLCBpKE1lKSksIE1lLnJlc3VsdCgpO1xuICB9LCBhLnByb2plY3Rpb24gPSBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaSA9IG8gPT0gbnVsbCA/IChlID0gbnVsbCwgWWwpIDogKGUgPSBvKS5zdHJlYW0sIGEpIDogZTtcbiAgfSwgYS5jb250ZXh0ID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHMgPSBvID09IG51bGwgPyAodCA9IG51bGwsIG5ldyBIZChuKSkgOiBuZXcgV2codCA9IG8pLCB0eXBlb2YgciAhPSBcImZ1bmN0aW9uXCIgJiYgcy5wb2ludFJhZGl1cyhyKSwgYSkgOiB0O1xuICB9LCBhLnBvaW50UmFkaXVzID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHIgPSB0eXBlb2YgbyA9PSBcImZ1bmN0aW9uXCIgPyBvIDogKHMucG9pbnRSYWRpdXMoK28pLCArbyksIGEpIDogcjtcbiAgfSwgYS5kaWdpdHMgPSBmdW5jdGlvbihvKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbjtcbiAgICBpZiAobyA9PSBudWxsKSBuID0gbnVsbDtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGwgPSBNYXRoLmZsb29yKG8pO1xuICAgICAgaWYgKCEobCA+PSAwKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGludmFsaWQgZGlnaXRzOiAke299YCk7XG4gICAgICBuID0gbDtcbiAgICB9XG4gICAgcmV0dXJuIHQgPT09IG51bGwgJiYgKHMgPSBuZXcgSGQobikpLCBhO1xuICB9LCBhLnByb2plY3Rpb24oZSkuZGlnaXRzKG4pLmNvbnRleHQodCk7XG59XG5mdW5jdGlvbiBldShlKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIG4gPSBuZXcgcmMoKTtcbiAgICBmb3IgKHZhciByIGluIGUpIG5bcl0gPSBlW3JdO1xuICAgIHJldHVybiBuLnN0cmVhbSA9IHQsIG47XG4gIH07XG59XG5mdW5jdGlvbiByYygpIHtcbn1cbnJjLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IHJjLFxuICBwb2ludDogZnVuY3Rpb24oZSwgdCkge1xuICAgIHRoaXMuc3RyZWFtLnBvaW50KGUsIHQpO1xuICB9LFxuICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3RyZWFtLnNwaGVyZSgpO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3RyZWFtLmxpbmVTdGFydCgpO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0cmVhbS5saW5lRW5kKCk7XG4gIH0sXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgfVxufTtcbmZ1bmN0aW9uIG51KGUsIHQsIG4pIHtcbiAgdmFyIHIgPSBlLmNsaXBFeHRlbnQgJiYgZS5jbGlwRXh0ZW50KCk7XG4gIHJldHVybiBlLnNjYWxlKDE1MCkudHJhbnNsYXRlKFswLCAwXSksIHIgIT0gbnVsbCAmJiBlLmNsaXBFeHRlbnQobnVsbCksIExyKG4sIGUuc3RyZWFtKExhKSksIHQoTGEucmVzdWx0KCkpLCByICE9IG51bGwgJiYgZS5jbGlwRXh0ZW50KHIpLCBlO1xufVxuZnVuY3Rpb24gS2coZSwgdCwgbikge1xuICByZXR1cm4gbnUoZSwgZnVuY3Rpb24ocikge1xuICAgIHZhciBpID0gdFsxXVswXSAtIHRbMF1bMF0sIHMgPSB0WzFdWzFdIC0gdFswXVsxXSwgYSA9IE1hdGgubWluKGkgLyAoclsxXVswXSAtIHJbMF1bMF0pLCBzIC8gKHJbMV1bMV0gLSByWzBdWzFdKSksIG8gPSArdFswXVswXSArIChpIC0gYSAqIChyWzFdWzBdICsgclswXVswXSkpIC8gMiwgbCA9ICt0WzBdWzFdICsgKHMgLSBhICogKHJbMV1bMV0gKyByWzBdWzFdKSkgLyAyO1xuICAgIGUuc2NhbGUoMTUwICogYSkudHJhbnNsYXRlKFtvLCBsXSk7XG4gIH0sIG4pO1xufVxuZnVuY3Rpb24gSUEoZSwgdCwgbikge1xuICByZXR1cm4gS2coZSwgW1swLCAwXSwgdF0sIG4pO1xufVxuZnVuY3Rpb24gTkEoZSwgdCwgbikge1xuICByZXR1cm4gbnUoZSwgZnVuY3Rpb24ocikge1xuICAgIHZhciBpID0gK3QsIHMgPSBpIC8gKHJbMV1bMF0gLSByWzBdWzBdKSwgYSA9IChpIC0gcyAqIChyWzFdWzBdICsgclswXVswXSkpIC8gMiwgbyA9IC1zICogclswXVsxXTtcbiAgICBlLnNjYWxlKDE1MCAqIHMpLnRyYW5zbGF0ZShbYSwgb10pO1xuICB9LCBuKTtcbn1cbmZ1bmN0aW9uIFBBKGUsIHQsIG4pIHtcbiAgcmV0dXJuIG51KGUsIGZ1bmN0aW9uKHIpIHtcbiAgICB2YXIgaSA9ICt0LCBzID0gaSAvIChyWzFdWzFdIC0gclswXVsxXSksIGEgPSAtcyAqIHJbMF1bMF0sIG8gPSAoaSAtIHMgKiAoclsxXVsxXSArIHJbMF1bMV0pKSAvIDI7XG4gICAgZS5zY2FsZSgxNTAgKiBzKS50cmFuc2xhdGUoW2EsIG9dKTtcbiAgfSwgbik7XG59XG52YXIgVmQgPSAxNiwgVUEgPSBTdCgzMCAqIEJ0KTtcbmZ1bmN0aW9uIEdkKGUsIHQpIHtcbiAgcmV0dXJuICt0ID8gSEEoZSwgdCkgOiBCQShlKTtcbn1cbmZ1bmN0aW9uIEJBKGUpIHtcbiAgcmV0dXJuIGV1KHtcbiAgICBwb2ludDogZnVuY3Rpb24odCwgbikge1xuICAgICAgdCA9IGUodCwgbiksIHRoaXMuc3RyZWFtLnBvaW50KHRbMF0sIHRbMV0pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBIQShlLCB0KSB7XG4gIGZ1bmN0aW9uIG4ociwgaSwgcywgYSwgbywgbCwgYywgdSwgZCwgaCwgcCwgZiwgZywgbSkge1xuICAgIHZhciB2ID0gYyAtIHIsIHggPSB1IC0gaSwgXyA9IHYgKiB2ICsgeCAqIHg7XG4gICAgaWYgKF8gPiA0ICogdCAmJiBnLS0pIHtcbiAgICAgIHZhciBFID0gYSArIGgsIGIgPSBvICsgcCwgUyA9IGwgKyBmLCBNID0gamUoRSAqIEUgKyBiICogYiArIFMgKiBTKSwgRCA9IENuKFMgLz0gTSksIEEgPSBPdChPdChTKSAtIDEpIDwgVHQgfHwgT3QocyAtIGQpIDwgVHQgPyAocyArIGQpIC8gMiA6IGxyKGIsIEUpLCBSID0gZShBLCBEKSwgJCA9IFJbMF0sIEggPSBSWzFdLCBQID0gJCAtIHIsIEIgPSBIIC0gaSwgTyA9IHggKiBQIC0gdiAqIEI7XG4gICAgICAoTyAqIE8gLyBfID4gdCB8fCBPdCgodiAqIFAgKyB4ICogQikgLyBfIC0gMC41KSA+IDAuMyB8fCBhICogaCArIG8gKiBwICsgbCAqIGYgPCBVQSkgJiYgKG4ociwgaSwgcywgYSwgbywgbCwgJCwgSCwgQSwgRSAvPSBNLCBiIC89IE0sIFMsIGcsIG0pLCBtLnBvaW50KCQsIEgpLCBuKCQsIEgsIEEsIEUsIGIsIFMsIGMsIHUsIGQsIGgsIHAsIGYsIGcsIG0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKHIpIHtcbiAgICB2YXIgaSwgcywgYSwgbywgbCwgYywgdSwgZCwgaCwgcCwgZiwgZywgbSA9IHtcbiAgICAgIHBvaW50OiB2LFxuICAgICAgbGluZVN0YXJ0OiB4LFxuICAgICAgbGluZUVuZDogRSxcbiAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHIucG9seWdvblN0YXJ0KCksIG0ubGluZVN0YXJ0ID0gYjtcbiAgICAgIH0sXG4gICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgci5wb2x5Z29uRW5kKCksIG0ubGluZVN0YXJ0ID0geDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHYoRCwgQSkge1xuICAgICAgRCA9IGUoRCwgQSksIHIucG9pbnQoRFswXSwgRFsxXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHgoKSB7XG4gICAgICBkID0gTmFOLCBtLnBvaW50ID0gXywgci5saW5lU3RhcnQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gXyhELCBBKSB7XG4gICAgICB2YXIgUiA9IHRpKFtELCBBXSksICQgPSBlKEQsIEEpO1xuICAgICAgbihkLCBoLCB1LCBwLCBmLCBnLCBkID0gJFswXSwgaCA9ICRbMV0sIHUgPSBELCBwID0gUlswXSwgZiA9IFJbMV0sIGcgPSBSWzJdLCBWZCwgciksIHIucG9pbnQoZCwgaCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEUoKSB7XG4gICAgICBtLnBvaW50ID0gdiwgci5saW5lRW5kKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGIoKSB7XG4gICAgICB4KCksIG0ucG9pbnQgPSBTLCBtLmxpbmVFbmQgPSBNO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTKEQsIEEpIHtcbiAgICAgIF8oaSA9IEQsIEEpLCBzID0gZCwgYSA9IGgsIG8gPSBwLCBsID0gZiwgYyA9IGcsIG0ucG9pbnQgPSBfO1xuICAgIH1cbiAgICBmdW5jdGlvbiBNKCkge1xuICAgICAgbihkLCBoLCB1LCBwLCBmLCBnLCBzLCBhLCBpLCBvLCBsLCBjLCBWZCwgciksIG0ubGluZUVuZCA9IEUsIEUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG07XG4gIH07XG59XG52YXIgVkEgPSBldSh7XG4gIHBvaW50OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgdGhpcy5zdHJlYW0ucG9pbnQoZSAqIEJ0LCB0ICogQnQpO1xuICB9XG59KTtcbmZ1bmN0aW9uIEdBKGUpIHtcbiAgcmV0dXJuIGV1KHtcbiAgICBwb2ludDogZnVuY3Rpb24odCwgbikge1xuICAgICAgdmFyIHIgPSBlKHQsIG4pO1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLnBvaW50KHJbMF0sIHJbMV0pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB6QShlLCB0LCBuLCByLCBpKSB7XG4gIGZ1bmN0aW9uIHMoYSwgbykge1xuICAgIHJldHVybiBhICo9IHIsIG8gKj0gaSwgW3QgKyBlICogYSwgbiAtIGUgKiBvXTtcbiAgfVxuICByZXR1cm4gcy5pbnZlcnQgPSBmdW5jdGlvbihhLCBvKSB7XG4gICAgcmV0dXJuIFsoYSAtIHQpIC8gZSAqIHIsIChuIC0gbykgLyBlICogaV07XG4gIH0sIHM7XG59XG5mdW5jdGlvbiB6ZChlLCB0LCBuLCByLCBpLCBzKSB7XG4gIGlmICghcykgcmV0dXJuIHpBKGUsIHQsIG4sIHIsIGkpO1xuICB2YXIgYSA9IFN0KHMpLCBvID0geHQocyksIGwgPSBhICogZSwgYyA9IG8gKiBlLCB1ID0gYSAvIGUsIGQgPSBvIC8gZSwgaCA9IChvICogbiAtIGEgKiB0KSAvIGUsIHAgPSAobyAqIHQgKyBhICogbikgLyBlO1xuICBmdW5jdGlvbiBmKGcsIG0pIHtcbiAgICByZXR1cm4gZyAqPSByLCBtICo9IGksIFtsICogZyAtIGMgKiBtICsgdCwgbiAtIGMgKiBnIC0gbCAqIG1dO1xuICB9XG4gIHJldHVybiBmLmludmVydCA9IGZ1bmN0aW9uKGcsIG0pIHtcbiAgICByZXR1cm4gW3IgKiAodSAqIGcgLSBkICogbSArIGgpLCBpICogKHAgLSBkICogZyAtIHUgKiBtKV07XG4gIH0sIGY7XG59XG5mdW5jdGlvbiB1byhlKSB7XG4gIHJldHVybiBRZyhmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZTtcbiAgfSkoKTtcbn1cbmZ1bmN0aW9uIFFnKGUpIHtcbiAgdmFyIHQsIG4gPSAxNTAsIHIgPSA0ODAsIGkgPSAyNTAsIHMgPSAwLCBhID0gMCwgbyA9IDAsIGwgPSAwLCBjID0gMCwgdSwgZCA9IDAsIGggPSAxLCBwID0gMSwgZiA9IG51bGwsIGcgPSBSZCwgbSA9IG51bGwsIHYsIHgsIF8sIEUgPSBZbCwgYiA9IDAuNSwgUywgTSwgRCwgQSwgUjtcbiAgZnVuY3Rpb24gJChPKSB7XG4gICAgcmV0dXJuIEQoT1swXSAqIEJ0LCBPWzFdICogQnQpO1xuICB9XG4gIGZ1bmN0aW9uIEgoTykge1xuICAgIHJldHVybiBPID0gRC5pbnZlcnQoT1swXSwgT1sxXSksIE8gJiYgW09bMF0gKiBzZSwgT1sxXSAqIHNlXTtcbiAgfVxuICAkLnN0cmVhbSA9IGZ1bmN0aW9uKE8pIHtcbiAgICByZXR1cm4gQSAmJiBSID09PSBPID8gQSA6IEEgPSBWQShHQSh1KShnKFMoRShSID0gTykpKSkpO1xuICB9LCAkLnByZWNsaXAgPSBmdW5jdGlvbihPKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZyA9IE8sIGYgPSB2b2lkIDAsIEIoKSkgOiBnO1xuICB9LCAkLnBvc3RjbGlwID0gZnVuY3Rpb24oTykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKEUgPSBPLCBtID0gdiA9IHggPSBfID0gbnVsbCwgQigpKSA6IEU7XG4gIH0sICQuY2xpcEFuZ2xlID0gZnVuY3Rpb24oTykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGcgPSArTyA/IGJBKGYgPSBPICogQnQpIDogKGYgPSBudWxsLCBSZCksIEIoKSkgOiBmICogc2U7XG4gIH0sICQuY2xpcEV4dGVudCA9IGZ1bmN0aW9uKE8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChFID0gTyA9PSBudWxsID8gKG0gPSB2ID0geCA9IF8gPSBudWxsLCBZbCkgOiBFQShtID0gK09bMF1bMF0sIHYgPSArT1swXVsxXSwgeCA9ICtPWzFdWzBdLCBfID0gK09bMV1bMV0pLCBCKCkpIDogbSA9PSBudWxsID8gbnVsbCA6IFtbbSwgdl0sIFt4LCBfXV07XG4gIH0sICQuc2NhbGUgPSBmdW5jdGlvbihPKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9ICtPLCBQKCkpIDogbjtcbiAgfSwgJC50cmFuc2xhdGUgPSBmdW5jdGlvbihPKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAociA9ICtPWzBdLCBpID0gK09bMV0sIFAoKSkgOiBbciwgaV07XG4gIH0sICQuY2VudGVyID0gZnVuY3Rpb24oTykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHMgPSBPWzBdICUgMzYwICogQnQsIGEgPSBPWzFdICUgMzYwICogQnQsIFAoKSkgOiBbcyAqIHNlLCBhICogc2VdO1xuICB9LCAkLnJvdGF0ZSA9IGZ1bmN0aW9uKE8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvID0gT1swXSAlIDM2MCAqIEJ0LCBsID0gT1sxXSAlIDM2MCAqIEJ0LCBjID0gTy5sZW5ndGggPiAyID8gT1syXSAlIDM2MCAqIEJ0IDogMCwgUCgpKSA6IFtvICogc2UsIGwgKiBzZSwgYyAqIHNlXTtcbiAgfSwgJC5hbmdsZSA9IGZ1bmN0aW9uKE8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkID0gTyAlIDM2MCAqIEJ0LCBQKCkpIDogZCAqIHNlO1xuICB9LCAkLnJlZmxlY3RYID0gZnVuY3Rpb24oTykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGggPSBPID8gLTEgOiAxLCBQKCkpIDogaCA8IDA7XG4gIH0sICQucmVmbGVjdFkgPSBmdW5jdGlvbihPKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocCA9IE8gPyAtMSA6IDEsIFAoKSkgOiBwIDwgMDtcbiAgfSwgJC5wcmVjaXNpb24gPSBmdW5jdGlvbihPKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoUyA9IEdkKE0sIGIgPSBPICogTyksIEIoKSkgOiBqZShiKTtcbiAgfSwgJC5maXRFeHRlbnQgPSBmdW5jdGlvbihPLCB3KSB7XG4gICAgcmV0dXJuIEtnKCQsIE8sIHcpO1xuICB9LCAkLmZpdFNpemUgPSBmdW5jdGlvbihPLCB3KSB7XG4gICAgcmV0dXJuIElBKCQsIE8sIHcpO1xuICB9LCAkLmZpdFdpZHRoID0gZnVuY3Rpb24oTywgdykge1xuICAgIHJldHVybiBOQSgkLCBPLCB3KTtcbiAgfSwgJC5maXRIZWlnaHQgPSBmdW5jdGlvbihPLCB3KSB7XG4gICAgcmV0dXJuIFBBKCQsIE8sIHcpO1xuICB9O1xuICBmdW5jdGlvbiBQKCkge1xuICAgIHZhciBPID0gemQobiwgMCwgMCwgaCwgcCwgZCkuYXBwbHkobnVsbCwgdChzLCBhKSksIHcgPSB6ZChuLCByIC0gT1swXSwgaSAtIE9bMV0sIGgsIHAsIGQpO1xuICAgIHJldHVybiB1ID0gTmcobywgbCwgYyksIE0gPSBXbCh0LCB3KSwgRCA9IFdsKHUsIE0pLCBTID0gR2QoTSwgYiksIEIoKTtcbiAgfVxuICBmdW5jdGlvbiBCKCkge1xuICAgIHJldHVybiBBID0gUiA9IG51bGwsICQ7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0ID0gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCAkLmludmVydCA9IHQuaW52ZXJ0ICYmIEgsIFAoKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIEpnKGUpIHtcbiAgdmFyIHQgPSAwLCBuID0gZnQgLyAzLCByID0gUWcoZSksIGkgPSByKHQsIG4pO1xuICByZXR1cm4gaS5wYXJhbGxlbHMgPSBmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyByKHQgPSBzWzBdICogQnQsIG4gPSBzWzFdICogQnQpIDogW3QgKiBzZSwgbiAqIHNlXTtcbiAgfSwgaTtcbn1cbmZ1bmN0aW9uIEZBKGUpIHtcbiAgdmFyIHQgPSBTdChlKTtcbiAgZnVuY3Rpb24gbihyLCBpKSB7XG4gICAgcmV0dXJuIFtyICogdCwgeHQoaSkgLyB0XTtcbiAgfVxuICByZXR1cm4gbi5pbnZlcnQgPSBmdW5jdGlvbihyLCBpKSB7XG4gICAgcmV0dXJuIFtyIC8gdCwgQ24oaSAqIHQpXTtcbiAgfSwgbjtcbn1cbmZ1bmN0aW9uIGpBKGUsIHQpIHtcbiAgdmFyIG4gPSB4dChlKSwgciA9IChuICsgeHQodCkpIC8gMjtcbiAgaWYgKE90KHIpIDwgVHQpIHJldHVybiBGQShlKTtcbiAgdmFyIGkgPSAxICsgbiAqICgyICogciAtIG4pLCBzID0gamUoaSkgLyByO1xuICBmdW5jdGlvbiBhKG8sIGwpIHtcbiAgICB2YXIgYyA9IGplKGkgLSAyICogciAqIHh0KGwpKSAvIHI7XG4gICAgcmV0dXJuIFtjICogeHQobyAqPSByKSwgcyAtIGMgKiBTdChvKV07XG4gIH1cbiAgcmV0dXJuIGEuaW52ZXJ0ID0gZnVuY3Rpb24obywgbCkge1xuICAgIHZhciBjID0gcyAtIGwsIHUgPSBscihvLCBPdChjKSkgKiBVbihjKTtcbiAgICByZXR1cm4gYyAqIHIgPCAwICYmICh1IC09IGZ0ICogVW4obykgKiBVbihjKSksIFt1IC8gciwgQ24oKGkgLSAobyAqIG8gKyBjICogYykgKiByICogcikgLyAoMiAqIHIpKV07XG4gIH0sIGE7XG59XG5mdW5jdGlvbiB0digpIHtcbiAgcmV0dXJuIEpnKGpBKS5zY2FsZSgxNTUuNDI0KS5jZW50ZXIoWzAsIDMzLjY0NDJdKTtcbn1cbmZ1bmN0aW9uIFdBKCkge1xuICByZXR1cm4gdHYoKS5wYXJhbGxlbHMoWzI5LjUsIDQ1LjVdKS5zY2FsZSgxMDcwKS50cmFuc2xhdGUoWzQ4MCwgMjUwXSkucm90YXRlKFs5NiwgMF0pLmNlbnRlcihbLTAuNiwgMzguN10pO1xufVxuZnVuY3Rpb24gcnUoZSwgdCkge1xuICByZXR1cm4gW2UsIGNBKHVBKChkZSArIHQpIC8gMikpXTtcbn1cbnJ1LmludmVydCA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgcmV0dXJuIFtlLCAyICogSWcobEEodCkpIC0gZGVdO1xufTtcbmZ1bmN0aW9uIHFBKCkge1xuICByZXR1cm4gWUEocnUpLnNjYWxlKDk2MSAvIEVlKTtcbn1cbmZ1bmN0aW9uIFlBKGUpIHtcbiAgdmFyIHQgPSB1byhlKSwgbiA9IHQuY2VudGVyLCByID0gdC5zY2FsZSwgaSA9IHQudHJhbnNsYXRlLCBzID0gdC5jbGlwRXh0ZW50LCBhID0gbnVsbCwgbywgbCwgYztcbiAgdC5zY2FsZSA9IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyKGQpLCB1KCkpIDogcigpO1xuICB9LCB0LnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpKGQpLCB1KCkpIDogaSgpO1xuICB9LCB0LmNlbnRlciA9IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuKGQpLCB1KCkpIDogbigpO1xuICB9LCB0LmNsaXBFeHRlbnQgPSBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZCA9PSBudWxsID8gYSA9IG8gPSBsID0gYyA9IG51bGwgOiAoYSA9ICtkWzBdWzBdLCBvID0gK2RbMF1bMV0sIGwgPSArZFsxXVswXSwgYyA9ICtkWzFdWzFdKSwgdSgpKSA6IGEgPT0gbnVsbCA/IG51bGwgOiBbW2EsIG9dLCBbbCwgY11dO1xuICB9O1xuICBmdW5jdGlvbiB1KCkge1xuICAgIHZhciBkID0gZnQgKiByKCksIGggPSB0KGRBKHQucm90YXRlKCkpLmludmVydChbMCwgMF0pKTtcbiAgICByZXR1cm4gcyhhID09IG51bGwgPyBbW2hbMF0gLSBkLCBoWzFdIC0gZF0sIFtoWzBdICsgZCwgaFsxXSArIGRdXSA6IGUgPT09IHJ1ID8gW1tNYXRoLm1heChoWzBdIC0gZCwgYSksIG9dLCBbTWF0aC5taW4oaFswXSArIGQsIGwpLCBjXV0gOiBbW2EsIE1hdGgubWF4KGhbMV0gLSBkLCBvKV0sIFtsLCBNYXRoLm1pbihoWzFdICsgZCwgYyldXSk7XG4gIH1cbiAgcmV0dXJuIHUoKTtcbn1cbmZ1bmN0aW9uIElhKGUsIHQpIHtcbiAgcmV0dXJuIFtlLCB0XTtcbn1cbklhLmludmVydCA9IElhO1xuZnVuY3Rpb24gWEEoKSB7XG4gIHJldHVybiB1byhJYSkuc2NhbGUoMTUyLjYzKTtcbn1cbmZ1bmN0aW9uIFpBKGUsIHQpIHtcbiAgdmFyIG4gPSBTdChlKSwgciA9IGUgPT09IHQgPyB4dChlKSA6IChuIC0gU3QodCkpIC8gKHQgLSBlKSwgaSA9IG4gLyByICsgZTtcbiAgaWYgKE90KHIpIDwgVHQpIHJldHVybiBJYTtcbiAgZnVuY3Rpb24gcyhhLCBvKSB7XG4gICAgdmFyIGwgPSBpIC0gbywgYyA9IHIgKiBhO1xuICAgIHJldHVybiBbbCAqIHh0KGMpLCBpIC0gbCAqIFN0KGMpXTtcbiAgfVxuICByZXR1cm4gcy5pbnZlcnQgPSBmdW5jdGlvbihhLCBvKSB7XG4gICAgdmFyIGwgPSBpIC0gbywgYyA9IGxyKGEsIE90KGwpKSAqIFVuKGwpO1xuICAgIHJldHVybiBsICogciA8IDAgJiYgKGMgLT0gZnQgKiBVbihhKSAqIFVuKGwpKSwgW2MgLyByLCBpIC0gVW4ocikgKiBqZShhICogYSArIGwgKiBsKV07XG4gIH0sIHM7XG59XG5mdW5jdGlvbiBLQSgpIHtcbiAgcmV0dXJuIEpnKFpBKS5zY2FsZSgxMzEuMTU0KS5jZW50ZXIoWzAsIDEzLjkzODldKTtcbn1cbnZhciBIaSA9IDEuMzQwMjY0LCBWaSA9IC0wLjA4MTEwNiwgR2kgPSA4OTNlLTYsIHppID0gMzc5NmUtNiwgTmEgPSBqZSgzKSAvIDIsIFFBID0gMTI7XG5mdW5jdGlvbiBldihlLCB0KSB7XG4gIHZhciBuID0gQ24oTmEgKiB4dCh0KSksIHIgPSBuICogbiwgaSA9IHIgKiByICogcjtcbiAgcmV0dXJuIFtcbiAgICBlICogU3QobikgLyAoTmEgKiAoSGkgKyAzICogVmkgKiByICsgaSAqICg3ICogR2kgKyA5ICogemkgKiByKSkpLFxuICAgIG4gKiAoSGkgKyBWaSAqIHIgKyBpICogKEdpICsgemkgKiByKSlcbiAgXTtcbn1cbmV2LmludmVydCA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgZm9yICh2YXIgbiA9IHQsIHIgPSBuICogbiwgaSA9IHIgKiByICogciwgcyA9IDAsIGEsIG8sIGw7IHMgPCBRQSAmJiAobyA9IG4gKiAoSGkgKyBWaSAqIHIgKyBpICogKEdpICsgemkgKiByKSkgLSB0LCBsID0gSGkgKyAzICogVmkgKiByICsgaSAqICg3ICogR2kgKyA5ICogemkgKiByKSwgbiAtPSBhID0gbyAvIGwsIHIgPSBuICogbiwgaSA9IHIgKiByICogciwgIShPdChhKSA8IG9BKSk7ICsrcylcbiAgICA7XG4gIHJldHVybiBbXG4gICAgTmEgKiBlICogKEhpICsgMyAqIFZpICogciArIGkgKiAoNyAqIEdpICsgOSAqIHppICogcikpIC8gU3QobiksXG4gICAgQ24oeHQobikgLyBOYSlcbiAgXTtcbn07XG5mdW5jdGlvbiBKQSgpIHtcbiAgcmV0dXJuIHVvKGV2KS5zY2FsZSgxNzcuMTU4KTtcbn1cbmZ1bmN0aW9uIG52KGUsIHQpIHtcbiAgdmFyIG4gPSB0ICogdCwgciA9IG4gKiBuO1xuICByZXR1cm4gW1xuICAgIGUgKiAoMC44NzA3IC0gMC4xMzE5NzkgKiBuICsgciAqICgtMC4wMTM3OTEgKyByICogKDM5NzFlLTYgKiBuIC0gMTUyOWUtNiAqIHIpKSksXG4gICAgdCAqICgxLjAwNzIyNiArIG4gKiAoMC4wMTUwODUgKyByICogKC0wLjA0NDQ3NSArIDAuMDI4ODc0ICogbiAtIDU5MTZlLTYgKiByKSkpXG4gIF07XG59XG5udi5pbnZlcnQgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHZhciBuID0gdCwgciA9IDI1LCBpO1xuICBkbyB7XG4gICAgdmFyIHMgPSBuICogbiwgYSA9IHMgKiBzO1xuICAgIG4gLT0gaSA9IChuICogKDEuMDA3MjI2ICsgcyAqICgwLjAxNTA4NSArIGEgKiAoLTAuMDQ0NDc1ICsgMC4wMjg4NzQgKiBzIC0gNTkxNmUtNiAqIGEpKSkgLSB0KSAvICgxLjAwNzIyNiArIHMgKiAoMC4wMTUwODUgKiAzICsgYSAqICgtMC4wNDQ0NzUgKiA3ICsgMC4wMjg4NzQgKiA5ICogcyAtIDU5MTZlLTYgKiAxMSAqIGEpKSk7XG4gIH0gd2hpbGUgKE90KGkpID4gVHQgJiYgLS1yID4gMCk7XG4gIHJldHVybiBbXG4gICAgZSAvICgwLjg3MDcgKyAocyA9IG4gKiBuKSAqICgtMC4xMzE5NzkgKyBzICogKC0wLjAxMzc5MSArIHMgKiBzICogcyAqICgzOTcxZS02IC0gMTUyOWUtNiAqIHMpKSkpLFxuICAgIG5cbiAgXTtcbn07XG5mdW5jdGlvbiB0TCgpIHtcbiAgcmV0dXJuIHVvKG52KS5zY2FsZSgxNzUuMjk1KTtcbn1cbmZ1bmN0aW9uIGVMKGUsIHQpIHtcbiAgcmV0dXJuIGUucGFyZW50ID09PSB0LnBhcmVudCA/IDEgOiAyO1xufVxuZnVuY3Rpb24gbkwoZSkge1xuICByZXR1cm4gZS5yZWR1Y2UockwsIDApIC8gZS5sZW5ndGg7XG59XG5mdW5jdGlvbiByTChlLCB0KSB7XG4gIHJldHVybiBlICsgdC54O1xufVxuZnVuY3Rpb24gaUwoZSkge1xuICByZXR1cm4gMSArIGUucmVkdWNlKHNMLCAwKTtcbn1cbmZ1bmN0aW9uIHNMKGUsIHQpIHtcbiAgcmV0dXJuIE1hdGgubWF4KGUsIHQueSk7XG59XG5mdW5jdGlvbiBhTChlKSB7XG4gIGZvciAodmFyIHQ7IHQgPSBlLmNoaWxkcmVuOyApIGUgPSB0WzBdO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIG9MKGUpIHtcbiAgZm9yICh2YXIgdDsgdCA9IGUuY2hpbGRyZW47ICkgZSA9IHRbdC5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBsTCgpIHtcbiAgdmFyIGUgPSBlTCwgdCA9IDEsIG4gPSAxLCByID0gITE7XG4gIGZ1bmN0aW9uIGkocykge1xuICAgIHZhciBhLCBvID0gMDtcbiAgICBzLmVhY2hBZnRlcihmdW5jdGlvbihoKSB7XG4gICAgICB2YXIgcCA9IGguY2hpbGRyZW47XG4gICAgICBwID8gKGgueCA9IG5MKHApLCBoLnkgPSBpTChwKSkgOiAoaC54ID0gYSA/IG8gKz0gZShoLCBhKSA6IDAsIGgueSA9IDAsIGEgPSBoKTtcbiAgICB9KTtcbiAgICB2YXIgbCA9IGFMKHMpLCBjID0gb0wocyksIHUgPSBsLnggLSBlKGwsIGMpIC8gMiwgZCA9IGMueCArIGUoYywgbCkgLyAyO1xuICAgIHJldHVybiBzLmVhY2hBZnRlcihyID8gZnVuY3Rpb24oaCkge1xuICAgICAgaC54ID0gKGgueCAtIHMueCkgKiB0LCBoLnkgPSAocy55IC0gaC55KSAqIG47XG4gICAgfSA6IGZ1bmN0aW9uKGgpIHtcbiAgICAgIGgueCA9IChoLnggLSB1KSAvIChkIC0gdSkgKiB0LCBoLnkgPSAoMSAtIChzLnkgPyBoLnkgLyBzLnkgOiAxKSkgKiBuO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBpLnNlcGFyYXRpb24gPSBmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZSA9IHMsIGkpIDogZTtcbiAgfSwgaS5zaXplID0gZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHIgPSAhMSwgdCA9ICtzWzBdLCBuID0gK3NbMV0sIGkpIDogciA/IG51bGwgOiBbdCwgbl07XG4gIH0sIGkubm9kZVNpemUgPSBmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAociA9ICEwLCB0ID0gK3NbMF0sIG4gPSArc1sxXSwgaSkgOiByID8gW3QsIG5dIDogbnVsbDtcbiAgfSwgaTtcbn1cbmZ1bmN0aW9uIGNMKGUpIHtcbiAgdmFyIHQgPSAwLCBuID0gZS5jaGlsZHJlbiwgciA9IG4gJiYgbi5sZW5ndGg7XG4gIGlmICghcikgdCA9IDE7XG4gIGVsc2UgZm9yICg7IC0tciA+PSAwOyApIHQgKz0gbltyXS52YWx1ZTtcbiAgZS52YWx1ZSA9IHQ7XG59XG5mdW5jdGlvbiB1TCgpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaEFmdGVyKGNMKTtcbn1cbmZ1bmN0aW9uIGhMKGUsIHQpIHtcbiAgbGV0IG4gPSAtMTtcbiAgZm9yIChjb25zdCByIG9mIHRoaXMpXG4gICAgZS5jYWxsKHQsIHIsICsrbiwgdGhpcyk7XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gZEwoZSwgdCkge1xuICBmb3IgKHZhciBuID0gdGhpcywgciA9IFtuXSwgaSwgcywgYSA9IC0xOyBuID0gci5wb3AoKTsgKVxuICAgIGlmIChlLmNhbGwodCwgbiwgKythLCB0aGlzKSwgaSA9IG4uY2hpbGRyZW4pXG4gICAgICBmb3IgKHMgPSBpLmxlbmd0aCAtIDE7IHMgPj0gMDsgLS1zKVxuICAgICAgICByLnB1c2goaVtzXSk7XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gcEwoZSwgdCkge1xuICBmb3IgKHZhciBuID0gdGhpcywgciA9IFtuXSwgaSA9IFtdLCBzLCBhLCBvLCBsID0gLTE7IG4gPSByLnBvcCgpOyApXG4gICAgaWYgKGkucHVzaChuKSwgcyA9IG4uY2hpbGRyZW4pXG4gICAgICBmb3IgKGEgPSAwLCBvID0gcy5sZW5ndGg7IGEgPCBvOyArK2EpXG4gICAgICAgIHIucHVzaChzW2FdKTtcbiAgZm9yICg7IG4gPSBpLnBvcCgpOyApXG4gICAgZS5jYWxsKHQsIG4sICsrbCwgdGhpcyk7XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gZkwoZSwgdCkge1xuICBsZXQgbiA9IC0xO1xuICBmb3IgKGNvbnN0IHIgb2YgdGhpcylcbiAgICBpZiAoZS5jYWxsKHQsIHIsICsrbiwgdGhpcykpXG4gICAgICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIG1MKGUpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaEFmdGVyKGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBuID0gK2UodC5kYXRhKSB8fCAwLCByID0gdC5jaGlsZHJlbiwgaSA9IHIgJiYgci5sZW5ndGg7IC0taSA+PSAwOyApIG4gKz0gcltpXS52YWx1ZTtcbiAgICB0LnZhbHVlID0gbjtcbiAgfSk7XG59XG5mdW5jdGlvbiBnTChlKSB7XG4gIHJldHVybiB0aGlzLmVhY2hCZWZvcmUoZnVuY3Rpb24odCkge1xuICAgIHQuY2hpbGRyZW4gJiYgdC5jaGlsZHJlbi5zb3J0KGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHZMKGUpIHtcbiAgZm9yICh2YXIgdCA9IHRoaXMsIG4gPSB5TCh0LCBlKSwgciA9IFt0XTsgdCAhPT0gbjsgKVxuICAgIHQgPSB0LnBhcmVudCwgci5wdXNoKHQpO1xuICBmb3IgKHZhciBpID0gci5sZW5ndGg7IGUgIT09IG47IClcbiAgICByLnNwbGljZShpLCAwLCBlKSwgZSA9IGUucGFyZW50O1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIHlMKGUsIHQpIHtcbiAgaWYgKGUgPT09IHQpIHJldHVybiBlO1xuICB2YXIgbiA9IGUuYW5jZXN0b3JzKCksIHIgPSB0LmFuY2VzdG9ycygpLCBpID0gbnVsbDtcbiAgZm9yIChlID0gbi5wb3AoKSwgdCA9IHIucG9wKCk7IGUgPT09IHQ7IClcbiAgICBpID0gZSwgZSA9IG4ucG9wKCksIHQgPSByLnBvcCgpO1xuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIHhMKCkge1xuICBmb3IgKHZhciBlID0gdGhpcywgdCA9IFtlXTsgZSA9IGUucGFyZW50OyApXG4gICAgdC5wdXNoKGUpO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIGJMKCkge1xuICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzKTtcbn1cbmZ1bmN0aW9uIF9MKCkge1xuICB2YXIgZSA9IFtdO1xuICByZXR1cm4gdGhpcy5lYWNoQmVmb3JlKGZ1bmN0aW9uKHQpIHtcbiAgICB0LmNoaWxkcmVuIHx8IGUucHVzaCh0KTtcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBFTCgpIHtcbiAgdmFyIGUgPSB0aGlzLCB0ID0gW107XG4gIHJldHVybiBlLmVhY2goZnVuY3Rpb24obikge1xuICAgIG4gIT09IGUgJiYgdC5wdXNoKHsgc291cmNlOiBuLnBhcmVudCwgdGFyZ2V0OiBuIH0pO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uKiBPTCgpIHtcbiAgdmFyIGUgPSB0aGlzLCB0LCBuID0gW2VdLCByLCBpLCBzO1xuICBkb1xuICAgIGZvciAodCA9IG4ucmV2ZXJzZSgpLCBuID0gW107IGUgPSB0LnBvcCgpOyApXG4gICAgICBpZiAoeWllbGQgZSwgciA9IGUuY2hpbGRyZW4pXG4gICAgICAgIGZvciAoaSA9IDAsIHMgPSByLmxlbmd0aDsgaSA8IHM7ICsraSlcbiAgICAgICAgICBuLnB1c2gocltpXSk7XG4gIHdoaWxlIChuLmxlbmd0aCk7XG59XG5mdW5jdGlvbiB5cyhlLCB0KSB7XG4gIGUgaW5zdGFuY2VvZiBNYXAgPyAoZSA9IFt2b2lkIDAsIGVdLCB0ID09PSB2b2lkIDAgJiYgKHQgPSB3TCkpIDogdCA9PT0gdm9pZCAwICYmICh0ID0gVEwpO1xuICBmb3IgKHZhciBuID0gbmV3IHNzKGUpLCByLCBpID0gW25dLCBzLCBhLCBvLCBsOyByID0gaS5wb3AoKTsgKVxuICAgIGlmICgoYSA9IHQoci5kYXRhKSkgJiYgKGwgPSAoYSA9IEFycmF5LmZyb20oYSkpLmxlbmd0aCkpXG4gICAgICBmb3IgKHIuY2hpbGRyZW4gPSBhLCBvID0gbCAtIDE7IG8gPj0gMDsgLS1vKVxuICAgICAgICBpLnB1c2gocyA9IGFbb10gPSBuZXcgc3MoYVtvXSkpLCBzLnBhcmVudCA9IHIsIHMuZGVwdGggPSByLmRlcHRoICsgMTtcbiAgcmV0dXJuIG4uZWFjaEJlZm9yZShNTCk7XG59XG5mdW5jdGlvbiBTTCgpIHtcbiAgcmV0dXJuIHlzKHRoaXMpLmVhY2hCZWZvcmUoJEwpO1xufVxuZnVuY3Rpb24gVEwoZSkge1xuICByZXR1cm4gZS5jaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIHdMKGUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZSkgPyBlWzFdIDogbnVsbDtcbn1cbmZ1bmN0aW9uICRMKGUpIHtcbiAgZS5kYXRhLnZhbHVlICE9PSB2b2lkIDAgJiYgKGUudmFsdWUgPSBlLmRhdGEudmFsdWUpLCBlLmRhdGEgPSBlLmRhdGEuZGF0YTtcbn1cbmZ1bmN0aW9uIE1MKGUpIHtcbiAgdmFyIHQgPSAwO1xuICBkb1xuICAgIGUuaGVpZ2h0ID0gdDtcbiAgd2hpbGUgKChlID0gZS5wYXJlbnQpICYmIGUuaGVpZ2h0IDwgKyt0KTtcbn1cbmZ1bmN0aW9uIHNzKGUpIHtcbiAgdGhpcy5kYXRhID0gZSwgdGhpcy5kZXB0aCA9IHRoaXMuaGVpZ2h0ID0gMCwgdGhpcy5wYXJlbnQgPSBudWxsO1xufVxuc3MucHJvdG90eXBlID0geXMucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3Rvcjogc3MsXG4gIGNvdW50OiB1TCxcbiAgZWFjaDogaEwsXG4gIGVhY2hBZnRlcjogcEwsXG4gIGVhY2hCZWZvcmU6IGRMLFxuICBmaW5kOiBmTCxcbiAgc3VtOiBtTCxcbiAgc29ydDogZ0wsXG4gIHBhdGg6IHZMLFxuICBhbmNlc3RvcnM6IHhMLFxuICBkZXNjZW5kYW50czogYkwsXG4gIGxlYXZlczogX0wsXG4gIGxpbmtzOiBFTCxcbiAgY29weTogU0wsXG4gIFtTeW1ib2wuaXRlcmF0b3JdOiBPTFxufTtcbmZ1bmN0aW9uIENMKGUpIHtcbiAgcmV0dXJuIGUgPT0gbnVsbCA/IG51bGwgOiBydihlKTtcbn1cbmZ1bmN0aW9uIHJ2KGUpIHtcbiAgaWYgKHR5cGVvZiBlICE9IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKCk7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gS24oKSB7XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24ga3IoZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGU7XG4gIH07XG59XG5jb25zdCBBTCA9IDE2NjQ1MjUsIExMID0gMTAxMzkwNDIyMywgRmQgPSA0Mjk0OTY3Mjk2O1xuZnVuY3Rpb24ga0woKSB7XG4gIGxldCBlID0gMTtcbiAgcmV0dXJuICgpID0+IChlID0gKEFMICogZSArIExMKSAlIEZkKSAvIEZkO1xufVxuZnVuY3Rpb24gREwoZSkge1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBcImxlbmd0aFwiIGluIGUgPyBlIDogQXJyYXkuZnJvbShlKTtcbn1cbmZ1bmN0aW9uIFJMKGUsIHQpIHtcbiAgbGV0IG4gPSBlLmxlbmd0aCwgciwgaTtcbiAgZm9yICg7IG47IClcbiAgICBpID0gdCgpICogbi0tIHwgMCwgciA9IGVbbl0sIGVbbl0gPSBlW2ldLCBlW2ldID0gcjtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBJTChlLCB0KSB7XG4gIGZvciAodmFyIG4gPSAwLCByID0gKGUgPSBSTChBcnJheS5mcm9tKGUpLCB0KSkubGVuZ3RoLCBpID0gW10sIHMsIGE7IG4gPCByOyApXG4gICAgcyA9IGVbbl0sIGEgJiYgaXYoYSwgcykgPyArK24gOiAoYSA9IFBMKGkgPSBOTChpLCBzKSksIG4gPSAwKTtcbiAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiBOTChlLCB0KSB7XG4gIHZhciBuLCByO1xuICBpZiAoSm8odCwgZSkpIHJldHVybiBbdF07XG4gIGZvciAobiA9IDA7IG4gPCBlLmxlbmd0aDsgKytuKVxuICAgIGlmIChQcyh0LCBlW25dKSAmJiBKbyhSaShlW25dLCB0KSwgZSkpXG4gICAgICByZXR1cm4gW2Vbbl0sIHRdO1xuICBmb3IgKG4gPSAwOyBuIDwgZS5sZW5ndGggLSAxOyArK24pXG4gICAgZm9yIChyID0gbiArIDE7IHIgPCBlLmxlbmd0aDsgKytyKVxuICAgICAgaWYgKFBzKFJpKGVbbl0sIGVbcl0pLCB0KSAmJiBQcyhSaShlW25dLCB0KSwgZVtyXSkgJiYgUHMoUmkoZVtyXSwgdCksIGVbbl0pICYmIEpvKHN2KGVbbl0sIGVbcl0sIHQpLCBlKSlcbiAgICAgICAgcmV0dXJuIFtlW25dLCBlW3JdLCB0XTtcbiAgdGhyb3cgbmV3IEVycm9yKCk7XG59XG5mdW5jdGlvbiBQcyhlLCB0KSB7XG4gIHZhciBuID0gZS5yIC0gdC5yLCByID0gdC54IC0gZS54LCBpID0gdC55IC0gZS55O1xuICByZXR1cm4gbiA8IDAgfHwgbiAqIG4gPCByICogciArIGkgKiBpO1xufVxuZnVuY3Rpb24gaXYoZSwgdCkge1xuICB2YXIgbiA9IGUuciAtIHQuciArIE1hdGgubWF4KGUuciwgdC5yLCAxKSAqIDFlLTksIHIgPSB0LnggLSBlLngsIGkgPSB0LnkgLSBlLnk7XG4gIHJldHVybiBuID4gMCAmJiBuICogbiA+IHIgKiByICsgaSAqIGk7XG59XG5mdW5jdGlvbiBKbyhlLCB0KSB7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7ICsrbilcbiAgICBpZiAoIWl2KGUsIHRbbl0pKVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBQTChlKSB7XG4gIHN3aXRjaCAoZS5sZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gVUwoZVswXSk7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIFJpKGVbMF0sIGVbMV0pO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBzdihlWzBdLCBlWzFdLCBlWzJdKTtcbiAgfVxufVxuZnVuY3Rpb24gVUwoZSkge1xuICByZXR1cm4ge1xuICAgIHg6IGUueCxcbiAgICB5OiBlLnksXG4gICAgcjogZS5yXG4gIH07XG59XG5mdW5jdGlvbiBSaShlLCB0KSB7XG4gIHZhciBuID0gZS54LCByID0gZS55LCBpID0gZS5yLCBzID0gdC54LCBhID0gdC55LCBvID0gdC5yLCBsID0gcyAtIG4sIGMgPSBhIC0gciwgdSA9IG8gLSBpLCBkID0gTWF0aC5zcXJ0KGwgKiBsICsgYyAqIGMpO1xuICByZXR1cm4ge1xuICAgIHg6IChuICsgcyArIGwgLyBkICogdSkgLyAyLFxuICAgIHk6IChyICsgYSArIGMgLyBkICogdSkgLyAyLFxuICAgIHI6IChkICsgaSArIG8pIC8gMlxuICB9O1xufVxuZnVuY3Rpb24gc3YoZSwgdCwgbikge1xuICB2YXIgciA9IGUueCwgaSA9IGUueSwgcyA9IGUuciwgYSA9IHQueCwgbyA9IHQueSwgbCA9IHQuciwgYyA9IG4ueCwgdSA9IG4ueSwgZCA9IG4uciwgaCA9IHIgLSBhLCBwID0gciAtIGMsIGYgPSBpIC0gbywgZyA9IGkgLSB1LCBtID0gbCAtIHMsIHYgPSBkIC0gcywgeCA9IHIgKiByICsgaSAqIGkgLSBzICogcywgXyA9IHggLSBhICogYSAtIG8gKiBvICsgbCAqIGwsIEUgPSB4IC0gYyAqIGMgLSB1ICogdSArIGQgKiBkLCBiID0gcCAqIGYgLSBoICogZywgUyA9IChmICogRSAtIGcgKiBfKSAvIChiICogMikgLSByLCBNID0gKGcgKiBtIC0gZiAqIHYpIC8gYiwgRCA9IChwICogXyAtIGggKiBFKSAvIChiICogMikgLSBpLCBBID0gKGggKiB2IC0gcCAqIG0pIC8gYiwgUiA9IE0gKiBNICsgQSAqIEEgLSAxLCAkID0gMiAqIChzICsgUyAqIE0gKyBEICogQSksIEggPSBTICogUyArIEQgKiBEIC0gcyAqIHMsIFAgPSAtKE1hdGguYWJzKFIpID4gMWUtNiA/ICgkICsgTWF0aC5zcXJ0KCQgKiAkIC0gNCAqIFIgKiBIKSkgLyAoMiAqIFIpIDogSCAvICQpO1xuICByZXR1cm4ge1xuICAgIHg6IHIgKyBTICsgTSAqIFAsXG4gICAgeTogaSArIEQgKyBBICogUCxcbiAgICByOiBQXG4gIH07XG59XG5mdW5jdGlvbiBqZChlLCB0LCBuKSB7XG4gIHZhciByID0gZS54IC0gdC54LCBpLCBzLCBhID0gZS55IC0gdC55LCBvLCBsLCBjID0gciAqIHIgKyBhICogYTtcbiAgYyA/IChzID0gdC5yICsgbi5yLCBzICo9IHMsIGwgPSBlLnIgKyBuLnIsIGwgKj0gbCwgcyA+IGwgPyAoaSA9IChjICsgbCAtIHMpIC8gKDIgKiBjKSwgbyA9IE1hdGguc3FydChNYXRoLm1heCgwLCBsIC8gYyAtIGkgKiBpKSksIG4ueCA9IGUueCAtIGkgKiByIC0gbyAqIGEsIG4ueSA9IGUueSAtIGkgKiBhICsgbyAqIHIpIDogKGkgPSAoYyArIHMgLSBsKSAvICgyICogYyksIG8gPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgcyAvIGMgLSBpICogaSkpLCBuLnggPSB0LnggKyBpICogciAtIG8gKiBhLCBuLnkgPSB0LnkgKyBpICogYSArIG8gKiByKSkgOiAobi54ID0gdC54ICsgbi5yLCBuLnkgPSB0LnkpO1xufVxuZnVuY3Rpb24gV2QoZSwgdCkge1xuICB2YXIgbiA9IGUuciArIHQuciAtIDFlLTYsIHIgPSB0LnggLSBlLngsIGkgPSB0LnkgLSBlLnk7XG4gIHJldHVybiBuID4gMCAmJiBuICogbiA+IHIgKiByICsgaSAqIGk7XG59XG5mdW5jdGlvbiBxZChlKSB7XG4gIHZhciB0ID0gZS5fLCBuID0gZS5uZXh0Ll8sIHIgPSB0LnIgKyBuLnIsIGkgPSAodC54ICogbi5yICsgbi54ICogdC5yKSAvIHIsIHMgPSAodC55ICogbi5yICsgbi55ICogdC5yKSAvIHI7XG4gIHJldHVybiBpICogaSArIHMgKiBzO1xufVxuZnVuY3Rpb24gVXMoZSkge1xuICB0aGlzLl8gPSBlLCB0aGlzLm5leHQgPSBudWxsLCB0aGlzLnByZXZpb3VzID0gbnVsbDtcbn1cbmZ1bmN0aW9uIEJMKGUsIHQpIHtcbiAgaWYgKCEocyA9IChlID0gREwoZSkpLmxlbmd0aCkpIHJldHVybiAwO1xuICB2YXIgbiwgciwgaSwgcywgYSwgbywgbCwgYywgdSwgZCwgaDtcbiAgaWYgKG4gPSBlWzBdLCBuLnggPSAwLCBuLnkgPSAwLCAhKHMgPiAxKSkgcmV0dXJuIG4ucjtcbiAgaWYgKHIgPSBlWzFdLCBuLnggPSAtci5yLCByLnggPSBuLnIsIHIueSA9IDAsICEocyA+IDIpKSByZXR1cm4gbi5yICsgci5yO1xuICBqZChyLCBuLCBpID0gZVsyXSksIG4gPSBuZXcgVXMobiksIHIgPSBuZXcgVXMociksIGkgPSBuZXcgVXMoaSksIG4ubmV4dCA9IGkucHJldmlvdXMgPSByLCByLm5leHQgPSBuLnByZXZpb3VzID0gaSwgaS5uZXh0ID0gci5wcmV2aW91cyA9IG47XG4gIHQ6IGZvciAobCA9IDM7IGwgPCBzOyArK2wpIHtcbiAgICBqZChuLl8sIHIuXywgaSA9IGVbbF0pLCBpID0gbmV3IFVzKGkpLCBjID0gci5uZXh0LCB1ID0gbi5wcmV2aW91cywgZCA9IHIuXy5yLCBoID0gbi5fLnI7XG4gICAgZG9cbiAgICAgIGlmIChkIDw9IGgpIHtcbiAgICAgICAgaWYgKFdkKGMuXywgaS5fKSkge1xuICAgICAgICAgIHIgPSBjLCBuLm5leHQgPSByLCByLnByZXZpb3VzID0gbiwgLS1sO1xuICAgICAgICAgIGNvbnRpbnVlIHQ7XG4gICAgICAgIH1cbiAgICAgICAgZCArPSBjLl8uciwgYyA9IGMubmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChXZCh1Ll8sIGkuXykpIHtcbiAgICAgICAgICBuID0gdSwgbi5uZXh0ID0gciwgci5wcmV2aW91cyA9IG4sIC0tbDtcbiAgICAgICAgICBjb250aW51ZSB0O1xuICAgICAgICB9XG4gICAgICAgIGggKz0gdS5fLnIsIHUgPSB1LnByZXZpb3VzO1xuICAgICAgfVxuICAgIHdoaWxlIChjICE9PSB1Lm5leHQpO1xuICAgIGZvciAoaS5wcmV2aW91cyA9IG4sIGkubmV4dCA9IHIsIG4ubmV4dCA9IHIucHJldmlvdXMgPSByID0gaSwgYSA9IHFkKG4pOyAoaSA9IGkubmV4dCkgIT09IHI7IClcbiAgICAgIChvID0gcWQoaSkpIDwgYSAmJiAobiA9IGksIGEgPSBvKTtcbiAgICByID0gbi5uZXh0O1xuICB9XG4gIGZvciAobiA9IFtyLl9dLCBpID0gcjsgKGkgPSBpLm5leHQpICE9PSByOyApIG4ucHVzaChpLl8pO1xuICBmb3IgKGkgPSBJTChuLCB0KSwgbCA9IDA7IGwgPCBzOyArK2wpIG4gPSBlW2xdLCBuLnggLT0gaS54LCBuLnkgLT0gaS55O1xuICByZXR1cm4gaS5yO1xufVxuZnVuY3Rpb24gSEwoZSkge1xuICByZXR1cm4gTWF0aC5zcXJ0KGUudmFsdWUpO1xufVxuZnVuY3Rpb24gVkwoKSB7XG4gIHZhciBlID0gbnVsbCwgdCA9IDEsIG4gPSAxLCByID0gS247XG4gIGZ1bmN0aW9uIGkocykge1xuICAgIGNvbnN0IGEgPSBrTCgpO1xuICAgIHJldHVybiBzLnggPSB0IC8gMiwgcy55ID0gbiAvIDIsIGUgPyBzLmVhY2hCZWZvcmUoWWQoZSkpLmVhY2hBZnRlcih0bChyLCAwLjUsIGEpKS5lYWNoQmVmb3JlKFhkKDEpKSA6IHMuZWFjaEJlZm9yZShZZChITCkpLmVhY2hBZnRlcih0bChLbiwgMSwgYSkpLmVhY2hBZnRlcih0bChyLCBzLnIgLyBNYXRoLm1pbih0LCBuKSwgYSkpLmVhY2hCZWZvcmUoWGQoTWF0aC5taW4odCwgbikgLyAoMiAqIHMucikpKSwgcztcbiAgfVxuICByZXR1cm4gaS5yYWRpdXMgPSBmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZSA9IENMKHMpLCBpKSA6IGU7XG4gIH0sIGkuc2l6ZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0ID0gK3NbMF0sIG4gPSArc1sxXSwgaSkgOiBbdCwgbl07XG4gIH0sIGkucGFkZGluZyA9IGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyID0gdHlwZW9mIHMgPT0gXCJmdW5jdGlvblwiID8gcyA6IGtyKCtzKSwgaSkgOiByO1xuICB9LCBpO1xufVxuZnVuY3Rpb24gWWQoZSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHQuY2hpbGRyZW4gfHwgKHQuciA9IE1hdGgubWF4KDAsICtlKHQpIHx8IDApKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHRsKGUsIHQsIG4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHIpIHtcbiAgICBpZiAoaSA9IHIuY2hpbGRyZW4pIHtcbiAgICAgIHZhciBpLCBzLCBhID0gaS5sZW5ndGgsIG8gPSBlKHIpICogdCB8fCAwLCBsO1xuICAgICAgaWYgKG8pIGZvciAocyA9IDA7IHMgPCBhOyArK3MpIGlbc10uciArPSBvO1xuICAgICAgaWYgKGwgPSBCTChpLCBuKSwgbykgZm9yIChzID0gMDsgcyA8IGE7ICsrcykgaVtzXS5yIC09IG87XG4gICAgICByLnIgPSBsICsgbztcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBYZChlKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIG4gPSB0LnBhcmVudDtcbiAgICB0LnIgKj0gZSwgbiAmJiAodC54ID0gbi54ICsgZSAqIHQueCwgdC55ID0gbi55ICsgZSAqIHQueSk7XG4gIH07XG59XG5mdW5jdGlvbiBHTChlKSB7XG4gIGUueDAgPSBNYXRoLnJvdW5kKGUueDApLCBlLnkwID0gTWF0aC5yb3VuZChlLnkwKSwgZS54MSA9IE1hdGgucm91bmQoZS54MSksIGUueTEgPSBNYXRoLnJvdW5kKGUueTEpO1xufVxuZnVuY3Rpb24gekwoZSwgdCwgbiwgciwgaSkge1xuICBmb3IgKHZhciBzID0gZS5jaGlsZHJlbiwgYSwgbyA9IC0xLCBsID0gcy5sZW5ndGgsIGMgPSBlLnZhbHVlICYmIChyIC0gdCkgLyBlLnZhbHVlOyArK28gPCBsOyApXG4gICAgYSA9IHNbb10sIGEueTAgPSBuLCBhLnkxID0gaSwgYS54MCA9IHQsIGEueDEgPSB0ICs9IGEudmFsdWUgKiBjO1xufVxuZnVuY3Rpb24gRkwoZSwgdCkge1xuICByZXR1cm4gZS5wYXJlbnQgPT09IHQucGFyZW50ID8gMSA6IDI7XG59XG5mdW5jdGlvbiBlbChlKSB7XG4gIHZhciB0ID0gZS5jaGlsZHJlbjtcbiAgcmV0dXJuIHQgPyB0WzBdIDogZS50O1xufVxuZnVuY3Rpb24gbmwoZSkge1xuICB2YXIgdCA9IGUuY2hpbGRyZW47XG4gIHJldHVybiB0ID8gdFt0Lmxlbmd0aCAtIDFdIDogZS50O1xufVxuZnVuY3Rpb24gakwoZSwgdCwgbikge1xuICB2YXIgciA9IG4gLyAodC5pIC0gZS5pKTtcbiAgdC5jIC09IHIsIHQucyArPSBuLCBlLmMgKz0gciwgdC56ICs9IG4sIHQubSArPSBuO1xufVxuZnVuY3Rpb24gV0woZSkge1xuICBmb3IgKHZhciB0ID0gMCwgbiA9IDAsIHIgPSBlLmNoaWxkcmVuLCBpID0gci5sZW5ndGgsIHM7IC0taSA+PSAwOyApXG4gICAgcyA9IHJbaV0sIHMueiArPSB0LCBzLm0gKz0gdCwgdCArPSBzLnMgKyAobiArPSBzLmMpO1xufVxuZnVuY3Rpb24gcUwoZSwgdCwgbikge1xuICByZXR1cm4gZS5hLnBhcmVudCA9PT0gdC5wYXJlbnQgPyBlLmEgOiBuO1xufVxuZnVuY3Rpb24gbmEoZSwgdCkge1xuICB0aGlzLl8gPSBlLCB0aGlzLnBhcmVudCA9IG51bGwsIHRoaXMuY2hpbGRyZW4gPSBudWxsLCB0aGlzLkEgPSBudWxsLCB0aGlzLmEgPSB0aGlzLCB0aGlzLnogPSAwLCB0aGlzLm0gPSAwLCB0aGlzLmMgPSAwLCB0aGlzLnMgPSAwLCB0aGlzLnQgPSBudWxsLCB0aGlzLmkgPSB0O1xufVxubmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzcy5wcm90b3R5cGUpO1xuZnVuY3Rpb24gWUwoZSkge1xuICBmb3IgKHZhciB0ID0gbmV3IG5hKGUsIDApLCBuLCByID0gW3RdLCBpLCBzLCBhLCBvOyBuID0gci5wb3AoKTsgKVxuICAgIGlmIChzID0gbi5fLmNoaWxkcmVuKVxuICAgICAgZm9yIChuLmNoaWxkcmVuID0gbmV3IEFycmF5KG8gPSBzLmxlbmd0aCksIGEgPSBvIC0gMTsgYSA+PSAwOyAtLWEpXG4gICAgICAgIHIucHVzaChpID0gbi5jaGlsZHJlblthXSA9IG5ldyBuYShzW2FdLCBhKSksIGkucGFyZW50ID0gbjtcbiAgcmV0dXJuICh0LnBhcmVudCA9IG5ldyBuYShudWxsLCAwKSkuY2hpbGRyZW4gPSBbdF0sIHQ7XG59XG5mdW5jdGlvbiBYTCgpIHtcbiAgdmFyIGUgPSBGTCwgdCA9IDEsIG4gPSAxLCByID0gbnVsbDtcbiAgZnVuY3Rpb24gaShjKSB7XG4gICAgdmFyIHUgPSBZTChjKTtcbiAgICBpZiAodS5lYWNoQWZ0ZXIocyksIHUucGFyZW50Lm0gPSAtdS56LCB1LmVhY2hCZWZvcmUoYSksIHIpIGMuZWFjaEJlZm9yZShsKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBkID0gYywgaCA9IGMsIHAgPSBjO1xuICAgICAgYy5lYWNoQmVmb3JlKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgeC54IDwgZC54ICYmIChkID0geCksIHgueCA+IGgueCAmJiAoaCA9IHgpLCB4LmRlcHRoID4gcC5kZXB0aCAmJiAocCA9IHgpO1xuICAgICAgfSk7XG4gICAgICB2YXIgZiA9IGQgPT09IGggPyAxIDogZShkLCBoKSAvIDIsIGcgPSBmIC0gZC54LCBtID0gdCAvIChoLnggKyBmICsgZyksIHYgPSBuIC8gKHAuZGVwdGggfHwgMSk7XG4gICAgICBjLmVhY2hCZWZvcmUoZnVuY3Rpb24oeCkge1xuICAgICAgICB4LnggPSAoeC54ICsgZykgKiBtLCB4LnkgPSB4LmRlcHRoICogdjtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYztcbiAgfVxuICBmdW5jdGlvbiBzKGMpIHtcbiAgICB2YXIgdSA9IGMuY2hpbGRyZW4sIGQgPSBjLnBhcmVudC5jaGlsZHJlbiwgaCA9IGMuaSA/IGRbYy5pIC0gMV0gOiBudWxsO1xuICAgIGlmICh1KSB7XG4gICAgICBXTChjKTtcbiAgICAgIHZhciBwID0gKHVbMF0ueiArIHVbdS5sZW5ndGggLSAxXS56KSAvIDI7XG4gICAgICBoID8gKGMueiA9IGgueiArIGUoYy5fLCBoLl8pLCBjLm0gPSBjLnogLSBwKSA6IGMueiA9IHA7XG4gICAgfSBlbHNlIGggJiYgKGMueiA9IGgueiArIGUoYy5fLCBoLl8pKTtcbiAgICBjLnBhcmVudC5BID0gbyhjLCBoLCBjLnBhcmVudC5BIHx8IGRbMF0pO1xuICB9XG4gIGZ1bmN0aW9uIGEoYykge1xuICAgIGMuXy54ID0gYy56ICsgYy5wYXJlbnQubSwgYy5tICs9IGMucGFyZW50Lm07XG4gIH1cbiAgZnVuY3Rpb24gbyhjLCB1LCBkKSB7XG4gICAgaWYgKHUpIHtcbiAgICAgIGZvciAodmFyIGggPSBjLCBwID0gYywgZiA9IHUsIGcgPSBoLnBhcmVudC5jaGlsZHJlblswXSwgbSA9IGgubSwgdiA9IHAubSwgeCA9IGYubSwgXyA9IGcubSwgRTsgZiA9IG5sKGYpLCBoID0gZWwoaCksIGYgJiYgaDsgKVxuICAgICAgICBnID0gZWwoZyksIHAgPSBubChwKSwgcC5hID0gYywgRSA9IGYueiArIHggLSBoLnogLSBtICsgZShmLl8sIGguXyksIEUgPiAwICYmIChqTChxTChmLCBjLCBkKSwgYywgRSksIG0gKz0gRSwgdiArPSBFKSwgeCArPSBmLm0sIG0gKz0gaC5tLCBfICs9IGcubSwgdiArPSBwLm07XG4gICAgICBmICYmICFubChwKSAmJiAocC50ID0gZiwgcC5tICs9IHggLSB2KSwgaCAmJiAhZWwoZykgJiYgKGcudCA9IGgsIGcubSArPSBtIC0gXywgZCA9IGMpO1xuICAgIH1cbiAgICByZXR1cm4gZDtcbiAgfVxuICBmdW5jdGlvbiBsKGMpIHtcbiAgICBjLnggKj0gdCwgYy55ID0gYy5kZXB0aCAqIG47XG4gIH1cbiAgcmV0dXJuIGkuc2VwYXJhdGlvbiA9IGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlID0gYywgaSkgOiBlO1xuICB9LCBpLnNpemUgPSBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAociA9ICExLCB0ID0gK2NbMF0sIG4gPSArY1sxXSwgaSkgOiByID8gbnVsbCA6IFt0LCBuXTtcbiAgfSwgaS5ub2RlU2l6ZSA9IGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyID0gITAsIHQgPSArY1swXSwgbiA9ICtjWzFdLCBpKSA6IHIgPyBbdCwgbl0gOiBudWxsO1xuICB9LCBpO1xufVxuZnVuY3Rpb24gWkwoZSwgdCwgbiwgciwgaSkge1xuICBmb3IgKHZhciBzID0gZS5jaGlsZHJlbiwgYSwgbyA9IC0xLCBsID0gcy5sZW5ndGgsIGMgPSBlLnZhbHVlICYmIChpIC0gbikgLyBlLnZhbHVlOyArK28gPCBsOyApXG4gICAgYSA9IHNbb10sIGEueDAgPSB0LCBhLngxID0gciwgYS55MCA9IG4sIGEueTEgPSBuICs9IGEudmFsdWUgKiBjO1xufVxudmFyIEtMID0gKDEgKyBNYXRoLnNxcnQoNSkpIC8gMjtcbmZ1bmN0aW9uIFFMKGUsIHQsIG4sIHIsIGksIHMpIHtcbiAgZm9yICh2YXIgYSA9IFtdLCBvID0gdC5jaGlsZHJlbiwgbCwgYywgdSA9IDAsIGQgPSAwLCBoID0gby5sZW5ndGgsIHAsIGYsIGcgPSB0LnZhbHVlLCBtLCB2LCB4LCBfLCBFLCBiLCBTOyB1IDwgaDsgKSB7XG4gICAgcCA9IGkgLSBuLCBmID0gcyAtIHI7XG4gICAgZG9cbiAgICAgIG0gPSBvW2QrK10udmFsdWU7XG4gICAgd2hpbGUgKCFtICYmIGQgPCBoKTtcbiAgICBmb3IgKHYgPSB4ID0gbSwgYiA9IE1hdGgubWF4KGYgLyBwLCBwIC8gZikgLyAoZyAqIGUpLCBTID0gbSAqIG0gKiBiLCBFID0gTWF0aC5tYXgoeCAvIFMsIFMgLyB2KTsgZCA8IGg7ICsrZCkge1xuICAgICAgaWYgKG0gKz0gYyA9IG9bZF0udmFsdWUsIGMgPCB2ICYmICh2ID0gYyksIGMgPiB4ICYmICh4ID0gYyksIFMgPSBtICogbSAqIGIsIF8gPSBNYXRoLm1heCh4IC8gUywgUyAvIHYpLCBfID4gRSkge1xuICAgICAgICBtIC09IGM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgRSA9IF87XG4gICAgfVxuICAgIGEucHVzaChsID0geyB2YWx1ZTogbSwgZGljZTogcCA8IGYsIGNoaWxkcmVuOiBvLnNsaWNlKHUsIGQpIH0pLCBsLmRpY2UgPyB6TChsLCBuLCByLCBpLCBnID8gciArPSBmICogbSAvIGcgOiBzKSA6IFpMKGwsIG4sIHIsIGcgPyBuICs9IHAgKiBtIC8gZyA6IGksIHMpLCBnIC09IG0sIHUgPSBkO1xuICB9XG4gIHJldHVybiBhO1xufVxuY29uc3QgSkwgPSBmdW5jdGlvbiBlKHQpIHtcbiAgZnVuY3Rpb24gbihyLCBpLCBzLCBhLCBvKSB7XG4gICAgUUwodCwgciwgaSwgcywgYSwgbyk7XG4gIH1cbiAgcmV0dXJuIG4ucmF0aW8gPSBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIGUoKHIgPSArcikgPiAxID8gciA6IDEpO1xuICB9LCBuO1xufShLTCk7XG5mdW5jdGlvbiB0aygpIHtcbiAgdmFyIGUgPSBKTCwgdCA9ICExLCBuID0gMSwgciA9IDEsIGkgPSBbMF0sIHMgPSBLbiwgYSA9IEtuLCBvID0gS24sIGwgPSBLbiwgYyA9IEtuO1xuICBmdW5jdGlvbiB1KGgpIHtcbiAgICByZXR1cm4gaC54MCA9IGgueTAgPSAwLCBoLngxID0gbiwgaC55MSA9IHIsIGguZWFjaEJlZm9yZShkKSwgaSA9IFswXSwgdCAmJiBoLmVhY2hCZWZvcmUoR0wpLCBoO1xuICB9XG4gIGZ1bmN0aW9uIGQoaCkge1xuICAgIHZhciBwID0gaVtoLmRlcHRoXSwgZiA9IGgueDAgKyBwLCBnID0gaC55MCArIHAsIG0gPSBoLngxIC0gcCwgdiA9IGgueTEgLSBwO1xuICAgIG0gPCBmICYmIChmID0gbSA9IChmICsgbSkgLyAyKSwgdiA8IGcgJiYgKGcgPSB2ID0gKGcgKyB2KSAvIDIpLCBoLngwID0gZiwgaC55MCA9IGcsIGgueDEgPSBtLCBoLnkxID0gdiwgaC5jaGlsZHJlbiAmJiAocCA9IGlbaC5kZXB0aCArIDFdID0gcyhoKSAvIDIsIGYgKz0gYyhoKSAtIHAsIGcgKz0gYShoKSAtIHAsIG0gLT0gbyhoKSAtIHAsIHYgLT0gbChoKSAtIHAsIG0gPCBmICYmIChmID0gbSA9IChmICsgbSkgLyAyKSwgdiA8IGcgJiYgKGcgPSB2ID0gKGcgKyB2KSAvIDIpLCBlKGgsIGYsIGcsIG0sIHYpKTtcbiAgfVxuICByZXR1cm4gdS5yb3VuZCA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0ID0gISFoLCB1KSA6IHQ7XG4gIH0sIHUuc2l6ZSA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gK2hbMF0sIHIgPSAraFsxXSwgdSkgOiBbbiwgcl07XG4gIH0sIHUudGlsZSA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlID0gcnYoaCksIHUpIDogZTtcbiAgfSwgdS5wYWRkaW5nID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdS5wYWRkaW5nSW5uZXIoaCkucGFkZGluZ091dGVyKGgpIDogdS5wYWRkaW5nSW5uZXIoKTtcbiAgfSwgdS5wYWRkaW5nSW5uZXIgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocyA9IHR5cGVvZiBoID09IFwiZnVuY3Rpb25cIiA/IGggOiBrcigraCksIHUpIDogcztcbiAgfSwgdS5wYWRkaW5nT3V0ZXIgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB1LnBhZGRpbmdUb3AoaCkucGFkZGluZ1JpZ2h0KGgpLnBhZGRpbmdCb3R0b20oaCkucGFkZGluZ0xlZnQoaCkgOiB1LnBhZGRpbmdUb3AoKTtcbiAgfSwgdS5wYWRkaW5nVG9wID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGEgPSB0eXBlb2YgaCA9PSBcImZ1bmN0aW9uXCIgPyBoIDoga3IoK2gpLCB1KSA6IGE7XG4gIH0sIHUucGFkZGluZ1JpZ2h0ID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG8gPSB0eXBlb2YgaCA9PSBcImZ1bmN0aW9uXCIgPyBoIDoga3IoK2gpLCB1KSA6IG87XG4gIH0sIHUucGFkZGluZ0JvdHRvbSA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChsID0gdHlwZW9mIGggPT0gXCJmdW5jdGlvblwiID8gaCA6IGtyKCtoKSwgdSkgOiBsO1xuICB9LCB1LnBhZGRpbmdMZWZ0ID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGMgPSB0eXBlb2YgaCA9PSBcImZ1bmN0aW9uXCIgPyBoIDoga3IoK2gpLCB1KSA6IGM7XG4gIH0sIHU7XG59XG5mdW5jdGlvbiBobyhlKSB7XG4gIGxldCB0ID0gMztcbiAgcmV0dXJuIGUuZGlnaXRzID0gZnVuY3Rpb24obikge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHQ7XG4gICAgaWYgKG4gPT0gbnVsbClcbiAgICAgIHQgPSBudWxsO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgciA9IE1hdGguZmxvb3Iobik7XG4gICAgICBpZiAoIShyID49IDApKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgaW52YWxpZCBkaWdpdHM6ICR7bn1gKTtcbiAgICAgIHQgPSByO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSwgKCkgPT4gbmV3IHR1KHQpO1xufVxuZnVuY3Rpb24gZWsoZSkge1xuICByZXR1cm4gZS5pbm5lclJhZGl1cztcbn1cbmZ1bmN0aW9uIG5rKGUpIHtcbiAgcmV0dXJuIGUub3V0ZXJSYWRpdXM7XG59XG5mdW5jdGlvbiByayhlKSB7XG4gIHJldHVybiBlLnN0YXJ0QW5nbGU7XG59XG5mdW5jdGlvbiBpayhlKSB7XG4gIHJldHVybiBlLmVuZEFuZ2xlO1xufVxuZnVuY3Rpb24gc2soZSkge1xuICByZXR1cm4gZSAmJiBlLnBhZEFuZ2xlO1xufVxuZnVuY3Rpb24gYWsoZSwgdCwgbiwgciwgaSwgcywgYSwgbykge1xuICB2YXIgbCA9IG4gLSBlLCBjID0gciAtIHQsIHUgPSBhIC0gaSwgZCA9IG8gLSBzLCBoID0gZCAqIGwgLSB1ICogYztcbiAgaWYgKCEoaCAqIGggPCBuZSkpXG4gICAgcmV0dXJuIGggPSAodSAqICh0IC0gcykgLSBkICogKGUgLSBpKSkgLyBoLCBbZSArIGggKiBsLCB0ICsgaCAqIGNdO1xufVxuZnVuY3Rpb24gQnMoZSwgdCwgbiwgciwgaSwgcywgYSkge1xuICB2YXIgbyA9IGUgLSBuLCBsID0gdCAtIHIsIGMgPSAoYSA/IHMgOiAtcykgLyBCcihvICogbyArIGwgKiBsKSwgdSA9IGMgKiBsLCBkID0gLWMgKiBvLCBoID0gZSArIHUsIHAgPSB0ICsgZCwgZiA9IG4gKyB1LCBnID0gciArIGQsIG0gPSAoaCArIGYpIC8gMiwgdiA9IChwICsgZykgLyAyLCB4ID0gZiAtIGgsIF8gPSBnIC0gcCwgRSA9IHggKiB4ICsgXyAqIF8sIGIgPSBpIC0gcywgUyA9IGggKiBnIC0gZiAqIHAsIE0gPSAoXyA8IDAgPyAtMSA6IDEpICogQnIoR00oMCwgYiAqIGIgKiBFIC0gUyAqIFMpKSwgRCA9IChTICogXyAtIHggKiBNKSAvIEUsIEEgPSAoLVMgKiB4IC0gXyAqIE0pIC8gRSwgUiA9IChTICogXyArIHggKiBNKSAvIEUsICQgPSAoLVMgKiB4ICsgXyAqIE0pIC8gRSwgSCA9IEQgLSBtLCBQID0gQSAtIHYsIEIgPSBSIC0gbSwgTyA9ICQgLSB2O1xuICByZXR1cm4gSCAqIEggKyBQICogUCA+IEIgKiBCICsgTyAqIE8gJiYgKEQgPSBSLCBBID0gJCksIHtcbiAgICBjeDogRCxcbiAgICBjeTogQSxcbiAgICB4MDE6IC11LFxuICAgIHkwMTogLWQsXG4gICAgeDExOiBEICogKGkgLyBiIC0gMSksXG4gICAgeTExOiBBICogKGkgLyBiIC0gMSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGFzKCkge1xuICB2YXIgZSA9IGVrLCB0ID0gbmssIG4gPSBkdCgwKSwgciA9IG51bGwsIGkgPSByaywgcyA9IGlrLCBhID0gc2ssIG8gPSBudWxsLCBsID0gaG8oYyk7XG4gIGZ1bmN0aW9uIGMoKSB7XG4gICAgdmFyIHUsIGQsIGggPSArZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwID0gK3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgZiA9IGkuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIFNhLCBnID0gcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gU2EsIG0gPSBpZChnIC0gZiksIHYgPSBnID4gZjtcbiAgICBpZiAobyB8fCAobyA9IHUgPSBsKCkpLCBwIDwgaCAmJiAoZCA9IHAsIHAgPSBoLCBoID0gZCksICEocCA+IG5lKSkgby5tb3ZlVG8oMCwgMCk7XG4gICAgZWxzZSBpZiAobSA+IEtzIC0gbmUpXG4gICAgICBvLm1vdmVUbyhwICogcW4oZiksIHAgKiBaZShmKSksIG8uYXJjKDAsIDAsIHAsIGYsIGcsICF2KSwgaCA+IG5lICYmIChvLm1vdmVUbyhoICogcW4oZyksIGggKiBaZShnKSksIG8uYXJjKDAsIDAsIGgsIGcsIGYsIHYpKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciB4ID0gZiwgXyA9IGcsIEUgPSBmLCBiID0gZywgUyA9IG0sIE0gPSBtLCBEID0gYS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC8gMiwgQSA9IEQgPiBuZSAmJiAociA/ICtyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBCcihoICogaCArIHAgKiBwKSksIFIgPSBHbyhpZChwIC0gaCkgLyAyLCArbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSwgJCA9IFIsIEggPSBSLCBQLCBCO1xuICAgICAgaWYgKEEgPiBuZSkge1xuICAgICAgICB2YXIgTyA9IHNkKEEgLyBoICogWmUoRCkpLCB3ID0gc2QoQSAvIHAgKiBaZShEKSk7XG4gICAgICAgIChTIC09IE8gKiAyKSA+IG5lID8gKE8gKj0gdiA/IDEgOiAtMSwgRSArPSBPLCBiIC09IE8pIDogKFMgPSAwLCBFID0gYiA9IChmICsgZykgLyAyKSwgKE0gLT0gdyAqIDIpID4gbmUgPyAodyAqPSB2ID8gMSA6IC0xLCB4ICs9IHcsIF8gLT0gdykgOiAoTSA9IDAsIHggPSBfID0gKGYgKyBnKSAvIDIpO1xuICAgICAgfVxuICAgICAgdmFyIEwgPSBwICogcW4oeCksIGsgPSBwICogWmUoeCksIFUgPSBoICogcW4oYiksIFogPSBoICogWmUoYik7XG4gICAgICBpZiAoUiA+IG5lKSB7XG4gICAgICAgIHZhciBqID0gcCAqIHFuKF8pLCBGID0gcCAqIFplKF8pLCBZID0gaCAqIHFuKEUpLCBvdCA9IGggKiBaZShFKSwgUTtcbiAgICAgICAgaWYgKG0gPCBucylcbiAgICAgICAgICBpZiAoUSA9IGFrKEwsIGssIFksIG90LCBqLCBGLCBVLCBaKSkge1xuICAgICAgICAgICAgdmFyIHEgPSBMIC0gUVswXSwgdHQgPSBrIC0gUVsxXSwgbHQgPSBqIC0gUVswXSwgeiA9IEYgLSBRWzFdLCBXID0gMSAvIFplKHpNKChxICogbHQgKyB0dCAqIHopIC8gKEJyKHEgKiBxICsgdHQgKiB0dCkgKiBCcihsdCAqIGx0ICsgeiAqIHopKSkgLyAyKSwgWCA9IEJyKFFbMF0gKiBRWzBdICsgUVsxXSAqIFFbMV0pO1xuICAgICAgICAgICAgJCA9IEdvKFIsIChoIC0gWCkgLyAoVyAtIDEpKSwgSCA9IEdvKFIsIChwIC0gWCkgLyAoVyArIDEpKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICQgPSBIID0gMDtcbiAgICAgIH1cbiAgICAgIE0gPiBuZSA/IEggPiBuZSA/IChQID0gQnMoWSwgb3QsIEwsIGssIHAsIEgsIHYpLCBCID0gQnMoaiwgRiwgVSwgWiwgcCwgSCwgdiksIG8ubW92ZVRvKFAuY3ggKyBQLngwMSwgUC5jeSArIFAueTAxKSwgSCA8IFIgPyBvLmFyYyhQLmN4LCBQLmN5LCBILCBKdChQLnkwMSwgUC54MDEpLCBKdChCLnkwMSwgQi54MDEpLCAhdikgOiAoby5hcmMoUC5jeCwgUC5jeSwgSCwgSnQoUC55MDEsIFAueDAxKSwgSnQoUC55MTEsIFAueDExKSwgIXYpLCBvLmFyYygwLCAwLCBwLCBKdChQLmN5ICsgUC55MTEsIFAuY3ggKyBQLngxMSksIEp0KEIuY3kgKyBCLnkxMSwgQi5jeCArIEIueDExKSwgIXYpLCBvLmFyYyhCLmN4LCBCLmN5LCBILCBKdChCLnkxMSwgQi54MTEpLCBKdChCLnkwMSwgQi54MDEpLCAhdikpKSA6IChvLm1vdmVUbyhMLCBrKSwgby5hcmMoMCwgMCwgcCwgeCwgXywgIXYpKSA6IG8ubW92ZVRvKEwsIGspLCAhKGggPiBuZSkgfHwgIShTID4gbmUpID8gby5saW5lVG8oVSwgWikgOiAkID4gbmUgPyAoUCA9IEJzKFUsIFosIGosIEYsIGgsIC0kLCB2KSwgQiA9IEJzKEwsIGssIFksIG90LCBoLCAtJCwgdiksIG8ubGluZVRvKFAuY3ggKyBQLngwMSwgUC5jeSArIFAueTAxKSwgJCA8IFIgPyBvLmFyYyhQLmN4LCBQLmN5LCAkLCBKdChQLnkwMSwgUC54MDEpLCBKdChCLnkwMSwgQi54MDEpLCAhdikgOiAoby5hcmMoUC5jeCwgUC5jeSwgJCwgSnQoUC55MDEsIFAueDAxKSwgSnQoUC55MTEsIFAueDExKSwgIXYpLCBvLmFyYygwLCAwLCBoLCBKdChQLmN5ICsgUC55MTEsIFAuY3ggKyBQLngxMSksIEp0KEIuY3kgKyBCLnkxMSwgQi5jeCArIEIueDExKSwgdiksIG8uYXJjKEIuY3gsIEIuY3ksICQsIEp0KEIueTExLCBCLngxMSksIEp0KEIueTAxLCBCLngwMSksICF2KSkpIDogby5hcmMoMCwgMCwgaCwgYiwgRSwgdik7XG4gICAgfVxuICAgIGlmIChvLmNsb3NlUGF0aCgpLCB1KSByZXR1cm4gbyA9IG51bGwsIHUgKyBcIlwiIHx8IG51bGw7XG4gIH1cbiAgcmV0dXJuIGMuY2VudHJvaWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdSA9ICgrZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgK3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyLCBkID0gKCtpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSAvIDIgLSBucyAvIDI7XG4gICAgcmV0dXJuIFtxbihkKSAqIHUsIFplKGQpICogdV07XG4gIH0sIGMuaW5uZXJSYWRpdXMgPSBmdW5jdGlvbih1KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZSA9IHR5cGVvZiB1ID09IFwiZnVuY3Rpb25cIiA/IHUgOiBkdCgrdSksIGMpIDogZTtcbiAgfSwgYy5vdXRlclJhZGl1cyA9IGZ1bmN0aW9uKHUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0ID0gdHlwZW9mIHUgPT0gXCJmdW5jdGlvblwiID8gdSA6IGR0KCt1KSwgYykgOiB0O1xuICB9LCBjLmNvcm5lclJhZGl1cyA9IGZ1bmN0aW9uKHUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gdHlwZW9mIHUgPT0gXCJmdW5jdGlvblwiID8gdSA6IGR0KCt1KSwgYykgOiBuO1xuICB9LCBjLnBhZFJhZGl1cyA9IGZ1bmN0aW9uKHUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyID0gdSA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiB1ID09IFwiZnVuY3Rpb25cIiA/IHUgOiBkdCgrdSksIGMpIDogcjtcbiAgfSwgYy5zdGFydEFuZ2xlID0gZnVuY3Rpb24odSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGkgPSB0eXBlb2YgdSA9PSBcImZ1bmN0aW9uXCIgPyB1IDogZHQoK3UpLCBjKSA6IGk7XG4gIH0sIGMuZW5kQW5nbGUgPSBmdW5jdGlvbih1KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocyA9IHR5cGVvZiB1ID09IFwiZnVuY3Rpb25cIiA/IHUgOiBkdCgrdSksIGMpIDogcztcbiAgfSwgYy5wYWRBbmdsZSA9IGZ1bmN0aW9uKHUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhID0gdHlwZW9mIHUgPT0gXCJmdW5jdGlvblwiID8gdSA6IGR0KCt1KSwgYykgOiBhO1xuICB9LCBjLmNvbnRleHQgPSBmdW5jdGlvbih1KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobyA9IHUgPz8gbnVsbCwgYykgOiBvO1xuICB9LCBjO1xufVxuZnVuY3Rpb24gaXUoZSkge1xuICByZXR1cm4gZVswXTtcbn1cbmZ1bmN0aW9uIHN1KGUpIHtcbiAgcmV0dXJuIGVbMV07XG59XG5mdW5jdGlvbiB4cyhlLCB0KSB7XG4gIHZhciBuID0gZHQoITApLCByID0gbnVsbCwgaSA9IG9vLCBzID0gbnVsbCwgYSA9IGhvKG8pO1xuICBlID0gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZSA6IGUgPT09IHZvaWQgMCA/IGl1IDogZHQoZSksIHQgPSB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyB0IDogdCA9PT0gdm9pZCAwID8gc3UgOiBkdCh0KTtcbiAgZnVuY3Rpb24gbyhsKSB7XG4gICAgdmFyIGMsIHUgPSAobCA9IHNvKGwpKS5sZW5ndGgsIGQsIGggPSAhMSwgcDtcbiAgICBmb3IgKHIgPT0gbnVsbCAmJiAocyA9IGkocCA9IGEoKSkpLCBjID0gMDsgYyA8PSB1OyArK2MpXG4gICAgICAhKGMgPCB1ICYmIG4oZCA9IGxbY10sIGMsIGwpKSA9PT0gaCAmJiAoKGggPSAhaCkgPyBzLmxpbmVTdGFydCgpIDogcy5saW5lRW5kKCkpLCBoICYmIHMucG9pbnQoK2UoZCwgYywgbCksICt0KGQsIGMsIGwpKTtcbiAgICBpZiAocCkgcmV0dXJuIHMgPSBudWxsLCBwICsgXCJcIiB8fCBudWxsO1xuICB9XG4gIHJldHVybiBvLnggPSBmdW5jdGlvbihsKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZSA9IHR5cGVvZiBsID09IFwiZnVuY3Rpb25cIiA/IGwgOiBkdCgrbCksIG8pIDogZTtcbiAgfSwgby55ID0gZnVuY3Rpb24obCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQgPSB0eXBlb2YgbCA9PSBcImZ1bmN0aW9uXCIgPyBsIDogZHQoK2wpLCBvKSA6IHQ7XG4gIH0sIG8uZGVmaW5lZCA9IGZ1bmN0aW9uKGwpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gdHlwZW9mIGwgPT0gXCJmdW5jdGlvblwiID8gbCA6IGR0KCEhbCksIG8pIDogbjtcbiAgfSwgby5jdXJ2ZSA9IGZ1bmN0aW9uKGwpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpID0gbCwgciAhPSBudWxsICYmIChzID0gaShyKSksIG8pIDogaTtcbiAgfSwgby5jb250ZXh0ID0gZnVuY3Rpb24obCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGwgPT0gbnVsbCA/IHIgPSBzID0gbnVsbCA6IHMgPSBpKHIgPSBsKSwgbykgOiByO1xuICB9LCBvO1xufVxuZnVuY3Rpb24gYXUoZSwgdCwgbikge1xuICB2YXIgciA9IG51bGwsIGkgPSBkdCghMCksIHMgPSBudWxsLCBhID0gb28sIG8gPSBudWxsLCBsID0gaG8oYyk7XG4gIGUgPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlIDogZSA9PT0gdm9pZCAwID8gaXUgOiBkdCgrZSksIHQgPSB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyB0IDogZHQodCA9PT0gdm9pZCAwID8gMCA6ICt0KSwgbiA9IHR5cGVvZiBuID09IFwiZnVuY3Rpb25cIiA/IG4gOiBuID09PSB2b2lkIDAgPyBzdSA6IGR0KCtuKTtcbiAgZnVuY3Rpb24gYyhkKSB7XG4gICAgdmFyIGgsIHAsIGYsIGcgPSAoZCA9IHNvKGQpKS5sZW5ndGgsIG0sIHYgPSAhMSwgeCwgXyA9IG5ldyBBcnJheShnKSwgRSA9IG5ldyBBcnJheShnKTtcbiAgICBmb3IgKHMgPT0gbnVsbCAmJiAobyA9IGEoeCA9IGwoKSkpLCBoID0gMDsgaCA8PSBnOyArK2gpIHtcbiAgICAgIGlmICghKGggPCBnICYmIGkobSA9IGRbaF0sIGgsIGQpKSA9PT0gdilcbiAgICAgICAgaWYgKHYgPSAhdilcbiAgICAgICAgICBwID0gaCwgby5hcmVhU3RhcnQoKSwgby5saW5lU3RhcnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZm9yIChvLmxpbmVFbmQoKSwgby5saW5lU3RhcnQoKSwgZiA9IGggLSAxOyBmID49IHA7IC0tZilcbiAgICAgICAgICAgIG8ucG9pbnQoX1tmXSwgRVtmXSk7XG4gICAgICAgICAgby5saW5lRW5kKCksIG8uYXJlYUVuZCgpO1xuICAgICAgICB9XG4gICAgICB2ICYmIChfW2hdID0gK2UobSwgaCwgZCksIEVbaF0gPSArdChtLCBoLCBkKSwgby5wb2ludChyID8gK3IobSwgaCwgZCkgOiBfW2hdLCBuID8gK24obSwgaCwgZCkgOiBFW2hdKSk7XG4gICAgfVxuICAgIGlmICh4KSByZXR1cm4gbyA9IG51bGwsIHggKyBcIlwiIHx8IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gdSgpIHtcbiAgICByZXR1cm4geHMoKS5kZWZpbmVkKGkpLmN1cnZlKGEpLmNvbnRleHQocyk7XG4gIH1cbiAgcmV0dXJuIGMueCA9IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlID0gdHlwZW9mIGQgPT0gXCJmdW5jdGlvblwiID8gZCA6IGR0KCtkKSwgciA9IG51bGwsIGMpIDogZTtcbiAgfSwgYy54MCA9IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlID0gdHlwZW9mIGQgPT0gXCJmdW5jdGlvblwiID8gZCA6IGR0KCtkKSwgYykgOiBlO1xuICB9LCBjLngxID0gZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHIgPSBkID09IG51bGwgPyBudWxsIDogdHlwZW9mIGQgPT0gXCJmdW5jdGlvblwiID8gZCA6IGR0KCtkKSwgYykgOiByO1xuICB9LCBjLnkgPSBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodCA9IHR5cGVvZiBkID09IFwiZnVuY3Rpb25cIiA/IGQgOiBkdCgrZCksIG4gPSBudWxsLCBjKSA6IHQ7XG4gIH0sIGMueTAgPSBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodCA9IHR5cGVvZiBkID09IFwiZnVuY3Rpb25cIiA/IGQgOiBkdCgrZCksIGMpIDogdDtcbiAgfSwgYy55MSA9IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gZCA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBkID09IFwiZnVuY3Rpb25cIiA/IGQgOiBkdCgrZCksIGMpIDogbjtcbiAgfSwgYy5saW5lWDAgPSBjLmxpbmVZMCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB1KCkueChlKS55KHQpO1xuICB9LCBjLmxpbmVZMSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB1KCkueChlKS55KG4pO1xuICB9LCBjLmxpbmVYMSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB1KCkueChyKS55KHQpO1xuICB9LCBjLmRlZmluZWQgPSBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaSA9IHR5cGVvZiBkID09IFwiZnVuY3Rpb25cIiA/IGQgOiBkdCghIWQpLCBjKSA6IGk7XG4gIH0sIGMuY3VydmUgPSBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYSA9IGQsIHMgIT0gbnVsbCAmJiAobyA9IGEocykpLCBjKSA6IGE7XG4gIH0sIGMuY29udGV4dCA9IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkID09IG51bGwgPyBzID0gbyA9IG51bGwgOiBvID0gYShzID0gZCksIGMpIDogcztcbiAgfSwgYztcbn1cbmZ1bmN0aW9uIG9rKGUsIHQpIHtcbiAgcmV0dXJuIHQgPCBlID8gLTEgOiB0ID4gZSA/IDEgOiB0ID49IGUgPyAwIDogTmFOO1xufVxuZnVuY3Rpb24gbGsoZSkge1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIGNrKCkge1xuICB2YXIgZSA9IGxrLCB0ID0gb2ssIG4gPSBudWxsLCByID0gZHQoMCksIGkgPSBkdChLcyksIHMgPSBkdCgwKTtcbiAgZnVuY3Rpb24gYShvKSB7XG4gICAgdmFyIGwsIGMgPSAobyA9IHNvKG8pKS5sZW5ndGgsIHUsIGQsIGggPSAwLCBwID0gbmV3IEFycmF5KGMpLCBmID0gbmV3IEFycmF5KGMpLCBnID0gK3IuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgbSA9IE1hdGgubWluKEtzLCBNYXRoLm1heCgtS3MsIGkuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGcpKSwgdiwgeCA9IE1hdGgubWluKE1hdGguYWJzKG0pIC8gYywgcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSwgXyA9IHggKiAobSA8IDAgPyAtMSA6IDEpLCBFO1xuICAgIGZvciAobCA9IDA7IGwgPCBjOyArK2wpXG4gICAgICAoRSA9IGZbcFtsXSA9IGxdID0gK2Uob1tsXSwgbCwgbykpID4gMCAmJiAoaCArPSBFKTtcbiAgICBmb3IgKHQgIT0gbnVsbCA/IHAuc29ydChmdW5jdGlvbihiLCBTKSB7XG4gICAgICByZXR1cm4gdChmW2JdLCBmW1NdKTtcbiAgICB9KSA6IG4gIT0gbnVsbCAmJiBwLnNvcnQoZnVuY3Rpb24oYiwgUykge1xuICAgICAgcmV0dXJuIG4ob1tiXSwgb1tTXSk7XG4gICAgfSksIGwgPSAwLCBkID0gaCA/IChtIC0gYyAqIF8pIC8gaCA6IDA7IGwgPCBjOyArK2wsIGcgPSB2KVxuICAgICAgdSA9IHBbbF0sIEUgPSBmW3VdLCB2ID0gZyArIChFID4gMCA/IEUgKiBkIDogMCkgKyBfLCBmW3VdID0ge1xuICAgICAgICBkYXRhOiBvW3VdLFxuICAgICAgICBpbmRleDogbCxcbiAgICAgICAgdmFsdWU6IEUsXG4gICAgICAgIHN0YXJ0QW5nbGU6IGcsXG4gICAgICAgIGVuZEFuZ2xlOiB2LFxuICAgICAgICBwYWRBbmdsZTogeFxuICAgICAgfTtcbiAgICByZXR1cm4gZjtcbiAgfVxuICByZXR1cm4gYS52YWx1ZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlID0gdHlwZW9mIG8gPT0gXCJmdW5jdGlvblwiID8gbyA6IGR0KCtvKSwgYSkgOiBlO1xuICB9LCBhLnNvcnRWYWx1ZXMgPSBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodCA9IG8sIG4gPSBudWxsLCBhKSA6IHQ7XG4gIH0sIGEuc29ydCA9IGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gbywgdCA9IG51bGwsIGEpIDogbjtcbiAgfSwgYS5zdGFydEFuZ2xlID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHIgPSB0eXBlb2YgbyA9PSBcImZ1bmN0aW9uXCIgPyBvIDogZHQoK28pLCBhKSA6IHI7XG4gIH0sIGEuZW5kQW5nbGUgPSBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaSA9IHR5cGVvZiBvID09IFwiZnVuY3Rpb25cIiA/IG8gOiBkdCgrbyksIGEpIDogaTtcbiAgfSwgYS5wYWRBbmdsZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzID0gdHlwZW9mIG8gPT0gXCJmdW5jdGlvblwiID8gbyA6IGR0KCtvKSwgYSkgOiBzO1xuICB9LCBhO1xufVxudmFyIHVrID0gb3Yob28pO1xuZnVuY3Rpb24gYXYoZSkge1xuICB0aGlzLl9jdXJ2ZSA9IGU7XG59XG5hdi5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY3VydmUuYXJlYVN0YXJ0KCk7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnZlLmFyZWFFbmQoKTtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jdXJ2ZS5saW5lU3RhcnQoKTtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY3VydmUubGluZUVuZCgpO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oZSwgdCkge1xuICAgIHRoaXMuX2N1cnZlLnBvaW50KHQgKiBNYXRoLnNpbihlKSwgdCAqIC1NYXRoLmNvcyhlKSk7XG4gIH1cbn07XG5mdW5jdGlvbiBvdihlKSB7XG4gIGZ1bmN0aW9uIHQobikge1xuICAgIHJldHVybiBuZXcgYXYoZShuKSk7XG4gIH1cbiAgcmV0dXJuIHQuX2N1cnZlID0gZSwgdDtcbn1cbmZ1bmN0aW9uIGhrKGUpIHtcbiAgdmFyIHQgPSBlLmN1cnZlO1xuICByZXR1cm4gZS5hbmdsZSA9IGUueCwgZGVsZXRlIGUueCwgZS5yYWRpdXMgPSBlLnksIGRlbGV0ZSBlLnksIGUuY3VydmUgPSBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0KG92KG4pKSA6IHQoKS5fY3VydmU7XG4gIH0sIGU7XG59XG5mdW5jdGlvbiBkaygpIHtcbiAgcmV0dXJuIGhrKHhzKCkuY3VydmUodWspKTtcbn1cbmNsYXNzIHBrIHtcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHRoaXMuX2NvbnRleHQgPSB0LCB0aGlzLl94ID0gbjtcbiAgfVxuICBhcmVhU3RhcnQoKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH1cbiAgYXJlYUVuZCgpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9XG4gIGxpbmVTdGFydCgpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH1cbiAgbGluZUVuZCgpIHtcbiAgICAodGhpcy5fbGluZSB8fCB0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSAmJiB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpLCB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH1cbiAgcG9pbnQodCwgbikge1xuICAgIHN3aXRjaCAodCA9ICt0LCBuID0gK24sIHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHtcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAxLCB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8odCwgbikgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0LCBuKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMjtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhpcy5feCA/IHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh0aGlzLl94MCA9ICh0aGlzLl94MCArIHQpIC8gMiwgdGhpcy5feTAsIHRoaXMuX3gwLCBuLCB0LCBuKSA6IHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh0aGlzLl94MCwgdGhpcy5feTAgPSAodGhpcy5feTAgKyBuKSAvIDIsIHQsIHRoaXMuX3kwLCB0LCBuKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdCwgdGhpcy5feTAgPSBuO1xuICB9XG59XG5mdW5jdGlvbiBmayhlKSB7XG4gIHJldHVybiBuZXcgcGsoZSwgITApO1xufVxuZnVuY3Rpb24gbWsoZSkge1xuICByZXR1cm4gZS5zb3VyY2U7XG59XG5mdW5jdGlvbiBnayhlKSB7XG4gIHJldHVybiBlLnRhcmdldDtcbn1cbmZ1bmN0aW9uIHZrKGUpIHtcbiAgbGV0IHQgPSBtaywgbiA9IGdrLCByID0gaXUsIGkgPSBzdSwgcyA9IG51bGwsIGEgPSBudWxsLCBvID0gaG8obCk7XG4gIGZ1bmN0aW9uIGwoKSB7XG4gICAgbGV0IGM7XG4gICAgY29uc3QgdSA9IGt3LmNhbGwoYXJndW1lbnRzKSwgZCA9IHQuYXBwbHkodGhpcywgdSksIGggPSBuLmFwcGx5KHRoaXMsIHUpO1xuICAgIGlmIChzID09IG51bGwgJiYgKGEgPSBlKGMgPSBvKCkpKSwgYS5saW5lU3RhcnQoKSwgdVswXSA9IGQsIGEucG9pbnQoK3IuYXBwbHkodGhpcywgdSksICtpLmFwcGx5KHRoaXMsIHUpKSwgdVswXSA9IGgsIGEucG9pbnQoK3IuYXBwbHkodGhpcywgdSksICtpLmFwcGx5KHRoaXMsIHUpKSwgYS5saW5lRW5kKCksIGMpIHJldHVybiBhID0gbnVsbCwgYyArIFwiXCIgfHwgbnVsbDtcbiAgfVxuICByZXR1cm4gbC5zb3VyY2UgPSBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodCA9IGMsIGwpIDogdDtcbiAgfSwgbC50YXJnZXQgPSBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9IGMsIGwpIDogbjtcbiAgfSwgbC54ID0gZnVuY3Rpb24oYykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHIgPSB0eXBlb2YgYyA9PSBcImZ1bmN0aW9uXCIgPyBjIDogZHQoK2MpLCBsKSA6IHI7XG4gIH0sIGwueSA9IGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpID0gdHlwZW9mIGMgPT0gXCJmdW5jdGlvblwiID8gYyA6IGR0KCtjKSwgbCkgOiBpO1xuICB9LCBsLmNvbnRleHQgPSBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYyA9PSBudWxsID8gcyA9IGEgPSBudWxsIDogYSA9IGUocyA9IGMpLCBsKSA6IHM7XG4gIH0sIGw7XG59XG5mdW5jdGlvbiB5aygpIHtcbiAgcmV0dXJuIHZrKGZrKTtcbn1cbmxldCBtdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodCwgbiwgcikge1xuICAgIGlmICh0aGlzLnR5cGUgPSBcIlwiLCB0aGlzLnJlbmRlclR5cGUgPSBydC5IVE1MLCB0aGlzLmlkID0gXCJcIiwgdGhpcy5wYXJlbnQgPSB2b2lkIDAsIHRoaXMuY29uZmlncyA9IHt9LCB0aGlzLm1vZGVsID0gdCwgdGhpcy5zZXJ2aWNlcyA9IG4sIHIgJiYgKHRoaXMuY29uZmlncyA9IHIsIHRoaXMuY29uZmlncy5pZCkpIHtcbiAgICAgIGNvbnN0IGkgPSB5KHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLCBcInN0eWxlXCIsIFwicHJlZml4XCIpO1xuICAgICAgdGhpcy5pZCA9IGAke2l9LS0ke3RoaXMuY29uZmlncy5pZH1gO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudCB8fCB0aGlzLnNldFBhcmVudChcbiAgICAgIEkoXG4gICAgICAgIHRoaXMuc2VydmljZXMuZG9tVXRpbHMuZ2V0TWFpbkNvbnRhaW5lcigpXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBpbml0KCkge1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIHJlbmRlcih0ID0gITApIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3I6IENvbXBvbmVudCBkaWQgbm90IHByb3ZpZGUgdGhlIHJlcXVpcmVkIHJlbmRlciBmdW5jdGlvbi5cIik7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgfVxuICAvLyBVc2VkIHRvIHBhc3MgZG93biBpbmZvcm1hdGlvbiB0byB0aGUgY29tcG9uZW50c1xuICBzZXRNb2RlbCh0KSB7XG4gICAgdGhpcy5tb2RlbCA9IHQ7XG4gIH1cbiAgLy8gVXNlZCB0byBwYXNzIGRvd24gaW5mb3JtYXRpb24gdG8gdGhlIGNvbXBvbmVudHNcbiAgc2V0U2VydmljZXModCkge1xuICAgIHRoaXMuc2VydmljZXMgPSB0O1xuICB9XG4gIHNldFBhcmVudCh0KSB7XG4gICAgdmFyIG47XG4gICAgY29uc3QgciA9IHRoaXMucGFyZW50O1xuICAgIGlmICh0aGlzLnBhcmVudCA9IHQsICEociAmJiByLm5vZGUoKSA9PT0gdC5ub2RlKCkpICYmIHRoaXMudHlwZSkge1xuICAgICAgY29uc3QgaSA9IHkodGhpcy5tb2RlbC5nZXRPcHRpb25zKCksIFwic3R5bGVcIiwgXCJwcmVmaXhcIik7XG4gICAgICAobiA9IHRoaXMucGFyZW50KSA9PSBudWxsIHx8IG4uY2xhc3NlZChgJHt1ZX0tLSR7aX0tLSR7dGhpcy50eXBlfWAsICEwKSwgciAmJiByLmNsYXNzZWQoYCR7dWV9LS0ke2l9LS0ke3RoaXMudHlwZX1gLCAhMSk7XG4gICAgfVxuICB9XG4gIGdldFBhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gIH1cbiAgZ2V0Q29tcG9uZW50Q29udGFpbmVyKHQgPSB7IGFyaWFMYWJlbDogbnVsbCwgaXNQcmVzZW50YXRpb25hbDogITEsIHdpdGhpbkNoYXJ0Q2xpcDogITEgfSkge1xuICAgIGlmICh0aGlzLnR5cGUpIHtcbiAgICAgIGNvbnN0IG4gPSB5KHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLCBcInN0eWxlXCIsIFwicHJlZml4XCIpLCByID0gdGhpcy5pZCA/IGAjJHt0aGlzLmlkfWAgOiBcIlwiLCBpID0gTi5hcHBlbmRPclNlbGVjdChcbiAgICAgICAgdGhpcy5wYXJlbnQsXG4gICAgICAgIGAke3RoaXMucmVuZGVyVHlwZSA9PT0gcnQuU1ZHID8gXCJzdmdcIiA6IFwiZGl2XCJ9JHtyfS4ke3VlfS0tJHtufS0tJHt0aGlzLnR5cGV9YFxuICAgICAgKTtcbiAgICAgIGlmICh0LmFyaWFMYWJlbCAmJiBpLmF0dHIoXCJhcmlhLWxhYmVsXCIsIHQuYXJpYUxhYmVsKSwgdC5pc1ByZXNlbnRhdGlvbmFsICYmIGkuYXR0cihcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIiksIHQud2l0aGluQ2hhcnRDbGlwKSB7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLm1vZGVsLmdldChcImNoYXJ0Q2xpcElkXCIpO1xuICAgICAgICBpZiAocykge1xuICAgICAgICAgIGNvbnN0IGEgPSBJKGAjJHtzfWApLnNlbGVjdChcInJlY3RcIik7XG4gICAgICAgICAgYS5zaXplKCkgIT09IDAgJiYgcGFyc2VGbG9hdChhLmF0dHIoXCJoZWlnaHRcIikpID4gMCAmJiBpLmF0dHIoXCJjbGlwLXBhdGhcIiwgYHVybCgjJHtzfSlgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGkuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKS5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICB9XG4gIC8qKlxuICAgKiBncmFwaHMgdXNlZCBpbiBjb21ibyBjaGFydHMgc2hhcmUgYSBtb2RlbCB3aXRoIGdsb2JhbCBvcHRpb25zIGJ1dCBjYW4gcmVjZWl2ZSB0aGVpciBvd24gbG9jYWwgb3B0aW9ucy5cbiAgICogdGhpcyBmdW5jdGlvbiByZXRyaWV2ZXMgdGhlIGdsb2JhbCBvcHRpb25zIGFuZCBtZXJnZXMgaXQgd2l0aCBhbnkgb3B0aW9ucyBwYXNzZWQgaW50byB0aGlzXG4gICAqIGNvbXBvbmVudCdzIGNvbmZpZy5vcHRpb25zIG9iamVjdC5cbiAgICovXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlncy5vcHRpb25zID8gYXQoe30sIHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLCB0aGlzLmNvbmZpZ3Mub3B0aW9ucykgOiB0aGlzLm1vZGVsLmdldE9wdGlvbnMoKTtcbiAgfVxufTtcbi8qISBAbGljZW5zZSBET01QdXJpZnkgMy4yLjYgfCAoYykgQ3VyZTUzIGFuZCBvdGhlciBjb250cmlidXRvcnMgfCBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIGxpY2Vuc2UgMi4wIGFuZCBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlIDIuMCB8IGdpdGh1Yi5jb20vY3VyZTUzL0RPTVB1cmlmeS9ibG9iLzMuMi42L0xJQ0VOU0UgKi9cbmNvbnN0IHtcbiAgZW50cmllczogbHYsXG4gIHNldFByb3RvdHlwZU9mOiBaZCxcbiAgaXNGcm96ZW46IHhrLFxuICBnZXRQcm90b3R5cGVPZjogYmssXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogX2tcbn0gPSBPYmplY3Q7XG5sZXQge1xuICBmcmVlemU6IG9lLFxuICBzZWFsOiBSZSxcbiAgY3JlYXRlOiBjdlxufSA9IE9iamVjdCwge1xuICBhcHBseTogaWMsXG4gIGNvbnN0cnVjdDogc2Ncbn0gPSB0eXBlb2YgUmVmbGVjdCA8IFwidVwiICYmIFJlZmxlY3Q7XG5vZSB8fCAob2UgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlO1xufSk7XG5SZSB8fCAoUmUgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlO1xufSk7XG5pYyB8fCAoaWMgPSBmdW5jdGlvbihlLCB0LCBuKSB7XG4gIHJldHVybiBlLmFwcGx5KHQsIG4pO1xufSk7XG5zYyB8fCAoc2MgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHJldHVybiBuZXcgZSguLi50KTtcbn0pO1xuY29uc3QgSHMgPSBsZShBcnJheS5wcm90b3R5cGUuZm9yRWFjaCksIEVrID0gbGUoQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mKSwgS2QgPSBsZShBcnJheS5wcm90b3R5cGUucG9wKSwgeGkgPSBsZShBcnJheS5wcm90b3R5cGUucHVzaCksIE9rID0gbGUoQXJyYXkucHJvdG90eXBlLnNwbGljZSksIHJhID0gbGUoU3RyaW5nLnByb3RvdHlwZS50b0xvd2VyQ2FzZSksIHJsID0gbGUoU3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyksIFFkID0gbGUoU3RyaW5nLnByb3RvdHlwZS5tYXRjaCksIGJpID0gbGUoU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKSwgU2sgPSBsZShTdHJpbmcucHJvdG90eXBlLmluZGV4T2YpLCBUayA9IGxlKFN0cmluZy5wcm90b3R5cGUudHJpbSksIFVlID0gbGUoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSksIGllID0gbGUoUmVnRXhwLnByb3RvdHlwZS50ZXN0KSwgX2kgPSB3ayhUeXBlRXJyb3IpO1xuZnVuY3Rpb24gbGUoZSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHQgaW5zdGFuY2VvZiBSZWdFeHAgJiYgKHQubGFzdEluZGV4ID0gMCk7XG4gICAgZm9yICh2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBuZXcgQXJyYXkobiA+IDEgPyBuIC0gMSA6IDApLCBpID0gMTsgaSA8IG47IGkrKylcbiAgICAgIHJbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBpYyhlLCB0LCByKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHdrKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoLCBuID0gbmV3IEFycmF5KHQpLCByID0gMDsgciA8IHQ7IHIrKylcbiAgICAgIG5bcl0gPSBhcmd1bWVudHNbcl07XG4gICAgcmV0dXJuIHNjKGUsIG4pO1xuICB9O1xufVxuZnVuY3Rpb24gcHQoZSwgdCkge1xuICBsZXQgbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogcmE7XG4gIFpkICYmIFpkKGUsIG51bGwpO1xuICBsZXQgciA9IHQubGVuZ3RoO1xuICBmb3IgKDsgci0tOyApIHtcbiAgICBsZXQgaSA9IHRbcl07XG4gICAgaWYgKHR5cGVvZiBpID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IHMgPSBuKGkpO1xuICAgICAgcyAhPT0gaSAmJiAoeGsodCkgfHwgKHRbcl0gPSBzKSwgaSA9IHMpO1xuICAgIH1cbiAgICBlW2ldID0gITA7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiAkayhlKSB7XG4gIGZvciAobGV0IHQgPSAwOyB0IDwgZS5sZW5ndGg7IHQrKylcbiAgICBVZShlLCB0KSB8fCAoZVt0XSA9IG51bGwpO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIG1uKGUpIHtcbiAgY29uc3QgdCA9IGN2KG51bGwpO1xuICBmb3IgKGNvbnN0IFtuLCByXSBvZiBsdihlKSlcbiAgICBVZShlLCBuKSAmJiAoQXJyYXkuaXNBcnJheShyKSA/IHRbbl0gPSAkayhyKSA6IHIgJiYgdHlwZW9mIHIgPT0gXCJvYmplY3RcIiAmJiByLmNvbnN0cnVjdG9yID09PSBPYmplY3QgPyB0W25dID0gbW4ocikgOiB0W25dID0gcik7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gRWkoZSwgdCkge1xuICBmb3IgKDsgZSAhPT0gbnVsbDsgKSB7XG4gICAgY29uc3QgciA9IF9rKGUsIHQpO1xuICAgIGlmIChyKSB7XG4gICAgICBpZiAoci5nZXQpXG4gICAgICAgIHJldHVybiBsZShyLmdldCk7XG4gICAgICBpZiAodHlwZW9mIHIudmFsdWUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gbGUoci52YWx1ZSk7XG4gICAgfVxuICAgIGUgPSBiayhlKTtcbiAgfVxuICBmdW5jdGlvbiBuKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBuO1xufVxuY29uc3QgSmQgPSBvZShbXCJhXCIsIFwiYWJiclwiLCBcImFjcm9ueW1cIiwgXCJhZGRyZXNzXCIsIFwiYXJlYVwiLCBcImFydGljbGVcIiwgXCJhc2lkZVwiLCBcImF1ZGlvXCIsIFwiYlwiLCBcImJkaVwiLCBcImJkb1wiLCBcImJpZ1wiLCBcImJsaW5rXCIsIFwiYmxvY2txdW90ZVwiLCBcImJvZHlcIiwgXCJiclwiLCBcImJ1dHRvblwiLCBcImNhbnZhc1wiLCBcImNhcHRpb25cIiwgXCJjZW50ZXJcIiwgXCJjaXRlXCIsIFwiY29kZVwiLCBcImNvbFwiLCBcImNvbGdyb3VwXCIsIFwiY29udGVudFwiLCBcImRhdGFcIiwgXCJkYXRhbGlzdFwiLCBcImRkXCIsIFwiZGVjb3JhdG9yXCIsIFwiZGVsXCIsIFwiZGV0YWlsc1wiLCBcImRmblwiLCBcImRpYWxvZ1wiLCBcImRpclwiLCBcImRpdlwiLCBcImRsXCIsIFwiZHRcIiwgXCJlbGVtZW50XCIsIFwiZW1cIiwgXCJmaWVsZHNldFwiLCBcImZpZ2NhcHRpb25cIiwgXCJmaWd1cmVcIiwgXCJmb250XCIsIFwiZm9vdGVyXCIsIFwiZm9ybVwiLCBcImgxXCIsIFwiaDJcIiwgXCJoM1wiLCBcImg0XCIsIFwiaDVcIiwgXCJoNlwiLCBcImhlYWRcIiwgXCJoZWFkZXJcIiwgXCJoZ3JvdXBcIiwgXCJoclwiLCBcImh0bWxcIiwgXCJpXCIsIFwiaW1nXCIsIFwiaW5wdXRcIiwgXCJpbnNcIiwgXCJrYmRcIiwgXCJsYWJlbFwiLCBcImxlZ2VuZFwiLCBcImxpXCIsIFwibWFpblwiLCBcIm1hcFwiLCBcIm1hcmtcIiwgXCJtYXJxdWVlXCIsIFwibWVudVwiLCBcIm1lbnVpdGVtXCIsIFwibWV0ZXJcIiwgXCJuYXZcIiwgXCJub2JyXCIsIFwib2xcIiwgXCJvcHRncm91cFwiLCBcIm9wdGlvblwiLCBcIm91dHB1dFwiLCBcInBcIiwgXCJwaWN0dXJlXCIsIFwicHJlXCIsIFwicHJvZ3Jlc3NcIiwgXCJxXCIsIFwicnBcIiwgXCJydFwiLCBcInJ1YnlcIiwgXCJzXCIsIFwic2FtcFwiLCBcInNlY3Rpb25cIiwgXCJzZWxlY3RcIiwgXCJzaGFkb3dcIiwgXCJzbWFsbFwiLCBcInNvdXJjZVwiLCBcInNwYWNlclwiLCBcInNwYW5cIiwgXCJzdHJpa2VcIiwgXCJzdHJvbmdcIiwgXCJzdHlsZVwiLCBcInN1YlwiLCBcInN1bW1hcnlcIiwgXCJzdXBcIiwgXCJ0YWJsZVwiLCBcInRib2R5XCIsIFwidGRcIiwgXCJ0ZW1wbGF0ZVwiLCBcInRleHRhcmVhXCIsIFwidGZvb3RcIiwgXCJ0aFwiLCBcInRoZWFkXCIsIFwidGltZVwiLCBcInRyXCIsIFwidHJhY2tcIiwgXCJ0dFwiLCBcInVcIiwgXCJ1bFwiLCBcInZhclwiLCBcInZpZGVvXCIsIFwid2JyXCJdKSwgaWwgPSBvZShbXCJzdmdcIiwgXCJhXCIsIFwiYWx0Z2x5cGhcIiwgXCJhbHRnbHlwaGRlZlwiLCBcImFsdGdseXBoaXRlbVwiLCBcImFuaW1hdGVjb2xvclwiLCBcImFuaW1hdGVtb3Rpb25cIiwgXCJhbmltYXRldHJhbnNmb3JtXCIsIFwiY2lyY2xlXCIsIFwiY2xpcHBhdGhcIiwgXCJkZWZzXCIsIFwiZGVzY1wiLCBcImVsbGlwc2VcIiwgXCJmaWx0ZXJcIiwgXCJmb250XCIsIFwiZ1wiLCBcImdseXBoXCIsIFwiZ2x5cGhyZWZcIiwgXCJoa2VyblwiLCBcImltYWdlXCIsIFwibGluZVwiLCBcImxpbmVhcmdyYWRpZW50XCIsIFwibWFya2VyXCIsIFwibWFza1wiLCBcIm1ldGFkYXRhXCIsIFwibXBhdGhcIiwgXCJwYXRoXCIsIFwicGF0dGVyblwiLCBcInBvbHlnb25cIiwgXCJwb2x5bGluZVwiLCBcInJhZGlhbGdyYWRpZW50XCIsIFwicmVjdFwiLCBcInN0b3BcIiwgXCJzdHlsZVwiLCBcInN3aXRjaFwiLCBcInN5bWJvbFwiLCBcInRleHRcIiwgXCJ0ZXh0cGF0aFwiLCBcInRpdGxlXCIsIFwidHJlZlwiLCBcInRzcGFuXCIsIFwidmlld1wiLCBcInZrZXJuXCJdKSwgc2wgPSBvZShbXCJmZUJsZW5kXCIsIFwiZmVDb2xvck1hdHJpeFwiLCBcImZlQ29tcG9uZW50VHJhbnNmZXJcIiwgXCJmZUNvbXBvc2l0ZVwiLCBcImZlQ29udm9sdmVNYXRyaXhcIiwgXCJmZURpZmZ1c2VMaWdodGluZ1wiLCBcImZlRGlzcGxhY2VtZW50TWFwXCIsIFwiZmVEaXN0YW50TGlnaHRcIiwgXCJmZURyb3BTaGFkb3dcIiwgXCJmZUZsb29kXCIsIFwiZmVGdW5jQVwiLCBcImZlRnVuY0JcIiwgXCJmZUZ1bmNHXCIsIFwiZmVGdW5jUlwiLCBcImZlR2F1c3NpYW5CbHVyXCIsIFwiZmVJbWFnZVwiLCBcImZlTWVyZ2VcIiwgXCJmZU1lcmdlTm9kZVwiLCBcImZlTW9ycGhvbG9neVwiLCBcImZlT2Zmc2V0XCIsIFwiZmVQb2ludExpZ2h0XCIsIFwiZmVTcGVjdWxhckxpZ2h0aW5nXCIsIFwiZmVTcG90TGlnaHRcIiwgXCJmZVRpbGVcIiwgXCJmZVR1cmJ1bGVuY2VcIl0pLCBNayA9IG9lKFtcImFuaW1hdGVcIiwgXCJjb2xvci1wcm9maWxlXCIsIFwiY3Vyc29yXCIsIFwiZGlzY2FyZFwiLCBcImZvbnQtZmFjZVwiLCBcImZvbnQtZmFjZS1mb3JtYXRcIiwgXCJmb250LWZhY2UtbmFtZVwiLCBcImZvbnQtZmFjZS1zcmNcIiwgXCJmb250LWZhY2UtdXJpXCIsIFwiZm9yZWlnbm9iamVjdFwiLCBcImhhdGNoXCIsIFwiaGF0Y2hwYXRoXCIsIFwibWVzaFwiLCBcIm1lc2hncmFkaWVudFwiLCBcIm1lc2hwYXRjaFwiLCBcIm1lc2hyb3dcIiwgXCJtaXNzaW5nLWdseXBoXCIsIFwic2NyaXB0XCIsIFwic2V0XCIsIFwic29saWRjb2xvclwiLCBcInVua25vd25cIiwgXCJ1c2VcIl0pLCBhbCA9IG9lKFtcIm1hdGhcIiwgXCJtZW5jbG9zZVwiLCBcIm1lcnJvclwiLCBcIm1mZW5jZWRcIiwgXCJtZnJhY1wiLCBcIm1nbHlwaFwiLCBcIm1pXCIsIFwibWxhYmVsZWR0clwiLCBcIm1tdWx0aXNjcmlwdHNcIiwgXCJtblwiLCBcIm1vXCIsIFwibW92ZXJcIiwgXCJtcGFkZGVkXCIsIFwibXBoYW50b21cIiwgXCJtcm9vdFwiLCBcIm1yb3dcIiwgXCJtc1wiLCBcIm1zcGFjZVwiLCBcIm1zcXJ0XCIsIFwibXN0eWxlXCIsIFwibXN1YlwiLCBcIm1zdXBcIiwgXCJtc3Vic3VwXCIsIFwibXRhYmxlXCIsIFwibXRkXCIsIFwibXRleHRcIiwgXCJtdHJcIiwgXCJtdW5kZXJcIiwgXCJtdW5kZXJvdmVyXCIsIFwibXByZXNjcmlwdHNcIl0pLCBDayA9IG9lKFtcIm1hY3Rpb25cIiwgXCJtYWxpZ25ncm91cFwiLCBcIm1hbGlnbm1hcmtcIiwgXCJtbG9uZ2RpdlwiLCBcIm1zY2Fycmllc1wiLCBcIm1zY2FycnlcIiwgXCJtc2dyb3VwXCIsIFwibXN0YWNrXCIsIFwibXNsaW5lXCIsIFwibXNyb3dcIiwgXCJzZW1hbnRpY3NcIiwgXCJhbm5vdGF0aW9uXCIsIFwiYW5ub3RhdGlvbi14bWxcIiwgXCJtcHJlc2NyaXB0c1wiLCBcIm5vbmVcIl0pLCB0cCA9IG9lKFtcIiN0ZXh0XCJdKSwgZXAgPSBvZShbXCJhY2NlcHRcIiwgXCJhY3Rpb25cIiwgXCJhbGlnblwiLCBcImFsdFwiLCBcImF1dG9jYXBpdGFsaXplXCIsIFwiYXV0b2NvbXBsZXRlXCIsIFwiYXV0b3BpY3R1cmVpbnBpY3R1cmVcIiwgXCJhdXRvcGxheVwiLCBcImJhY2tncm91bmRcIiwgXCJiZ2NvbG9yXCIsIFwiYm9yZGVyXCIsIFwiY2FwdHVyZVwiLCBcImNlbGxwYWRkaW5nXCIsIFwiY2VsbHNwYWNpbmdcIiwgXCJjaGVja2VkXCIsIFwiY2l0ZVwiLCBcImNsYXNzXCIsIFwiY2xlYXJcIiwgXCJjb2xvclwiLCBcImNvbHNcIiwgXCJjb2xzcGFuXCIsIFwiY29udHJvbHNcIiwgXCJjb250cm9sc2xpc3RcIiwgXCJjb29yZHNcIiwgXCJjcm9zc29yaWdpblwiLCBcImRhdGV0aW1lXCIsIFwiZGVjb2RpbmdcIiwgXCJkZWZhdWx0XCIsIFwiZGlyXCIsIFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlcGljdHVyZWlucGljdHVyZVwiLCBcImRpc2FibGVyZW1vdGVwbGF5YmFja1wiLCBcImRvd25sb2FkXCIsIFwiZHJhZ2dhYmxlXCIsIFwiZW5jdHlwZVwiLCBcImVudGVya2V5aGludFwiLCBcImZhY2VcIiwgXCJmb3JcIiwgXCJoZWFkZXJzXCIsIFwiaGVpZ2h0XCIsIFwiaGlkZGVuXCIsIFwiaGlnaFwiLCBcImhyZWZcIiwgXCJocmVmbGFuZ1wiLCBcImlkXCIsIFwiaW5wdXRtb2RlXCIsIFwiaW50ZWdyaXR5XCIsIFwiaXNtYXBcIiwgXCJraW5kXCIsIFwibGFiZWxcIiwgXCJsYW5nXCIsIFwibGlzdFwiLCBcImxvYWRpbmdcIiwgXCJsb29wXCIsIFwibG93XCIsIFwibWF4XCIsIFwibWF4bGVuZ3RoXCIsIFwibWVkaWFcIiwgXCJtZXRob2RcIiwgXCJtaW5cIiwgXCJtaW5sZW5ndGhcIiwgXCJtdWx0aXBsZVwiLCBcIm11dGVkXCIsIFwibmFtZVwiLCBcIm5vbmNlXCIsIFwibm9zaGFkZVwiLCBcIm5vdmFsaWRhdGVcIiwgXCJub3dyYXBcIiwgXCJvcGVuXCIsIFwib3B0aW11bVwiLCBcInBhdHRlcm5cIiwgXCJwbGFjZWhvbGRlclwiLCBcInBsYXlzaW5saW5lXCIsIFwicG9wb3ZlclwiLCBcInBvcG92ZXJ0YXJnZXRcIiwgXCJwb3BvdmVydGFyZ2V0YWN0aW9uXCIsIFwicG9zdGVyXCIsIFwicHJlbG9hZFwiLCBcInB1YmRhdGVcIiwgXCJyYWRpb2dyb3VwXCIsIFwicmVhZG9ubHlcIiwgXCJyZWxcIiwgXCJyZXF1aXJlZFwiLCBcInJldlwiLCBcInJldmVyc2VkXCIsIFwicm9sZVwiLCBcInJvd3NcIiwgXCJyb3dzcGFuXCIsIFwic3BlbGxjaGVja1wiLCBcInNjb3BlXCIsIFwic2VsZWN0ZWRcIiwgXCJzaGFwZVwiLCBcInNpemVcIiwgXCJzaXplc1wiLCBcInNwYW5cIiwgXCJzcmNsYW5nXCIsIFwic3RhcnRcIiwgXCJzcmNcIiwgXCJzcmNzZXRcIiwgXCJzdGVwXCIsIFwic3R5bGVcIiwgXCJzdW1tYXJ5XCIsIFwidGFiaW5kZXhcIiwgXCJ0aXRsZVwiLCBcInRyYW5zbGF0ZVwiLCBcInR5cGVcIiwgXCJ1c2VtYXBcIiwgXCJ2YWxpZ25cIiwgXCJ2YWx1ZVwiLCBcIndpZHRoXCIsIFwid3JhcFwiLCBcInhtbG5zXCIsIFwic2xvdFwiXSksIG9sID0gb2UoW1wiYWNjZW50LWhlaWdodFwiLCBcImFjY3VtdWxhdGVcIiwgXCJhZGRpdGl2ZVwiLCBcImFsaWdubWVudC1iYXNlbGluZVwiLCBcImFtcGxpdHVkZVwiLCBcImFzY2VudFwiLCBcImF0dHJpYnV0ZW5hbWVcIiwgXCJhdHRyaWJ1dGV0eXBlXCIsIFwiYXppbXV0aFwiLCBcImJhc2VmcmVxdWVuY3lcIiwgXCJiYXNlbGluZS1zaGlmdFwiLCBcImJlZ2luXCIsIFwiYmlhc1wiLCBcImJ5XCIsIFwiY2xhc3NcIiwgXCJjbGlwXCIsIFwiY2xpcHBhdGh1bml0c1wiLCBcImNsaXAtcGF0aFwiLCBcImNsaXAtcnVsZVwiLCBcImNvbG9yXCIsIFwiY29sb3ItaW50ZXJwb2xhdGlvblwiLCBcImNvbG9yLWludGVycG9sYXRpb24tZmlsdGVyc1wiLCBcImNvbG9yLXByb2ZpbGVcIiwgXCJjb2xvci1yZW5kZXJpbmdcIiwgXCJjeFwiLCBcImN5XCIsIFwiZFwiLCBcImR4XCIsIFwiZHlcIiwgXCJkaWZmdXNlY29uc3RhbnRcIiwgXCJkaXJlY3Rpb25cIiwgXCJkaXNwbGF5XCIsIFwiZGl2aXNvclwiLCBcImR1clwiLCBcImVkZ2Vtb2RlXCIsIFwiZWxldmF0aW9uXCIsIFwiZW5kXCIsIFwiZXhwb25lbnRcIiwgXCJmaWxsXCIsIFwiZmlsbC1vcGFjaXR5XCIsIFwiZmlsbC1ydWxlXCIsIFwiZmlsdGVyXCIsIFwiZmlsdGVydW5pdHNcIiwgXCJmbG9vZC1jb2xvclwiLCBcImZsb29kLW9wYWNpdHlcIiwgXCJmb250LWZhbWlseVwiLCBcImZvbnQtc2l6ZVwiLCBcImZvbnQtc2l6ZS1hZGp1c3RcIiwgXCJmb250LXN0cmV0Y2hcIiwgXCJmb250LXN0eWxlXCIsIFwiZm9udC12YXJpYW50XCIsIFwiZm9udC13ZWlnaHRcIiwgXCJmeFwiLCBcImZ5XCIsIFwiZzFcIiwgXCJnMlwiLCBcImdseXBoLW5hbWVcIiwgXCJnbHlwaHJlZlwiLCBcImdyYWRpZW50dW5pdHNcIiwgXCJncmFkaWVudHRyYW5zZm9ybVwiLCBcImhlaWdodFwiLCBcImhyZWZcIiwgXCJpZFwiLCBcImltYWdlLXJlbmRlcmluZ1wiLCBcImluXCIsIFwiaW4yXCIsIFwiaW50ZXJjZXB0XCIsIFwia1wiLCBcImsxXCIsIFwiazJcIiwgXCJrM1wiLCBcIms0XCIsIFwia2VybmluZ1wiLCBcImtleXBvaW50c1wiLCBcImtleXNwbGluZXNcIiwgXCJrZXl0aW1lc1wiLCBcImxhbmdcIiwgXCJsZW5ndGhhZGp1c3RcIiwgXCJsZXR0ZXItc3BhY2luZ1wiLCBcImtlcm5lbG1hdHJpeFwiLCBcImtlcm5lbHVuaXRsZW5ndGhcIiwgXCJsaWdodGluZy1jb2xvclwiLCBcImxvY2FsXCIsIFwibWFya2VyLWVuZFwiLCBcIm1hcmtlci1taWRcIiwgXCJtYXJrZXItc3RhcnRcIiwgXCJtYXJrZXJoZWlnaHRcIiwgXCJtYXJrZXJ1bml0c1wiLCBcIm1hcmtlcndpZHRoXCIsIFwibWFza2NvbnRlbnR1bml0c1wiLCBcIm1hc2t1bml0c1wiLCBcIm1heFwiLCBcIm1hc2tcIiwgXCJtZWRpYVwiLCBcIm1ldGhvZFwiLCBcIm1vZGVcIiwgXCJtaW5cIiwgXCJuYW1lXCIsIFwibnVtb2N0YXZlc1wiLCBcIm9mZnNldFwiLCBcIm9wZXJhdG9yXCIsIFwib3BhY2l0eVwiLCBcIm9yZGVyXCIsIFwib3JpZW50XCIsIFwib3JpZW50YXRpb25cIiwgXCJvcmlnaW5cIiwgXCJvdmVyZmxvd1wiLCBcInBhaW50LW9yZGVyXCIsIFwicGF0aFwiLCBcInBhdGhsZW5ndGhcIiwgXCJwYXR0ZXJuY29udGVudHVuaXRzXCIsIFwicGF0dGVybnRyYW5zZm9ybVwiLCBcInBhdHRlcm51bml0c1wiLCBcInBvaW50c1wiLCBcInByZXNlcnZlYWxwaGFcIiwgXCJwcmVzZXJ2ZWFzcGVjdHJhdGlvXCIsIFwicHJpbWl0aXZldW5pdHNcIiwgXCJyXCIsIFwicnhcIiwgXCJyeVwiLCBcInJhZGl1c1wiLCBcInJlZnhcIiwgXCJyZWZ5XCIsIFwicmVwZWF0Y291bnRcIiwgXCJyZXBlYXRkdXJcIiwgXCJyZXN0YXJ0XCIsIFwicmVzdWx0XCIsIFwicm90YXRlXCIsIFwic2NhbGVcIiwgXCJzZWVkXCIsIFwic2hhcGUtcmVuZGVyaW5nXCIsIFwic2xvcGVcIiwgXCJzcGVjdWxhcmNvbnN0YW50XCIsIFwic3BlY3VsYXJleHBvbmVudFwiLCBcInNwcmVhZG1ldGhvZFwiLCBcInN0YXJ0b2Zmc2V0XCIsIFwic3RkZGV2aWF0aW9uXCIsIFwic3RpdGNodGlsZXNcIiwgXCJzdG9wLWNvbG9yXCIsIFwic3RvcC1vcGFjaXR5XCIsIFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcInN0cm9rZS1kYXNob2Zmc2V0XCIsIFwic3Ryb2tlLWxpbmVjYXBcIiwgXCJzdHJva2UtbGluZWpvaW5cIiwgXCJzdHJva2UtbWl0ZXJsaW1pdFwiLCBcInN0cm9rZS1vcGFjaXR5XCIsIFwic3Ryb2tlXCIsIFwic3Ryb2tlLXdpZHRoXCIsIFwic3R5bGVcIiwgXCJzdXJmYWNlc2NhbGVcIiwgXCJzeXN0ZW1sYW5ndWFnZVwiLCBcInRhYmluZGV4XCIsIFwidGFibGV2YWx1ZXNcIiwgXCJ0YXJnZXR4XCIsIFwidGFyZ2V0eVwiLCBcInRyYW5zZm9ybVwiLCBcInRyYW5zZm9ybS1vcmlnaW5cIiwgXCJ0ZXh0LWFuY2hvclwiLCBcInRleHQtZGVjb3JhdGlvblwiLCBcInRleHQtcmVuZGVyaW5nXCIsIFwidGV4dGxlbmd0aFwiLCBcInR5cGVcIiwgXCJ1MVwiLCBcInUyXCIsIFwidW5pY29kZVwiLCBcInZhbHVlc1wiLCBcInZpZXdib3hcIiwgXCJ2aXNpYmlsaXR5XCIsIFwidmVyc2lvblwiLCBcInZlcnQtYWR2LXlcIiwgXCJ2ZXJ0LW9yaWdpbi14XCIsIFwidmVydC1vcmlnaW4teVwiLCBcIndpZHRoXCIsIFwid29yZC1zcGFjaW5nXCIsIFwid3JhcFwiLCBcIndyaXRpbmctbW9kZVwiLCBcInhjaGFubmVsc2VsZWN0b3JcIiwgXCJ5Y2hhbm5lbHNlbGVjdG9yXCIsIFwieFwiLCBcIngxXCIsIFwieDJcIiwgXCJ4bWxuc1wiLCBcInlcIiwgXCJ5MVwiLCBcInkyXCIsIFwielwiLCBcInpvb21hbmRwYW5cIl0pLCBucCA9IG9lKFtcImFjY2VudFwiLCBcImFjY2VudHVuZGVyXCIsIFwiYWxpZ25cIiwgXCJiZXZlbGxlZFwiLCBcImNsb3NlXCIsIFwiY29sdW1uc2FsaWduXCIsIFwiY29sdW1ubGluZXNcIiwgXCJjb2x1bW5zcGFuXCIsIFwiZGVub21hbGlnblwiLCBcImRlcHRoXCIsIFwiZGlyXCIsIFwiZGlzcGxheVwiLCBcImRpc3BsYXlzdHlsZVwiLCBcImVuY29kaW5nXCIsIFwiZmVuY2VcIiwgXCJmcmFtZVwiLCBcImhlaWdodFwiLCBcImhyZWZcIiwgXCJpZFwiLCBcImxhcmdlb3BcIiwgXCJsZW5ndGhcIiwgXCJsaW5ldGhpY2tuZXNzXCIsIFwibHNwYWNlXCIsIFwibHF1b3RlXCIsIFwibWF0aGJhY2tncm91bmRcIiwgXCJtYXRoY29sb3JcIiwgXCJtYXRoc2l6ZVwiLCBcIm1hdGh2YXJpYW50XCIsIFwibWF4c2l6ZVwiLCBcIm1pbnNpemVcIiwgXCJtb3ZhYmxlbGltaXRzXCIsIFwibm90YXRpb25cIiwgXCJudW1hbGlnblwiLCBcIm9wZW5cIiwgXCJyb3dhbGlnblwiLCBcInJvd2xpbmVzXCIsIFwicm93c3BhY2luZ1wiLCBcInJvd3NwYW5cIiwgXCJyc3BhY2VcIiwgXCJycXVvdGVcIiwgXCJzY3JpcHRsZXZlbFwiLCBcInNjcmlwdG1pbnNpemVcIiwgXCJzY3JpcHRzaXplbXVsdGlwbGllclwiLCBcInNlbGVjdGlvblwiLCBcInNlcGFyYXRvclwiLCBcInNlcGFyYXRvcnNcIiwgXCJzdHJldGNoeVwiLCBcInN1YnNjcmlwdHNoaWZ0XCIsIFwic3Vwc2NyaXB0c2hpZnRcIiwgXCJzeW1tZXRyaWNcIiwgXCJ2b2Zmc2V0XCIsIFwid2lkdGhcIiwgXCJ4bWxuc1wiXSksIFZzID0gb2UoW1wieGxpbms6aHJlZlwiLCBcInhtbDppZFwiLCBcInhsaW5rOnRpdGxlXCIsIFwieG1sOnNwYWNlXCIsIFwieG1sbnM6eGxpbmtcIl0pLCBBayA9IFJlKC9cXHtcXHtbXFx3XFxXXSp8W1xcd1xcV10qXFx9XFx9L2dtKSwgTGsgPSBSZSgvPCVbXFx3XFxXXSp8W1xcd1xcV10qJT4vZ20pLCBrayA9IFJlKC9cXCRcXHtbXFx3XFxXXSovZ20pLCBEayA9IFJlKC9eZGF0YS1bXFwtXFx3LlxcdTAwQjctXFx1RkZGRl0rJC8pLCBSayA9IFJlKC9eYXJpYS1bXFwtXFx3XSskLyksIHV2ID0gUmUoXG4gIC9eKD86KD86KD86ZnxodCl0cHM/fG1haWx0b3x0ZWx8Y2FsbHRvfHNtc3xjaWR8eG1wcHxtYXRyaXgpOnxbXmEtel18W2EteisuXFwtXSsoPzpbXmEteisuXFwtOl18JCkpL2lcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuKSwgSWsgPSBSZSgvXig/OlxcdytzY3JpcHR8ZGF0YSk6L2kpLCBOayA9IFJlKFxuICAvW1xcdTAwMDAtXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MTgwRVxcdTIwMDAtXFx1MjAyOVxcdTIwNUZcXHUzMDAwXS9nXG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udHJvbC1yZWdleFxuKSwgaHYgPSBSZSgvXmh0bWwkL2kpLCBQayA9IFJlKC9eW2Etel1bLlxcd10qKC1bLlxcd10rKSskL2kpO1xudmFyIHJwID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEFSSUFfQVRUUjogUmssXG4gIEFUVFJfV0hJVEVTUEFDRTogTmssXG4gIENVU1RPTV9FTEVNRU5UOiBQayxcbiAgREFUQV9BVFRSOiBEayxcbiAgRE9DVFlQRV9OQU1FOiBodixcbiAgRVJCX0VYUFI6IExrLFxuICBJU19BTExPV0VEX1VSSTogdXYsXG4gIElTX1NDUklQVF9PUl9EQVRBOiBJayxcbiAgTVVTVEFDSEVfRVhQUjogQWssXG4gIFRNUExJVF9FWFBSOiBra1xufSk7XG5jb25zdCBPaSA9IHtcbiAgZWxlbWVudDogMSxcbiAgdGV4dDogMyxcbiAgLy8gRGVwcmVjYXRlZFxuICBwcm9ncmVzc2luZ0luc3RydWN0aW9uOiA3LFxuICBjb21tZW50OiA4LFxuICBkb2N1bWVudDogOVxufSwgVWsgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPiBcInVcIiA/IG51bGwgOiB3aW5kb3c7XG59LCBCayA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgaWYgKHR5cGVvZiBlICE9IFwib2JqZWN0XCIgfHwgdHlwZW9mIGUuY3JlYXRlUG9saWN5ICE9IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IG4gPSBudWxsO1xuICBjb25zdCByID0gXCJkYXRhLXR0LXBvbGljeS1zdWZmaXhcIjtcbiAgdCAmJiB0Lmhhc0F0dHJpYnV0ZShyKSAmJiAobiA9IHQuZ2V0QXR0cmlidXRlKHIpKTtcbiAgY29uc3QgaSA9IFwiZG9tcHVyaWZ5XCIgKyAobiA/IFwiI1wiICsgbiA6IFwiXCIpO1xuICB0cnkge1xuICAgIHJldHVybiBlLmNyZWF0ZVBvbGljeShpLCB7XG4gICAgICBjcmVhdGVIVE1MKHMpIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9LFxuICAgICAgY3JlYXRlU2NyaXB0VVJMKHMpIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJUcnVzdGVkVHlwZXMgcG9saWN5IFwiICsgaSArIFwiIGNvdWxkIG5vdCBiZSBjcmVhdGVkLlwiKSwgbnVsbDtcbiAgfVxufSwgaXAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBhZnRlclNhbml0aXplQXR0cmlidXRlczogW10sXG4gICAgYWZ0ZXJTYW5pdGl6ZUVsZW1lbnRzOiBbXSxcbiAgICBhZnRlclNhbml0aXplU2hhZG93RE9NOiBbXSxcbiAgICBiZWZvcmVTYW5pdGl6ZUF0dHJpYnV0ZXM6IFtdLFxuICAgIGJlZm9yZVNhbml0aXplRWxlbWVudHM6IFtdLFxuICAgIGJlZm9yZVNhbml0aXplU2hhZG93RE9NOiBbXSxcbiAgICB1cG9uU2FuaXRpemVBdHRyaWJ1dGU6IFtdLFxuICAgIHVwb25TYW5pdGl6ZUVsZW1lbnQ6IFtdLFxuICAgIHVwb25TYW5pdGl6ZVNoYWRvd05vZGU6IFtdXG4gIH07XG59O1xuZnVuY3Rpb24gZHYoKSB7XG4gIGxldCBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiBVaygpO1xuICBjb25zdCB0ID0gKEMpID0+IGR2KEMpO1xuICBpZiAodC52ZXJzaW9uID0gXCIzLjIuNlwiLCB0LnJlbW92ZWQgPSBbXSwgIWUgfHwgIWUuZG9jdW1lbnQgfHwgZS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gT2kuZG9jdW1lbnQgfHwgIWUuRWxlbWVudClcbiAgICByZXR1cm4gdC5pc1N1cHBvcnRlZCA9ICExLCB0O1xuICBsZXQge1xuICAgIGRvY3VtZW50OiBuXG4gIH0gPSBlO1xuICBjb25zdCByID0gbiwgaSA9IHIuY3VycmVudFNjcmlwdCwge1xuICAgIERvY3VtZW50RnJhZ21lbnQ6IHMsXG4gICAgSFRNTFRlbXBsYXRlRWxlbWVudDogYSxcbiAgICBOb2RlOiBvLFxuICAgIEVsZW1lbnQ6IGwsXG4gICAgTm9kZUZpbHRlcjogYyxcbiAgICBOYW1lZE5vZGVNYXA6IHUgPSBlLk5hbWVkTm9kZU1hcCB8fCBlLk1vek5hbWVkQXR0ck1hcCxcbiAgICBIVE1MRm9ybUVsZW1lbnQ6IGQsXG4gICAgRE9NUGFyc2VyOiBoLFxuICAgIHRydXN0ZWRUeXBlczogcFxuICB9ID0gZSwgZiA9IGwucHJvdG90eXBlLCBnID0gRWkoZiwgXCJjbG9uZU5vZGVcIiksIG0gPSBFaShmLCBcInJlbW92ZVwiKSwgdiA9IEVpKGYsIFwibmV4dFNpYmxpbmdcIiksIHggPSBFaShmLCBcImNoaWxkTm9kZXNcIiksIF8gPSBFaShmLCBcInBhcmVudE5vZGVcIik7XG4gIGlmICh0eXBlb2YgYSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCBDID0gbi5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG4gICAgQy5jb250ZW50ICYmIEMuY29udGVudC5vd25lckRvY3VtZW50ICYmIChuID0gQy5jb250ZW50Lm93bmVyRG9jdW1lbnQpO1xuICB9XG4gIGxldCBFLCBiID0gXCJcIjtcbiAgY29uc3Qge1xuICAgIGltcGxlbWVudGF0aW9uOiBTLFxuICAgIGNyZWF0ZU5vZGVJdGVyYXRvcjogTSxcbiAgICBjcmVhdGVEb2N1bWVudEZyYWdtZW50OiBELFxuICAgIGdldEVsZW1lbnRzQnlUYWdOYW1lOiBBXG4gIH0gPSBuLCB7XG4gICAgaW1wb3J0Tm9kZTogUlxuICB9ID0gcjtcbiAgbGV0ICQgPSBpcCgpO1xuICB0LmlzU3VwcG9ydGVkID0gdHlwZW9mIGx2ID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgXyA9PSBcImZ1bmN0aW9uXCIgJiYgUyAmJiBTLmNyZWF0ZUhUTUxEb2N1bWVudCAhPT0gdm9pZCAwO1xuICBjb25zdCB7XG4gICAgTVVTVEFDSEVfRVhQUjogSCxcbiAgICBFUkJfRVhQUjogUCxcbiAgICBUTVBMSVRfRVhQUjogQixcbiAgICBEQVRBX0FUVFI6IE8sXG4gICAgQVJJQV9BVFRSOiB3LFxuICAgIElTX1NDUklQVF9PUl9EQVRBOiBMLFxuICAgIEFUVFJfV0hJVEVTUEFDRTogayxcbiAgICBDVVNUT01fRUxFTUVOVDogVVxuICB9ID0gcnA7XG4gIGxldCB7XG4gICAgSVNfQUxMT1dFRF9VUkk6IFpcbiAgfSA9IHJwLCBqID0gbnVsbDtcbiAgY29uc3QgRiA9IHB0KHt9LCBbLi4uSmQsIC4uLmlsLCAuLi5zbCwgLi4uYWwsIC4uLnRwXSk7XG4gIGxldCBZID0gbnVsbDtcbiAgY29uc3Qgb3QgPSBwdCh7fSwgWy4uLmVwLCAuLi5vbCwgLi4ubnAsIC4uLlZzXSk7XG4gIGxldCBRID0gT2JqZWN0LnNlYWwoY3YobnVsbCwge1xuICAgIHRhZ05hbWVDaGVjazoge1xuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9LFxuICAgIGF0dHJpYnV0ZU5hbWVDaGVjazoge1xuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9LFxuICAgIGFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50czoge1xuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgdmFsdWU6ICExXG4gICAgfVxuICB9KSksIHEgPSBudWxsLCB0dCA9IG51bGwsIGx0ID0gITAsIHogPSAhMCwgVyA9ICExLCBYID0gITAsIFYgPSAhMSwgdXQgPSAhMCwgc3QgPSAhMSwgRHQgPSAhMSwgTnQgPSAhMSwgbnQgPSAhMSwgeXQgPSAhMSwgU2UgPSAhMSwgZ2UgPSAhMCwgb2kgPSAhMTtcbiAgY29uc3QgbGkgPSBcInVzZXItY29udGVudC1cIjtcbiAgbGV0IEZuID0gITAsIEllID0gITEsIHlyID0ge30sIHhyID0gbnVsbDtcbiAgY29uc3QgeHUgPSBwdCh7fSwgW1wiYW5ub3RhdGlvbi14bWxcIiwgXCJhdWRpb1wiLCBcImNvbGdyb3VwXCIsIFwiZGVzY1wiLCBcImZvcmVpZ25vYmplY3RcIiwgXCJoZWFkXCIsIFwiaWZyYW1lXCIsIFwibWF0aFwiLCBcIm1pXCIsIFwibW5cIiwgXCJtb1wiLCBcIm1zXCIsIFwibXRleHRcIiwgXCJub2VtYmVkXCIsIFwibm9mcmFtZXNcIiwgXCJub3NjcmlwdFwiLCBcInBsYWludGV4dFwiLCBcInNjcmlwdFwiLCBcInN0eWxlXCIsIFwic3ZnXCIsIFwidGVtcGxhdGVcIiwgXCJ0aGVhZFwiLCBcInRpdGxlXCIsIFwidmlkZW9cIiwgXCJ4bXBcIl0pO1xuICBsZXQgYnUgPSBudWxsO1xuICBjb25zdCBfdSA9IHB0KHt9LCBbXCJhdWRpb1wiLCBcInZpZGVvXCIsIFwiaW1nXCIsIFwic291cmNlXCIsIFwiaW1hZ2VcIiwgXCJ0cmFja1wiXSk7XG4gIGxldCB5byA9IG51bGw7XG4gIGNvbnN0IEV1ID0gcHQoe30sIFtcImFsdFwiLCBcImNsYXNzXCIsIFwiZm9yXCIsIFwiaWRcIiwgXCJsYWJlbFwiLCBcIm5hbWVcIiwgXCJwYXR0ZXJuXCIsIFwicGxhY2Vob2xkZXJcIiwgXCJyb2xlXCIsIFwic3VtbWFyeVwiLCBcInRpdGxlXCIsIFwidmFsdWVcIiwgXCJzdHlsZVwiLCBcInhtbG5zXCJdKSwgX3MgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIiwgRXMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIG9uID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG4gIGxldCBiciA9IG9uLCB4byA9ICExLCBibyA9IG51bGw7XG4gIGNvbnN0IG4wID0gcHQoe30sIFtfcywgRXMsIG9uXSwgcmwpO1xuICBsZXQgT3MgPSBwdCh7fSwgW1wibWlcIiwgXCJtb1wiLCBcIm1uXCIsIFwibXNcIiwgXCJtdGV4dFwiXSksIFNzID0gcHQoe30sIFtcImFubm90YXRpb24teG1sXCJdKTtcbiAgY29uc3QgcjAgPSBwdCh7fSwgW1widGl0bGVcIiwgXCJzdHlsZVwiLCBcImZvbnRcIiwgXCJhXCIsIFwic2NyaXB0XCJdKTtcbiAgbGV0IGNpID0gbnVsbDtcbiAgY29uc3QgaTAgPSBbXCJhcHBsaWNhdGlvbi94aHRtbCt4bWxcIiwgXCJ0ZXh0L2h0bWxcIl0sIHMwID0gXCJ0ZXh0L2h0bWxcIjtcbiAgbGV0IHF0ID0gbnVsbCwgX3IgPSBudWxsO1xuICBjb25zdCBhMCA9IG4uY3JlYXRlRWxlbWVudChcImZvcm1cIiksIE91ID0gZnVuY3Rpb24oQykge1xuICAgIHJldHVybiBDIGluc3RhbmNlb2YgUmVnRXhwIHx8IEMgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbiAgfSwgX28gPSBmdW5jdGlvbigpIHtcbiAgICBsZXQgQyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgaWYgKCEoX3IgJiYgX3IgPT09IEMpKSB7XG4gICAgICBpZiAoKCFDIHx8IHR5cGVvZiBDICE9IFwib2JqZWN0XCIpICYmIChDID0ge30pLCBDID0gbW4oQyksIGNpID0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWluY2x1ZGVzXG4gICAgICBpMC5pbmRleE9mKEMuUEFSU0VSX01FRElBX1RZUEUpID09PSAtMSA/IHMwIDogQy5QQVJTRVJfTUVESUFfVFlQRSwgcXQgPSBjaSA9PT0gXCJhcHBsaWNhdGlvbi94aHRtbCt4bWxcIiA/IHJsIDogcmEsIGogPSBVZShDLCBcIkFMTE9XRURfVEFHU1wiKSA/IHB0KHt9LCBDLkFMTE9XRURfVEFHUywgcXQpIDogRiwgWSA9IFVlKEMsIFwiQUxMT1dFRF9BVFRSXCIpID8gcHQoe30sIEMuQUxMT1dFRF9BVFRSLCBxdCkgOiBvdCwgYm8gPSBVZShDLCBcIkFMTE9XRURfTkFNRVNQQUNFU1wiKSA/IHB0KHt9LCBDLkFMTE9XRURfTkFNRVNQQUNFUywgcmwpIDogbjAsIHlvID0gVWUoQywgXCJBRERfVVJJX1NBRkVfQVRUUlwiKSA/IHB0KG1uKEV1KSwgQy5BRERfVVJJX1NBRkVfQVRUUiwgcXQpIDogRXUsIGJ1ID0gVWUoQywgXCJBRERfREFUQV9VUklfVEFHU1wiKSA/IHB0KG1uKF91KSwgQy5BRERfREFUQV9VUklfVEFHUywgcXQpIDogX3UsIHhyID0gVWUoQywgXCJGT1JCSURfQ09OVEVOVFNcIikgPyBwdCh7fSwgQy5GT1JCSURfQ09OVEVOVFMsIHF0KSA6IHh1LCBxID0gVWUoQywgXCJGT1JCSURfVEFHU1wiKSA/IHB0KHt9LCBDLkZPUkJJRF9UQUdTLCBxdCkgOiBtbih7fSksIHR0ID0gVWUoQywgXCJGT1JCSURfQVRUUlwiKSA/IHB0KHt9LCBDLkZPUkJJRF9BVFRSLCBxdCkgOiBtbih7fSksIHlyID0gVWUoQywgXCJVU0VfUFJPRklMRVNcIikgPyBDLlVTRV9QUk9GSUxFUyA6ICExLCBsdCA9IEMuQUxMT1dfQVJJQV9BVFRSICE9PSAhMSwgeiA9IEMuQUxMT1dfREFUQV9BVFRSICE9PSAhMSwgVyA9IEMuQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgfHwgITEsIFggPSBDLkFMTE9XX1NFTEZfQ0xPU0VfSU5fQVRUUiAhPT0gITEsIFYgPSBDLlNBRkVfRk9SX1RFTVBMQVRFUyB8fCAhMSwgdXQgPSBDLlNBRkVfRk9SX1hNTCAhPT0gITEsIHN0ID0gQy5XSE9MRV9ET0NVTUVOVCB8fCAhMSwgbnQgPSBDLlJFVFVSTl9ET00gfHwgITEsIHl0ID0gQy5SRVRVUk5fRE9NX0ZSQUdNRU5UIHx8ICExLCBTZSA9IEMuUkVUVVJOX1RSVVNURURfVFlQRSB8fCAhMSwgTnQgPSBDLkZPUkNFX0JPRFkgfHwgITEsIGdlID0gQy5TQU5JVElaRV9ET00gIT09ICExLCBvaSA9IEMuU0FOSVRJWkVfTkFNRURfUFJPUFMgfHwgITEsIEZuID0gQy5LRUVQX0NPTlRFTlQgIT09ICExLCBJZSA9IEMuSU5fUExBQ0UgfHwgITEsIFogPSBDLkFMTE9XRURfVVJJX1JFR0VYUCB8fCB1diwgYnIgPSBDLk5BTUVTUEFDRSB8fCBvbiwgT3MgPSBDLk1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UUyB8fCBPcywgU3MgPSBDLkhUTUxfSU5URUdSQVRJT05fUE9JTlRTIHx8IFNzLCBRID0gQy5DVVNUT01fRUxFTUVOVF9IQU5ETElORyB8fCB7fSwgQy5DVVNUT01fRUxFTUVOVF9IQU5ETElORyAmJiBPdShDLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjaykgJiYgKFEudGFnTmFtZUNoZWNrID0gQy5DVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2spLCBDLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HICYmIE91KEMuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrKSAmJiAoUS5hdHRyaWJ1dGVOYW1lQ2hlY2sgPSBDLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjayksIEMuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcgJiYgdHlwZW9mIEMuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzID09IFwiYm9vbGVhblwiICYmIChRLmFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50cyA9IEMuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzKSwgViAmJiAoeiA9ICExKSwgeXQgJiYgKG50ID0gITApLCB5ciAmJiAoaiA9IHB0KHt9LCB0cCksIFkgPSBbXSwgeXIuaHRtbCA9PT0gITAgJiYgKHB0KGosIEpkKSwgcHQoWSwgZXApKSwgeXIuc3ZnID09PSAhMCAmJiAocHQoaiwgaWwpLCBwdChZLCBvbCksIHB0KFksIFZzKSksIHlyLnN2Z0ZpbHRlcnMgPT09ICEwICYmIChwdChqLCBzbCksIHB0KFksIG9sKSwgcHQoWSwgVnMpKSwgeXIubWF0aE1sID09PSAhMCAmJiAocHQoaiwgYWwpLCBwdChZLCBucCksIHB0KFksIFZzKSkpLCBDLkFERF9UQUdTICYmIChqID09PSBGICYmIChqID0gbW4oaikpLCBwdChqLCBDLkFERF9UQUdTLCBxdCkpLCBDLkFERF9BVFRSICYmIChZID09PSBvdCAmJiAoWSA9IG1uKFkpKSwgcHQoWSwgQy5BRERfQVRUUiwgcXQpKSwgQy5BRERfVVJJX1NBRkVfQVRUUiAmJiBwdCh5bywgQy5BRERfVVJJX1NBRkVfQVRUUiwgcXQpLCBDLkZPUkJJRF9DT05URU5UUyAmJiAoeHIgPT09IHh1ICYmICh4ciA9IG1uKHhyKSksIHB0KHhyLCBDLkZPUkJJRF9DT05URU5UUywgcXQpKSwgRm4gJiYgKGpbXCIjdGV4dFwiXSA9ICEwKSwgc3QgJiYgcHQoaiwgW1wiaHRtbFwiLCBcImhlYWRcIiwgXCJib2R5XCJdKSwgai50YWJsZSAmJiAocHQoaiwgW1widGJvZHlcIl0pLCBkZWxldGUgcS50Ym9keSksIEMuVFJVU1RFRF9UWVBFU19QT0xJQ1kpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBDLlRSVVNURURfVFlQRVNfUE9MSUNZLmNyZWF0ZUhUTUwgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHRocm93IF9pKCdUUlVTVEVEX1RZUEVTX1BPTElDWSBjb25maWd1cmF0aW9uIG9wdGlvbiBtdXN0IHByb3ZpZGUgYSBcImNyZWF0ZUhUTUxcIiBob29rLicpO1xuICAgICAgICBpZiAodHlwZW9mIEMuVFJVU1RFRF9UWVBFU19QT0xJQ1kuY3JlYXRlU2NyaXB0VVJMICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICB0aHJvdyBfaSgnVFJVU1RFRF9UWVBFU19QT0xJQ1kgY29uZmlndXJhdGlvbiBvcHRpb24gbXVzdCBwcm92aWRlIGEgXCJjcmVhdGVTY3JpcHRVUkxcIiBob29rLicpO1xuICAgICAgICBFID0gQy5UUlVTVEVEX1RZUEVTX1BPTElDWSwgYiA9IEUuY3JlYXRlSFRNTChcIlwiKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBFID09PSB2b2lkIDAgJiYgKEUgPSBCayhwLCBpKSksIEUgIT09IG51bGwgJiYgdHlwZW9mIGIgPT0gXCJzdHJpbmdcIiAmJiAoYiA9IEUuY3JlYXRlSFRNTChcIlwiKSk7XG4gICAgICBvZSAmJiBvZShDKSwgX3IgPSBDO1xuICAgIH1cbiAgfSwgU3UgPSBwdCh7fSwgWy4uLmlsLCAuLi5zbCwgLi4uTWtdKSwgVHUgPSBwdCh7fSwgWy4uLmFsLCAuLi5Da10pLCBvMCA9IGZ1bmN0aW9uKEMpIHtcbiAgICBsZXQgSiA9IF8oQyk7XG4gICAgKCFKIHx8ICFKLnRhZ05hbWUpICYmIChKID0ge1xuICAgICAgbmFtZXNwYWNlVVJJOiBicixcbiAgICAgIHRhZ05hbWU6IFwidGVtcGxhdGVcIlxuICAgIH0pO1xuICAgIGNvbnN0IEsgPSByYShDLnRhZ05hbWUpLCBidCA9IHJhKEoudGFnTmFtZSk7XG4gICAgcmV0dXJuIGJvW0MubmFtZXNwYWNlVVJJXSA/IEMubmFtZXNwYWNlVVJJID09PSBFcyA/IEoubmFtZXNwYWNlVVJJID09PSBvbiA/IEsgPT09IFwic3ZnXCIgOiBKLm5hbWVzcGFjZVVSSSA9PT0gX3MgPyBLID09PSBcInN2Z1wiICYmIChidCA9PT0gXCJhbm5vdGF0aW9uLXhtbFwiIHx8IE9zW2J0XSkgOiAhIVN1W0tdIDogQy5uYW1lc3BhY2VVUkkgPT09IF9zID8gSi5uYW1lc3BhY2VVUkkgPT09IG9uID8gSyA9PT0gXCJtYXRoXCIgOiBKLm5hbWVzcGFjZVVSSSA9PT0gRXMgPyBLID09PSBcIm1hdGhcIiAmJiBTc1tidF0gOiAhIVR1W0tdIDogQy5uYW1lc3BhY2VVUkkgPT09IG9uID8gSi5uYW1lc3BhY2VVUkkgPT09IEVzICYmICFTc1tidF0gfHwgSi5uYW1lc3BhY2VVUkkgPT09IF9zICYmICFPc1tidF0gPyAhMSA6ICFUdVtLXSAmJiAocjBbS10gfHwgIVN1W0tdKSA6ICEhKGNpID09PSBcImFwcGxpY2F0aW9uL3hodG1sK3htbFwiICYmIGJvW0MubmFtZXNwYWNlVVJJXSkgOiAhMTtcbiAgfSwgam4gPSBmdW5jdGlvbihDKSB7XG4gICAgeGkodC5yZW1vdmVkLCB7XG4gICAgICBlbGVtZW50OiBDXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIF8oQykucmVtb3ZlQ2hpbGQoQyk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBtKEMpO1xuICAgIH1cbiAgfSwgRXIgPSBmdW5jdGlvbihDLCBKKSB7XG4gICAgdHJ5IHtcbiAgICAgIHhpKHQucmVtb3ZlZCwge1xuICAgICAgICBhdHRyaWJ1dGU6IEouZ2V0QXR0cmlidXRlTm9kZShDKSxcbiAgICAgICAgZnJvbTogSlxuICAgICAgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB4aSh0LnJlbW92ZWQsIHtcbiAgICAgICAgYXR0cmlidXRlOiBudWxsLFxuICAgICAgICBmcm9tOiBKXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKEoucmVtb3ZlQXR0cmlidXRlKEMpLCBDID09PSBcImlzXCIpXG4gICAgICBpZiAobnQgfHwgeXQpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgam4oSik7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgSi5zZXRBdHRyaWJ1dGUoQywgXCJcIik7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICB9XG4gIH0sIHd1ID0gZnVuY3Rpb24oQykge1xuICAgIGxldCBKID0gbnVsbCwgSyA9IG51bGw7XG4gICAgaWYgKE50KVxuICAgICAgQyA9IFwiPHJlbW92ZT48L3JlbW92ZT5cIiArIEM7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBQdCA9IFFkKEMsIC9eW1xcclxcblxcdCBdKy8pO1xuICAgICAgSyA9IFB0ICYmIFB0WzBdO1xuICAgIH1cbiAgICBjaSA9PT0gXCJhcHBsaWNhdGlvbi94aHRtbCt4bWxcIiAmJiBiciA9PT0gb24gJiYgKEMgPSAnPGh0bWwgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI+PGhlYWQ+PC9oZWFkPjxib2R5PicgKyBDICsgXCI8L2JvZHk+PC9odG1sPlwiKTtcbiAgICBjb25zdCBidCA9IEUgPyBFLmNyZWF0ZUhUTUwoQykgOiBDO1xuICAgIGlmIChiciA9PT0gb24pXG4gICAgICB0cnkge1xuICAgICAgICBKID0gbmV3IGgoKS5wYXJzZUZyb21TdHJpbmcoYnQsIGNpKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgIGlmICghSiB8fCAhSi5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIEogPSBTLmNyZWF0ZURvY3VtZW50KGJyLCBcInRlbXBsYXRlXCIsIG51bGwpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgSi5kb2N1bWVudEVsZW1lbnQuaW5uZXJIVE1MID0geG8gPyBiIDogYnQ7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgWHQgPSBKLmJvZHkgfHwgSi5kb2N1bWVudEVsZW1lbnQ7XG4gICAgcmV0dXJuIEMgJiYgSyAmJiBYdC5pbnNlcnRCZWZvcmUobi5jcmVhdGVUZXh0Tm9kZShLKSwgWHQuY2hpbGROb2Rlc1swXSB8fCBudWxsKSwgYnIgPT09IG9uID8gQS5jYWxsKEosIHN0ID8gXCJodG1sXCIgOiBcImJvZHlcIilbMF0gOiBzdCA/IEouZG9jdW1lbnRFbGVtZW50IDogWHQ7XG4gIH0sICR1ID0gZnVuY3Rpb24oQykge1xuICAgIHJldHVybiBNLmNhbGwoXG4gICAgICBDLm93bmVyRG9jdW1lbnQgfHwgQyxcbiAgICAgIEMsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgYy5TSE9XX0VMRU1FTlQgfCBjLlNIT1dfQ09NTUVOVCB8IGMuU0hPV19URVhUIHwgYy5TSE9XX1BST0NFU1NJTkdfSU5TVFJVQ1RJT04gfCBjLlNIT1dfQ0RBVEFfU0VDVElPTixcbiAgICAgIG51bGxcbiAgICApO1xuICB9LCBFbyA9IGZ1bmN0aW9uKEMpIHtcbiAgICByZXR1cm4gQyBpbnN0YW5jZW9mIGQgJiYgKHR5cGVvZiBDLm5vZGVOYW1lICE9IFwic3RyaW5nXCIgfHwgdHlwZW9mIEMudGV4dENvbnRlbnQgIT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgQy5yZW1vdmVDaGlsZCAhPSBcImZ1bmN0aW9uXCIgfHwgIShDLmF0dHJpYnV0ZXMgaW5zdGFuY2VvZiB1KSB8fCB0eXBlb2YgQy5yZW1vdmVBdHRyaWJ1dGUgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBDLnNldEF0dHJpYnV0ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIEMubmFtZXNwYWNlVVJJICE9IFwic3RyaW5nXCIgfHwgdHlwZW9mIEMuaW5zZXJ0QmVmb3JlICE9IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgQy5oYXNDaGlsZE5vZGVzICE9IFwiZnVuY3Rpb25cIik7XG4gIH0sIE11ID0gZnVuY3Rpb24oQykge1xuICAgIHJldHVybiB0eXBlb2YgbyA9PSBcImZ1bmN0aW9uXCIgJiYgQyBpbnN0YW5jZW9mIG87XG4gIH07XG4gIGZ1bmN0aW9uIGxuKEMsIEosIEspIHtcbiAgICBIcyhDLCAoYnQpID0+IHtcbiAgICAgIGJ0LmNhbGwodCwgSiwgSywgX3IpO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IEN1ID0gZnVuY3Rpb24oQykge1xuICAgIGxldCBKID0gbnVsbDtcbiAgICBpZiAobG4oJC5iZWZvcmVTYW5pdGl6ZUVsZW1lbnRzLCBDLCBudWxsKSwgRW8oQykpXG4gICAgICByZXR1cm4gam4oQyksICEwO1xuICAgIGNvbnN0IEsgPSBxdChDLm5vZGVOYW1lKTtcbiAgICBpZiAobG4oJC51cG9uU2FuaXRpemVFbGVtZW50LCBDLCB7XG4gICAgICB0YWdOYW1lOiBLLFxuICAgICAgYWxsb3dlZFRhZ3M6IGpcbiAgICB9KSwgdXQgJiYgQy5oYXNDaGlsZE5vZGVzKCkgJiYgIU11KEMuZmlyc3RFbGVtZW50Q2hpbGQpICYmIGllKC88Wy9cXHchXS9nLCBDLmlubmVySFRNTCkgJiYgaWUoLzxbL1xcdyFdL2csIEMudGV4dENvbnRlbnQpIHx8IEMubm9kZVR5cGUgPT09IE9pLnByb2dyZXNzaW5nSW5zdHJ1Y3Rpb24gfHwgdXQgJiYgQy5ub2RlVHlwZSA9PT0gT2kuY29tbWVudCAmJiBpZSgvPFsvXFx3XS9nLCBDLmRhdGEpKVxuICAgICAgcmV0dXJuIGpuKEMpLCAhMDtcbiAgICBpZiAoIWpbS10gfHwgcVtLXSkge1xuICAgICAgaWYgKCFxW0tdICYmIEx1KEspICYmIChRLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBpZShRLnRhZ05hbWVDaGVjaywgSykgfHwgUS50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBRLnRhZ05hbWVDaGVjayhLKSkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGlmIChGbiAmJiAheHJbS10pIHtcbiAgICAgICAgY29uc3QgYnQgPSBfKEMpIHx8IEMucGFyZW50Tm9kZSwgWHQgPSB4KEMpIHx8IEMuY2hpbGROb2RlcztcbiAgICAgICAgaWYgKFh0ICYmIGJ0KSB7XG4gICAgICAgICAgY29uc3QgUHQgPSBYdC5sZW5ndGg7XG4gICAgICAgICAgZm9yIChsZXQgY24gPSBQdCAtIDE7IGNuID49IDA7IC0tY24pIHtcbiAgICAgICAgICAgIGNvbnN0IE5lID0gZyhYdFtjbl0sICEwKTtcbiAgICAgICAgICAgIE5lLl9fcmVtb3ZhbENvdW50ID0gKEMuX19yZW1vdmFsQ291bnQgfHwgMCkgKyAxLCBidC5pbnNlcnRCZWZvcmUoTmUsIHYoQykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGpuKEMpLCAhMDtcbiAgICB9XG4gICAgcmV0dXJuIEMgaW5zdGFuY2VvZiBsICYmICFvMChDKSB8fCAoSyA9PT0gXCJub3NjcmlwdFwiIHx8IEsgPT09IFwibm9lbWJlZFwiIHx8IEsgPT09IFwibm9mcmFtZXNcIikgJiYgaWUoLzxcXC9ubyhzY3JpcHR8ZW1iZWR8ZnJhbWVzKS9pLCBDLmlubmVySFRNTCkgPyAoam4oQyksICEwKSA6IChWICYmIEMubm9kZVR5cGUgPT09IE9pLnRleHQgJiYgKEogPSBDLnRleHRDb250ZW50LCBIcyhbSCwgUCwgQl0sIChidCkgPT4ge1xuICAgICAgSiA9IGJpKEosIGJ0LCBcIiBcIik7XG4gICAgfSksIEMudGV4dENvbnRlbnQgIT09IEogJiYgKHhpKHQucmVtb3ZlZCwge1xuICAgICAgZWxlbWVudDogQy5jbG9uZU5vZGUoKVxuICAgIH0pLCBDLnRleHRDb250ZW50ID0gSikpLCBsbigkLmFmdGVyU2FuaXRpemVFbGVtZW50cywgQywgbnVsbCksICExKTtcbiAgfSwgQXUgPSBmdW5jdGlvbihDLCBKLCBLKSB7XG4gICAgaWYgKGdlICYmIChKID09PSBcImlkXCIgfHwgSiA9PT0gXCJuYW1lXCIpICYmIChLIGluIG4gfHwgSyBpbiBhMCkpXG4gICAgICByZXR1cm4gITE7XG4gICAgaWYgKCEoeiAmJiAhdHRbSl0gJiYgaWUoTywgSikpICYmICEobHQgJiYgaWUodywgSikpKSB7XG4gICAgICBpZiAoIVlbSl0gfHwgdHRbSl0pIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIEZpcnN0IGNvbmRpdGlvbiBkb2VzIGEgdmVyeSBiYXNpYyBjaGVjayBpZiBhKSBpdCdzIGJhc2ljYWxseSBhIHZhbGlkIGN1c3RvbSBlbGVtZW50IHRhZ25hbWUgQU5EXG4gICAgICAgICAgLy8gYikgaWYgdGhlIHRhZ05hbWUgcGFzc2VzIHdoYXRldmVyIHRoZSB1c2VyIGhhcyBjb25maWd1cmVkIGZvciBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2tcbiAgICAgICAgICAvLyBhbmQgYykgaWYgdGhlIGF0dHJpYnV0ZSBuYW1lIHBhc3NlcyB3aGF0ZXZlciB0aGUgdXNlciBoYXMgY29uZmlndXJlZCBmb3IgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrXG4gICAgICAgICAgIShMdShDKSAmJiAoUS50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgaWUoUS50YWdOYW1lQ2hlY2ssIEMpIHx8IFEudGFnTmFtZUNoZWNrIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgUS50YWdOYW1lQ2hlY2soQykpICYmIChRLmF0dHJpYnV0ZU5hbWVDaGVjayBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBpZShRLmF0dHJpYnV0ZU5hbWVDaGVjaywgSikgfHwgUS5hdHRyaWJ1dGVOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBRLmF0dHJpYnV0ZU5hbWVDaGVjayhKKSkgfHwgLy8gQWx0ZXJuYXRpdmUsIHNlY29uZCBjb25kaXRpb24gY2hlY2tzIGlmIGl0J3MgYW4gYGlzYC1hdHRyaWJ1dGUsIEFORFxuICAgICAgICAgIC8vIHRoZSB2YWx1ZSBwYXNzZXMgd2hhdGV2ZXIgdGhlIHVzZXIgaGFzIGNvbmZpZ3VyZWQgZm9yIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVja1xuICAgICAgICAgIEogPT09IFwiaXNcIiAmJiBRLmFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50cyAmJiAoUS50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgaWUoUS50YWdOYW1lQ2hlY2ssIEspIHx8IFEudGFnTmFtZUNoZWNrIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgUS50YWdOYW1lQ2hlY2soSykpKVxuICAgICAgICApIHJldHVybiAhMTtcbiAgICAgIH0gZWxzZSBpZiAoIXlvW0pdICYmICFpZShaLCBiaShLLCBrLCBcIlwiKSkgJiYgISgoSiA9PT0gXCJzcmNcIiB8fCBKID09PSBcInhsaW5rOmhyZWZcIiB8fCBKID09PSBcImhyZWZcIikgJiYgQyAhPT0gXCJzY3JpcHRcIiAmJiBTayhLLCBcImRhdGE6XCIpID09PSAwICYmIGJ1W0NdKSAmJiAhKFcgJiYgIWllKEwsIGJpKEssIGssIFwiXCIpKSkgJiYgSylcbiAgICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICByZXR1cm4gITA7XG4gIH0sIEx1ID0gZnVuY3Rpb24oQykge1xuICAgIHJldHVybiBDICE9PSBcImFubm90YXRpb24teG1sXCIgJiYgUWQoQywgVSk7XG4gIH0sIGt1ID0gZnVuY3Rpb24oQykge1xuICAgIGxuKCQuYmVmb3JlU2FuaXRpemVBdHRyaWJ1dGVzLCBDLCBudWxsKTtcbiAgICBjb25zdCB7XG4gICAgICBhdHRyaWJ1dGVzOiBKXG4gICAgfSA9IEM7XG4gICAgaWYgKCFKIHx8IEVvKEMpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IEsgPSB7XG4gICAgICBhdHRyTmFtZTogXCJcIixcbiAgICAgIGF0dHJWYWx1ZTogXCJcIixcbiAgICAgIGtlZXBBdHRyOiAhMCxcbiAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBZLFxuICAgICAgZm9yY2VLZWVwQXR0cjogdm9pZCAwXG4gICAgfTtcbiAgICBsZXQgYnQgPSBKLmxlbmd0aDtcbiAgICBmb3IgKDsgYnQtLTsgKSB7XG4gICAgICBjb25zdCBYdCA9IEpbYnRdLCB7XG4gICAgICAgIG5hbWU6IFB0LFxuICAgICAgICBuYW1lc3BhY2VVUkk6IGNuLFxuICAgICAgICB2YWx1ZTogTmVcbiAgICAgIH0gPSBYdCwgWGUgPSBxdChQdCksIE9vID0gTmU7XG4gICAgICBsZXQgUXQgPSBQdCA9PT0gXCJ2YWx1ZVwiID8gT28gOiBUayhPbyk7XG4gICAgICBpZiAoSy5hdHRyTmFtZSA9IFhlLCBLLmF0dHJWYWx1ZSA9IFF0LCBLLmtlZXBBdHRyID0gITAsIEsuZm9yY2VLZWVwQXR0ciA9IHZvaWQgMCwgbG4oJC51cG9uU2FuaXRpemVBdHRyaWJ1dGUsIEMsIEspLCBRdCA9IEsuYXR0clZhbHVlLCBvaSAmJiAoWGUgPT09IFwiaWRcIiB8fCBYZSA9PT0gXCJuYW1lXCIpICYmIChFcihQdCwgQyksIFF0ID0gbGkgKyBRdCksIHV0ICYmIGllKC8oKC0tIT98XSk+KXw8XFwvKHN0eWxlfHRpdGxlKS9pLCBRdCkpIHtcbiAgICAgICAgRXIoUHQsIEMpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChLLmZvcmNlS2VlcEF0dHIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKCFLLmtlZXBBdHRyKSB7XG4gICAgICAgIEVyKFB0LCBDKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIVggJiYgaWUoL1xcLz4vaSwgUXQpKSB7XG4gICAgICAgIEVyKFB0LCBDKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBWICYmIEhzKFtILCBQLCBCXSwgKGMwKSA9PiB7XG4gICAgICAgIFF0ID0gYmkoUXQsIGMwLCBcIiBcIik7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IER1ID0gcXQoQy5ub2RlTmFtZSk7XG4gICAgICBpZiAoIUF1KER1LCBYZSwgUXQpKSB7XG4gICAgICAgIEVyKFB0LCBDKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoRSAmJiB0eXBlb2YgcCA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwLmdldEF0dHJpYnV0ZVR5cGUgPT0gXCJmdW5jdGlvblwiICYmICFjbilcbiAgICAgICAgc3dpdGNoIChwLmdldEF0dHJpYnV0ZVR5cGUoRHUsIFhlKSkge1xuICAgICAgICAgIGNhc2UgXCJUcnVzdGVkSFRNTFwiOiB7XG4gICAgICAgICAgICBRdCA9IEUuY3JlYXRlSFRNTChRdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIlRydXN0ZWRTY3JpcHRVUkxcIjoge1xuICAgICAgICAgICAgUXQgPSBFLmNyZWF0ZVNjcmlwdFVSTChRdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGlmIChRdCAhPT0gT28pXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY24gPyBDLnNldEF0dHJpYnV0ZU5TKGNuLCBQdCwgUXQpIDogQy5zZXRBdHRyaWJ1dGUoUHQsIFF0KSwgRW8oQykgPyBqbihDKSA6IEtkKHQucmVtb3ZlZCk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIEVyKFB0LCBDKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsbigkLmFmdGVyU2FuaXRpemVBdHRyaWJ1dGVzLCBDLCBudWxsKTtcbiAgfSwgbDAgPSBmdW5jdGlvbiBDKEopIHtcbiAgICBsZXQgSyA9IG51bGw7XG4gICAgY29uc3QgYnQgPSAkdShKKTtcbiAgICBmb3IgKGxuKCQuYmVmb3JlU2FuaXRpemVTaGFkb3dET00sIEosIG51bGwpOyBLID0gYnQubmV4dE5vZGUoKTsgKVxuICAgICAgbG4oJC51cG9uU2FuaXRpemVTaGFkb3dOb2RlLCBLLCBudWxsKSwgQ3UoSyksIGt1KEspLCBLLmNvbnRlbnQgaW5zdGFuY2VvZiBzICYmIEMoSy5jb250ZW50KTtcbiAgICBsbigkLmFmdGVyU2FuaXRpemVTaGFkb3dET00sIEosIG51bGwpO1xuICB9O1xuICByZXR1cm4gdC5zYW5pdGl6ZSA9IGZ1bmN0aW9uKEMpIHtcbiAgICBsZXQgSiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge30sIEsgPSBudWxsLCBidCA9IG51bGwsIFh0ID0gbnVsbCwgUHQgPSBudWxsO1xuICAgIGlmICh4byA9ICFDLCB4byAmJiAoQyA9IFwiPCEtLT5cIiksIHR5cGVvZiBDICE9IFwic3RyaW5nXCIgJiYgIU11KEMpKVxuICAgICAgaWYgKHR5cGVvZiBDLnRvU3RyaW5nID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoQyA9IEMudG9TdHJpbmcoKSwgdHlwZW9mIEMgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICB0aHJvdyBfaShcImRpcnR5IGlzIG5vdCBhIHN0cmluZywgYWJvcnRpbmdcIik7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhyb3cgX2koXCJ0b1N0cmluZyBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICBpZiAoIXQuaXNTdXBwb3J0ZWQpXG4gICAgICByZXR1cm4gQztcbiAgICBpZiAoRHQgfHwgX28oSiksIHQucmVtb3ZlZCA9IFtdLCB0eXBlb2YgQyA9PSBcInN0cmluZ1wiICYmIChJZSA9ICExKSwgSWUpIHtcbiAgICAgIGlmIChDLm5vZGVOYW1lKSB7XG4gICAgICAgIGNvbnN0IFhlID0gcXQoQy5ub2RlTmFtZSk7XG4gICAgICAgIGlmICghaltYZV0gfHwgcVtYZV0pXG4gICAgICAgICAgdGhyb3cgX2koXCJyb290IG5vZGUgaXMgZm9yYmlkZGVuIGFuZCBjYW5ub3QgYmUgc2FuaXRpemVkIGluLXBsYWNlXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQyBpbnN0YW5jZW9mIG8pXG4gICAgICBLID0gd3UoXCI8IS0tLS0+XCIpLCBidCA9IEsub3duZXJEb2N1bWVudC5pbXBvcnROb2RlKEMsICEwKSwgYnQubm9kZVR5cGUgPT09IE9pLmVsZW1lbnQgJiYgYnQubm9kZU5hbWUgPT09IFwiQk9EWVwiIHx8IGJ0Lm5vZGVOYW1lID09PSBcIkhUTUxcIiA/IEsgPSBidCA6IEsuYXBwZW5kQ2hpbGQoYnQpO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKCFudCAmJiAhViAmJiAhc3QgJiYgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWluY2x1ZGVzXG4gICAgICBDLmluZGV4T2YoXCI8XCIpID09PSAtMSlcbiAgICAgICAgcmV0dXJuIEUgJiYgU2UgPyBFLmNyZWF0ZUhUTUwoQykgOiBDO1xuICAgICAgaWYgKEsgPSB3dShDKSwgIUspXG4gICAgICAgIHJldHVybiBudCA/IG51bGwgOiBTZSA/IGIgOiBcIlwiO1xuICAgIH1cbiAgICBLICYmIE50ICYmIGpuKEsuZmlyc3RDaGlsZCk7XG4gICAgY29uc3QgY24gPSAkdShJZSA/IEMgOiBLKTtcbiAgICBmb3IgKDsgWHQgPSBjbi5uZXh0Tm9kZSgpOyApXG4gICAgICBDdShYdCksIGt1KFh0KSwgWHQuY29udGVudCBpbnN0YW5jZW9mIHMgJiYgbDAoWHQuY29udGVudCk7XG4gICAgaWYgKEllKVxuICAgICAgcmV0dXJuIEM7XG4gICAgaWYgKG50KSB7XG4gICAgICBpZiAoeXQpXG4gICAgICAgIGZvciAoUHQgPSBELmNhbGwoSy5vd25lckRvY3VtZW50KTsgSy5maXJzdENoaWxkOyApXG4gICAgICAgICAgUHQuYXBwZW5kQ2hpbGQoSy5maXJzdENoaWxkKTtcbiAgICAgIGVsc2VcbiAgICAgICAgUHQgPSBLO1xuICAgICAgcmV0dXJuIChZLnNoYWRvd3Jvb3QgfHwgWS5zaGFkb3dyb290bW9kZSkgJiYgKFB0ID0gUi5jYWxsKHIsIFB0LCAhMCkpLCBQdDtcbiAgICB9XG4gICAgbGV0IE5lID0gc3QgPyBLLm91dGVySFRNTCA6IEsuaW5uZXJIVE1MO1xuICAgIHJldHVybiBzdCAmJiBqW1wiIWRvY3R5cGVcIl0gJiYgSy5vd25lckRvY3VtZW50ICYmIEsub3duZXJEb2N1bWVudC5kb2N0eXBlICYmIEsub3duZXJEb2N1bWVudC5kb2N0eXBlLm5hbWUgJiYgaWUoaHYsIEsub3duZXJEb2N1bWVudC5kb2N0eXBlLm5hbWUpICYmIChOZSA9IFwiPCFET0NUWVBFIFwiICsgSy5vd25lckRvY3VtZW50LmRvY3R5cGUubmFtZSArIGA+XG5gICsgTmUpLCBWICYmIEhzKFtILCBQLCBCXSwgKFhlKSA9PiB7XG4gICAgICBOZSA9IGJpKE5lLCBYZSwgXCIgXCIpO1xuICAgIH0pLCBFICYmIFNlID8gRS5jcmVhdGVIVE1MKE5lKSA6IE5lO1xuICB9LCB0LnNldENvbmZpZyA9IGZ1bmN0aW9uKCkge1xuICAgIGxldCBDID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBfbyhDKSwgRHQgPSAhMDtcbiAgfSwgdC5jbGVhckNvbmZpZyA9IGZ1bmN0aW9uKCkge1xuICAgIF9yID0gbnVsbCwgRHQgPSAhMTtcbiAgfSwgdC5pc1ZhbGlkQXR0cmlidXRlID0gZnVuY3Rpb24oQywgSiwgSykge1xuICAgIF9yIHx8IF9vKHt9KTtcbiAgICBjb25zdCBidCA9IHF0KEMpLCBYdCA9IHF0KEopO1xuICAgIHJldHVybiBBdShidCwgWHQsIEspO1xuICB9LCB0LmFkZEhvb2sgPSBmdW5jdGlvbihDLCBKKSB7XG4gICAgdHlwZW9mIEogPT0gXCJmdW5jdGlvblwiICYmIHhpKCRbQ10sIEopO1xuICB9LCB0LnJlbW92ZUhvb2sgPSBmdW5jdGlvbihDLCBKKSB7XG4gICAgaWYgKEogIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgSyA9IEVrKCRbQ10sIEopO1xuICAgICAgcmV0dXJuIEsgPT09IC0xID8gdm9pZCAwIDogT2soJFtDXSwgSywgMSlbMF07XG4gICAgfVxuICAgIHJldHVybiBLZCgkW0NdKTtcbiAgfSwgdC5yZW1vdmVIb29rcyA9IGZ1bmN0aW9uKEMpIHtcbiAgICAkW0NdID0gW107XG4gIH0sIHQucmVtb3ZlQWxsSG9va3MgPSBmdW5jdGlvbigpIHtcbiAgICAkID0gaXAoKTtcbiAgfSwgdDtcbn1cbnZhciBvdSA9IGR2KCk7XG5jb25zdCBHcyA9IChlKSA9PiBvdS5zYW5pdGl6ZShlLCB7XG4gIFVTRV9QUk9GSUxFUzoge1xuICAgIGh0bWw6ICEwLFxuICAgIHN2ZzogITAsXG4gICAgc3ZnRmlsdGVyczogITBcbiAgfVxufSksIEhrID0gKGUpID0+IG91LnNhbml0aXplKGUsIHtcbiAgTkFNRVNQQUNFOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIFVTRV9QUk9GSUxFUzoge1xuICAgIGh0bWw6ICEwLFxuICAgIHN2ZzogITAsXG4gICAgc3ZnRmlsdGVyczogITBcbiAgfVxufSksIGVuID0gKGUpID0+IG91LnNhbml0aXplKGUsIHsgQUxMT1dFRF9UQUdTOiBbXSB9KSwgcHYgPSBjbGFzcyBmdiBleHRlbmRzIG10IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy50eXBlID0gXCJ0b29sYmFyXCIsIHRoaXMucmVuZGVyVHlwZSA9IHJ0LkhUTUw7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBjb25zdCB0ID0gKCkgPT4gdGhpcy51cGRhdGVPdmVyZmxvd01lbnUoITEpO1xuICAgIHRoaXMuc2VydmljZXMuZXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIoVC5Ub29sYmFyLlNIT1dfT1ZFUkZMT1dfTUVOVSwgKCkgPT4ge1xuICAgICAgdGhpcy5yZW5kZXJPdmVyZmxvd01lbnUoKSwgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdCk7XG4gICAgfSksIHRoaXMuc2VydmljZXMuZXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIoVC5Ub29sYmFyLkhJREVfT1ZFUkZMT1dfTUVOVSwgKCkgPT4ge1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdCk7XG4gICAgfSk7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcmVuZGVyKHQgPSAhMCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldENvbXBvbmVudENvbnRhaW5lcih7XG4gICAgICBhcmlhTGFiZWw6IFwidG9vbGJhclwiXG4gICAgfSkuYXR0cihcInJvbGVcIiwgXCJncm91cFwiKTtcbiAgICBpZiAoeSh0aGlzLmdldE9wdGlvbnMoKSwgXCJkYXRhXCIsIFwibG9hZGluZ1wiKSlcbiAgICAgIG4uaHRtbChcIlwiKSwgdGhpcy5vdmVyZmxvd01lbnUgPSBudWxsO1xuICAgIGVsc2Uge1xuICAgICAgdGhpcy5vdmVyZmxvd01lbnUgfHwgKHRoaXMub3ZlcmZsb3dNZW51ID0gbi5hcHBlbmQoXCJkaXZcIikuYXR0cihcbiAgICAgICAgXCJjbGFzc1wiLFxuICAgICAgICBcImNkcy0tb3ZlcmZsb3ctbWVudS1vcHRpb25zIGNkcy0tb3ZlcmZsb3ctbWVudS0tZmxpcCBjZHMtLW92ZXJmbG93LW1lbnUtb3B0aW9ucyBjZHMtLW92ZXJmbG93LW1lbnUtLWZsaXBcIlxuICAgICAgKS5hdHRyKFwidGFiaW5kZXhcIiwgLTEpLmh0bWwoXCI8dWwgcm9sZT0nbWVudSc+PC91bD5cIikpO1xuICAgICAgY29uc3QgeyBidXR0b25MaXN0OiByLCBvdmVyZmxvd01lbnVJdGVtTGlzdDogaSB9ID0gdGhpcy5nZXRDb250cm9sQ29uZmlncygpO1xuICAgICAgaSAmJiByLnB1c2godGhpcy5nZXRPdmVyZmxvd0J1dHRvbkNvbmZpZygpKTtcbiAgICAgIGNvbnN0IHMgPSBuLnNlbGVjdEFsbChcImRpdi50b29sYmFyLWNvbnRyb2xcIikuZGF0YShyLCAobCkgPT4gbC5pZCk7XG4gICAgICBzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgIGNvbnN0IGEgPSBzLmVudGVyKCkuYXBwZW5kKFwiZGl2XCIpLmF0dHIoXCJjbGFzc1wiLCBcInRvb2xiYXItY29udHJvbCBjZHMtLW92ZXJmbG93LW1lbnUgY2RzLS1vdmVyZmxvdy1tZW51XCIpLCBvID0gdGhpcztcbiAgICAgIGEubWVyZ2UocykuY2xhc3NlZChcImRpc2FibGVkXCIsIChsKSA9PiBsLnNob3VsZEJlRGlzYWJsZWQoKSkuYXR0cihcInJvbGVcIiwgXCJidXR0b25cIikuYXR0cihcImFyaWEtZGlzYWJsZWRcIiwgKGwpID0+IGwuc2hvdWxkQmVEaXNhYmxlZCgpKS5hdHRyKFwiYXJpYS1sYWJlbFwiLCAobCkgPT4gbC50aXRsZSkuaHRtbCgobCkgPT4gYFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRjbGFzcz1cImNkcy0tb3ZlcmZsb3ctbWVudV9fdHJpZ2dlciBjZHMtLW92ZXJmbG93LW1lbnVfX3RyaWdnZXJcIlxuXHRcdFx0XHRhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiIGlkPVwiJHt0aGlzLnNlcnZpY2VzLmRvbVV0aWxzLmdlbmVyYXRlRWxlbWVudElEU3RyaW5nKFxuICAgICAgICBgY29udHJvbC0ke2VuKGwuaWQpfWBcbiAgICAgICl9XCIgYXJpYS1sYWJlbD1cIiR7ZW4obC50aXRsZSl9XCI+XG5cdFx0XHRcdDxzdmcgZm9jdXNhYmxlPVwiZmFsc2VcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwieE1pZFlNaWQgbWVldFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImNkcy0tb3ZlcmZsb3ctbWVudV9faWNvbiBjZHMtLW92ZXJmbG93LW1lbnVfX2ljb25cIiB2aWV3Qm94PVwiMCAwIDMyIDMyXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG5cdFx0XHRcdFx0JHtIayhsLmljb25TVkcuY29udGVudCl9XG5cdFx0XHRcdDwvc3ZnPlxuXHRcdFx0PC9idXR0b24+YCkuZWFjaChmdW5jdGlvbihsLCBjKSB7XG4gICAgICAgIEkodGhpcykuc2VsZWN0KFwic3ZnXCIpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpLnN0eWxlKFwid2lsbC1jaGFuZ2VcIiwgXCJ0cmFuc2Zvcm1cIikuc3R5bGUoXCJ3aWR0aFwiLCBsLmljb25TVkcud2lkdGggIT09IHZvaWQgMCA/IGwuaWNvblNWRy53aWR0aCA6IFwiMjBweFwiKS5zdHlsZShcImhlaWdodFwiLCBsLmljb25TVkcuaGVpZ2h0ICE9PSB2b2lkIDAgPyBsLmljb25TVkcuaGVpZ2h0IDogXCIyMHB4XCIpLCBJKHRoaXMpLnNlbGVjdChcImJ1dHRvblwiKS5vbihcIm1vdXNlb3ZlciBmb2N1c1wiLCBmdW5jdGlvbih1KSB7XG4gICAgICAgICAgY29uc3QgZCA9IEkodGhpcyk7XG4gICAgICAgICAgZC5jbGFzc2VkKFwiaG92ZXJlZFwiLCAhMCksIG8uc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sYmFyLlNIT1dfVE9PTFRJUCwge1xuICAgICAgICAgICAgZXZlbnQ6IHUsXG4gICAgICAgICAgICBob3ZlcmVkRWxlbWVudDogZCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGwudGl0bGUsXG4gICAgICAgICAgICBub1dyYXA6ICEwLFxuICAgICAgICAgICAgcGxhY2VtZW50czogW1widG9wXCIsIFwiYm90dG9tXCJdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLm9uKFwibW91c2VvdXQgYmx1clwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBvLnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbGJhci5ISURFX1RPT0xUSVApO1xuICAgICAgICB9KS5vbihcImNsaWNrXCIsICh1KSA9PiB7XG4gICAgICAgICAgbC5zaG91bGRCZURpc2FibGVkKCkgfHwgby50cmlnZ2VyRnVuY3Rpb25BbmRFdmVudChsLCB1LCB0aGlzKTtcbiAgICAgICAgfSkub24oXCJrZXlkb3duXCIsICh1KSA9PiB7XG4gICAgICAgICAgdS5rZXkgJiYgdS5rZXkgPT09IFwiRW50ZXJcIiB8fCB1LmtleSA9PT0gXCIgXCIgPyAodS5wcmV2ZW50RGVmYXVsdCgpLCBvLnRyaWdnZXJGdW5jdGlvbkFuZEV2ZW50KGwsIHUsIHRoaXMpKSA6IHUua2V5ICYmIHUua2V5ID09PSBcIkFycm93TGVmdFwiID8gby5mb2N1c09uUHJldmlvdXNFbmFibGVkVG9vbGJhckl0ZW0oYykgOiB1LmtleSAmJiB1LmtleSA9PT0gXCJBcnJvd1JpZ2h0XCIgJiYgby5mb2N1c09uTmV4dEVuYWJsZWRUb29sYmFySXRlbShjKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSwgdGhpcy5vdmVyZmxvd0J1dHRvbiA9IHRoaXMuZ2V0Q29tcG9uZW50Q29udGFpbmVyKCkuc2VsZWN0KFxuICAgICAgICBgYnV0dG9uLmNkcy0tb3ZlcmZsb3ctbWVudV9fdHJpZ2dlciMke3RoaXMuc2VydmljZXMuZG9tVXRpbHMuZ2VuZXJhdGVFbGVtZW50SURTdHJpbmcoXG4gICAgICAgICAgXCJjb250cm9sLXRvb2xiYXItb3ZlcmZsb3ctbWVudVwiXG4gICAgICAgICl9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyT3ZlcmZsb3dNZW51KCkge1xuICAgIGNvbnN0IHsgb3ZlcmZsb3dNZW51SXRlbUxpc3Q6IHQgfSA9IHRoaXMuZ2V0Q29udHJvbENvbmZpZ3MoKSwgbiA9IHRoaXMub3ZlcmZsb3dNZW51LnNlbGVjdChcInVsXCIpLnNlbGVjdEFsbChcImxpLmNkcy0tb3ZlcmZsb3ctbWVudS1vcHRpb25zX19vcHRpb25cIikuZGF0YSh0LCAoaSkgPT4geShpLCBcImlkXCIpKTtcbiAgICBuLmV4aXQoKS5yZW1vdmUoKTtcbiAgICBjb25zdCByID0gbi5lbnRlcigpLmFwcGVuZChcImxpXCIpLmF0dHIoXCJpZFwiLCAoaSkgPT4gdGhpcy5zZXJ2aWNlcy5kb21VdGlscy5nZW5lcmF0ZUVsZW1lbnRJRFN0cmluZyhgY29udHJvbC0ke2kuaWR9YCkpLmF0dHIoXCJjbGFzc1wiLCBcImNkcy0tb3ZlcmZsb3ctbWVudS1vcHRpb25zX19vcHRpb24gY2RzLS1vdmVyZmxvdy1tZW51LW9wdGlvbnNfX29wdGlvblwiKS5hdHRyKFwicm9sZVwiLCBcIm1lbnVpdGVtXCIpLmF0dHIoXCJ0YWJpbmRleFwiLCAxKTtcbiAgICByLmFwcGVuZChcImJ1dHRvblwiKS5hdHRyKFwiY2xhc3NcIiwgXCJjZHMtLW92ZXJmbG93LW1lbnUtb3B0aW9uc19fYnRuIGNkcy0tb3ZlcmZsb3ctbWVudS1vcHRpb25zX19idG5cIiksIHIubWVyZ2UobikuY2xhc3NlZChcImNkcy0tb3ZlcmZsb3ctbWVudS1vcHRpb25zX19vcHRpb24tLWRpc2FibGVkXCIsIChpKSA9PiBpLnNob3VsZEJlRGlzYWJsZWQoKSkuY2xhc3NlZChcImNkcy0tb3ZlcmZsb3ctbWVudS1vcHRpb25zX19vcHRpb24tLWRpc2FibGVkXCIsIChpKSA9PiBpLnNob3VsZEJlRGlzYWJsZWQoKSkuYXR0cihcImFyaWEtZGlzYWJsZWRcIiwgKGkpID0+IGkuc2hvdWxkQmVEaXNhYmxlZCgpKS5zZWxlY3RBbGwoXCJidXR0b25cIikudGV4dCgoaSkgPT4gaS50aXRsZSk7XG4gIH1cbiAgaXNPdmVyZmxvd01lbnVPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJmbG93TWVudS5jbGFzc2VkKFwiaXMtb3BlblwiKTtcbiAgfVxuICAvLyBzaG93L2hpZGUgb3ZlcmZsb3cgbWVudVxuICB1cGRhdGVPdmVyZmxvd01lbnUodCkge1xuICAgIHRoaXMub3ZlcmZsb3dNZW51ICYmICh0aGlzLm92ZXJmbG93TWVudS5jbGFzc2VkKFwiaXMtb3BlblwiLCB0KSwgdGhpcy5vdmVyZmxvd0J1dHRvbiAmJiAodGhpcy5vdmVyZmxvd0J1dHRvbi5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCB0KSwgSSh0aGlzLm92ZXJmbG93QnV0dG9uLm5vZGUoKS5wYXJlbnROb2RlKS5jbGFzc2VkKFwiY2RzLS1vdmVyZmxvdy1tZW51LS1vcGVuXCIsIHQpLmNsYXNzZWQoXCJjZHMtLW92ZXJmbG93LW1lbnUtLW9wZW5cIiwgdCkpLCB0ID8gdGhpcy5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2xiYXIuU0hPV19PVkVSRkxPV19NRU5VKSA6IHRoaXMuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sYmFyLkhJREVfT1ZFUkZMT1dfTUVOVSkpO1xuICB9XG4gIC8vIFRvb2xiYXIgY29udHJvbGxlcnNcbiAgZm9jdXNPblByZXZpb3VzRW5hYmxlZFRvb2xiYXJJdGVtKHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRUb29sYmFyQnV0dG9uSXRlbXMoKTtcbiAgICBsZXQgciA9IG4ubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSB0IC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICBpZiAoIW5baV0uc2hvdWxkQmVEaXNhYmxlZCgpKSB7XG4gICAgICAgIHIgPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBpZiAociA8IG4ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBpID0gSShcbiAgICAgICAgYGJ1dHRvbiMke3RoaXMuc2VydmljZXMuZG9tVXRpbHMuZ2VuZXJhdGVFbGVtZW50SURTdHJpbmcoXG4gICAgICAgICAgYGNvbnRyb2wtJHtuW3JdLmlkfWBcbiAgICAgICAgKX1gXG4gICAgICApLm5vZGUoKTtcbiAgICAgIFwiZm9jdXNcIiBpbiBpICYmIGkuZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgZm9jdXNPbk5leHRFbmFibGVkVG9vbGJhckl0ZW0odCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldFRvb2xiYXJCdXR0b25JdGVtcygpO1xuICAgIGxldCByID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IHQgKyAxOyBpIDwgbi5sZW5ndGg7IGkrKylcbiAgICAgIGlmICghbltpXS5zaG91bGRCZURpc2FibGVkKCkpIHtcbiAgICAgICAgciA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGlmIChyID4gLTEpIHtcbiAgICAgIGNvbnN0IGkgPSBJKFxuICAgICAgICBgYnV0dG9uIyR7dGhpcy5zZXJ2aWNlcy5kb21VdGlscy5nZW5lcmF0ZUVsZW1lbnRJRFN0cmluZyhcbiAgICAgICAgICBgY29udHJvbC0ke25bcl0uaWR9YFxuICAgICAgICApfWBcbiAgICAgICkubm9kZSgpO1xuICAgICAgXCJmb2N1c1wiIGluIGkgJiYgaS5mb2N1cygpO1xuICAgIH1cbiAgfVxuICBmb2N1c09uUHJldmlvdXNFbmFibGVkTWVudUl0ZW0odCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldE92ZXJmbG93TWVudUl0ZW1zKCk7XG4gICAgbGV0IHIgPSBuLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gdCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgaWYgKCFuW2ldLnNob3VsZEJlRGlzYWJsZWQoKSkge1xuICAgICAgICByID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgaWYgKHIgPCBuLmxlbmd0aCkge1xuICAgICAgY29uc3QgaSA9IEkoXG4gICAgICAgIGAjJHt0aGlzLnNlcnZpY2VzLmRvbVV0aWxzLmdlbmVyYXRlRWxlbWVudElEU3RyaW5nKFxuICAgICAgICAgIGBjb250cm9sLSR7bltyXS5pZH1gXG4gICAgICAgICl9IGJ1dHRvbmBcbiAgICAgICkubm9kZSgpO1xuICAgICAgXCJmb2N1c1wiIGluIGkgJiYgaS5mb2N1cygpO1xuICAgIH1cbiAgfVxuICBmb2N1c09uTmV4dEVuYWJsZWRNZW51SXRlbSh0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0T3ZlcmZsb3dNZW51SXRlbXMoKTtcbiAgICBsZXQgciA9IC0xO1xuICAgIGZvciAobGV0IGkgPSB0ICsgMTsgaSA8IG4ubGVuZ3RoOyBpKyspXG4gICAgICBpZiAoIW5baV0uc2hvdWxkQmVEaXNhYmxlZCgpKSB7XG4gICAgICAgIHIgPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBpZiAociA+IC0xKSB7XG4gICAgICBjb25zdCBpID0gSShcbiAgICAgICAgYCMke3RoaXMuc2VydmljZXMuZG9tVXRpbHMuZ2VuZXJhdGVFbGVtZW50SURTdHJpbmcoXG4gICAgICAgICAgYGNvbnRyb2wtJHtuW3JdLmlkfWBcbiAgICAgICAgKX0gYnV0dG9uYFxuICAgICAgKS5ub2RlKCk7XG4gICAgICBcImZvY3VzXCIgaW4gaSAmJiBpLmZvY3VzKCk7XG4gICAgfVxuICB9XG4gIHRvZ2dsZU92ZXJmbG93TWVudSh0KSB7XG4gICAgaWYgKHRoaXMuaXNPdmVyZmxvd01lbnVPcGVuKCkpXG4gICAgICB0aGlzLnVwZGF0ZU92ZXJmbG93TWVudSghMSk7XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZU92ZXJmbG93TWVudSghMCk7XG4gICAgICBjb25zdCBuID0gdGhpcztcbiAgICAgIHRoaXMuZ2V0T3ZlcmZsb3dNZW51SXRlbXMoKS5mb3JFYWNoKChyLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHMgPSBJKFxuICAgICAgICAgIGAjJHt0aGlzLnNlcnZpY2VzLmRvbVV0aWxzLmdlbmVyYXRlRWxlbWVudElEU3RyaW5nKGBjb250cm9sLSR7ci5pZH1gKX1gXG4gICAgICAgICk7XG4gICAgICAgIHMgIT09IG51bGwgJiYgKHMub24oXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICAgICAgbi50cmlnZ2VyRnVuY3Rpb25BbmRFdmVudChyLCB0LCBzLm5vZGUoKSksIG4udXBkYXRlT3ZlcmZsb3dNZW51KCExKTtcbiAgICAgICAgfSksIHMub24oXCJrZXlkb3duXCIsIChhKSA9PiB7XG4gICAgICAgICAgYSAmJiBhLmtleSA9PT0gXCJFbnRlclwiID8gbi50cmlnZ2VyRnVuY3Rpb25BbmRFdmVudChyLCB0LCBzLm5vZGUoKSkgOiBhICYmIGEua2V5ID09PSBcIkFycm93VXBcIiA/IG4uZm9jdXNPblByZXZpb3VzRW5hYmxlZE1lbnVJdGVtKGkpIDogYSAmJiBhLmtleSA9PT0gXCJBcnJvd0Rvd25cIiA/IG4uZm9jdXNPbk5leHRFbmFibGVkTWVudUl0ZW0oaSkgOiBhICYmIGEua2V5ID09PSBcIkVzY2FwZVwiICYmIG4udXBkYXRlT3ZlcmZsb3dNZW51KCExKSwgYS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KSk7XG4gICAgICB9KSwgbi5mb2N1c09uTmV4dEVuYWJsZWRNZW51SXRlbSgtMSk7XG4gICAgfVxuICAgIHQgJiYgdC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgfVxuICAvLyBDYWxscyBwYXNzZWQgZnVuY3Rpb24gJiYgZGlzcGF0Y2hlcyBldmVudFxuICB0cmlnZ2VyRnVuY3Rpb25BbmRFdmVudCh0LCBuLCByKSB7XG4gICAgdHlwZW9mIHQuc2hvdWxkQmVEaXNhYmxlZCA9PSBcImZ1bmN0aW9uXCIgJiYgdC5zaG91bGRCZURpc2FibGVkKCkgfHwgKHR5cGVvZiB0LmNsaWNrRnVuY3Rpb24gPT0gXCJmdW5jdGlvblwiICYmIHQuY2xpY2tGdW5jdGlvbihuKSwgdGhpcy5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2xiYXIuQlVUVE9OX0NMSUNLLCB7XG4gICAgICBjb250cm9sOiB0LFxuICAgICAgZXZlbnQ6IG4sXG4gICAgICBlbGVtZW50OiByXG4gICAgfSkpO1xuICB9XG4gIGdldENvbnRyb2xDb25maWdzKCkge1xuICAgIGNvbnN0IHQgPSB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcInRvb2xiYXJcIiwgXCJudW1iZXJPZkljb25zXCIpIC0gMSwgbiA9IHkodGhpcy5nZXRPcHRpb25zKCksIFwidG9vbGJhclwiLCBcImNvbnRyb2xzXCIpLCByID0gW10sIGkgPSBbXSwgcyA9IFtdO1xuICAgIHJldHVybiBuLmZvckVhY2goKGEpID0+IHtcbiAgICAgIGxldCBvID0gbnVsbDtcbiAgICAgIGlmIChhLnR5cGUgPT09IF90LkNVU1RPTSlcbiAgICAgICAgeShhLCBcImlkXCIpID09PSBudWxsICYmIChhLmlkID0gYHRvb2xiYXItYnV0dG9uLSR7ZnYuYnV0dG9uSUQrK31gKSwgeShhLCBcInNob3VsZEJlRGlzYWJsZWRcIikgPT09IG51bGwgJiYgKGEuc2hvdWxkQmVEaXNhYmxlZCA9ICgpID0+ICExKSwgbyA9IGE7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbCA9IHRoaXMuc2VydmljZXMuZG9tVXRpbHMuaXNGdWxsU2NyZWVuTW9kZSgpO1xuICAgICAgICBhLnR5cGUgPT09IF90Lk1BS0VfRlVMTFNDUkVFTiAmJiBsID8gYS50eXBlID0gX3QuRVhJVF9GVUxMU0NSRUVOIDogYS50eXBlID09PSBfdC5FWElUX0ZVTExTQ1JFRU4gJiYgIWwgJiYgKGEudHlwZSA9IF90Lk1BS0VfRlVMTFNDUkVFTiksIG8gPSB0aGlzLmdldENvbnRyb2xDb25maWdCeVR5cGUoYS50eXBlKTtcbiAgICAgIH1cbiAgICAgIG8gJiYgKG8udGV4dCA9IGEudGV4dCA/IGEudGV4dCA6IGEudHlwZSwgby5pZC5pbmRleE9mKFwidG9vbGJhci1leHBvcnRcIikgIT09IC0xID8gci5wdXNoKG8pIDogaS5sZW5ndGggPCB0ID8geShvLCBcImljb25TVkdcIiwgXCJjb250ZW50XCIpID09PSBudWxsID8gcy5wdXNoKG8pIDogaS5wdXNoKG8pIDogcy5wdXNoKG8pKTtcbiAgICB9KSwgcy5wdXNoKC4uLnIpLCBzLmxlbmd0aCA/IHtcbiAgICAgIGJ1dHRvbkxpc3Q6IGksXG4gICAgICBvdmVyZmxvd01lbnVJdGVtTGlzdDogc1xuICAgIH0gOiB7XG4gICAgICBidXR0b25MaXN0OiBpXG4gICAgfTtcbiAgfVxuICBnZXRUb29sYmFyQnV0dG9uSXRlbXMoKSB7XG4gICAgY29uc3QgeyBidXR0b25MaXN0OiB0LCBvdmVyZmxvd01lbnVJdGVtTGlzdDogbiB9ID0gdGhpcy5nZXRDb250cm9sQ29uZmlncygpO1xuICAgIHJldHVybiBuICYmIHQucHVzaCh0aGlzLmdldE92ZXJmbG93QnV0dG9uQ29uZmlnKCkpLCB0IHx8IFtdO1xuICB9XG4gIGdldE92ZXJmbG93TWVudUl0ZW1zKCkge1xuICAgIGNvbnN0IHsgb3ZlcmZsb3dNZW51SXRlbUxpc3Q6IHQgfSA9IHRoaXMuZ2V0Q29udHJvbENvbmZpZ3MoKTtcbiAgICByZXR1cm4gdCB8fCBbXTtcbiAgfVxuICAvLyBzcGVjaWFsIGJ1dHRvbiBjb25maWcgZm9yIG92ZXJmbG93IGJ1dHRvblxuICBnZXRPdmVyZmxvd0J1dHRvbkNvbmZpZygpIHtcbiAgICBjb25zdCB7IG1vcmVPcHRpb25zOiB0IH0gPSB5KFxuICAgICAgdGhpcy5tb2RlbC5nZXRPcHRpb25zKCksXG4gICAgICBcImxvY2FsZVwiLFxuICAgICAgXCJ0cmFuc2xhdGlvbnNcIixcbiAgICAgIFwidG9vbGJhclwiXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IFwidG9vbGJhci1vdmVyZmxvdy1tZW51XCIsXG4gICAgICB0aXRsZTogdCxcbiAgICAgIHNob3VsZEJlRGlzYWJsZWQ6ICgpID0+ICExLFxuICAgICAgaWNvblNWRzoge1xuICAgICAgICBjb250ZW50OiBgPGNpcmNsZSBjeD1cIjE2XCIgY3k9XCI4XCIgcj1cIjJcIj48L2NpcmNsZT5cblx0XHRcdFx0PGNpcmNsZSBjeD1cIjE2XCIgY3k9XCIxNlwiIHI9XCIyXCI+PC9jaXJjbGU+XG5cdFx0XHRcdDxjaXJjbGUgY3g9XCIxNlwiIGN5PVwiMjRcIiByPVwiMlwiPjwvY2lyY2xlPmBcbiAgICAgIH0sXG4gICAgICBjbGlja0Z1bmN0aW9uOiAobikgPT4gdGhpcy50b2dnbGVPdmVyZmxvd01lbnUobilcbiAgICB9O1xuICB9XG4gIGdldENvbnRyb2xDb25maWdCeVR5cGUodCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLnNlcnZpY2VzLnpvb20gJiYgdGhpcy5zZXJ2aWNlcy56b29tLmlzWm9vbUJhckVuYWJsZWQoKSAmJiAhdGhpcy5zZXJ2aWNlcy56b29tLmlzRW1wdHlTdGF0ZSgpLCByID0gdGhpcy5tb2RlbC5nZXREaXNwbGF5RGF0YSgpLCBpID0gdGhpcy5tb2RlbC5nZXRPcHRpb25zKCksIHtcbiAgICAgIGV4cG9ydEFzQ1NWOiBzLFxuICAgICAgZXhwb3J0QXNKUEc6IGEsXG4gICAgICBleHBvcnRBc1BORzogbyxcbiAgICAgIHpvb21JbjogbCxcbiAgICAgIHpvb21PdXQ6IGMsXG4gICAgICByZXNldFpvb206IHUsXG4gICAgICBtYWtlRnVsbFNjcmVlbjogZCxcbiAgICAgIGV4aXRGdWxsU2NyZWVuOiBoLFxuICAgICAgc2hvd0FzVGFibGU6IHBcbiAgICB9ID0geShpLCBcImxvY2FsZVwiLCBcInRyYW5zbGF0aW9uc1wiLCBcInRvb2xiYXJcIik7XG4gICAgbGV0IGY7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICBjYXNlIF90LlpPT01fSU46XG4gICAgICAgIG4gJiYgKGYgPSB7XG4gICAgICAgICAgaWQ6IFwidG9vbGJhci16b29tSW5cIixcbiAgICAgICAgICB0aXRsZTogbCxcbiAgICAgICAgICBzaG91bGRCZURpc2FibGVkOiAoKSA9PiB0aGlzLnNlcnZpY2VzLnpvb20uaXNNaW5ab29tRG9tYWluKCksXG4gICAgICAgICAgaWNvblNWRzoge1xuICAgICAgICAgICAgY29udGVudDogdGhpcy5nZXRDb250cm9sSWNvbkJ5VHlwZSh0KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xpY2tGdW5jdGlvbjogKCkgPT4gdGhpcy5zZXJ2aWNlcy56b29tLnpvb21JbigpXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3QuWk9PTV9PVVQ6XG4gICAgICAgIG4gJiYgKGYgPSB7XG4gICAgICAgICAgaWQ6IFwidG9vbGJhci16b29tT3V0XCIsXG4gICAgICAgICAgdGl0bGU6IGMsXG4gICAgICAgICAgc2hvdWxkQmVEaXNhYmxlZDogKCkgPT4gdGhpcy5zZXJ2aWNlcy56b29tLmlzTWF4Wm9vbURvbWFpbigpLFxuICAgICAgICAgIGljb25TVkc6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuZ2V0Q29udHJvbEljb25CeVR5cGUodClcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsaWNrRnVuY3Rpb246ICgpID0+IHRoaXMuc2VydmljZXMuem9vbS56b29tT3V0KClcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdC5SRVNFVF9aT09NOlxuICAgICAgICBuICYmIChmID0ge1xuICAgICAgICAgIGlkOiBcInRvb2xiYXItcmVzZXRab29tXCIsXG4gICAgICAgICAgdGl0bGU6IHUsXG4gICAgICAgICAgc2hvdWxkQmVEaXNhYmxlZDogKCkgPT4gdGhpcy5zZXJ2aWNlcy56b29tLmlzTWF4Wm9vbURvbWFpbigpLFxuICAgICAgICAgIGljb25TVkc6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuZ2V0Q29udHJvbEljb25CeVR5cGUodClcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsaWNrRnVuY3Rpb246ICgpID0+IHRoaXMuc2VydmljZXMuem9vbS5yZXNldFpvb21Eb21haW4oKVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF90Lk1BS0VfRlVMTFNDUkVFTjpcbiAgICAgICAgZiA9IHtcbiAgICAgICAgICBpZDogXCJ0b29sYmFyLW1ha2VmdWxsc2NyZWVuXCIsXG4gICAgICAgICAgaWNvblNWRzoge1xuICAgICAgICAgICAgY29udGVudDogdGhpcy5nZXRDb250cm9sSWNvbkJ5VHlwZSh0KSxcbiAgICAgICAgICAgIHdpZHRoOiBcIjE1cHhcIixcbiAgICAgICAgICAgIGhlaWdodDogXCIxNXB4XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpdGxlOiBkLFxuICAgICAgICAgIHNob3VsZEJlRGlzYWJsZWQ6ICgpID0+ICExLFxuICAgICAgICAgIGNsaWNrRnVuY3Rpb246ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2VydmljZXMuZG9tVXRpbHMudG9nZ2xlRnVsbHNjcmVlbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF90LkVYSVRfRlVMTFNDUkVFTjpcbiAgICAgICAgZiA9IHtcbiAgICAgICAgICBpZDogXCJ0b29sYmFyLWV4aXRmdWxsc2NyZWVuXCIsXG4gICAgICAgICAgaWNvblNWRzoge1xuICAgICAgICAgICAgY29udGVudDogdGhpcy5nZXRDb250cm9sSWNvbkJ5VHlwZSh0KSxcbiAgICAgICAgICAgIHdpZHRoOiBcIjE1cHhcIixcbiAgICAgICAgICAgIGhlaWdodDogXCIxNXB4XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpdGxlOiBoLFxuICAgICAgICAgIHNob3VsZEJlRGlzYWJsZWQ6ICgpID0+ICExLFxuICAgICAgICAgIGNsaWNrRnVuY3Rpb246ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2VydmljZXMuZG9tVXRpbHMudG9nZ2xlRnVsbHNjcmVlbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF90LlNIT1dfQVNfREFUQVRBQkxFOlxuICAgICAgICBmID0ge1xuICAgICAgICAgIGlkOiBcInRvb2xiYXItc2hvd2FzZGF0YXRhYmxlXCIsXG4gICAgICAgICAgaWNvblNWRzoge1xuICAgICAgICAgICAgY29udGVudDogdGhpcy5nZXRDb250cm9sSWNvbkJ5VHlwZSh0KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGl0bGU6IHAsXG4gICAgICAgICAgc2hvdWxkQmVEaXNhYmxlZDogKCkgPT4gci5sZW5ndGggPT09IDAsXG4gICAgICAgICAgY2xpY2tGdW5jdGlvbjogKCkgPT4gdGhpcy5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULk1vZGFsLlNIT1cpXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdC5FWFBPUlRfQ1NWOlxuICAgICAgICBmID0ge1xuICAgICAgICAgIGlkOiBcInRvb2xiYXItZXhwb3J0LUNTVlwiLFxuICAgICAgICAgIHRpdGxlOiBzLFxuICAgICAgICAgIHNob3VsZEJlRGlzYWJsZWQ6ICgpID0+ICExLFxuICAgICAgICAgIGljb25TVkc6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuZ2V0Q29udHJvbEljb25CeVR5cGUodClcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsaWNrRnVuY3Rpb246ICgpID0+IHRoaXMubW9kZWwuZXhwb3J0VG9DU1YoKVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3QuRVhQT1JUX1BORzpcbiAgICAgICAgZiA9IHtcbiAgICAgICAgICBpZDogXCJ0b29sYmFyLWV4cG9ydC1QTkdcIixcbiAgICAgICAgICB0aXRsZTogbyxcbiAgICAgICAgICBzaG91bGRCZURpc2FibGVkOiAoKSA9PiAhMSxcbiAgICAgICAgICBpY29uU1ZHOiB7XG4gICAgICAgICAgICBjb250ZW50OiB0aGlzLmdldENvbnRyb2xJY29uQnlUeXBlKHQpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjbGlja0Z1bmN0aW9uOiAoKSA9PiB0aGlzLnNlcnZpY2VzLmRvbVV0aWxzLmV4cG9ydFRvUE5HKClcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF90LkVYUE9SVF9KUEc6XG4gICAgICAgIGYgPSB7XG4gICAgICAgICAgaWQ6IFwidG9vbGJhci1leHBvcnQtSlBHXCIsXG4gICAgICAgICAgdGl0bGU6IGEsXG4gICAgICAgICAgc2hvdWxkQmVEaXNhYmxlZDogKCkgPT4gITEsXG4gICAgICAgICAgaWNvblNWRzoge1xuICAgICAgICAgICAgY29udGVudDogdGhpcy5nZXRDb250cm9sSWNvbkJ5VHlwZSh0KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xpY2tGdW5jdGlvbjogKCkgPT4gdGhpcy5zZXJ2aWNlcy5kb21VdGlscy5leHBvcnRUb0pQRygpXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gYWRkIG1vcmUgdG9vbGJhciBjb250cm9sIGNvbmZpZ3VyYXRpb24gaGVyZVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJOb3Qgc3VwcG9ydGVkIHRvb2xiYXIgY29udHJvbCB0eXBlOiBcIiArIHQpO1xuICAgIH1cbiAgICByZXR1cm4gZjtcbiAgfVxuICBnZXRDb250cm9sSWNvbkJ5VHlwZSh0KSB7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICBjYXNlIF90LlpPT01fSU46XG4gICAgICAgIHJldHVybiBgPHBvbHlnb24gcG9pbnRzPVwiMTkgMTMgMTUgMTMgMTUgOSAxMyA5IDEzIDEzIDkgMTMgOSAxNSAxMyAxNSAxMyAxOSAxNSAxOSAxNSAxNSAxOSAxNSAxOSAxM1wiLz5cblx0XHRcdFx0XHRcdDxwYXRoIGQ9XCJNMjIuNDUsMjFBMTAuODcsMTAuODcsMCwwLDAsMjUsMTQsMTEsMTEsMCwxLDAsMTQsMjVhMTAuODcsMTAuODcsMCwwLDAsNy0yLjU1TDI4LjU5LDMwLDMwLDI4LjU5Wk0xNCwyM2E5LDksMCwxLDEsOS05QTksOSwwLDAsMSwxNCwyM1pcIi8+YDtcbiAgICAgIGNhc2UgX3QuWk9PTV9PVVQ6XG4gICAgICAgIHJldHVybiBgPHJlY3QgeD1cIjlcIiB5PVwiMTNcIiB3aWR0aD1cIjEwXCIgaGVpZ2h0PVwiMlwiLz5cblx0XHRcdFx0XHRcdDxwYXRoIGQ9XCJNMjIuNDUsMjFBMTAuODcsMTAuODcsMCwwLDAsMjUsMTQsMTEsMTEsMCwxLDAsMTQsMjVhMTAuODcsMTAuODcsMCwwLDAsNy0yLjU1TDI4LjU5LDMwLDMwLDI4LjU5Wk0xNCwyM2E5LDksMCwxLDEsOS05QTksOSwwLDAsMSwxNCwyM1pcIi8+YDtcbiAgICAgIGNhc2UgX3QuUkVTRVRfWk9PTTpcbiAgICAgICAgcmV0dXJuICc8cGF0aCBkPVwiTTIyLjQ0NzgsMjFBMTAuODU1LDEwLjg1NSwwLDAsMCwyNSwxNCwxMC45OSwxMC45OSwwLDAsMCw2LDYuNDY1OFYySDR2OGg4VjhINy4zMzJhOC45NzY4LDguOTc2OCwwLDEsMS0yLjEsOEgzLjE5MTJBMTEuMDExOCwxMS4wMTE4LDAsMCwwLDE0LDI1YTEwLjg1NSwxMC44NTUsMCwwLDAsNy0yLjU1MjJMMjguNTg1OSwzMCwzMCwyOC41ODU5WlwiLz4nO1xuICAgICAgY2FzZSBfdC5NQUtFX0ZVTExTQ1JFRU46XG4gICAgICAgIHJldHVybiAnPHBvbHlnb24gcG9pbnRzPVwiMjEgMiAyMSA0IDI2LjU5IDQgMTcgMTMuNTggMTguNDEgMTUgMjggNS40MSAyOCAxMSAzMCAxMSAzMCAyIDIxIDJcIi8+PHBvbHlnb24gcG9pbnRzPVwiMTUgMTguNDIgMTMuNTkgMTcgNCAyNi41OSA0IDIxIDIgMjEgMiAzMCAxMSAzMCAxMSAyOCA1LjQxIDI4IDE1IDE4LjQyXCIvPic7XG4gICAgICBjYXNlIF90LkVYSVRfRlVMTFNDUkVFTjpcbiAgICAgICAgcmV0dXJuICc8cG9seWdvbiBwb2ludHM9XCI0IDE4IDQgMjAgMTAuNTg2IDIwIDIgMjguNTgyIDMuNDE0IDMwIDEyIDIxLjQxNCAxMiAyOCAxNCAyOCAxNCAxOCA0IDE4XCIvPjxwb2x5Z29uIHBvaW50cz1cIjMwIDMuNDE2IDI4LjU5MiAyIDIwIDEwLjU4NiAyMCA0IDE4IDQgMTggMTQgMjggMTQgMjggMTIgMjEuNDE0IDEyIDMwIDMuNDE2XCIvPic7XG4gICAgICBjYXNlIF90LlNIT1dfQVNfREFUQVRBQkxFOlxuICAgICAgICByZXR1cm4gJzxyZWN0IHg9XCI0XCIgeT1cIjZcIiB3aWR0aD1cIjE4XCIgaGVpZ2h0PVwiMlwiLz48cmVjdCB4PVwiNFwiIHk9XCIxMlwiIHdpZHRoPVwiMThcIiBoZWlnaHQ9XCIyXCIvPjxyZWN0IHg9XCI0XCIgeT1cIjE4XCIgd2lkdGg9XCIxOFwiIGhlaWdodD1cIjJcIi8+PHJlY3QgeD1cIjRcIiB5PVwiMjRcIiB3aWR0aD1cIjE4XCIgaGVpZ2h0PVwiMlwiLz48cmVjdCB4PVwiMjZcIiB5PVwiNlwiIHdpZHRoPVwiMlwiIGhlaWdodD1cIjJcIi8+PHJlY3QgeD1cIjI2XCIgeT1cIjEyXCIgd2lkdGg9XCIyXCIgaGVpZ2h0PVwiMlwiLz48cmVjdCB4PVwiMjZcIiB5PVwiMThcIiB3aWR0aD1cIjJcIiBoZWlnaHQ9XCIyXCIvPjxyZWN0IHg9XCIyNlwiIHk9XCIyNFwiIHdpZHRoPVwiMlwiIGhlaWdodD1cIjJcIi8+JztcbiAgICAgIGNhc2UgX3QuRVhQT1JUX0NTVjpcbiAgICAgICAgcmV0dXJuICc8cGF0aCBkPVwiTTIyLjQ0NzgsMjFBMTAuODU1LDEwLjg1NSwwLDAsMCwyNSwxNCwxMC45OSwxMC45OSwwLDAsMCw2LDYuNDY1OFYySDR2OGg4VjhINy4zMzJhOC45NzY4LDguOTc2OCwwLDEsMS0yLjEsOEgzLjE5MTJBMTEuMDExOCwxMS4wMTE4LDAsMCwwLDE0LDI1YTEwLjg1NSwxMC44NTUsMCwwLDAsNy0yLjU1MjJMMjguNTg1OSwzMCwzMCwyOC41ODU5WlwiLz4nO1xuICAgICAgY2FzZSBfdC5FWFBPUlRfSlBHOlxuICAgICAgICByZXR1cm4gJzxwYXRoIGQ9XCJNMjIuNDQ3OCwyMUExMC44NTUsMTAuODU1LDAsMCwwLDI1LDE0LDEwLjk5LDEwLjk5LDAsMCwwLDYsNi40NjU4VjJINHY4aDhWOEg3LjMzMmE4Ljk3NjgsOC45NzY4LDAsMSwxLTIuMSw4SDMuMTkxMkExMS4wMTE4LDExLjAxMTgsMCwwLDAsMTQsMjVhMTAuODU1LDEwLjg1NSwwLDAsMCw3LTIuNTUyMkwyOC41ODU5LDMwLDMwLDI4LjU4NTlaXCIvPic7XG4gICAgICBjYXNlIF90LkVYUE9SVF9QTkc6XG4gICAgICAgIHJldHVybiAnPHBhdGggZD1cIk0yMi40NDc4LDIxQTEwLjg1NSwxMC44NTUsMCwwLDAsMjUsMTQsMTAuOTksMTAuOTksMCwwLDAsNiw2LjQ2NThWMkg0djhoOFY4SDcuMzMyYTguOTc2OCw4Ljk3NjgsMCwxLDEtMi4xLDhIMy4xOTEyQTExLjAxMTgsMTEuMDExOCwwLDAsMCwxNCwyNWExMC44NTUsMTAuODU1LDAsMCwwLDctMi41NTIyTDI4LjU4NTksMzAsMzAsMjguNTg1OVpcIi8+JztcbiAgICAgIC8vIGFkZCBtb3JlIGljb25zIGhlcmVcbiAgICAgIC8vIHN2ZyBpY29uIG11c3QgYmUgd2l0aCAzMngzMiB2aWV3Qm94XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBFcnJvcihcIk5vdCBzdXBwb3J0ZWQgdG9vbGJhciBjb250cm9sIHR5cGU6IFwiICsgdCk7XG4gICAgfVxuICB9XG59O1xucHYuYnV0dG9uSUQgPSAwO1xubGV0IHBvID0gcHY7XG5jb25zdCBtdiA9IGNsYXNzIGd2IGV4dGVuZHMgbXQge1xuICBjb25zdHJ1Y3Rvcih0LCBuLCByLCBpKSB7XG4gICAgc3VwZXIodCwgbiwgaSksIHRoaXMudHlwZSA9IFwibGF5b3V0XCIsIHRoaXMuY29uZmlncyA9IGksIHRoaXMuY2hpbGRyZW4gPSByLCB0aGlzLl9pbnN0YW5jZUlEID0gZ3YuaW5zdGFuY2VJRCsrLCB0aGlzLmluaXQoKTtcbiAgfVxuICBpbml0KCkge1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdC5jb21wb25lbnRzLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgbi5pbml0KCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBnZXRQcmVmZXJlZEFuZEZpeGVkU2l6ZVN1bSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5wYXJlbnQ7XG4gICAgbGV0IG4gPSAwO1xuICAgIHJldHVybiB0LnNlbGVjdEFsbChgZGl2LmxheW91dC1jaGlsZC0ke3RoaXMuX2luc3RhbmNlSUR9YCkuZmlsdGVyKChyKSA9PiB7XG4gICAgICBjb25zdCBpID0geShyLCBcImdyb3d0aFwiKTtcbiAgICAgIHJldHVybiBpID09PSBjdC5QUkVGRVJSRUQgfHwgaSA9PT0gY3QuRklYRUQ7XG4gICAgfSkuZWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBuICs9IHIuc2l6ZTtcbiAgICB9KSwgbjtcbiAgfVxuICBnZXROdW1PZlN0cmV0Y2hDaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQuc2VsZWN0QWxsKGBkaXYubGF5b3V0LWNoaWxkLSR7dGhpcy5faW5zdGFuY2VJRH1gKS5maWx0ZXIoKHQpID0+IHkodCwgXCJncm93dGhcIikgPT09IGN0LlNUUkVUQ0gpLnNpemUoKTtcbiAgfVxuICByZW5kZXIodCA9ICEwKSB7XG4gICAgY29uc3QgbiA9IHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLCByID0gdGhpcy5wYXJlbnQsIHsgd2lkdGg6IGksIGhlaWdodDogcyB9ID0gTi5nZXRIVE1MRWxlbWVudFNpemUoci5ub2RlKCkpLCBhID0gdGhpcy5jb25maWdzLmRpcmVjdGlvbiA9PT0gQXQuUk9XIHx8IHRoaXMuY29uZmlncy5kaXJlY3Rpb24gPT09IEF0LlJPV19SRVZFUlNFLCBvID0geSh0aGlzLm1vZGVsLmdldE9wdGlvbnMoKSwgXCJzdHlsZVwiLCBcInByZWZpeFwiKSwgbCA9IHIuY2xhc3NlZChcbiAgICAgIGAke3VlfS0tJHtvfS0tbGF5b3V0LXJvd2AsXG4gICAgICB0aGlzLmNvbmZpZ3MuZGlyZWN0aW9uID09PSBBdC5ST1dcbiAgICApLmNsYXNzZWQoXG4gICAgICBgJHt1ZX0tLSR7b30tLWxheW91dC1yb3ctcmV2ZXJzZWAsXG4gICAgICB0aGlzLmNvbmZpZ3MuZGlyZWN0aW9uID09PSBBdC5ST1dfUkVWRVJTRVxuICAgICkuY2xhc3NlZChcbiAgICAgIGAke3VlfS0tJHtvfS0tbGF5b3V0LWNvbHVtbmAsXG4gICAgICB0aGlzLmNvbmZpZ3MuZGlyZWN0aW9uID09PSBBdC5DT0xVTU5cbiAgICApLmNsYXNzZWQoXG4gICAgICBgJHt1ZX0tLSR7b30tLWxheW91dC1jb2x1bW4tcmV2ZXJzZWAsXG4gICAgICB0aGlzLmNvbmZpZ3MuZGlyZWN0aW9uID09PSBBdC5DT0xVTU5fUkVWRVJTRVxuICAgICkuY2xhc3NlZChcbiAgICAgIGAke3VlfS0tJHtvfS0tbGF5b3V0LWFsaWduaXRlbXMtY2VudGVyYCxcbiAgICAgIHRoaXMuY29uZmlncy5hbGlnbkl0ZW1zID09PSBuaS5DRU5URVJcbiAgICApLnNlbGVjdEFsbChgZGl2LmxheW91dC1jaGlsZC0ke3RoaXMuX2luc3RhbmNlSUR9YCkuZGF0YSh0aGlzLmNoaWxkcmVuLCAodSkgPT4gdS5pZCk7XG4gICAgbC5lbnRlcigpLmFwcGVuZChcImRpdlwiKS5tZXJnZShyLnNlbGVjdEFsbChgZGl2LmxheW91dC1jaGlsZC0ke3RoaXMuX2luc3RhbmNlSUR9YCkpLmF0dHIoXCJjbGFzc1wiLCAodSkgPT4gYGxheW91dC1jaGlsZCBsYXlvdXQtY2hpbGQtJHt0aGlzLl9pbnN0YW5jZUlEfSAke3UuaWR9YCkuZWFjaChmdW5jdGlvbih1KSB7XG4gICAgICB1LmNvbXBvbmVudHMuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICB2YXIgaDtcbiAgICAgICAgY29uc3QgcCA9IEkodGhpcyksIGYgPSB5KHUsIFwicmVuZGVyVHlwZVwiKSA9PT0gcnQuU1ZHO1xuICAgICAgICBkLnNldFBhcmVudChcbiAgICAgICAgICBmID8gTi5hcHBlbmRPclNlbGVjdChwLCBcInN2Zy5sYXlvdXQtc3ZnLXdyYXBwZXJcIikuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKS5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKSA6IHBcbiAgICAgICAgKSwgZiAmJiAhcC5zZWxlY3QoXCJzdmcubGF5b3V0LXN2Zy13cmFwcGVyXCIpLmF0dHIoXCJhcmlhLWxhYmVsXCIpICYmIHAuc2VsZWN0KFwic3ZnLmxheW91dC1zdmctd3JhcHBlclwiKS5hdHRyKFwiYXJpYS1sYWJlbFwiLCAoKGggPSBuID09IG51bGwgPyB2b2lkIDAgOiBuLmFjY2Vzc2liaWxpdHkpID09IG51bGwgPyB2b2lkIDAgOiBoLnN2Z0FyaWFMYWJlbCkgfHwgKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4udGl0bGUpKTtcbiAgICAgICAgY29uc3QgZyA9IHkodSwgXCJncm93dGhcIik7XG4gICAgICAgIChnID09PSBjdC5QUkVGRVJSRUQgfHwgZyA9PT0gY3QuRklYRUQpICYmIGQucmVuZGVyKHQpO1xuICAgICAgfSk7XG4gICAgfSksIHIuc2VsZWN0QWxsKGBkaXYubGF5b3V0LWNoaWxkLSR7dGhpcy5faW5zdGFuY2VJRH1gKS5zdHlsZShcImhlaWdodFwiLCBudWxsKS5zdHlsZShcIndpZHRoXCIsIG51bGwpLmVhY2goZnVuY3Rpb24odSkge1xuICAgICAgY29uc3QgZCA9IHkodSwgXCJncm93dGhcIiksIGggPSB5KHUsIFwicmVuZGVyVHlwZVwiKSA9PT0gcnQuU1ZHID8gTi5nZXRTVkdFbGVtZW50U2l6ZShJKHRoaXMpLnNlbGVjdChcInN2Zy5sYXlvdXQtc3ZnLXdyYXBwZXJcIiksIHtcbiAgICAgICAgdXNlQkJveDogITBcbiAgICAgIH0pIDogTi5nZXRIVE1MRWxlbWVudFNpemUodGhpcyk7XG4gICAgICBpZiAoZCA9PT0gY3QuUFJFRkVSUkVEKSB7XG4gICAgICAgIGNvbnN0IHAgPSBhID8gaC53aWR0aCA6IGguaGVpZ2h0LCBmID0gYSA/IGkgOiBzO1xuICAgICAgICB1LnNpemUgPSBwIC8gZiAqIDEwMDtcbiAgICAgIH1cbiAgICB9KSwgbC5leGl0KCkucmVtb3ZlKCksIHRoaXMuY2hpbGRyZW4uZmlsdGVyKCh1KSA9PiB5KHUsIFwiZ3Jvd3RoXCIpID09PSBjdC5TVFJFVENIKS5mb3JFYWNoKCh1KSA9PiB7XG4gICAgICB1LnNpemUgPSAoMTAwIC0gK3RoaXMuZ2V0UHJlZmVyZWRBbmRGaXhlZFNpemVTdW0oKSkgLyArdGhpcy5nZXROdW1PZlN0cmV0Y2hDaGlsZHJlbigpO1xuICAgIH0pO1xuICAgIGNvbnN0IGMgPSByLnNlbGVjdEFsbChgZGl2LmxheW91dC1jaGlsZC0ke3RoaXMuX2luc3RhbmNlSUR9YCkuZGF0YSh0aGlzLmNoaWxkcmVuLCAodSkgPT4gdS5pZCk7XG4gICAgYSA/IGMuc3R5bGUoXCJ3aWR0aFwiLCAodSkgPT4gYCR7dS5zaXplIC8gMTAwICogaX1weGApLnN0eWxlKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKSA6IGMuc3R5bGUoXCJoZWlnaHRcIiwgKHUpID0+IGAke3Uuc2l6ZSAvIDEwMCAqIHN9cHhgKS5zdHlsZShcIndpZHRoXCIsIFwiMTAwJVwiKSwgYy5lYWNoKGZ1bmN0aW9uKHUpIHtcbiAgICAgIHUuY29tcG9uZW50cy5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgIHkodSwgXCJncm93dGhcIikgPT09IGN0LlNUUkVUQ0ggJiYgZC5yZW5kZXIodCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvLyBQYXNzIG9uIG1vZGVsIHRvIGNoaWxkcmVuIGFzIHdlbGxcbiAgc2V0TW9kZWwodCkge1xuICAgIHN1cGVyLnNldE1vZGVsKHQpLCB0aGlzLmNoaWxkcmVuLmZvckVhY2goKG4pID0+IHtcbiAgICAgIG4uY29tcG9uZW50cy5mb3JFYWNoKChyKSA9PiByLnNldE1vZGVsKHQpKTtcbiAgICB9KTtcbiAgfVxuICAvLyBQYXNzIG9uIGVzc2VudGlhbHMgdG8gY2hpbGRyZW4gYXMgd2VsbFxuICBzZXRTZXJ2aWNlcyh0KSB7XG4gICAgc3VwZXIuc2V0U2VydmljZXModCksIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgobikgPT4ge1xuICAgICAgbi5jb21wb25lbnRzLmZvckVhY2goKHIpID0+IHIuc2V0U2VydmljZXModCkpO1xuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0LmNvbXBvbmVudHMuZm9yRWFjaCgobikgPT4gbi5kZXN0cm95KCkpO1xuICAgIH0pO1xuICB9XG59O1xubXYuaW5zdGFuY2VJRCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDk5OTk5OTk5OTk5KTtcbmxldCBiZSA9IG12O1xuY2xhc3MgQW4gZXh0ZW5kcyBtdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IFwic3BhY2VyXCI7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcmVuZGVyKHQgPSAhMSkge1xuICAgIHRoaXMuZ2V0Q29tcG9uZW50Q29udGFpbmVyKHtcbiAgICAgIGlzUHJlc2VudGF0aW9uYWw6ICEwXG4gICAgfSkuc3R5bGUoXCJ3aWR0aFwiLCBgJHt0aGlzLmNvbmZpZ3Muc2l6ZSB8fCBSaC5kZWZhdWx0LnNpemV9cHhgKS5zdHlsZShcImhlaWdodFwiLCBgJHt0aGlzLmNvbmZpZ3Muc2l6ZSB8fCBSaC5kZWZhdWx0LnNpemV9cHhgKS5hdHRyKFwib3BhY2l0eVwiLCAwKTtcbiAgfVxufVxuY2xhc3MgZm8gZXh0ZW5kcyBtdCB7XG4gIGNvbnN0cnVjdG9yKHQsIG4sIHIpIHtcbiAgICBzdXBlcih0LCBuLCByKSwgdGhpcy50eXBlID0gXCJtb2RhbFwiLCB0aGlzLmlzRXZlbnRMaXN0ZW5lckFkZGVkID0gITEsIHRoaXMuaGFuZGxlU2hvd01vZGFsID0gKCkgPT4ge1xuICAgICAgY29uc3QgaSA9IHRoaXMuc2VydmljZXMuZG9tVXRpbHMuZ2V0Q2hhcnRJRCgpO1xuICAgICAgdGhpcy5tb2RhbC5hdHRyKFwiZGF0YS1tb2RhbFwiLCAhMCkuYXR0cihcImNsYXNzXCIsIFwiY2RzLS1tb2RhbFwiKS5hdHRyKFwicm9sZVwiLCBcImRpYWxvZ1wiKS5hdHRyKFwiYXJpYS1tb2RhbFwiLCAhMCkuYXR0cihcImFyaWEtbGFiZWxsZWRieVwiLCBgJHtpfV9fbW9kYWwtdGl0bGVgKS5hdHRyKFwiYXJpYS1kZXNjcmliZWRieVwiLCBgJHtpfV9fbW9kYWwtZGVzY3JpcHRpb25gKS5hdHRyKFwidGFiaW5kZXhcIiwgLTEpLnN0eWxlKFwib3BhY2l0eVwiLCAxKS5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpLCB0aGlzLm1vZGFsLmh0bWwodGhpcy5nZXRNb2RhbEhUTUwoKSksIHRoaXMubW9kYWwuc2VsZWN0KFwiZGl2LmNkcy0tbW9kYWwtZm9vdGVyIGJ1dHRvbi5jZHMtLWJ0blwiKS5vbihcImNsaWNrXCIsICgpID0+IHRoaXMubW9kZWwuZXhwb3J0VG9DU1YoKSksIHRoaXMubW9kYWwub24oXCJjbGlja1wiLCB0aGlzLmhhbmRsZUhpZGVNb2RhbCksIHRoaXMubW9kYWwuc2VsZWN0KFwiLmNkcy0tbW9kYWwtY29udGFpbmVyXCIpLm9uKFwiY2xpY2tcIiwgKHMpID0+IHtcbiAgICAgICAgcy5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0pLCB0aGlzLm1vZGFsLnNlbGVjdChcIi5jZHMtLW1vZGFsLWNsb3NlXCIpLm9uKFwiY2xpY2tcIiwgdGhpcy5oYW5kbGVIaWRlTW9kYWwpLCB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlRXNjYXBlS2V5KTtcbiAgICB9LCB0aGlzLmhhbmRsZUVzY2FwZUtleSA9IChpKSA9PiB7XG4gICAgICBpLmtleSA9PT0gXCJFc2NhcGVcIiAmJiB0aGlzLmhhbmRsZUhpZGVNb2RhbCgpO1xuICAgIH0sIHRoaXMuaGFuZGxlSGlkZU1vZGFsID0gKCkgPT4ge1xuICAgICAgdGhpcy5tb2RhbC5hdHRyKFwicm9sZVwiLCBudWxsKS5hdHRyKFwiYXJpYS1tb2RhbFwiLCBudWxsKS5hdHRyKFwiYXJpYS1sYWJlbGxlZGJ5XCIsIG51bGwpLmF0dHIoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIG51bGwpLmF0dHIoXCJ0YWJpbmRleFwiLCBudWxsKS5zdHlsZShcIm9wYWNpdHlcIiwgMCkuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpLCB0aGlzLm1vZGFsLm9uKFwiY2xpY2tcIiwgbnVsbCksIHRoaXMubW9kYWwuc2VsZWN0KFwiLmNkcy0tbW9kYWwtY29udGFpbmVyXCIpLm9uKFwiY2xpY2tcIiwgbnVsbCksIHRoaXMubW9kYWwuc2VsZWN0KFwiLmNkcy0tbW9kYWwtY2xvc2VcIikub24oXCJjbGlja1wiLCBudWxsKSwgdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmhhbmRsZUVzY2FwZUtleSk7XG4gICAgfSwgdGhpcy5pbml0KCk7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5zZXJ2aWNlcy5ldmVudHMuYWRkRXZlbnRMaXN0ZW5lcihULk1vZGFsLlNIT1csIHRoaXMuaGFuZGxlU2hvd01vZGFsKTtcbiAgfVxuICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLnNlcnZpY2VzLmV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyKFQuTW9kYWwuU0hPVywgdGhpcy5oYW5kbGVTaG93TW9kYWwpO1xuICB9XG4gIGdldE1vZGFsSFRNTCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5zZXJ2aWNlcy5kb21VdGlscy5nZXRDaGFydElEKCksIG4gPSB0aGlzLm1vZGVsLmdldE9wdGlvbnMoKSwgeyB0aXRsZTogciwgZG93bmxvYWRBc0NTVjogaSB9ID0geShuLCBcImxvY2FsZVwiLCBcInRyYW5zbGF0aW9uc1wiLCBcInRhYnVsYXJSZXBcIiksIHMgPSB5KG4sIFwic3R5bGVcIiwgXCJwcmVmaXhcIiksIGEgPSB0aGlzLm1vZGVsLmdldFRhYnVsYXJEYXRhQXJyYXkoKTtcbiAgICByZXR1cm4gYFxuXHRcdDxkaXYgY2xhc3M9XCJjZHMtLW1vZGFsLWNvbnRhaW5lclwiPlxuXHRcdFx0PGRpdiBjbGFzcz1cImNkcy0tbW9kYWwtaGVhZGVyXCI+XG5cblx0XHRcdFx0PHAgY2xhc3M9XCJjZHMtLW1vZGFsLWhlYWRlcl9fbGFiZWwgY2RzLS10eXBlLWRlbHRhXCIgaWQ9XCJtb2RhbC10aXRsZVwiPiR7cn08L3A+XG5cblx0XHRcdFx0PHAgY2xhc3M9XCJjZHMtLW1vZGFsLWhlYWRlcl9faGVhZGluZyBjZHMtLXR5cGUtYmV0YVwiIGlkPVwiJHt0fV9fbW9kYWwtZGVzY3JpcHRpb25cIj4ke2VuKFxuICAgICAgbi50aXRsZVxuICAgICl9PC9wPlxuXG5cdFx0XHRcdDxidXR0b24gY2xhc3M9XCJjZHMtLW1vZGFsLWNsb3NlXCIgdHlwZT1cImJ1dHRvblwiIGRhdGEtbW9kYWwtY2xvc2UgYXJpYS1sYWJlbD1cImNsb3NlIG1vZGFsXCIgIGRhdGEtbW9kYWwtcHJpbWFyeS1mb2N1cz5cblx0XHRcdFx0XHQ8c3ZnIGZvY3VzYWJsZT1cImZhbHNlXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaWRZTWlkIG1lZXRcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGFyaWEtbGFiZWw9XCJDbG9zZVwiIHdpZHRoPVwiMjBcIiBoZWlnaHQ9XCIyMFwiIHZpZXdCb3g9XCIwIDAgMzIgMzJcIiByb2xlPVwiaW1nXCIgY2xhc3M9XCJjZHMtLW1vZGFsLWNsb3NlX19pY29uXCI+XG5cdFx0XHRcdFx0XHQ8cGF0aCBkPVwiTTI0IDkuNEwyMi42IDggMTYgMTQuNiA5LjQgOCA4IDkuNCAxNC42IDE2IDggMjIuNiA5LjQgMjQgMTYgMTcuNCAyMi42IDI0IDI0IDIyLjYgMTcuNCAxNiAyNCA5LjR6XCI+PC9wYXRoPlxuXHRcdFx0XHRcdDwvc3ZnPlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdDwvZGl2PlxuXG5cdFx0XHQ8ZGl2IGNsYXNzPVwiY2RzLS1tb2RhbC1jb250ZW50XCI+XG5cdFx0XHRcdDx0YWJsZSBjbGFzcz1cImNkcy0tZGF0YS10YWJsZSBjZHMtLWRhdGEtdGFibGUtLW5vLWJvcmRlclwiPlxuXHRcdFx0XHRcdDx0aGVhZD5cblx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0JHtndChhLCAwKS5tYXAoXG4gICAgICAobykgPT4gYDx0aCBzY29wZT1cImNvbFwiPlxuXHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJjZHMtLXRhYmxlLWhlYWRlci1sYWJlbFwiPiR7ZW4obyl9PC9kaXY+XG5cdFx0XHRcdFx0XHRcdDwvdGg+YFxuICAgICkuam9pbihcIlwiKX1cblx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0PC90aGVhZD5cblxuXHRcdFx0XHRcdDx0Ym9keT4ke2Euc2xpY2UoMSkubWFwKFxuICAgICAgKG8pID0+IGBcblx0XHRcdFx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdFx0XHRcdCR7by5tYXAoKGwpID0+IGA8dGQ+JHtlbihsKX08L3RkPmApLmpvaW4oXCJcIil9XG5cdFx0XHRcdFx0XHRcdDwvdHI+YFxuICAgICkuam9pbihcIlwiKX1cblx0XHRcdFx0XHQ8L3Rib2R5PlxuXHRcdFx0XHQ8L3RhYmxlPlxuXHRcdFx0PC9kaXY+XG5cblx0XHRcdDxkaXYgY2xhc3M9XCJjZHMtLW1vZGFsLWZvb3RlclwiPlxuXHRcdFx0ICA8ZGl2IGNsYXNzPVwiJHt1ZX0tLSR7c30tbW9kYWwtZm9vdGVyLXNwYWNlclwiPjwvZGl2PlxuXHRcdFx0ICA8YnV0dG9uIGNsYXNzPVwiY2RzLS1idG4gY2RzLS1idG4tLXByaW1hcnlcIiB0eXBlPVwiYnV0dG9uXCIgZGF0YS1tb2RhbC1wcmltYXJ5LWZvY3VzPiR7aX08L2J1dHRvbj5cblx0XHRcdDwvZGl2PlxuXHRcdDwvZGl2PmA7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcmVuZGVyKHQgPSAhMSkge1xuICAgIGNvbnN0IG4gPSB0aGlzLm1vZGVsLmdldE9wdGlvbnMoKTtcbiAgICBpZiAoIXRoaXMuaXNFdmVudExpc3RlbmVyQWRkZWQpIHtcbiAgICAgIGNvbnN0IHIgPSBJKHRoaXMuc2VydmljZXMuZG9tVXRpbHMuZ2V0SG9sZGVyKCkpLCBpID0geShuLCBcInN0eWxlXCIsIFwicHJlZml4XCIpO1xuICAgICAgdGhpcy5tb2RhbCA9IE4uYXBwZW5kT3JTZWxlY3QociwgYGRpdi4ke3VlfS0tJHtpfS0tbW9kYWxgKSwgdGhpcy5hZGRFdmVudExpc3RlbmVycygpLCB0aGlzLmlzRXZlbnRMaXN0ZW5lckFkZGVkID0gITA7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVycygpLCB0aGlzLmlzRXZlbnRMaXN0ZW5lckFkZGVkID0gITE7XG4gIH1cbn1cbmNsYXNzIGJzIGV4dGVuZHMgbXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnR5cGUgPSBcInRpdGxlXCIsIHRoaXMucmVuZGVyVHlwZSA9IHJ0LkhUTUw7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcmVuZGVyKHQgPSAhMSkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldENvbXBvbmVudENvbnRhaW5lcigpLCByID0geSh0aGlzLmdldE9wdGlvbnMoKSwgXCJ0aXRsZVwiKSwgaSA9IG4uc2VsZWN0QWxsKFwicC50aXRsZVwiKS5kYXRhKFtyXSk7XG4gICAgaWYgKGkuZW50ZXIoKS5hcHBlbmQoXCJwXCIpLmNsYXNzZWQoXCJ0aXRsZVwiLCAhMCkuYXR0cihcInJvbGVcIiwgXCJoZWFkaW5nXCIpLmF0dHIoXCJhcmlhLWxldmVsXCIsIDIpLm1lcmdlKGkpLmh0bWwoKHMpID0+IGVuKHMpKSwgaS5ub2RlKCkgJiYgaS5ub2RlKCkub2Zmc2V0V2lkdGggPCBpLm5vZGUoKS5zY3JvbGxXaWR0aCkge1xuICAgICAgY29uc3QgcyA9IHRoaXM7XG4gICAgICBpLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgcy5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuU0hPVywge1xuICAgICAgICAgIGV2ZW50OiBhLFxuICAgICAgICAgIGhvdmVyZWRFbGVtZW50OiBpLFxuICAgICAgICAgIGNvbnRlbnQ6IGkudGV4dCgpXG4gICAgICAgIH0pO1xuICAgICAgfSkub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24oYSkge1xuICAgICAgICBzLnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5NT1ZFLCB7XG4gICAgICAgICAgZXZlbnQ6IGFcbiAgICAgICAgfSk7XG4gICAgICB9KS5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzLnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5ISURFKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpLmV4aXQoKS5yZW1vdmUoKTtcbiAgfVxuICAvKipcbiAgICogVHJ1bmNhdGVzIHRpdGxlIGNyZWF0aW5nIGVsbGlwc2VzIGFuZCBhdHRhY2hpbmcgdG9vbHRpcCBmb3IgZXhwb3NpbmcgZnVsbCB0aXRsZS5cbiAgICovXG4gIHRydW5jYXRlVGl0bGUodCwgbikge1xuICAgIGlmIChuIDw9IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IHQudGV4dCgpO1xuICAgIGlmICh0Lm5vZGUoKS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKSA+IG4pIHtcbiAgICAgIHQuYXBwZW5kKFwidHNwYW5cIikudGV4dChcIi4uLlwiKTtcbiAgICAgIGNvbnN0IGkgPSBOLmFwcGVuZE9yU2VsZWN0KHQsIFwidHNwYW5cIikubm9kZSgpLmdldENvbXB1dGVkVGV4dExlbmd0aCgpLCBzID0gdC50ZXh0KCksIGEgPSB0aGlzLmdldFN1YnN0cmluZ0luZGV4KFxuICAgICAgICB0Lm5vZGUoKSxcbiAgICAgICAgMCxcbiAgICAgICAgcy5sZW5ndGggLSAxLFxuICAgICAgICBuIC0gaVxuICAgICAgKTtcbiAgICAgIHQuaHRtbChzLnN1YnN0cmluZygwLCBhIC0gMSkpLmFwcGVuZChcInRzcGFuXCIpLnRleHQoXCIuLi5cIik7XG4gICAgICBjb25zdCBvID0gdGhpcztcbiAgICAgIHQub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24obCkge1xuICAgICAgICBvLnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5TSE9XLCB7XG4gICAgICAgICAgZXZlbnQ6IGwsXG4gICAgICAgICAgaG92ZXJlZEVsZW1lbnQ6IHQsXG4gICAgICAgICAgY29udGVudDogclxuICAgICAgICB9KTtcbiAgICAgIH0pLm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgby5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuTU9WRSwge1xuICAgICAgICAgIGV2ZW50OiBsXG4gICAgICAgIH0pO1xuICAgICAgfSkub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgby5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuSElERSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLy8gY29tcHV0ZXMgdGhlIG1heGltdW0gc3BhY2UgYSB0aXRsZSBjYW4gdGFrZVxuICBnZXRNYXhUaXRsZVdpZHRoKCkge1xuICAgIHJldHVybiBOLmdldFNWR0VsZW1lbnRTaXplKHRoaXMucGFyZW50Lm5vZGUoKSwge1xuICAgICAgdXNlQXR0cnM6ICEwXG4gICAgfSkud2lkdGg7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IGZvciBhIG1heGltdW0gbGVuZ3RoIHN1YnN0cmluZyB0aGF0IGlzIGxlc3MgdGhhbiB0aGUgd2lkdGggcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0gdGl0bGUgdGhlIHRpdGxlIG5vZGUgdXNlZCBmb3IgZ2V0dGluZyB0aGUgdGV4dCBsZW5ndGhzIG9mIHN1YnN0cmluZ3NcbiAgICogQHBhcmFtIHN0YXJ0IHRoZSBzdGFydCBpbmRleCBmb3IgdGhlIGJpbmFyeSBzZWFyY2hcbiAgICogQHBhcmFtIGVuZCB0aGUgZW5kIGluZGV4IGZvciB0aGUgYmluYXJ5IHNlYXJjaFxuICAgKiBAcGFyYW0gd2lkdGggdGhlIHdpZHRoIG9mIHRoZSBzdmcgY29udGFpbmVyIHRoYXQgaG9sZHMgdGhlIHRpdGxlXG4gICAqL1xuICBnZXRTdWJzdHJpbmdJbmRleCh0LCBuLCByLCBpKSB7XG4gICAgY29uc3QgcyA9IE1hdGguZmxvb3IoKHIgKyBuKSAvIDIpO1xuICAgIHJldHVybiB0LmdldFN1YlN0cmluZ0xlbmd0aCgwLCBzKSA+IGkgPyB0aGlzLmdldFN1YnN0cmluZ0luZGV4KHQsIG4sIHMsIGkpIDogdC5nZXRTdWJTdHJpbmdMZW5ndGgoMCwgcykgPCBpID8gdC5nZXRTdWJTdHJpbmdMZW5ndGgoMCwgcyArIDEpID4gaSA/IHMgOiB0aGlzLmdldFN1YnN0cmluZ0luZGV4KHQsIHMsIHIsIGkpIDogcztcbiAgfVxufVxuY2xhc3MgbHUgZXh0ZW5kcyBtdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IFwibGVnZW5kXCIsIHRoaXMucmVuZGVyVHlwZSA9IHJ0LkhUTUw7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcmVuZGVyKHQgPSAhMSkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldE9wdGlvbnMoKSwgciA9IHkobiwgXCJsZWdlbmRcIiksIGkgPSB5KHIsIFwiYWxpZ25tZW50XCIpLCBzID0geShuLCBcImxlZ2VuZFwiLCBcIm9yaWVudGF0aW9uXCIpO1xuICAgIGxldCBhID0gdGhpcy5tb2RlbC5nZXREYXRhR3JvdXBzKCk7XG4gICAgY29uc3QgeyBESVNBQkxFRDogbyB9ID0gSXQuaXRlbXMuc3RhdHVzLCBsID0gYS5zb21lKCh4KSA9PiB4LnN0YXR1cyA9PT0gbyksIGMgPSB5KHIsIFwib3JkZXJcIiksIHUgPSB0aGlzLmdldENvbXBvbmVudENvbnRhaW5lcigpLmNsYXNzZWQoXCJjZW50ZXItYWxpZ25lZFwiLCBpID09PSBqdC5DRU5URVIpLmNsYXNzZWQoXCJyaWdodC1hbGlnbmVkXCIsIGkgPT09IGp0LlJJR0hUKS5jbGFzc2VkKHMsICEwKS5jbGFzc2VkKFwiaGFzLWRlYWN0aXZhdGVkLWl0ZW1zXCIsIGwpLmF0dHIoXCJyb2xlXCIsIGh0LkdST1VQKS5hdHRyKFwiYXJpYS1sYWJlbFwiLCBcIkRhdGEgZ3JvdXBzXCIpLmF0dHIoXCJkYXRhLW5hbWVcIiwgXCJsZWdlbmQtaXRlbXNcIik7XG4gICAgYyAmJiAoYSA9IHRoaXMuc29ydERhdGFHcm91cHMoYSwgYykpO1xuICAgIGNvbnN0IGQgPSB1LnNlbGVjdEFsbChcImRpdi5sZWdlbmQtaXRlbVwiKS5kYXRhKGEsICh4KSA9PiB4Lm5hbWUpLCBoID0gZC5lbnRlcigpLmFwcGVuZChcImRpdlwiKS5hdHRyKFwiY2xhc3NcIiwgXCJsZWdlbmQtaXRlbVwiKTtcbiAgICBoLm1lcmdlKHUuc2VsZWN0QWxsKFwiZGl2LmxlZ2VuZC1pdGVtXCIpKS5jbGFzc2VkKFwiYWN0aXZlXCIsIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4LnN0YXR1cyA9PT0gSXQuaXRlbXMuc3RhdHVzLkFDVElWRTtcbiAgICB9KTtcbiAgICBjb25zdCBwID0geSh0aGlzLmdldE9wdGlvbnMoKSwgXCJsZWdlbmRcIiwgXCJjbGlja2FibGVcIik7XG4gICAgdS5jbGFzc2VkKFwiY2xpY2thYmxlXCIsIHAgJiYgYS5sZW5ndGggPiAxKTtcbiAgICBjb25zdCBmID0gSXQuY2hlY2tib3gucmFkaXVzLCBnID0gaC5hcHBlbmQoXCJkaXZcIikuY2xhc3NlZChcImNoZWNrYm94XCIsICEwKSwgbSA9IGcubWVyZ2UoZC5zZWxlY3QoXCJkaXYuY2hlY2tib3hcIikpLmF0dHIoXCJyb2xlXCIsIGh0LkNIRUNLQk9YKS5hdHRyKFwidGFiaW5kZXhcIiwgcCA/IDAgOiAtMSkuYXR0cihcbiAgICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCIsXG4gICAgICAoeCwgXykgPT4gdGhpcy5zZXJ2aWNlcy5kb21VdGlscy5nZW5lcmF0ZUVsZW1lbnRJRFN0cmluZyhgbGVnZW5kLWRhdGFncm91cC0ke199LXRpdGxlYClcbiAgICApLmF0dHIoXCJhcmlhLWNoZWNrZWRcIiwgKHsgc3RhdHVzOiB4IH0pID0+IHggPT09IEl0Lml0ZW1zLnN0YXR1cy5BQ1RJVkUpLmF0dHIoXCJ3aWR0aFwiLCBmICogMikuYXR0cihcImhlaWdodFwiLCBmICogMikuYXR0cihcbiAgICAgIFwiY2xhc3NcIixcbiAgICAgICh4KSA9PiB0aGlzLm1vZGVsLmdldENvbG9yQ2xhc3NOYW1lKHtcbiAgICAgICAgY2xhc3NOYW1lVHlwZXM6IFtpdC5CQUNLR1JPVU5EXSxcbiAgICAgICAgZGF0YUdyb3VwTmFtZTogeC5uYW1lLFxuICAgICAgICBvcmlnaW5hbENsYXNzTmFtZTogXCJjaGVja2JveFwiXG4gICAgICB9KVxuICAgICkuc3R5bGUoXG4gICAgICBcImJhY2tncm91bmRcIixcbiAgICAgICh4KSA9PiB4LnN0YXR1cyA9PT0gSXQuaXRlbXMuc3RhdHVzLkFDVElWRSA/IHRoaXMubW9kZWwuZ2V0RmlsbENvbG9yKHgubmFtZSkgfHwgdGhpcy5tb2RlbC5nZXRTdHJva2VDb2xvcih4Lm5hbWUpIDogbnVsbFxuICAgICkuY2xhc3NlZChcImFjdGl2ZVwiLCBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geC5zdGF0dXMgPT09IEl0Lml0ZW1zLnN0YXR1cy5BQ1RJVkU7XG4gICAgfSk7XG4gICAgZy5hcHBlbmQoXCJzdmdcIikuYXR0cihcImZvY3VzYWJsZVwiLCAhMSkuYXR0cihcInByZXNlcnZlQXNwZWN0UmF0aW9cIiwgXCJ4TWlkWU1pZCBtZWV0XCIpLmF0dHIoXCJ4bWxuc1wiLCBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIpLmF0dHIoXCJ3aWR0aFwiLCBcIjExXCIpLmF0dHIoXCJoZWlnaHRcIiwgXCIxMVwiKS5hdHRyKFwidmlld0JveFwiLCBcIjAgMCAzMSAyOFwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIiwgITApLnN0eWxlKFwid2lsbC1jaGFuZ2VcIiwgXCJ0cmFuc2Zvcm1cIikuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiZFwiLCBcIk0xMyAyMS4ybC03LjEtNy4xLTEuNCAxLjQgNy4xIDcuMUwxMyAyNCAyNy4xIDkuOWwtMS40LTEuNXpcIiksIGguYXBwZW5kKFwicFwiKS5tZXJnZShkLnNlbGVjdChcInBcIikpO1xuICAgIGNvbnN0IHYgPSB5KG4sIFwibGVnZW5kXCIsIFwiYWRkaXRpb25hbEl0ZW1zXCIpO1xuICAgIGlmICh2ICYmIGEubGVuZ3RoKSB7XG4gICAgICBjb25zdCB4ID0gdGhpcywgXyA9IHUuc2VsZWN0QWxsKFwiZGl2LmFkZGl0aW9uYWwtaXRlbVwiKS5kYXRhKHYpO1xuICAgICAgXy5leGl0KCkucmVtb3ZlKCk7XG4gICAgICBjb25zdCBFID0gXy5lbnRlcigpLmFwcGVuZChcImRpdlwiKS5tZXJnZShfKS5jbGFzc2VkKFwibGVnZW5kLWl0ZW1cIiwgITApLmNsYXNzZWQoXCJhZGRpdGlvbmFsXCIsICEwKS5hdHRyKFxuICAgICAgICBcImFyaWEtbGFiZWxsZWRieVwiLFxuICAgICAgICAoTSwgRCkgPT4gdGhpcy5zZXJ2aWNlcy5kb21VdGlscy5nZW5lcmF0ZUVsZW1lbnRJRFN0cmluZyhcbiAgICAgICAgICBgbGVnZW5kLWRhdGFncm91cC0ke20uc2l6ZSgpICsgRH0tdGl0bGVgXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBFLnNlbGVjdEFsbChcIipcIikucmVtb3ZlKCk7XG4gICAgICBsZXQgYiwgUyA9IDE7XG4gICAgICBFLmFwcGVuZChcInN2Z1wiKS5jbGFzc2VkKFwiaWNvblwiLCAhMCkuZWFjaChmdW5jdGlvbihNKSB7XG4gICAgICAgIGNvbnN0IEQgPSBJKHRoaXMpO1xuICAgICAgICAhYiB8fCBiICE9IE0udHlwZSA/IChiID0gTS50eXBlLCBTID0gMSkgOiBTKyssIHguYWRkQWRkaXRpb25hbEl0ZW0oRCwgTSwgUyk7XG4gICAgICB9KSwgRS5hcHBlbmQoXCJwXCIpLm1lcmdlKEUuc2VsZWN0KFwicFwiKSksIHRoaXMudHJ1bmNhdGVMZWdlbmRUZXh0KCk7XG4gICAgfVxuICAgIGQuZXhpdCgpLm9uKFwibW91c2VvdmVyXCIsIG51bGwpLm9uKFwiY2xpY2tcIiwgbnVsbCkub24oXCJtb3VzZW91dFwiLCBudWxsKS5yZW1vdmUoKSwgcCAmJiBoLnNpemUoKSA+IDEgJiYgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICB9XG4gIHNvcnREYXRhR3JvdXBzKHQsIG4pIHtcbiAgICBpZiAodC5zb3J0KFxuICAgICAgKHIsIGkpID0+IG4uaW5kZXhPZihyLm5hbWUpIC0gbi5pbmRleE9mKGkubmFtZSlcbiAgICApLCBuLmxlbmd0aCA8IHQubGVuZ3RoKSB7XG4gICAgICBjb25zdCByID0gdC5sZW5ndGggLSBuLmxlbmd0aDtcbiAgICAgIHJldHVybiB0LnNsaWNlKHIpLmNvbmNhdCh0LnNsaWNlKDAsIHIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgYWRkQWRkaXRpb25hbEl0ZW0odCwgbiwgcikge1xuICAgIGNvbnN0IHsgd2lkdGg6IGksIGhlaWdodDogcyB9ID0gSXQuYXJlYTtcbiAgICBpZiAobi50eXBlID09PSBHdC5SQURJVVMgPyB0LnN0eWxlKFwid2lkdGhcIiwgYCR7c31weGApLnN0eWxlKFwiaGVpZ2h0XCIsIGAke3N9cHhgKSA6IHQuc3R5bGUoXCJ3aWR0aFwiLCBgJHtpfXB4YCkuc3R5bGUoXCJoZWlnaHRcIiwgYCR7c31weGApLCBuLnR5cGUgPT09IEd0LlJBRElVUykge1xuICAgICAgY29uc3QgeyBpY29uRGF0YTogYSwgZmlsbDogbywgc3Ryb2tlOiBsIH0gPSBJdC5yYWRpdXM7XG4gICAgICB0LmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKS5zZWxlY3RBbGwoXCJjaXJjbGVcIikuZGF0YShhKS5lbnRlcigpLmFwcGVuZChcImNpcmNsZVwiKS5jbGFzc2VkKFwicmFkaXVzXCIsICEwKS5hdHRyKFwicm9sZVwiLCBodC5JTUcpLmF0dHIoXCJhcmlhLWxhYmVsXCIsIFwicmFkaXVzXCIpLmF0dHIoXCJjeFwiLCAoYykgPT4gYy5jeCkuYXR0cihcImN5XCIsIChjKSA9PiBjLmN5KS5hdHRyKFwiclwiLCAoYykgPT4gYy5yKS5zdHlsZShcImZpbGxcIiwgbi5maWxsID8gbi5maWxsIDogbykuc3R5bGUoXCJzdHJva2VcIiwgbi5zdHJva2UgPyBuLnN0cm9rZSA6IGwpO1xuICAgIH0gZWxzZSBpZiAobi50eXBlID09PSBHdC5MSU5FKSB7XG4gICAgICBjb25zdCBhID0gSXQubGluZTtcbiAgICAgIHQuc2VsZWN0KFwibGluZS5saW5lXCIpLmVtcHR5KCkgJiYgdC5hcHBlbmQoXCJsaW5lXCIpLmNsYXNzZWQoYGxpbmUtJHtyfWAsICEwKS5hdHRyKFwicm9sZVwiLCBodC5JTUcpLmF0dHIoXCJhcmlhLWxhYmVsXCIsIFwibGluZVwiKS5hdHRyKFwieDFcIiwgMCkuYXR0cihcInkxXCIsIGEueVBvc2l0aW9uKS5hdHRyKFwieDJcIiwgaSkuYXR0cihcInkyXCIsIGEueVBvc2l0aW9uKS5zdHlsZShcInN0cm9rZVwiLCBuLnN0cm9rZSA/IG4uc3Ryb2tlIDogYS5zdHJva2UpLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIGEuc3Ryb2tlV2lkdGgpO1xuICAgIH0gZWxzZSBpZiAobi50eXBlID09PSBHdC5BUkVBKVxuICAgICAgdC5zZWxlY3QoXCJyZWN0LmFyZWFcIikuZW1wdHkoKSAmJiB0LmFwcGVuZChcInJlY3RcIikuY2xhc3NlZChgYXJlYS0ke3J9YCwgITApLmF0dHIoXCJyb2xlXCIsIGh0LklNRykuYXR0cihcImFyaWEtbGFiZWxcIiwgXCJhcmVhXCIpLmF0dHIoXCJ3aWR0aFwiLCBpKS5hdHRyKFwiaGVpZ2h0XCIsIHMpLnN0eWxlKFxuICAgICAgICBcImZpbGxcIixcbiAgICAgICAgciA+IDMgJiYgIW4uZmlsbCA/IEl0LmFyZWEuZmlsbCA6IG4uZmlsbFxuICAgICAgKS5zdHlsZShcInN0cm9rZVwiLCBuLnN0cm9rZSk7XG4gICAgZWxzZSBpZiAobi50eXBlID09PSBHdC5TSVpFKSB7XG4gICAgICBjb25zdCB7IGljb25EYXRhOiBhLCBmaWxsOiBvLCBzdHJva2U6IGwgfSA9IEl0LnNpemU7XG4gICAgICB0LmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKS5hdHRyKFwicm9sZVwiLCBodC5JTUcpLmF0dHIoXCJhcmlhLWxhYmVsXCIsIFwic2l6ZVwiKS5zZWxlY3RBbGwoXCJyZWN0XCIpLmRhdGEoYSkuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpLmNsYXNzZWQoXCJzaXplXCIsICEwKS5hdHRyKFwid2lkdGhcIiwgKGMpID0+IGMud2lkdGgpLmF0dHIoXCJoZWlnaHRcIiwgKGMpID0+IGMuaGVpZ2h0KS5hdHRyKFwieVwiLCAoKSA9PiAwKS5zdHlsZShcImZpbGxcIiwgbi5maWxsID8gbi5maWxsIDogbykuc3R5bGUoXCJzdHJva2VcIiwgbi5zdHJva2UgPyBuLnN0cm9rZSA6IGwpLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIDEpO1xuICAgIH0gZWxzZSBpZiAobi50eXBlID09PSBHdC5RVUFSVElMRSkge1xuICAgICAgY29uc3QgeyBpY29uRGF0YTogYSB9ID0gSXQucXVhcnRpbGU7XG4gICAgICB0LnNlbGVjdEFsbChcInJlY3RcIikuYXR0cihcInJvbGVcIiwgaHQuSU1HKS5hdHRyKFwiYXJpYS1sYWJlbFwiLCBcInF1YXJ0aWxlXCIpLmRhdGEoYSkuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJjbGFzc1wiLCAobywgbCkgPT4gYHF1YXJ0aWxlLSR7bCA9PT0gMCA/IFwid3JhcHBlclwiIDogXCJsaW5lXCJ9YCkuYXR0cihcInhcIiwgKG8pID0+IG8ueCkuYXR0cihcInlcIiwgKG8pID0+IG8ueSkuYXR0cihcIndpZHRoXCIsIChvKSA9PiBvLndpZHRoKS5hdHRyKFwiaGVpZ2h0XCIsIChvKSA9PiBvLmhlaWdodCk7XG4gICAgfSBlbHNlIGlmIChuLnR5cGUgPT09IEd0LlpPT00pIHtcbiAgICAgIGNvbnN0IHsgaWNvbkRhdGE6IGEsIGNvbG9yOiBvIH0gPSB5KEl0LCBcInpvb21cIiksIGwgPSB0LmF0dHIoXCJyb2xlXCIsIGh0LklNRykuYXR0cihcImFyaWEtbGFiZWxcIiwgXCJ6b29tXCIpLnNlbGVjdEFsbChcImcuaWNvblwiKS5kYXRhKGEpLmVudGVyKCk7XG4gICAgICBsLmFwcGVuZChcImdcIikuYXR0cihcInhcIiwgKGMpID0+IGMueCkuYXR0cihcInlcIiwgKGMpID0+IGMueSkuYXR0cihcIndpZHRoXCIsIChjKSA9PiBjLndpZHRoKS5hdHRyKFwiaGVpZ2h0XCIsIChjKSA9PiBjLmhlaWdodCkuYXBwZW5kKFwicG9seWdvblwiKS5hdHRyKFxuICAgICAgICBcInBvaW50c1wiLFxuICAgICAgICBcIjcuNyA0LjgyIDUuNzggNC44MiA1Ljc4IDIuODkgNC44MiAyLjg5IDQuODIgNC44MiAyLjg5IDQuODIgMi44OSA1Ljc4IDQuODIgNS43OCA0LjgyIDcuNyA1Ljc4IDcuNyA1Ljc4IDUuNzggNy43IDUuNzggNy43IDQuODJcIlxuICAgICAgKS5hdHRyKFwiZmlsbFwiLCAoKSA9PiBuLmNvbG9yID8gbi5jb2xvciA6IG8pLCBsLmFwcGVuZChcInBhdGhcIikuYXR0cihcbiAgICAgICAgXCJkXCIsXG4gICAgICAgIFwiTTkuMzYsOC42N0E1LjIyLDUuMjIsMCwwLDAsMTAuNTksNS4zLDUuMyw1LjMsMCwxLDAsNS4zLDEwLjU5LDUuMjIsNS4yMiwwLDAsMCw4LjY3LDkuMzZMMTIuMzIsMTNsLjY4LS42OFptLTQuMDYsMUE0LjM0LDQuMzQsMCwxLDEsOS42Myw1LjMsNC4zMyw0LjMzLDAsMCwxLDUuMyw5LjYzWlwiXG4gICAgICApLmF0dHIoXCJmaWxsXCIsICgpID0+IG4uY29sb3IgPyBuLmNvbG9yIDogbyk7XG4gICAgfVxuICB9XG4gIHRydW5jYXRlTGVnZW5kVGV4dCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoKSwgbiA9IHkodGhpcy5nZXRPcHRpb25zKCksIFwibGVnZW5kXCIsIFwidHJ1bmNhdGlvblwiKSwgciA9IHkobiwgXCJ0eXBlXCIpLCBpID0geShuLCBcInRocmVzaG9sZFwiKSwgcyA9IHkobiwgXCJudW1DaGFyYWN0ZXJcIiksIGEgPSB0LnNlbGVjdEFsbChcImRpdi5sZWdlbmQtaXRlbSBwXCIpO1xuICAgIGEuYXR0cihcImlkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICh0aGlzLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvcihcImRpdi5jaGVja2JveFwiKSB8fCB0aGlzLnBhcmVudE5vZGUpLmdldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiKTtcbiAgICB9KSwgciAhPT0gVmUuTk9ORSA/IGEuaHRtbChmdW5jdGlvbihvKSB7XG4gICAgICBjb25zdCBsID0gZW4oby5uYW1lKTtcbiAgICAgIHJldHVybiBsLmxlbmd0aCA+IGkgJiYgbC5sZW5ndGggIT09IHMgPyBlcyhsLCByLCBzKSA6IGw7XG4gICAgfSkgOiBhLmh0bWwoKG8pID0+IGVuKG8ubmFtZSkpO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLCBuID0gdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoKSwgciA9IHRoaXMuZ2V0T3B0aW9ucygpLCBpID0geShyLCBcImxlZ2VuZFwiKSwgcyA9IHkoaSwgXCJ0cnVuY2F0aW9uXCIpO1xuICAgIG4uc2VsZWN0QWxsKFwiZGl2LmxlZ2VuZC1pdGVtXCIpLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKGEpIHtcbiAgICAgIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5MZWdlbmQuSVRFTV9IT1ZFUiwge1xuICAgICAgICBob3ZlcmVkRWxlbWVudDogSSh0aGlzKVxuICAgICAgfSk7XG4gICAgICBjb25zdCBvID0gSSh0aGlzKTtcbiAgICAgIG8uc2VsZWN0KFwiZGl2LmNoZWNrYm94XCIpLmNsYXNzZWQoXCJob3ZlcmVkXCIsICEwKTtcbiAgICAgIGNvbnN0IGwgPSBvLmRhdHVtKCk7XG4gICAgICBsLm5hbWUubGVuZ3RoID4gcy50aHJlc2hvbGQgJiYgcy5udW1DaGFyYWN0ZXIgPCBsLm5hbWUubGVuZ3RoICYmIHMudHlwZSAhPT0gVmUuTk9ORSAmJiB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5TSE9XLCB7XG4gICAgICAgIGV2ZW50OiBhLFxuICAgICAgICBob3ZlcmVkRWxlbWVudDogbyxcbiAgICAgICAgY29udGVudDogbC5uYW1lXG4gICAgICB9KTtcbiAgICB9KS5vbihcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbihhKSB7XG4gICAgICBJKHRoaXMpLmRhdHVtKCkubmFtZS5sZW5ndGggPiBzLnRocmVzaG9sZCAmJiBzLnR5cGUgIT09IFZlLk5PTkUgJiYgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuTU9WRSwge1xuICAgICAgICBldmVudDogYVxuICAgICAgfSk7XG4gICAgfSkub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5MZWdlbmQuSVRFTV9DTElDSywge1xuICAgICAgICBjbGlja2VkRWxlbWVudDogSSh0aGlzKVxuICAgICAgfSk7XG4gICAgICBjb25zdCBhID0gSSh0aGlzKS5kYXR1bSgpO1xuICAgICAgdC5tb2RlbC50b2dnbGVEYXRhTGFiZWwoYS5uYW1lKTtcbiAgICB9KS5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgYSA9IEkodGhpcyk7XG4gICAgICBhLnNlbGVjdChcImRpdi5jaGVja2JveFwiKS5jbGFzc2VkKFwiaG92ZXJlZFwiLCAhMSksIGEuZGF0dW0oKS5uYW1lLmxlbmd0aCA+IHMudGhyZXNob2xkICYmIHMudHlwZSAhPT0gVmUuTk9ORSAmJiB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5ISURFKSwgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkxlZ2VuZC5JVEVNX01PVVNFT1VULCB7XG4gICAgICAgIGhvdmVyZWRFbGVtZW50OiBhXG4gICAgICB9KTtcbiAgICB9KSwgbi5zZWxlY3RBbGwoXCJkaXYubGVnZW5kLWl0ZW0gZGl2LmNoZWNrYm94XCIpLm9uKFwia2V5dXBcIiwgZnVuY3Rpb24oYSkge1xuICAgICAgYS5rZXkgJiYgYS5rZXkgPT09IFwiVGFiXCIgJiYgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkxlZ2VuZC5JVEVNX0hPVkVSLCB7XG4gICAgICAgIGhvdmVyZWRFbGVtZW50OiBJKHRoaXMpXG4gICAgICB9KTtcbiAgICB9KSwgbi5zZWxlY3RBbGwoXCJkaXYubGVnZW5kLWl0ZW0gZGl2LmNoZWNrYm94XCIpLm9uKFwia2V5ZG93blwiLCBmdW5jdGlvbihhLCBvKSB7XG4gICAgICBhLmtleSAmJiBhLmtleSA9PT0gXCIgXCIgPyAoYS5wcmV2ZW50RGVmYXVsdCgpLCB0Lm1vZGVsLnRvZ2dsZURhdGFMYWJlbChvLm5hbWUpKSA6IGEua2V5ICYmIGEua2V5ID09PSBcIlRhYlwiICYmIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5MZWdlbmQuSVRFTV9NT1VTRU9VVCwge1xuICAgICAgICBob3ZlcmVkRWxlbWVudDogSSh0aGlzKVxuICAgICAgfSk7XG4gICAgfSksIG4uc2VsZWN0QWxsKFwiZy5hZGRpdGlvbmFsLWl0ZW1cIikub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oYSkge1xuICAgICAgY29uc3QgbyA9IEkodGhpcyksIGwgPSBvLmRhdHVtKCk7XG4gICAgICBsLm5hbWUubGVuZ3RoID4gcy50aHJlc2hvbGQgJiYgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuU0hPVywge1xuICAgICAgICBldmVudDogYSxcbiAgICAgICAgaG92ZXJlZEVsZW1lbnQ6IG8sXG4gICAgICAgIGNvbnRlbnQ6IGwubmFtZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIHZ2IGV4dGVuZHMgbXQge1xuICBjb25zdHJ1Y3Rvcih0LCBuLCByKSB7XG4gICAgc3VwZXIodCwgbiwgciksIHRoaXMudHlwZSA9IFwiY2hhcnQtY2xpcFwiLCB0aGlzLnJlbmRlclR5cGUgPSBydC5TVkcsIHRoaXMuY2hhcnRDbGlwSWQgPSBcImNoYXJ0LWNsaXAtaWQtXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA5OTk5OTk5OTk5OSksIHRoaXMuaW5pdCgpO1xuICB9XG4gIGluaXQoKSB7XG4gICAgdGhpcy5tb2RlbC5zZXQoeyBjaGFydENsaXBJZDogdGhpcy5jaGFydENsaXBJZCB9LCB7IHNraXBVcGRhdGU6ICEwIH0pO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIHJlbmRlcih0ID0gITApIHtcbiAgICB0aGlzLmNyZWF0ZUNsaXBQYXRoKCk7XG4gIH1cbiAgY3JlYXRlQ2xpcFBhdGgoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMucGFyZW50LCB7IGNhcnRlc2lhblNjYWxlczogbiB9ID0gdGhpcy5zZXJ2aWNlcztcbiAgICBpZiAoIW4pIHRocm93IG5ldyBFcnJvcihcIlNlcnZpY2UgY2FydGVzaWFuU2NhbGVzIHdhcyB1bmRlZmluZWRcIik7XG4gICAgY29uc3QgciA9IG4uZ2V0TWFpblhTY2FsZSgpLCBpID0gbi5nZXRNYWluWVNjYWxlKCksIFtzLCBhXSA9IHIucmFuZ2UoKSwgW28sIGxdID0gaS5yYW5nZSgpO1xuICAgIGlmICghdClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInN2ZyBpcyB1bmRlZmluZWRcIik7XG4gICAgdGhpcy5jaGFydENsaXBQYXRoID0gTi5hcHBlbmRPclNlbGVjdChcbiAgICAgIHQsXG4gICAgICBgY2xpcFBhdGguJHt0aGlzLnR5cGV9YFxuICAgICkuYXR0cihcImlkXCIsIHRoaXMuY2hhcnRDbGlwSWQpO1xuICAgIGNvbnN0IGMgPSBOLmFwcGVuZE9yU2VsZWN0KHRoaXMuY2hhcnRDbGlwUGF0aCwgYHJlY3QuJHt0aGlzLnR5cGV9YCk7XG4gICAgYSAtIHMgPiAwICYmIGMuYXR0cihcInhcIiwgcykuYXR0cihcInlcIiwgbCkuYXR0cihcIndpZHRoXCIsIGEgLSBzKS5hdHRyKFwiaGVpZ2h0XCIsIG8gLSBsKSwgdGhpcy5jaGFydENsaXBQYXRoLm1lcmdlKGMpLmxvd2VyKCk7XG4gIH1cbn1cbmNsYXNzIFZrIGV4dGVuZHMgdnYge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnR5cGUgPSBcImNhbnZhcy1jaGFydC1jbGlwXCIsIHRoaXMuY2hhcnRDbGlwSWQgPSBcImNhbnZhcy1jaGFydC1jbGlwLWlkLVwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogOTk5OTk5OTk5OTkpO1xuICB9XG4gIGNyZWF0ZUNsaXBQYXRoKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnBhcmVudCwgeyB3aWR0aDogbiwgaGVpZ2h0OiByIH0gPSBOLmdldFNWR0VsZW1lbnRTaXplKHRoaXMucGFyZW50LCB7XG4gICAgICB1c2VBdHRyczogITBcbiAgICB9KTtcbiAgICB0aGlzLmNoYXJ0Q2xpcFBhdGggPSBOLmFwcGVuZE9yU2VsZWN0KHQsIGBjbGlwUGF0aC4ke3RoaXMudHlwZX1gKS5hdHRyKFxuICAgICAgXCJpZFwiLFxuICAgICAgdGhpcy5jaGFydENsaXBJZFxuICAgICk7XG4gICAgY29uc3QgaSA9IE4uYXBwZW5kT3JTZWxlY3QodGhpcy5jaGFydENsaXBQYXRoLCBgcmVjdC4ke3RoaXMudHlwZX1gKTtcbiAgICBpLmF0dHIoXCJ4XCIsIDApLmF0dHIoXCJ5XCIsIDApLmF0dHIoXCJ3aWR0aFwiLCBuKS5hdHRyKFwiaGVpZ2h0XCIsIHIpLCB0aGlzLmNoYXJ0Q2xpcFBhdGgubWVyZ2UoaSkubG93ZXIoKTtcbiAgfVxufVxudmFyIE1yLCBWdDtcbihmdW5jdGlvbihlKSB7XG4gIGUuTEVGVCA9IFwibGVmdFwiLCBlLlJJR0hUID0gXCJyaWdodFwiLCBlLlRPUCA9IFwidG9wXCIsIGUuQk9UVE9NID0gXCJib3R0b21cIjtcbn0pKFZ0IHx8IChWdCA9IHt9KSk7XG52YXIgc3AgPSAoTXIgPSB7fSwgTXJbVnQuTEVGVF0gPSBmdW5jdGlvbihlLCB0LCBuKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiBlLnRvcCAtIE1hdGgucm91bmQodC5vZmZzZXRIZWlnaHQgLyAyKSArIE1hdGgucm91bmQobi5oZWlnaHQgLyAyKSxcbiAgICBsZWZ0OiBNYXRoLnJvdW5kKGUubGVmdCAtIHQub2Zmc2V0V2lkdGgpXG4gIH07XG59LCBNcltWdC5SSUdIVF0gPSBmdW5jdGlvbihlLCB0LCBuKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiBlLnRvcCAtIE1hdGgucm91bmQodC5vZmZzZXRIZWlnaHQgLyAyKSArIE1hdGgucm91bmQobi5oZWlnaHQgLyAyKSxcbiAgICBsZWZ0OiBNYXRoLnJvdW5kKGUubGVmdCArIG4ud2lkdGgpXG4gIH07XG59LCBNcltWdC5UT1BdID0gZnVuY3Rpb24oZSwgdCwgbikge1xuICByZXR1cm4ge1xuICAgIHRvcDogTWF0aC5yb3VuZChlLnRvcCAtIHQub2Zmc2V0SGVpZ2h0KSxcbiAgICBsZWZ0OiBlLmxlZnQgLSBNYXRoLnJvdW5kKHQub2Zmc2V0V2lkdGggLyAyKSArIE1hdGgucm91bmQobi53aWR0aCAvIDIpXG4gIH07XG59LCBNcltWdC5CT1RUT01dID0gZnVuY3Rpb24oZSwgdCwgbikge1xuICByZXR1cm4ge1xuICAgIHRvcDogTWF0aC5yb3VuZChlLnRvcCArIG4uaGVpZ2h0KSxcbiAgICBsZWZ0OiBlLmxlZnQgLSBNYXRoLnJvdW5kKHQub2Zmc2V0V2lkdGggLyAyKSArIE1hdGgucm91bmQobi53aWR0aCAvIDIpXG4gIH07XG59LCBNciksIGFwID0gdHlwZW9mIHdpbmRvdyA8IFwidVwiID8gd2luZG93IDoge1xuICBpbm5lckhlaWdodDogMCxcbiAgaW5uZXJXaWR0aDogMFxufSwgbW8gPSAoXG4gIC8qKiBAY2xhc3MgKi9cbiAgZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gZSh0KSB7XG4gICAgICB0ID09PSB2b2lkIDAgJiYgKHQgPSB7fSksIHRoaXMucG9zaXRpb25zID0gc3AsIHRoaXMucG9zaXRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgc3AsIHQpO1xuICAgIH1cbiAgICByZXR1cm4gZS5wcm90b3R5cGUuZ2V0UmVsYXRpdmVPZmZzZXQgPSBmdW5jdGlvbih0KSB7XG4gICAgICBmb3IgKHZhciBuID0ge1xuICAgICAgICBsZWZ0OiB0Lm9mZnNldExlZnQsXG4gICAgICAgIHRvcDogdC5vZmZzZXRUb3BcbiAgICAgIH07IHQub2Zmc2V0UGFyZW50ICYmIGdldENvbXB1dGVkU3R5bGUodC5vZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSBcInN0YXRpY1wiOyApXG4gICAgICAgIG4ubGVmdCArPSB0Lm9mZnNldExlZnQsIG4udG9wICs9IHQub2Zmc2V0VG9wLCB0ID0gdC5vZmZzZXRQYXJlbnQ7XG4gICAgICByZXR1cm4gbjtcbiAgICB9LCBlLnByb3RvdHlwZS5nZXRBYnNvbHV0ZU9mZnNldCA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgIGZvciAodmFyIG4gPSB0LCByID0ge1xuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDBcbiAgICAgIH07IG4ub2Zmc2V0UGFyZW50OyApIHtcbiAgICAgICAgdmFyIGkgPSBnZXRDb21wdXRlZFN0eWxlKG4ub2Zmc2V0UGFyZW50KTtcbiAgICAgICAgaS5wb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiAmJiBpLm1hcmdpbkxlZnQgJiYgaS5tYXJnaW5Ub3AgJiYgKHBhcnNlSW50KGkubWFyZ2luVG9wLCAxMCkgJiYgKHIudG9wICs9IHBhcnNlSW50KGkubWFyZ2luVG9wLCAxMCkpLCBwYXJzZUludChpLm1hcmdpbkxlZnQsIDEwKSAmJiAoci5sZWZ0ICs9IHBhcnNlSW50KGkubWFyZ2luTGVmdCwgMTApKSksIG4gPSBuLm9mZnNldFBhcmVudDtcbiAgICAgIH1cbiAgICAgIHZhciBzID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYSA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHMudG9wIC0gYS50b3AgKyByLnRvcCxcbiAgICAgICAgbGVmdDogcy5sZWZ0IC0gYS5sZWZ0ICsgci5sZWZ0XG4gICAgICB9O1xuICAgIH0sIGUucHJvdG90eXBlLmZpbmRSZWxhdGl2ZSA9IGZ1bmN0aW9uKHQsIG4sIHIpIHtcbiAgICAgIHZhciBpID0gdGhpcy5nZXRSZWxhdGl2ZU9mZnNldCh0KSwgcyA9IHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVQb3NpdGlvbihpLCBzLCBuLCByKTtcbiAgICB9LCBlLnByb3RvdHlwZS5maW5kQWJzb2x1dGUgPSBmdW5jdGlvbih0LCBuLCByKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuZ2V0QWJzb2x1dGVPZmZzZXQodCksIHMgPSB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlUG9zaXRpb24oaSwgcywgbiwgcik7XG4gICAgfSwgZS5wcm90b3R5cGUuZmluZFBvc2l0aW9uID0gZnVuY3Rpb24odCwgbiwgciwgaSkge1xuICAgICAgaSA9PT0gdm9pZCAwICYmIChpID0gdGhpcy5nZXRBYnNvbHV0ZU9mZnNldC5iaW5kKHRoaXMpKTtcbiAgICAgIHZhciBzID0gaSh0KSwgYSA9IHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVQb3NpdGlvbihzLCBhLCBuLCByKTtcbiAgICB9LCBlLnByb3RvdHlwZS5maW5kUG9zaXRpb25BdCA9IGZ1bmN0aW9uKHQsIG4sIHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZVBvc2l0aW9uKHQsIHsgdG9wOiAwLCBsZWZ0OiAwLCBoZWlnaHQ6IDAsIHdpZHRoOiAwIH0sIG4sIHIpO1xuICAgIH0sIGUucHJvdG90eXBlLmdldFBsYWNlbWVudEJveCA9IGZ1bmN0aW9uKHQsIG4pIHtcbiAgICAgIHZhciByID0gdC5vZmZzZXRIZWlnaHQgKyBuLnRvcCwgaSA9IHQub2Zmc2V0V2lkdGggKyBuLmxlZnQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IG4udG9wLFxuICAgICAgICBib3R0b206IHIsXG4gICAgICAgIGxlZnQ6IG4ubGVmdCxcbiAgICAgICAgcmlnaHQ6IGlcbiAgICAgIH07XG4gICAgfSwgZS5wcm90b3R5cGUuYWRkT2Zmc2V0ID0gZnVuY3Rpb24odCwgbiwgcikge1xuICAgICAgcmV0dXJuIG4gPT09IHZvaWQgMCAmJiAobiA9IDApLCByID09PSB2b2lkIDAgJiYgKHIgPSAwKSwgT2JqZWN0LmFzc2lnbih7fSwgdCwge1xuICAgICAgICB0b3A6IHQudG9wICsgbixcbiAgICAgICAgbGVmdDogdC5sZWZ0ICsgclxuICAgICAgfSk7XG4gICAgfSwgZS5wcm90b3R5cGUuc2V0RWxlbWVudCA9IGZ1bmN0aW9uKHQsIG4pIHtcbiAgICAgIHQuc3R5bGUudG9wID0gbi50b3AgKyBcInB4XCIsIHQuc3R5bGUubGVmdCA9IG4ubGVmdCArIFwicHhcIjtcbiAgICB9LCBlLnByb3RvdHlwZS5maW5kQmVzdFBsYWNlbWVudCA9IGZ1bmN0aW9uKHQsIG4sIHIsIGksIHMpIHtcbiAgICAgIHZhciBhID0gdGhpcztcbiAgICAgIGkgPT09IHZvaWQgMCAmJiAoaSA9IHRoaXMuZGVmYXVsdENvbnRhaW5lckZ1bmN0aW9uLmJpbmQodGhpcykpLCBzID09PSB2b2lkIDAgJiYgKHMgPSB0aGlzLmZpbmRQb3NpdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgIHZhciBvID0gci5tYXAoZnVuY3Rpb24obCkge1xuICAgICAgICB2YXIgYyA9IHModCwgbiwgbCksIHUgPSBhLmdldFBsYWNlbWVudEJveChuLCBjKSwgZCA9IDAsIGggPSAwLCBwID0gaSgpO1xuICAgICAgICB1LnRvcCA8IHAudG9wID8gZCA9IHAudG9wIC0gdS50b3AgOiB1LmJvdHRvbSA+IHAuaGVpZ2h0ICYmIChkID0gdS5ib3R0b20gLSBwLmhlaWdodCksIHUubGVmdCA8IHAubGVmdCA/IGggPSBwLmxlZnQgLSB1LmxlZnQgOiB1LnJpZ2h0ID4gcC53aWR0aCAmJiAoaCA9IHUucmlnaHQgLSBwLndpZHRoKSwgZCAmJiAhaCA/IGggPSAxIDogaCAmJiAhZCAmJiAoZCA9IDEpO1xuICAgICAgICB2YXIgZiA9IG4ub2Zmc2V0SGVpZ2h0ICogbi5vZmZzZXRXaWR0aCwgZyA9IGQgKiBoLCBtID0gZiAtIGcsIHYgPSBtIC8gZjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwbGFjZW1lbnQ6IGwsXG4gICAgICAgICAgd2VpZ2h0OiB2XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvLnNvcnQoZnVuY3Rpb24obCwgYykge1xuICAgICAgICByZXR1cm4gYy53ZWlnaHQgLSBsLndlaWdodDtcbiAgICAgIH0pLCBvWzBdLnBsYWNlbWVudDtcbiAgICB9LCBlLnByb3RvdHlwZS5maW5kQmVzdFBsYWNlbWVudEF0ID0gZnVuY3Rpb24odCwgbiwgciwgaSkge1xuICAgICAgdmFyIHMgPSB0aGlzO1xuICAgICAgaSA9PT0gdm9pZCAwICYmIChpID0gdGhpcy5kZWZhdWx0Q29udGFpbmVyRnVuY3Rpb24uYmluZCh0aGlzKSk7XG4gICAgICB2YXIgYSA9IGZ1bmN0aW9uKG8sIGwsIGMpIHtcbiAgICAgICAgcmV0dXJuIHMuZmluZFBvc2l0aW9uQXQodCwgbCwgYyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMuZmluZEJlc3RQbGFjZW1lbnQobnVsbCwgbiwgciwgaSwgYSk7XG4gICAgfSwgZS5wcm90b3R5cGUuZGVmYXVsdENvbnRhaW5lckZ1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyB3ZSBnbyB3aXRoIHdpbmRvdyBoZXJlLCBiZWNhdXNlIHRoYXQncyBnb2luZyB0byBiZSB0aGUgc2ltcGxlL2NvbW1vbiBjYXNlXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgaGVpZ2h0OiBhcC5pbm5lckhlaWdodCxcbiAgICAgICAgd2lkdGg6IGFwLmlubmVyV2lkdGhcbiAgICAgIH07XG4gICAgfSwgZS5wcm90b3R5cGUuY2FsY3VsYXRlUG9zaXRpb24gPSBmdW5jdGlvbih0LCBuLCByLCBpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbnNbaV0gPyB0aGlzLnBvc2l0aW9uc1tpXSh0LCByLCBuKSA6IChjb25zb2xlLmVycm9yKFwiTm8gZnVuY3Rpb24gZm91bmQgZm9yIHBsYWNlbWVudCwgZGVmYXVsdGluZyB0byAwLDBcIiksIHsgbGVmdDogMCwgdG9wOiAwIH0pO1xuICAgIH0sIGU7XG4gIH0oKVxuKTtcbm5ldyBtbygpO1xuY2xhc3MgY3UgZXh0ZW5kcyBtdCB7XG4gIGNvbnN0cnVjdG9yKHQsIG4sIHIpIHtcbiAgICBzdXBlcih0LCBuLCByKSwgdGhpcy50eXBlID0gXCJ0b29sdGlwXCIsIHRoaXMucmVuZGVyVHlwZSA9IHJ0LkhUTUwsIHRoaXMuaXNFdmVudExpc3RlbmVyQWRkZWQgPSAhMSwgdGhpcy5sYXN0VHJpZ2dlcmVkRXZlbnRUeXBlID0gXCJcIiwgdGhpcy5wb3NpdGlvblNlcnZpY2UgPSBuZXcgbW8oKSwgdGhpcy5oYW5kbGVTaG93VG9vbHRpcCA9IChpKSA9PiB7XG4gICAgICBjb25zdCBzID0gaS5kZXRhaWwuZGF0YSB8fCBpLmRldGFpbC5pdGVtcywgYSA9IEkoaS5kZXRhaWwuZXZlbnQudGFyZ2V0KS5kYXR1bSgpO1xuICAgICAgbGV0IG87XG4gICAgICBjb25zdCBsID0gdGhpcy5mb3JtYXRJdGVtcyh0aGlzLmdldEl0ZW1zKGkpKTtcbiAgICAgIGkuZGV0YWlsLmNvbnRlbnQgPyBvID0gYDxkaXYgY2xhc3M9XCJ0aXRsZS10b29sdGlwXCI+PHA+JHtHcyhpLmRldGFpbC5jb250ZW50KX08L3A+PC9kaXY+YCA6IG8gPSBHcyh0aGlzLmdldFRvb2x0aXBIVE1MKGwpKTtcbiAgICAgIGNvbnN0IGMgPSBOLmFwcGVuZE9yU2VsZWN0KHRoaXMudG9vbHRpcCwgXCJkaXYuY29udGVudC1ib3hcIik7XG4gICAgICBpZiAoeSh0aGlzLmdldE9wdGlvbnMoKSwgXCJ0b29sdGlwXCIsIFwiY3VzdG9tSFRNTFwiKSlcbiAgICAgICAgaWYgKGkuZGV0YWlsLmNvbnRlbnQpIHtcbiAgICAgICAgICBjb25zdCB1ID0gYDxkaXYgY2xhc3M9XCJ0aXRsZS10b29sdGlwXCI+PHA+JHtHcyhcbiAgICAgICAgICAgIGkuZGV0YWlsLmNvbnRlbnRcbiAgICAgICAgICApfTwvcD48L2Rpdj5gO1xuICAgICAgICAgIGMuaHRtbCh1KTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgYy5odG1sKFxuICAgICAgICAgICAgYDxkaXYgY2xhc3M9XCJ0aXRsZS10b29sdGlwXCI+PHA+JHtHcyhcbiAgICAgICAgICAgICAgdGhpcy5tb2RlbC5nZXRPcHRpb25zKCkudG9vbHRpcC5jdXN0b21IVE1MKHMsIG8sIGEpXG4gICAgICAgICAgICApfTwvcD48L2Rpdj5gXG4gICAgICAgICAgKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYy5odG1sKG8pO1xuICAgICAgYy5zZWxlY3RBbGwoXCIuZGF0YXBvaW50LXRvb2x0aXBcIikuZWFjaChmdW5jdGlvbih1LCBkKSB7XG4gICAgICAgIGNvbnN0IGggPSBsW2RdO1xuICAgICAgICBsW2RdICYmIGxbZF0uY29sb3IgJiYgSSh0aGlzKS5zZWxlY3QoXCIudG9vbHRpcC1jb2xvclwiKS5hdHRyKFwiY2xhc3NcIiwgXCJ0b29sdGlwLWNvbG9yXCIpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBoLmNvbG9yKTtcbiAgICAgIH0pLCB0aGlzLnBvc2l0aW9uVG9vbHRpcChpKSwgdGhpcy50b29sdGlwLmNsYXNzZWQoXCJoaWRkZW5cIiwgITEpLmF0dHIoXCJhcmlhLWhpZGRlblwiLCAhMSksIHRoaXMubGFzdFRyaWdnZXJlZEV2ZW50VHlwZSA9IGkudHlwZTtcbiAgICB9LCB0aGlzLmhhbmRsZUhpZGVUb29sdGlwID0gKCkgPT4ge1xuICAgICAgdGhpcy50b29sdGlwLmNsYXNzZWQoXCJoaWRkZW5cIiwgITApLmF0dHIoXCJhcmlhLWhpZGRlblwiLCAhMCk7XG4gICAgfSwgdGhpcy5pbml0KCk7XG4gIH1cbiAgYWRkVG9vbHRpcEV2ZW50TGlzdGVuZXIoKSB7XG4gICAgdGhpcy5zZXJ2aWNlcy5ldmVudHMuYWRkRXZlbnRMaXN0ZW5lcihULlRvb2x0aXAuTU9WRSwgKHQpID0+IHtcbiAgICAgIHRoaXMubGFzdFRyaWdnZXJlZEV2ZW50VHlwZSAhPT0gVC5Ub29sYmFyLlNIT1dfVE9PTFRJUCAmJiB0aGlzLnRvb2x0aXAuY2xhc3NlZChcImhpZGRlblwiKSA9PT0gITEgJiYgdGhpcy5wb3NpdGlvblRvb2x0aXAodCk7XG4gICAgfSksIHRoaXMuc2VydmljZXMuZXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIoVC5Ub29sdGlwLlNIT1csIHRoaXMuaGFuZGxlU2hvd1Rvb2x0aXApLCB0aGlzLnNlcnZpY2VzLmV2ZW50cy5hZGRFdmVudExpc3RlbmVyKFQuVG9vbHRpcC5ISURFLCB0aGlzLmhhbmRsZUhpZGVUb29sdGlwKSwgdGhpcy5zZXJ2aWNlcy5ldmVudHMuYWRkRXZlbnRMaXN0ZW5lcihULkNoYXJ0Lk1PVVNFT1VULCB0aGlzLmhhbmRsZUhpZGVUb29sdGlwKSwgdGhpcy5zZXJ2aWNlcy5ldmVudHMuYWRkRXZlbnRMaXN0ZW5lcihULlRvb2xiYXIuU0hPV19UT09MVElQLCB0aGlzLmhhbmRsZVNob3dUb29sdGlwKSwgdGhpcy5zZXJ2aWNlcy5ldmVudHMuYWRkRXZlbnRMaXN0ZW5lcihULlRvb2xiYXIuSElERV9UT09MVElQLCB0aGlzLmhhbmRsZUhpZGVUb29sdGlwKTtcbiAgfVxuICByZW1vdmVUb29sdGlwRXZlbnRMaXN0ZW5lcigpIHtcbiAgICB0aGlzLnNlcnZpY2VzLmV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyKFQuVG9vbHRpcC5NT1ZFLCBudWxsKSwgdGhpcy5zZXJ2aWNlcy5ldmVudHMucmVtb3ZlRXZlbnRMaXN0ZW5lcihULlRvb2x0aXAuU0hPVywgdGhpcy5oYW5kbGVTaG93VG9vbHRpcCksIHRoaXMuc2VydmljZXMuZXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIoVC5Ub29sdGlwLkhJREUsIHRoaXMuaGFuZGxlSGlkZVRvb2x0aXApLCB0aGlzLnNlcnZpY2VzLmV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyKFQuQ2hhcnQuTU9VU0VPVVQsIHRoaXMuaGFuZGxlSGlkZVRvb2x0aXApLCB0aGlzLnNlcnZpY2VzLmV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyKFQuVG9vbGJhci5TSE9XX1RPT0xUSVAsIHRoaXMuaGFuZGxlU2hvd1Rvb2x0aXApLCB0aGlzLnNlcnZpY2VzLmV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyKFQuVG9vbGJhci5ISURFX1RPT0xUSVAsIHRoaXMuaGFuZGxlSGlkZVRvb2x0aXApO1xuICB9XG4gIGdldEl0ZW1zKHQpIHtcbiAgICByZXR1cm4gdC5kZXRhaWwuaXRlbXMgPyB0LmRldGFpbC5pdGVtcyA6IFtdO1xuICB9XG4gIGZvcm1hdEl0ZW1zKHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRPcHRpb25zKCksIHIgPSB5KG4sIFwidG9vbHRpcFwiLCBcInRydW5jYXRpb25cIiwgXCJ0eXBlXCIpLCBpID0geShuLCBcInRvb2x0aXBcIiwgXCJ0cnVuY2F0aW9uXCIsIFwidGhyZXNob2xkXCIpLCBzID0geShuLCBcInRvb2x0aXBcIiwgXCJ0cnVuY2F0aW9uXCIsIFwibnVtQ2hhcmFjdGVyXCIpO1xuICAgIHJldHVybiByICE9PSBWZS5OT05FID8gdC5tYXAoKGEpID0+IHtcbiAgICAgIGNvbnN0IG8gPSBhLmxhYmVsSWNvbiA/IDEyIDogMDtcbiAgICAgIHJldHVybiBhLnZhbHVlID0gdGhpcy52YWx1ZUZvcm1hdHRlcihhLnZhbHVlLCBhLmxhYmVsKSwgYS5sYWJlbCAmJiBhLmxhYmVsLmxlbmd0aCArIG8gPiBpICYmIChhLmxhYmVsID0gZXMoYS5sYWJlbCwgciwgcykpLCBhLnZhbHVlICYmIGEudmFsdWUubGVuZ3RoID4gaSAmJiAoYS52YWx1ZSA9IGVzKGEudmFsdWUsIHIsIHMpKSwgYTtcbiAgICB9KSA6IHQubWFwKChhKSA9PiAoYS52YWx1ZSA9IHRoaXMudmFsdWVGb3JtYXR0ZXIoYS52YWx1ZSwgYS5sYWJlbCksIGEpKTtcbiAgfVxuICBnZXRUb29sdGlwSFRNTCh0KSB7XG4gICAgcmV0dXJuICc8dWwgY2xhc3M9XCJtdWx0aS10b29sdGlwXCI+JyArIHQubWFwKFxuICAgICAgKG4pID0+IGA8bGk+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImRhdGFwb2ludC10b29sdGlwJHtuLmJvbGQgPyBcIiBib2xkXCIgOiBcIlwifVwiPlxuXHRcdFx0XHRcdFx0JHtuLmNsYXNzIHx8IG4uY29sb3IgPyBgPGRpdiBjbGFzcz1cInRvb2x0aXAtY29sb3IgJHtuLmNsYXNzfVwiPjwvZGl2PmAgOiBcIlwifVxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImxhYmVsXCI+XG5cdFx0XHRcdFx0XHQ8cD4ke24ubGFiZWwgfHwgXCJcIn08L3A+XG5cdFx0XHRcdFx0XHQke24ubGFiZWxJY29uID8gYDxzcGFuIGNsYXNzPVwibGFiZWwtaWNvblwiLz4ke24ubGFiZWxJY29ufTwvc3Bhbj5gIDogXCJcIn1cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0JHtuLnZhbHVlID09PSB2b2lkIDAgfHwgbi52YWx1ZSA9PT0gbnVsbCA/IFwiXCIgOiBgPHAgY2xhc3M9XCJ2YWx1ZVwiLz4ke24udmFsdWV9PC9wPmB9XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvbGk+YFxuICAgICkuam9pbihcIlwiKSArIFwiPC91bD5cIjtcbiAgfVxuICBpc0RhdGUodCkge1xuICAgIHJldHVybiB0IGluc3RhbmNlb2YgRGF0ZTtcbiAgfVxuICB2YWx1ZUZvcm1hdHRlcih0LCBuKSB7XG4gICAgY29uc3QgciA9IHRoaXMuZ2V0T3B0aW9ucygpLCBpID0geShyLCBcInRvb2x0aXBcIiwgXCJ2YWx1ZUZvcm1hdHRlclwiKSwge1xuICAgICAgY29kZTogcyxcbiAgICAgIG51bWJlcjogYSxcbiAgICAgIGRhdGU6IG9cbiAgICB9ID0geShyLCBcImxvY2FsZVwiKTtcbiAgICBpZiAoaSlcbiAgICAgIHJldHVybiBpKHQsIG4pO1xuICAgIGlmICh0aGlzLmlzRGF0ZSh0KSlcbiAgICAgIHJldHVybiBvKHQsIHMsIHsgbW9udGg6IFwic2hvcnRcIiwgZGF5OiBcIm51bWVyaWNcIiwgeWVhcjogXCJudW1lcmljXCIgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiICYmIC9cXGR7NH0tXFxkezJ9LVxcZHsyfVRcXGR7Mn06XFxkezJ9OlxcZHsyfS5cXGR7M31aLy50ZXN0KHQpKSB7XG4gICAgICAgIGNvbnN0IGwgPSBuZXcgRGF0ZSh0KTtcbiAgICAgICAgcmV0dXJuIG8obCwgcywge1xuICAgICAgICAgIG1vbnRoOiBcInNob3J0XCIsXG4gICAgICAgICAgZGF5OiBcIm51bWVyaWNcIixcbiAgICAgICAgICB5ZWFyOiBcIm51bWVyaWNcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgcmV0dXJuIGEodCwgcyk7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcmVuZGVyKHQgPSAhMSkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldE9wdGlvbnMoKSwgciA9IHkobiwgXCJ0b29sdGlwXCIsIFwiZW5hYmxlZFwiKTtcbiAgICBpZiAocikge1xuICAgICAgY29uc3QgaSA9IEkodGhpcy5zZXJ2aWNlcy5kb21VdGlscy5nZXRIb2xkZXIoKSksIHMgPSB5KG4sIFwic3R5bGVcIiwgXCJwcmVmaXhcIik7XG4gICAgICB0aGlzLnRvb2x0aXAgPSBOLmFwcGVuZE9yU2VsZWN0KGksIGBkaXYuJHt1ZX0tLSR7c30tLXRvb2x0aXBgKSwgdGhpcy50b29sdGlwLnN0eWxlKFwibWF4LXdpZHRoXCIsIG51bGwpLmF0dHIoXCJyb2xlXCIsIFwidG9vbHRpcFwiKSwgdGhpcy5pc0V2ZW50TGlzdGVuZXJBZGRlZCB8fCAodGhpcy5hZGRUb29sdGlwRXZlbnRMaXN0ZW5lcigpLCB0aGlzLmlzRXZlbnRMaXN0ZW5lckFkZGVkID0gITApLCB0aGlzLnRvb2x0aXAuY2xhc3NlZChcImhpZGRlblwiLCAhMCk7XG4gICAgfSBlbHNlICFyICYmIHRoaXMuaXNFdmVudExpc3RlbmVyQWRkZWQgJiYgKHRoaXMucmVtb3ZlVG9vbHRpcEV2ZW50TGlzdGVuZXIoKSwgdGhpcy5pc0V2ZW50TGlzdGVuZXJBZGRlZCA9ICExKTtcbiAgfVxuICBhZGRPZmZzZXRCeVBsYWNlbWVudCh0LCBuLCByKSB7XG4gICAgY29uc3QgaSA9IE9iamVjdC5hc3NpZ24oe30sIHQpO1xuICAgIHJldHVybiBuID09IFZ0LkxFRlQgPyBpLmxlZnQgLT0gciA6IG4gPT0gVnQuUklHSFQgPyBpLmxlZnQgKz0gciA6IG4gPT0gVnQuVE9QID8gaS50b3AgLT0gciA6IG4gPT0gVnQuQk9UVE9NICYmIChpLnRvcCArPSByKSwgaTtcbiAgfVxuICBwb3NpdGlvblRvb2x0aXAodCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLnNlcnZpY2VzLmRvbVV0aWxzLmdldEhvbGRlcigpLCByID0gbi5vZmZzZXRXaWR0aCwgaSA9IG4ub2Zmc2V0SGVpZ2h0LCBzID0gdGhpcy50b29sdGlwLm5vZGUoKSwgYSA9IHRoaXMuZ2V0T3B0aW9ucygpLCBvID0geShhLCBcInpvb21CYXJcIiwgXCJ0b3BcIiwgXCJlbmFibGVkXCIpLCBsID0gISF5KHQsIFwiZGV0YWlsXCIsIFwibm9XcmFwXCIpLCBjID0gQXJyYXkuaXNBcnJheSh5KHQsIFwiZGV0YWlsXCIsIFwicGxhY2VtZW50c1wiKSksIHUgPSBjID8geSh0LCBcImRldGFpbFwiLCBcInBsYWNlbWVudHNcIikgOiBbVnQuUklHSFQsIFZ0LkxFRlQsIFZ0LlRPUCwgVnQuQk9UVE9NXTtcbiAgICBsZXQgZCwgeyBob3Jpem9udGFsT2Zmc2V0OiBoIH0gPSBJaDtcbiAgICBjb25zdCB7IGRlZmF1bHRPZmZzZXQ6IHAgfSA9IEloO1xuICAgIGlmICh0aGlzLnRvb2x0aXAuc2VsZWN0KFwiZGl2LnRpdGxlLXRvb2x0aXBcIikuY2xhc3NlZChcInRpdGxlLXRvb2x0aXAtbm93cmFwXCIsIGwpLCBjKSB7XG4gICAgICBjb25zdCBtID0geSh0LCBcImRldGFpbFwiLCBcImV2ZW50XCIsIFwidGFyZ2V0XCIpLCB2ID0gdGhpcy5zZXJ2aWNlcy5kb21VdGlscy5nZXRFbGVtZW50T2Zmc2V0KG0sICEwKTtcbiAgICAgIGQgPSB0aGlzLnBvc2l0aW9uU2VydmljZS5maW5kQmVzdFBsYWNlbWVudEF0KFxuICAgICAgICB2LFxuICAgICAgICBzLFxuICAgICAgICB1LFxuICAgICAgICAoKSA9PiAoe1xuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHdpZHRoOiByLFxuICAgICAgICAgIGhlaWdodDogaVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGxldCB4ID0gdGhpcy5wb3NpdGlvblNlcnZpY2UuZmluZFBvc2l0aW9uKFxuICAgICAgICBtLFxuICAgICAgICBzLFxuICAgICAgICBkLFxuICAgICAgICAoKSA9PiB0aGlzLnNlcnZpY2VzLmRvbVV0aWxzLmdldEVsZW1lbnRPZmZzZXQobSlcbiAgICAgICk7XG4gICAgICB4ID0gdGhpcy5hZGRPZmZzZXRCeVBsYWNlbWVudCh4LCBkLCBwKSwgdGhpcy5wb3NpdGlvblNlcnZpY2Uuc2V0RWxlbWVudChzLCB4KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGYgPSB5KHQsIFwiZGV0YWlsXCIsIFwibW91c2VQb3NpdGlvblwiKTtcbiAgICBpZiAoIWYpXG4gICAgICBmID0gcnIoeSh0LCBcImRldGFpbFwiLCBcImV2ZW50XCIpLCBuKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IG0gPSB5KGEsIFwiem9vbUJhclwiLCBcInRvcFwiLCBcInR5cGVcIiksIHYgPSB5ZS5oZWlnaHRbbV07XG4gICAgICBvICYmIChmWzFdICs9IHYgKyB5ZS5zcGFjZXJIZWlnaHQpO1xuICAgIH1cbiAgICBmWzBdIC8gciA+IDAuOSA/IGQgPSBWdC5MRUZUIDogZlswXSAvIHIgPCAwLjEgPyBkID0gVnQuUklHSFQgOiBkID0gdGhpcy5wb3NpdGlvblNlcnZpY2UuZmluZEJlc3RQbGFjZW1lbnRBdChcbiAgICAgIHtcbiAgICAgICAgbGVmdDogZlswXSxcbiAgICAgICAgdG9wOiBmWzFdXG4gICAgICB9LFxuICAgICAgcyxcbiAgICAgIHUsXG4gICAgICAoKSA9PiAoe1xuICAgICAgICB0b3A6IHZvaWQgMCxcbiAgICAgICAgLy8gcHJvcGVydGllcyB3ZXJlIG5ldmVyIHNldCB0byBvcHRpb25hbCAocHJvYmFibHkgc2hvdWxkKVxuICAgICAgICBsZWZ0OiB2b2lkIDAsXG4gICAgICAgIC8vIGRpdHRvXG4gICAgICAgIHdpZHRoOiByLFxuICAgICAgICBoZWlnaHQ6IGlcbiAgICAgIH0pXG4gICAgKSwgZCA9PT0gVnQuTEVGVCAmJiAoaCAqPSAtMSk7XG4gICAgY29uc3QgZyA9IHRoaXMucG9zaXRpb25TZXJ2aWNlLmZpbmRQb3NpdGlvbkF0KFxuICAgICAge1xuICAgICAgICBsZWZ0OiBmWzBdICsgaCxcbiAgICAgICAgdG9wOiBmWzFdXG4gICAgICB9LFxuICAgICAgcyxcbiAgICAgIGRcbiAgICApO1xuICAgIHRoaXMucG9zaXRpb25TZXJ2aWNlLnNldEVsZW1lbnQocywgZyk7XG4gIH1cbn1cbmNvbnN0IHl2ID0gY2xhc3MgaWEgZXh0ZW5kcyBtdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IFwiZ3JpZC1icnVzaFwiLCB0aGlzLnJlbmRlclR5cGUgPSBydC5TVkcsIHRoaXMuc2VsZWN0aW9uU2VsZWN0b3IgPSBcInJlY3Quc2VsZWN0aW9uXCIsIHRoaXMuZnJvbnRTZWxlY3Rpb25TZWxlY3RvciA9IFwicmVjdC5mcm9udFNlbGVjdGlvblwiO1xuICB9XG4gIC8vIG5lZWRzIHRvIG1hdGNoIHRoZSBjbGFzcyBuYW1lIGluIF9ncmlkLWJydXNoLnNjc3NcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcmVuZGVyKHQgPSAhMCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLnBhcmVudCwgciA9IHRoaXMuZ2V0Q29tcG9uZW50Q29udGFpbmVyKHtcbiAgICAgIGlzUHJlc2VudGF0aW9uYWw6ICEwXG4gICAgfSk7XG4gICAgaWYgKCFuKSB0aHJvdyBuZXcgRXJyb3IoXCJTVkcgd2FzIG5vdCBkZWZpbmVkXCIpO1xuICAgIGNvbnN0IGkgPSBOLmFwcGVuZE9yU2VsZWN0KFxuICAgICAgbixcbiAgICAgIFwic3ZnLmNoYXJ0LWdyaWQtYmFja2Ryb3BcIlxuICAgICksIHMgPSBOLmFwcGVuZE9yU2VsZWN0KGksIGBnLiR7dGhpcy50eXBlfWApLCBhID0gTi5hcHBlbmRPclNlbGVjdChzLCB0aGlzLnNlbGVjdGlvblNlbGVjdG9yKSwgeyB3aWR0aDogbywgaGVpZ2h0OiBsIH0gPSBOLmdldFNWR0VsZW1lbnRTaXplKGksIHtcbiAgICAgIHVzZUF0dHJzOiAhMFxuICAgIH0pLCB7IGNhcnRlc2lhblNjYWxlczogYyB9ID0gdGhpcy5zZXJ2aWNlcywgdSA9IGMuZ2V0TWFpblhTY2FsZVR5cGUoKSwgZCA9IGMuZ2V0TWFpblhTY2FsZSgpLCBbaF0gPSBkLnJhbmdlKCk7XG4gICAgci5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHtofSwwKWApO1xuICAgIGNvbnN0IHAgPSBOLmFwcGVuZE9yU2VsZWN0KHIsIHRoaXMuZnJvbnRTZWxlY3Rpb25TZWxlY3Rvcik7XG4gICAgaWYgKGQgJiYgdSA9PT0gZXQuVElNRSkge1xuICAgICAgbGV0IGYgPSB0aGlzLm1vZGVsLmdldChcInpvb21Eb21haW5cIik7XG4gICAgICBmID09PSB2b2lkIDAgJiYgKGYgPSB0aGlzLnNlcnZpY2VzLnpvb20uZ2V0RGVmYXVsdFpvb21CYXJEb21haW4oKSwgZiAmJiB0aGlzLm1vZGVsLnNldCh7IHpvb21Eb21haW46IGYgfSwgeyBhbmltYXRlOiAhMSB9KSk7XG4gICAgICBjb25zdCBnID0gKGIpID0+IHtcbiAgICAgICAgY29uc3QgUyA9IGJbMV0gLSBiWzBdO1xuICAgICAgICBsZXQgTSA9IFwiMCxcIiArIFMudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgRCA9IE1hdGguZmxvb3IobCAvIGlhLkRBU0hfTEVOR1RIKSwgQSA9IEQgKiBpYS5EQVNIX0xFTkdUSDtcbiAgICAgICAgZm9yIChsZXQgUiA9IDA7IFIgPCBEOyBSKyspXG4gICAgICAgICAgTSArPSBcIixcIiArIGlhLkRBU0hfTEVOR1RIO1xuICAgICAgICBNICs9IFwiLFwiICsgKGwgLSBBKSwgRCAlIDIgPT09IDEgJiYgKE0gKz0gXCIsMFwiKSwgTSArPSBcIixcIiArIFMudG9TdHJpbmcoKSwgTSArPSBcIixcIiArIGwudG9TdHJpbmcoKSwgcC5hdHRyKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBNKTtcbiAgICAgIH0sIG0gPSAoYikgPT4ge1xuICAgICAgICBjb25zdCBTID0gYi5zZWxlY3Rpb247XG4gICAgICAgIFMgPT09IG51bGwgfHwgU1swXSA9PT0gU1sxXSB8fCAocC5hdHRyKFwieFwiLCBwYXJzZUZsb2F0KGEuYXR0cihcInhcIikpICsgcGFyc2VGbG9hdChpLmF0dHIoXCJ4XCIpKSkuYXR0cihcInlcIiwgYS5hdHRyKFwieVwiKSkuYXR0cihcIndpZHRoXCIsIGEuYXR0cihcIndpZHRoXCIpKS5hdHRyKFwiaGVpZ2h0XCIsIGEuYXR0cihcImhlaWdodFwiKSkuc3R5bGUoXCJjdXJzb3JcIiwgXCJwb2ludGVyXCIpLnN0eWxlKFwiZGlzcGxheVwiLCBudWxsKSwgZyhTKSk7XG4gICAgICB9LCB2ID0gKGIsIFMpID0+IHtcbiAgICAgICAgY29uc3QgTSA9IGVnKCkucmFuZ2UoWzAsIG9dKS5kb21haW4oZik7XG4gICAgICAgIGxldCBEID0gW00uaW52ZXJ0KGIpLCBNLmludmVydChTKV07XG4gICAgICAgIERbMF0udmFsdWVPZigpID09PSBEWzFdLnZhbHVlT2YoKSAmJiAoRCA9IHRoaXMuc2VydmljZXMuem9vbS5nZXREZWZhdWx0Wm9vbUJhckRvbWFpbigpKSwgKGZbMF0udmFsdWVPZigpICE9PSBEWzBdLnZhbHVlT2YoKSB8fCBmWzFdLnZhbHVlT2YoKSAhPT0gRFsxXS52YWx1ZU9mKCkpICYmIHRoaXMuc2VydmljZXMuem9vbS5oYW5kbGVEb21haW5DaGFuZ2UoRCk7XG4gICAgICB9O1xuICAgICAgbGV0IHg7XG4gICAgICBjb25zdCBfID0gKGIpID0+IHtcbiAgICAgICAgY29uc3QgUyA9IGIuc2VsZWN0aW9uO1xuICAgICAgICBTICE9PSBudWxsICYmICh2KFNbMF0sIFNbMV0pLCBzLmNhbGwoeC5tb3ZlLCBudWxsKSwgcC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpKTtcbiAgICAgIH07XG4gICAgICBsICE9IDAgJiYgbyAhPSAwICYmICh4ID0ga2coKS5leHRlbnQoW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFtvIC0gMSwgbF1cbiAgICAgIF0pLm9uKFwic3RhcnQgYnJ1c2ggZW5kXCIsIG0pLm9uKFwiZW5kLmJydXNoZWRcIiwgXyksIHMuY2FsbCh4KSk7XG4gICAgICBjb25zdCBFID0gdGhpcy5zZXJ2aWNlcy56b29tLmdldFpvb21SYXRpbygpO1xuICAgICAgaS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgaWYgKGIuc2hpZnRLZXkpIHtcbiAgICAgICAgICBjb25zdCBTID0gdGhpcy5zZXJ2aWNlcy5kb21VdGlscy5nZXRIb2xkZXIoKSwgTSA9IHJyKHMubm9kZSgpLCBTKVswXTtcbiAgICAgICAgICBsZXQgRCA9IE0gLSBvICogRSAvIDI7XG4gICAgICAgICAgRCA8IDAgJiYgKEQgPSAwKTtcbiAgICAgICAgICBsZXQgQSA9IE0gKyBvICogRSAvIDI7XG4gICAgICAgICAgQSA+IG8gJiYgKEEgPSBvKSwgdihELCBBKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xueXYuREFTSF9MRU5HVEggPSA0O1xubGV0IEdrID0geXY7XG5jbGFzcyB6ayBleHRlbmRzIG10IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy50eXBlID0gXCJ6b29tLWJhclwiLCB0aGlzLnJlbmRlclR5cGUgPSBydC5TVkcsIHRoaXMuTUlOX1NFTEVDVElPTl9ESUZGID0gOWUtMTAsIHRoaXMuYnJ1c2hTZWxlY3RvciA9IFwiZy56b29tLWJhci1icnVzaFwiLCB0aGlzLmNsaXBJZCA9IFwiem9vbUJhckNsaXAtXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA5OTk5OTk5OTk5OSksIHRoaXMuYnJ1c2ggPSBrZygpLCB0aGlzLmhpZ2hsaWdodFN0cm9rZVdpZHRoID0gMTtcbiAgfVxuICBpbml0KCkge1xuICAgIHRoaXMuc2VydmljZXMuZXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIoVC5ab29tQmFyLlVQREFURSwgdGhpcy5yZW5kZXIuYmluZCh0aGlzKSk7XG4gICAgY29uc3QgdCA9IHkodGhpcy5nZXRPcHRpb25zKCksIFwiem9vbUJhclwiLCBHLlRPUCwgXCJkYXRhXCIpO1xuICAgIHRoaXMubW9kZWwuc2V0Wm9vbUJhckRhdGEodCk7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcmVuZGVyKHQgPSAhMCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldENvbXBvbmVudENvbnRhaW5lcih7XG4gICAgICBhcmlhTGFiZWw6IFwiem9vbSBiYXJcIlxuICAgIH0pLCByID0gdGhpcy5zZXJ2aWNlcy56b29tLmlzWm9vbUJhckxvYWRpbmcoRy5UT1ApLCBpID0gdGhpcy5zZXJ2aWNlcy56b29tLmlzWm9vbUJhckxvY2tlZChHLlRPUCksIHMgPSB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcInpvb21CYXJcIiwgRy5UT1AsIFwidHlwZVwiKSwgYSA9IHkodGhpcy5nZXRPcHRpb25zKCksIFwiYXhlc1wiLCBHLkJPVFRPTSwgXCJoaWdobGlnaHRzXCIpLCBvID0geWUuaGVpZ2h0W3NdLCB7IHdpZHRoOiBsIH0gPSBOLmdldFNWR0VsZW1lbnRTaXplKHRoaXMucGFyZW50LCB7XG4gICAgICB1c2VBdHRyczogITBcbiAgICB9KTtcbiAgICBpZiAobCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBsZXQgYyA9IDA7XG4gICAgY29uc3QgdSA9IHRoaXMubW9kZWwuZ2V0KFwiYXhlc01hcmdpbnNcIik7XG4gICAgdSAmJiB1LmxlZnQgJiYgKGMgPSB1LmxlZnQpO1xuICAgIGNvbnN0IGQgPSBOLmFwcGVuZE9yU2VsZWN0KG4sIFwic3ZnLnpvb20tY29udGFpbmVyXCIpLmF0dHIoXCJ3aWR0aFwiLCBcIjEwMCVcIikuYXR0cihcImhlaWdodFwiLCBvKS5hdHRyKFwib3BhY2l0eVwiLCAxKTtcbiAgICBpZiAoTi5hcHBlbmRPclNlbGVjdChuLCBcInJlY3Quem9vbS1zcGFjZXJcIikuYXR0cihcInhcIiwgMCkuYXR0cihcInlcIiwgbykuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKS5hdHRyKFwiaGVpZ2h0XCIsIHllLnNwYWNlckhlaWdodCkuYXR0cihcIm9wYWNpdHlcIiwgMSkuYXR0cihcImZpbGxcIiwgXCJub25lXCIpLCBzID09PSBLZS5HUkFQSF9WSUVXID8gTi5hcHBlbmRPclNlbGVjdChkLCBcInJlY3Quem9vbS1iZ1wiKS5hdHRyKFwieFwiLCBjKS5hdHRyKFwieVwiLCAwKS5hdHRyKFwid2lkdGhcIiwgbCAtIGMpLmF0dHIoXCJoZWlnaHRcIiwgXCIxMDAlXCIpLmNsYXNzZWQoXCJ6b29tLWJnLXNrZWxldG9uXCIsIHIpLnN0eWxlKFxuICAgICAgXCJzdHJva2VcIixcbiAgICAgIHIgPyBgdXJsKCMke3RoaXMuc2VydmljZXMuZG9tVXRpbHMuZ2VuZXJhdGVFbGVtZW50SURTdHJpbmcoXCJzaGltbWVyLWxpbmVzXCIpfSlgIDogbnVsbFxuICAgICkgOiBzID09PSBLZS5TTElERVJfVklFVyAmJiBOLmFwcGVuZE9yU2VsZWN0KGQsIFwicmVjdC56b29tLXNsaWRlci1iZ1wiKS5hdHRyKFwieFwiLCBjKS5hdHRyKFwieVwiLCBvIC8gMiAtIDEpLmF0dHIoXCJ3aWR0aFwiLCBsIC0gYykuYXR0cihcImhlaWdodFwiLCAyKS5jbGFzc2VkKFwiem9vbS1zbGlkZXItYmctc2tlbGV0b25cIiwgcikuc3R5bGUoXG4gICAgICBcInN0cm9rZVwiLFxuICAgICAgciA/IGB1cmwoIyR7dGhpcy5zZXJ2aWNlcy5kb21VdGlscy5nZW5lcmF0ZUVsZW1lbnRJRFN0cmluZyhcInNoaW1tZXItbGluZXNcIil9KWAgOiBudWxsXG4gICAgKSwgcikge1xuICAgICAgdGhpcy5yZW5kZXJTa2VsZXRvbihkLCBjLCBsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjYXJ0ZXNpYW5TY2FsZXM6IGggfSA9IHRoaXMuc2VydmljZXMsIHAgPSBoLmdldE1haW5YU2NhbGUoKSwgZiA9IGguZ2V0TWFpbllTY2FsZSgpLCBnID0gaC5nZXRNYWluWFNjYWxlVHlwZSgpO1xuICAgIGlmIChwICYmIGcgPT09IGV0LlRJTUUpIHtcbiAgICAgIGxldCBtID0gdGhpcy5zZXJ2aWNlcy56b29tLmdldFpvb21CYXJEYXRhKCk7XG4gICAgICBpZiAoQmUobSkgfHwgbS5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMueFNjYWxlID0gcC5jb3B5KCksIHRoaXMueVNjYWxlID0gZi5jb3B5KCk7XG4gICAgICBjb25zdCB2ID0gdGhpcy5zZXJ2aWNlcy56b29tLmdldERlZmF1bHRab29tQmFyRG9tYWluKG0pO1xuICAgICAgbSA9IHRoaXMuY29tcGVuc2F0ZURhdGFGb3JEZWZhdWx0RG9tYWluKG0sIHYpO1xuICAgICAgY29uc3QgeCA9IHRoaXMubW9kZWwuZ2V0KFwiaW5pdGlhbFpvb21Eb21haW5cIiksIF8gPSB5KFxuICAgICAgICB0aGlzLmdldE9wdGlvbnMoKSxcbiAgICAgICAgXCJ6b29tQmFyXCIsXG4gICAgICAgIEcuVE9QLFxuICAgICAgICBcImluaXRpYWxab29tRG9tYWluXCJcbiAgICAgICk7XG4gICAgICBfICYmIF9bMF0gJiYgX1sxXSAmJiAoX1swXSA9IG5ldyBEYXRlKF9bMF0pLCBfWzFdID0gbmV3IERhdGUoX1sxXSkpLCBfICYmICEoeCAmJiB4WzBdLnZhbHVlT2YoKSA9PT0gX1swXS52YWx1ZU9mKCkgJiYgeFsxXS52YWx1ZU9mKCkgPT09IF9bMV0udmFsdWVPZigpKSA/IHRoaXMubW9kZWwuc2V0KFxuICAgICAgICB7XG4gICAgICAgICAgLy8gdXNlIGEgbmV3IG9iamVjdCBpbnN0ZWFkIG9mIG5ld0luaXRpYWxab29tRG9tYWluXG4gICAgICAgICAgaW5pdGlhbFpvb21Eb21haW46IGF0KFtdLCBfKSxcbiAgICAgICAgICB6b29tRG9tYWluOiBfID8gYXQoW10sIF8pIDogdlxuICAgICAgICB9LFxuICAgICAgICB7IHNraXBVcGRhdGU6ICEwIH1cbiAgICAgICkgOiBfID09PSBudWxsICYmIHggIT09IG51bGwgJiYgdGhpcy5tb2RlbC5zZXQoXG4gICAgICAgIHtcbiAgICAgICAgICBpbml0aWFsWm9vbURvbWFpbjogbnVsbCxcbiAgICAgICAgICB6b29tRG9tYWluOiBhdChbXSwgdilcbiAgICAgICAgfSxcbiAgICAgICAgeyBza2lwVXBkYXRlOiAhMCB9XG4gICAgICApLCB0aGlzLnhTY2FsZS5yYW5nZShbYywgbF0pLmRvbWFpbih2KSwgdGhpcy5tYXhTZWxlY3Rpb25SYW5nZSA9IHRoaXMueFNjYWxlLnJhbmdlKCksIHRoaXMueVNjYWxlLnJhbmdlKFswLCBvIC0gNl0pLmRvbWFpbih6ZShtLCAoUykgPT4gUy52YWx1ZSkpO1xuICAgICAgY29uc3QgRSA9IHRoaXMubW9kZWwuZ2V0KFwiem9vbURvbWFpblwiKTtcbiAgICAgIGlmIChzID09PSBLZS5HUkFQSF9WSUVXICYmICh0aGlzLnJlbmRlclpvb21CYXJBcmVhKGQsIFwicGF0aC56b29tLWdyYXBoLWFyZWEtdW5zZWxlY3RlZFwiLCBtLCBudWxsKSwgdGhpcy51cGRhdGVDbGlwUGF0aChuLCB0aGlzLmNsaXBJZCwgMCwgMCwgMCwgMCksIHRoaXMucmVuZGVyWm9vbUJhckFyZWEoZCwgXCJwYXRoLnpvb20tZ3JhcGgtYXJlYVwiLCBtLCB0aGlzLmNsaXBJZCksIHRoaXMucmVuZGVyWm9vbUJhckJhc2VsaW5lKGQsIGMsIGwpLCBhKSkge1xuICAgICAgICBjb25zdCBTID0gYS5oaWdobGlnaHRTdGFydE1hcHNUbywgTSA9IGEuaGlnaGxpZ2h0RW5kTWFwc1RvLCBEID0gYS5jb2xvciwgQSA9IGEubGFiZWxNYXBzVG87XG4gICAgICAgIGEuZGF0YS5mb3JFYWNoKChSLCAkKSA9PiB7XG4gICAgICAgICAgTi5hcHBlbmRPclNlbGVjdChkLCBgcmVjdC5oaWdobGlnaHQtJHskfWApLmF0dHIoXCJoZWlnaHRcIiwgbyAtIDIgKiB0aGlzLmhpZ2hsaWdodFN0cm9rZVdpZHRoKS5hdHRyKFwieVwiLCB0aGlzLmhpZ2hsaWdodFN0cm9rZVdpZHRoKS5hdHRyKFwieFwiLCB0aGlzLnhTY2FsZShSW1NdKSkuYXR0cihcbiAgICAgICAgICAgIFwid2lkdGhcIixcbiAgICAgICAgICAgIHRoaXMueFNjYWxlKFJbTV0pIC0gdGhpcy54U2NhbGUoUltTXSlcbiAgICAgICAgICApLnN0eWxlKFxuICAgICAgICAgICAgXCJmaWxsXCIsXG4gICAgICAgICAgICBEICYmIEQuc2NhbGVbUltBXV0gPyBELnNjYWxlW1JbQV1dIDogbnVsbFxuICAgICAgICAgICkuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgMC4xKS5zdHlsZShcbiAgICAgICAgICAgIFwic3Ryb2tlXCIsXG4gICAgICAgICAgICBEICYmIEQuc2NhbGVbUltBXV0gPyBELnNjYWxlW1JbQV1dIDogbnVsbFxuICAgICAgICAgICkuc3R5bGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIFwiMiwgMlwiKS5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIFwiMXB4XCIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkQnJ1c2hFdmVudExpc3RlbmVyKEUsIGMsIGwpO1xuICAgICAgY29uc3QgYiA9IE4uYXBwZW5kT3JTZWxlY3QobiwgdGhpcy5icnVzaFNlbGVjdG9yKS5jYWxsKHRoaXMuYnJ1c2gpO1xuICAgICAgaWYgKEUgIT09IHZvaWQgMCkgaWYgKEVbMF0udmFsdWVPZigpID09PSBFWzFdLnZhbHVlT2YoKSlcbiAgICAgICAgYi5jYWxsKHRoaXMuYnJ1c2gubW92ZSwgdGhpcy54U2NhbGUucmFuZ2UoKSksIHRoaXMudXBkYXRlQnJ1c2hIYW5kbGUodGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoKSwgdGhpcy54U2NhbGUucmFuZ2UoKSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgUyA9IEUubWFwKChNKSA9PiB0aGlzLnhTY2FsZShNKSk7XG4gICAgICAgIFNbMV0gLSBTWzBdIDwgdGhpcy5NSU5fU0VMRUNUSU9OX0RJRkYgfHwgKGIuY2FsbCh0aGlzLmJydXNoLm1vdmUsIFMpLCB0aGlzLnVwZGF0ZUJydXNoSGFuZGxlKHRoaXMuZ2V0Q29tcG9uZW50Q29udGFpbmVyKCksIFMpKTtcbiAgICAgIH1cbiAgICAgIGkgJiYgKHRoaXMuYnJ1c2guZmlsdGVyKCgpID0+ICExKSwgYi5zZWxlY3RBbGwoXCJyZWN0XCIpLmF0dHIoXCJjdXJzb3JcIiwgXCJhdXRvXCIpKTtcbiAgICB9XG4gIH1cbiAgYWRkQnJ1c2hFdmVudExpc3RlbmVyKHQsIG4sIHIpIHtcbiAgICBjb25zdCBpID0gKG8pID0+IHtcbiAgICAgIGNvbnN0IGwgPSBvLnNlbGVjdGlvbjtcbiAgICAgIGwgPT09IG51bGwgPyB0aGlzLmhhbmRsZUJydXNoZWRFdmVudChvLCB0LCB0aGlzLnhTY2FsZSwgdGhpcy54U2NhbGUucmFuZ2UoKSkgOiBsWzBdID09PSBsWzFdIHx8IHRoaXMuaGFuZGxlQnJ1c2hlZEV2ZW50KG8sIHQsIHRoaXMueFNjYWxlLCBsKTtcbiAgICB9LCBzID0geSh0aGlzLmdldE9wdGlvbnMoKSwgXCJ6b29tQmFyXCIsIEcuVE9QLCBcInR5cGVcIiksIGEgPSB5ZS5oZWlnaHRbc107XG4gICAgdGhpcy5icnVzaC5leHRlbnQoW1xuICAgICAgW24sIDBdLFxuICAgICAgW3IsIGFdXG4gICAgXSkub24oXCJzdGFydCBicnVzaCBlbmRcIiwgbnVsbCkub24oXCJzdGFydCBicnVzaCBlbmRcIiwgaSk7XG4gIH1cbiAgLy8gYnJ1c2ggZXZlbnQgbGlzdGVuZXJcbiAgaGFuZGxlQnJ1c2hlZEV2ZW50KHQsIG4sIHIsIGkpIHtcbiAgICBjb25zdCBzID0gW3IuaW52ZXJ0KGlbMF0pLCByLmludmVydChpWzFdKV07XG4gICAgaWYgKHRoaXMudXBkYXRlQnJ1c2hIYW5kbGUodGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoKSwgaSksIHQuc291cmNlRXZlbnQgIT0gbnVsbCAmJiAodC5zb3VyY2VFdmVudC50eXBlID09PSBcIm1vdXNlbW92ZVwiIHx8IHQuc291cmNlRXZlbnQudHlwZSA9PT0gXCJtb3VzZXVwXCIgfHwgdC5zb3VyY2VFdmVudC50eXBlID09PSBcIm1vdXNlZG93blwiIHx8IHQuc291cmNlRXZlbnQudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIgfHwgdC5zb3VyY2VFdmVudC50eXBlID09PSBcInRvdWNobW92ZVwiIHx8IHQuc291cmNlRXZlbnQudHlwZSA9PT0gXCJ0b3VjaGVuZFwiKSkge1xuICAgICAgKG4gPT09IHZvaWQgMCB8fCBuWzBdICE9PSBzWzBdIHx8IG5bMV0gIT09IHNbMV0pICYmIHRoaXMuc2VydmljZXMuem9vbS5oYW5kbGVEb21haW5DaGFuZ2Uocywge1xuICAgICAgICBkaXNwYXRjaEV2ZW50OiAhMVxuICAgICAgfSk7XG4gICAgICBsZXQgYTtcbiAgICAgIHQudHlwZSA9PT0gXCJzdGFydFwiID8gYSA9IFQuWm9vbUJhci5TRUxFQ1RJT05fU1RBUlQgOiB0LnR5cGUgPT09IFwiYnJ1c2hcIiA/IGEgPSBULlpvb21CYXIuU0VMRUNUSU9OX0lOX1BST0dSRVNTIDogdC50eXBlID09PSBcImVuZFwiICYmIChhID0gVC5ab29tQmFyLlNFTEVDVElPTl9FTkQsIHRoaXMuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5ab29tRG9tYWluLkNIQU5HRSwge1xuICAgICAgICBuZXdEb21haW46IHNcbiAgICAgIH0pKSwgdGhpcy5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChhLCB7XG4gICAgICAgIHNlbGVjdGlvbjogaSxcbiAgICAgICAgbmV3RG9tYWluOiBzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlQnJ1c2hIYW5kbGUodCwgbikge1xuICAgIGNvbnN0IHIgPSB0aGlzLCBpID0geWUuaGFuZGxlV2lkdGgsIHMgPSB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcInpvb21CYXJcIiwgRy5UT1AsIFwidHlwZVwiKSwgYSA9IHllLmhlaWdodFtzXSwgbyA9IC1pIC8gMiwgbCA9IHllLmhhbmRsZUJhcldpZHRoLCBjID0gcyA9PT0gS2UuR1JBUEhfVklFVyA/IHllLmhhbmRsZUJhckhlaWdodCA6IDYsIHUgPSAtbCAvIDIsIGQgPSAoYSAtIGMpIC8gMjtcbiAgICB0LnNlbGVjdCh0aGlzLmJydXNoU2VsZWN0b3IpLnNlbGVjdEFsbChcInJlY3QuaGFuZGxlXCIpLmRhdGEoW3sgdHlwZTogXCJ3XCIgfSwgeyB0eXBlOiBcImVcIiB9XSkuYXR0cihcInhcIiwgZnVuY3Rpb24ocCkge1xuICAgICAgaWYgKHAudHlwZSA9PT0gXCJ3XCIpXG4gICAgICAgIHJldHVybiBNYXRoLm1heChuWzBdICsgbywgci5tYXhTZWxlY3Rpb25SYW5nZVswXSk7XG4gICAgICBpZiAocC50eXBlID09PSBcImVcIilcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKG5bMV0gKyBvLCByLm1heFNlbGVjdGlvblJhbmdlWzFdIC0gaSk7XG4gICAgfSkuYXR0cihcInlcIiwgMCkuYXR0cihcIndpZHRoXCIsIGkpLmF0dHIoXCJoZWlnaHRcIiwgYSkuYXR0cihcImN1cnNvclwiLCBcImV3LXJlc2l6ZVwiKS5zdHlsZShcImRpc3BsYXlcIiwgbnVsbCk7XG4gICAgY29uc3QgaCA9IHQuc2VsZWN0KHRoaXMuYnJ1c2hTZWxlY3Rvcikuc2VsZWN0QWxsKFwicmVjdC5oYW5kbGUtYmFyXCIpLmRhdGEoW3sgdHlwZTogXCJ3XCIgfSwgeyB0eXBlOiBcImVcIiB9XSk7XG4gICAgaC5lbnRlcigpLmFwcGVuZChcInJlY3RcIikuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBcImhhbmRsZS1iYXIgaGFuZGxlLWJhci0tXCIgKyBwLnR5cGU7XG4gICAgfSksIGguYXR0cihcInhcIiwgZnVuY3Rpb24ocCkge1xuICAgICAgaWYgKHAudHlwZSA9PT0gXCJ3XCIpXG4gICAgICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgICAgICBuWzBdICsgdSxcbiAgICAgICAgICByLm1heFNlbGVjdGlvblJhbmdlWzBdIC0gbyArIHVcbiAgICAgICAgKTtcbiAgICAgIGlmIChwLnR5cGUgPT09IFwiZVwiKVxuICAgICAgICByZXR1cm4gTWF0aC5taW4oXG4gICAgICAgICAgblsxXSArIHUsXG4gICAgICAgICAgci5tYXhTZWxlY3Rpb25SYW5nZVsxXSArIG8gKyB1XG4gICAgICAgICk7XG4gICAgfSkuYXR0cihcInlcIiwgZCkuYXR0cihcIndpZHRoXCIsIGwpLmF0dHIoXCJoZWlnaHRcIiwgYykuYXR0cihcImN1cnNvclwiLCBcImV3LXJlc2l6ZVwiKSwgcyA9PT0gS2UuU0xJREVSX1ZJRVcgJiYgdGhpcy51cGRhdGVTbGlkZXJTZWxlY3RlZEFyZWEobiksIHRoaXMudXBkYXRlQ2xpcFBhdGgoXG4gICAgICB0LFxuICAgICAgdGhpcy5jbGlwSWQsXG4gICAgICBuWzBdLFxuICAgICAgMCxcbiAgICAgIG5bMV0gLSBuWzBdLFxuICAgICAgYVxuICAgICk7XG4gIH1cbiAgdXBkYXRlU2xpZGVyU2VsZWN0ZWRBcmVhKHQpIHtcbiAgICBjb25zdCBuID0geSh0aGlzLmdldE9wdGlvbnMoKSwgXCJ6b29tQmFyXCIsIEcuVE9QLCBcInR5cGVcIiksIHIgPSB5ZS5oZWlnaHRbbl0sIGkgPSB0aGlzLmdldENvbXBvbmVudENvbnRhaW5lcigpLnNlbGVjdChcInN2Zy56b29tLWNvbnRhaW5lclwiKTtcbiAgICBOLmFwcGVuZE9yU2VsZWN0KGksIFwicmVjdC56b29tLXNsaWRlci1zZWxlY3RlZC1hcmVhXCIpLmF0dHIoXCJ4XCIsIHRbMF0pLmF0dHIoXCJ5XCIsIHIgLyAyIC0gMSkuYXR0cihcIndpZHRoXCIsIHRbMV0gLSB0WzBdKS5hdHRyKFwiaGVpZ2h0XCIsIDIpO1xuICB9XG4gIHJlbmRlclpvb21CYXJBcmVhKHQsIG4sIHIsIGkpIHtcbiAgICBjb25zdCB7IGNhcnRlc2lhblNjYWxlczogcyB9ID0gdGhpcy5zZXJ2aWNlcywgYSA9IHMuZ2V0TWFpblhBeGlzUG9zaXRpb24oKSwgbyA9IHMuZ2V0TWFpbllBeGlzUG9zaXRpb24oKSwgbCA9IHMuZ2V0TWFpblhTY2FsZVR5cGUoKSwgYyA9IHMuZ2V0TWFpbllTY2FsZVR5cGUoKSwgdSA9ICh2LCB4LCBfKSA9PiAoRSkgPT4gcy5nZXRWYWx1ZUZyb21TY2FsZSh2LCB4LCBfLCBFKSwgZCA9IHUodGhpcy54U2NhbGUsIGwsIGEpLCBoID0gdSh0aGlzLnlTY2FsZSwgYywgbyksIHAgPSB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcInpvb21CYXJcIiwgRy5UT1AsIFwidHlwZVwiKSwgZiA9IHllLmhlaWdodFtwXSwgZyA9IGF1KCkueCgodikgPT4gZCh2KSkueTAoZikueTEoKHYpID0+IGYgLSBoKHYpKSwgbSA9IE4uYXBwZW5kT3JTZWxlY3QodCwgbikuZGF0dW0ocikuYXR0cihcImRcIiwgZyk7XG4gICAgaSAmJiBtLmF0dHIoXCJjbGlwLXBhdGhcIiwgYHVybCgjJHtpfSlgKTtcbiAgfVxuICB1cGRhdGVDbGlwUGF0aCh0LCBuLCByLCBpLCBzLCBhKSB7XG4gICAgY29uc3QgbyA9IE4uYXBwZW5kT3JTZWxlY3QodCwgXCJjbGlwUGF0aFwiKS5hdHRyKFwiaWRcIiwgbik7XG4gICAgTi5hcHBlbmRPclNlbGVjdChvLCBcInJlY3RcIikuYXR0cihcInhcIiwgcikuYXR0cihcInlcIiwgaSkuYXR0cihcIndpZHRoXCIsIHMpLmF0dHIoXCJoZWlnaHRcIiwgYSk7XG4gIH1cbiAgLy8gYXNzdW1lIHRoZSBkb21haW5zIGluIGRhdGEgYXJlIGFscmVhZHkgc29ydGVkXG4gIGNvbXBlbnNhdGVEYXRhRm9yRGVmYXVsdERvbWFpbih0LCBuKSB7XG4gICAgaWYgKCF0IHx8IHQubGVuZ3RoIDwgMilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByID0gU24odCksIGkgPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXREb21haW5JZGVudGlmaWVyKCksIHMgPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRSYW5nZUlkZW50aWZpZXIoKTtcbiAgICBpZiAoTnVtYmVyKG5bMF0pIDwgTnVtYmVyKHJbMF1baV0pKSB7XG4gICAgICBjb25zdCBhID0ge307XG4gICAgICBhW2ldID0gblswXSwgYVtzXSA9IDAsIHIudW5zaGlmdChhKTtcbiAgICB9XG4gICAgaWYgKE51bWJlcihuWzFdKSA+IE51bWJlcihyW3IubGVuZ3RoIC0gMV1baV0pKSB7XG4gICAgICBjb25zdCBhID0ge307XG4gICAgICBhW2ldID0gblsxXSwgYVtzXSA9IDAsIHIucHVzaChhKTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgcmVuZGVyWm9vbUJhckJhc2VsaW5lKHQsIG4sIHIsIGkgPSAhMSkge1xuICAgIGNvbnN0IHMgPSB5KFxuICAgICAgdGhpcy5tb2RlbC5nZXRPcHRpb25zKCksXG4gICAgICBcInpvb21CYXJcIixcbiAgICAgIEcuVE9QLFxuICAgICAgXCJ0eXBlXCJcbiAgICApLCBhID0geWUuaGVpZ2h0W3NdLCBvID0geHMoKShbXG4gICAgICBbbiwgYV0sXG4gICAgICBbciwgYV1cbiAgICBdKTtcbiAgICBOLmFwcGVuZE9yU2VsZWN0KHQsIFwicGF0aC56b29tLWJnLWJhc2VsaW5lXCIpLmF0dHIoXCJkXCIsIG8pLmNsYXNzZWQoXCJ6b29tLWJnLWJhc2VsaW5lLXNrZWxldG9uXCIsIGkpLnN0eWxlKFxuICAgICAgXCJzdHJva2VcIixcbiAgICAgIGkgPyBgdXJsKCMke3RoaXMuc2VydmljZXMuZG9tVXRpbHMuZ2VuZXJhdGVFbGVtZW50SURTdHJpbmcoXCJzaGltbWVyLWxpbmVzXCIpfSlgIDogbnVsbFxuICAgICk7XG4gIH1cbiAgcmVuZGVyU2tlbGV0b24odCwgbiwgcikge1xuICAgIHRoaXMucmVuZGVyWm9vbUJhckFyZWEodCwgXCJwYXRoLnpvb20tZ3JhcGgtYXJlYS11bnNlbGVjdGVkXCIsIFtdLCBudWxsKSwgdGhpcy5yZW5kZXJab29tQmFyQXJlYSh0LCBcInBhdGguem9vbS1ncmFwaC1hcmVhXCIsIFtdLCB0aGlzLmNsaXBJZCksIHRoaXMuYnJ1c2gub24oXCJzdGFydCBicnVzaCBlbmRcIiwgbnVsbCksIE4uYXBwZW5kT3JTZWxlY3QodGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoKSwgdGhpcy5icnVzaFNlbGVjdG9yKS5odG1sKG51bGwpLCB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcInpvb21CYXJcIiwgRy5UT1AsIFwidHlwZVwiKSA9PT0gS2UuR1JBUEhfVklFVyAmJiB0aGlzLnJlbmRlclpvb21CYXJCYXNlbGluZSh0LCBuLCByLCAhMCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmJydXNoLm9uKFwic3RhcnQgYnJ1c2ggZW5kXCIsIG51bGwpLCB0aGlzLnNlcnZpY2VzLmV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyKFQuWm9vbUJhci5VUERBVEUsIHRoaXMucmVuZGVyLmJpbmQodGhpcykpO1xuICB9XG59XG5jbGFzcyBGayBleHRlbmRzIG10IHtcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHN1cGVyKHQsIG4pLCB0aGlzLnR5cGUgPSBcInRocmVzaG9sZFwiLCB0aGlzLnJlbmRlclR5cGUgPSBydC5TVkcsIHRoaXMucG9zaXRpb25TZXJ2aWNlID0gbmV3IG1vKCk7XG4gIH1cbiAgcmVuZGVyKHQgPSAhMSkge1xuICAgIGNvbnN0IG4gPSB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcImF4ZXNcIiksIHIgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhuKS5mb3JFYWNoKChjKSA9PiB7XG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhHKS5pbmNsdWRlcyhjKSkge1xuICAgICAgICBjb25zdCB1ID0gbltjXTtcbiAgICAgICAgdS50aHJlc2hvbGRzICYmIHUudGhyZXNob2xkcy5sZW5ndGggPiAwICYmIHIucHVzaCh7XG4gICAgICAgICAgYXhpc1Bvc2l0aW9uOiBjLFxuICAgICAgICAgIHRocmVzaG9sZHM6IHUudGhyZXNob2xkcyxcbiAgICAgICAgICBjb3JyZXNwb25kaW5nRGF0YXNldHM6IHUgPT0gbnVsbCA/IHZvaWQgMCA6IHUuY29ycmVzcG9uZGluZ0RhdGFzZXRzLFxuICAgICAgICAgIG1hcHNUbzogdSA9PSBudWxsID8gdm9pZCAwIDogdS5tYXBzVG9cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0Q29tcG9uZW50Q29udGFpbmVyKHtcbiAgICAgIGFyaWFMYWJlbDogXCJ0aHJlc2hvbGQgbGluZXNcIixcbiAgICAgIHdpdGhpbkNoYXJ0Q2xpcDogITBcbiAgICB9KS5zZWxlY3RBbGwoXCJnLmF4aXMtdGhyZXNob2xkc1wiKS5kYXRhKHIsIChjKSA9PiBjLmF4aXNQb3NpdGlvbik7XG4gICAgaS5leGl0KCkuYXR0cihcIm9wYWNpdHlcIiwgMCkucmVtb3ZlKCk7XG4gICAgY29uc3QgcyA9IGkuZW50ZXIoKS5hcHBlbmQoXCJnXCIpLm1lcmdlKGkpO1xuICAgIHMuYXR0cihcImNsYXNzXCIsIChjKSA9PiBgYXhpcy10aHJlc2hvbGRzICR7Yy5heGlzUG9zaXRpb259YCk7XG4gICAgY29uc3QgYSA9IHMuc2VsZWN0QWxsKFwiZy50aHJlc2hvbGQtZ3JvdXBcIikuZGF0YShcbiAgICAgIChjKSA9PiBjLnRocmVzaG9sZHMubWFwKCh1KSA9PiAodS5heGlzUG9zaXRpb24gPSBjLmF4aXNQb3NpdGlvbiwgdS5kYXR1bSA9IHRoaXMuY29uc3RydWN0RGF0dW1PYmooYywgdSksIHUpKVxuICAgICk7XG4gICAgYS5leGl0KCkuYXR0cihcIm9wYWNpdHlcIiwgMCkucmVtb3ZlKCk7XG4gICAgY29uc3QgbyA9IGEuZW50ZXIoKS5hcHBlbmQoXCJnXCIpO1xuICAgIG8uYXBwZW5kKFwibGluZVwiKS5hdHRyKFwiY2xhc3NcIiwgXCJ0aHJlc2hvbGQtbGluZVwiKSwgby5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJjbGFzc1wiLCBcInRocmVzaG9sZC1ob3ZlcmFibGUtYXJlYVwiKSwgby5tZXJnZShhKS5hdHRyKFwiY2xhc3NcIiwgXCJ0aHJlc2hvbGQtZ3JvdXBcIik7XG4gICAgY29uc3QgbCA9IHRoaXM7XG4gICAgcy5lYWNoKGZ1bmN0aW9uKHsgYXhpc1Bvc2l0aW9uOiBjIH0pIHtcbiAgICAgIGNvbnN0IHUgPSBsLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRTY2FsZUJ5UG9zaXRpb24oXG4gICAgICAgIGNcbiAgICAgICksIGQgPSBsLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRTY2FsZVR5cGVCeVBvc2l0aW9uKGMpO1xuICAgICAgbGV0IGggPSBudWxsLCBwID0gbnVsbDtcbiAgICAgIGMgPT09IEcuTEVGVCB8fCBjID09PSBHLlJJR0hUID8gKHAgPSB1LCBoID0gbC5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0TWFpblhTY2FsZSgpKSA6IChoID0gdSwgcCA9IGwuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldE1haW5ZU2NhbGUoKSk7XG4gICAgICBjb25zdCBmID0gZCA9PT0gZXQuTEFCRUxTLCBbZywgbV0gPSBoLnJhbmdlKCksIFt2LCB4XSA9IHAucmFuZ2UoKSwgeyBjYXJ0ZXNpYW5TY2FsZXM6IF8gfSA9IGwuc2VydmljZXMsIEUgPSBfLmdldE9yaWVudGF0aW9uKCksIGIgPSAoUikgPT4gXy5nZXREb21haW5WYWx1ZShSKSwgUyA9IChSKSA9PiBfLmdldFJhbmdlVmFsdWUoUiksIFtNLCBEXSA9IEVuKFxuICAgICAgICBiLFxuICAgICAgICBTLFxuICAgICAgICBFXG4gICAgICApLCBBID0gSSh0aGlzKTtcbiAgICAgIGMgPT09IEcuVE9QIHx8IGMgPT09IEcuQk9UVE9NID8gKEEuc2VsZWN0QWxsKFwibGluZS50aHJlc2hvbGQtbGluZVwiKS50cmFuc2l0aW9uKCkuY2FsbChcbiAgICAgICAgKFIpID0+IGwuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICB0cmFuc2l0aW9uOiBSLFxuICAgICAgICAgIG5hbWU6IFwidGhyZXNob2xkLWxpbmUtdXBkYXRlXCIsXG4gICAgICAgICAgYW5pbWF0ZTogdFxuICAgICAgICB9KVxuICAgICAgKS5hdHRyKFwieTFcIiwgeCkuYXR0cihcInkyXCIsIHYpLmF0dHIoXG4gICAgICAgIFwieDFcIixcbiAgICAgICAgKHsgZGF0dW06IFIgfSkgPT4gTShSKSArIChmID8gdS5zdGVwKCkgLyAyIDogMClcbiAgICAgICkuYXR0cihcbiAgICAgICAgXCJ4MlwiLFxuICAgICAgICAoeyBkYXR1bTogUiB9KSA9PiBNKFIpICsgKGYgPyB1LnN0ZXAoKSAvIDIgOiAwKVxuICAgICAgKS5zdHlsZShcInN0cm9rZVwiLCAoeyBmaWxsQ29sb3I6IFIgfSkgPT4gUiksIEEuc2VsZWN0QWxsKFwicmVjdC50aHJlc2hvbGQtaG92ZXJhYmxlLWFyZWFcIikuYXR0cihcInhcIiwgMCkuYXR0cihcInlcIiwgKHsgZGF0dW06IFIgfSkgPT4gLU0oUikpLmF0dHIoXCJ3aWR0aFwiLCBNYXRoLmFicyh2IC0geCkpLmNsYXNzZWQoXCJyb3RhdGVcIiwgITApKSA6IChBLnNlbGVjdEFsbChcImxpbmUudGhyZXNob2xkLWxpbmVcIikudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAgIChSKSA9PiBsLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgdHJhbnNpdGlvbjogUixcbiAgICAgICAgICBuYW1lOiBcInRocmVzaG9sZC1saW5lLXVwZGF0ZVwiLFxuICAgICAgICAgIGFuaW1hdGU6IHRcbiAgICAgICAgfSlcbiAgICAgICkuYXR0cihcIngxXCIsIGcpLmF0dHIoXCJ4MlwiLCBtKS5hdHRyKFxuICAgICAgICBcInkxXCIsXG4gICAgICAgICh7IGRhdHVtOiBSIH0pID0+IEQoUikgKyAoZiA/IHUuc3RlcCgpIC8gMiA6IDApXG4gICAgICApLmF0dHIoXG4gICAgICAgIFwieTJcIixcbiAgICAgICAgKHsgZGF0dW06IFIgfSkgPT4gRChSKSArIChmID8gdS5zdGVwKCkgLyAyIDogMClcbiAgICAgICkuc3R5bGUoXCJzdHJva2VcIiwgKHsgZmlsbENvbG9yOiBSIH0pID0+IFIpLCBBLnNlbGVjdEFsbChcInJlY3QudGhyZXNob2xkLWhvdmVyYWJsZS1hcmVhXCIpLmF0dHIoXCJ4XCIsIGcpLmF0dHIoXCJ5XCIsICh7IGRhdHVtOiBSIH0pID0+IEQoUikpLmF0dHIoXCJ3aWR0aFwiLCBNYXRoLmFicyhtIC0gZykpLmNsYXNzZWQoXCJyb3RhdGVcIiwgITEpKTtcbiAgICB9KSwgdGhpcy5zZXJ2aWNlcy5ldmVudHMuYWRkRXZlbnRMaXN0ZW5lcihULlRocmVzaG9sZC5TSE9XLCAoYykgPT4ge1xuICAgICAgdGhpcy5zZXRUaHJlc2hvbGRMYWJlbFBvc2l0aW9uKGMuZGV0YWlsKSwgdGhpcy5sYWJlbC5jbGFzc2VkKFwiaGlkZGVuXCIsICExKTtcbiAgICB9KSwgdGhpcy5zZXJ2aWNlcy5ldmVudHMuYWRkRXZlbnRMaXN0ZW5lcihULlRocmVzaG9sZC5ISURFLCAoKSA9PiB7XG4gICAgICB0aGlzLmxhYmVsLmNsYXNzZWQoXCJoaWRkZW5cIiwgITApO1xuICAgIH0pLCB0aGlzLmFwcGVuZFRocmVzaG9sZExhYmVsKCksIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICBnZXRGb3JtYXR0ZWRWYWx1ZSh0KSB7XG4gICAgY29uc3QgeyB2YWx1ZTogbiwgYXhpc1Bvc2l0aW9uOiByIH0gPSB0LCBpID0gdGhpcy5nZXRPcHRpb25zKCksIHMgPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRTY2FsZVR5cGVCeVBvc2l0aW9uKHIpLCB7IGNvZGU6IGEsIG51bWJlcjogbyB9ID0geShpLCBcImxvY2FsZVwiKTtcbiAgICBpZiAocyA9PT0gZXQuVElNRSkge1xuICAgICAgY29uc3QgbCA9IFtHLkxFRlQsIEcuUklHSFRdLmluY2x1ZGVzKHIpLCBjID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0TWFpblhTY2FsZSgpLCB1ID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0TWFpbllTY2FsZSgpLCBkID0gbCA/IHUgOiBjLCBoID0geShpLCBcInRpbWVTY2FsZVwiKSwgcCA9IERsKFxuICAgICAgICBkLnRpY2tzKCksXG4gICAgICAgIHkoaCwgXCJ0aW1lSW50ZXJ2YWxcIilcbiAgICAgICk7XG4gICAgICByZXR1cm4ga2wobiwgMCwgZC50aWNrcygpLCBwLCBoLCBpLmxvY2FsZSk7XG4gICAgfVxuICAgIHJldHVybiBvKG4sIGEpO1xuICB9XG4gIGFwcGVuZFRocmVzaG9sZExhYmVsKCkge1xuICAgIGNvbnN0IHQgPSBJKHRoaXMuc2VydmljZXMuZG9tVXRpbHMuZ2V0SG9sZGVyKCkpLCBuID0geSh0aGlzLmdldE9wdGlvbnMoKSwgXCJzdHlsZVwiLCBcInByZWZpeFwiKTtcbiAgICB0aGlzLmxhYmVsID0gTi5hcHBlbmRPclNlbGVjdChcbiAgICAgIHQsXG4gICAgICBgZGl2LiR7dWV9LS0ke259LS10aHJlc2hvbGQtLWxhYmVsYFxuICAgICkuY2xhc3NlZChcImhpZGRlblwiLCAhMCk7XG4gIH1cbiAgc2V0VGhyZXNob2xkTGFiZWxQb3NpdGlvbih7IGV2ZW50OiB0LCBkYXR1bTogbiB9KSB7XG4gICAgY29uc3QgciA9IHRoaXMuc2VydmljZXMuZG9tVXRpbHMuZ2V0SG9sZGVyKCksIGkgPSBycih0LCByKSwgcyA9IG4udmFsdWVGb3JtYXR0ZXIgPyBuLnZhbHVlRm9ybWF0dGVyKG4udmFsdWUpIDogdGhpcy5nZXRGb3JtYXR0ZWRWYWx1ZShuKTtcbiAgICB0aGlzLmxhYmVsLmh0bWwoZW4oYCR7bi5sYWJlbCB8fCBcIlRocmVzaG9sZFwifTogJHtzfWApKS5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgbi5maWxsQ29sb3IpO1xuICAgIGNvbnN0IGEgPSB0aGlzLmxhYmVsLm5vZGUoKSwgbyA9IHRoaXMucG9zaXRpb25TZXJ2aWNlLmZpbmRCZXN0UGxhY2VtZW50QXQoXG4gICAgICB7XG4gICAgICAgIGxlZnQ6IGlbMF0sXG4gICAgICAgIHRvcDogaVsxXVxuICAgICAgfSxcbiAgICAgIGEsXG4gICAgICBbVnQuUklHSFQsIFZ0LkxFRlQsIFZ0LlRPUCwgVnQuQk9UVE9NXSxcbiAgICAgICgpID0+ICh7XG4gICAgICAgIHRvcDogdm9pZCAwLFxuICAgICAgICAvLyBvdGhlciBwYWNrYWdlIGxpc3RzIHRoaXMgYXMgbm9uLW9wdGlvbmFsXG4gICAgICAgIGxlZnQ6IHZvaWQgMCxcbiAgICAgICAgLy8gZGl0dG9cbiAgICAgICAgd2lkdGg6IHIub2Zmc2V0V2lkdGgsXG4gICAgICAgIGhlaWdodDogci5vZmZzZXRIZWlnaHRcbiAgICAgIH0pXG4gICAgKSwgbCA9IHRoaXMucG9zaXRpb25TZXJ2aWNlLmZpbmRQb3NpdGlvbkF0KFxuICAgICAge1xuICAgICAgICBsZWZ0OiBpWzBdLFxuICAgICAgICB0b3A6IGlbMV1cbiAgICAgIH0sXG4gICAgICBhLFxuICAgICAgb1xuICAgICk7XG4gICAgdGhpcy5wb3NpdGlvblNlcnZpY2Uuc2V0RWxlbWVudChhLCBsKTtcbiAgfVxuICAvLyBDb25zdHJ1Y3RzIG9iamVjdCB0byBwYXNzIGluIHNjYWxlIGZ1bmN0aW9uc1xuICBjb25zdHJ1Y3REYXR1bU9iaih0LCBuKSB7XG4gICAgY29uc3QgciA9IHt9O1xuICAgIHJldHVybiB0LmNvcnJlc3BvbmRpbmdEYXRhc2V0cyAmJiAoci5ncm91cCA9IHkodCwgXCJjb3JyZXNwb25kaW5nRGF0YXNldHNcIiwgMCkpLCByW3QubWFwc1RvXSA9IG4udmFsdWUsIHI7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXM7XG4gICAgdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoeyB3aXRoaW5DaGFydENsaXA6ICEwIH0pLnNlbGVjdEFsbChcInJlY3QudGhyZXNob2xkLWhvdmVyYWJsZS1hcmVhXCIpLm9uKFwibW91c2VvdmVyIG1vdXNlbW92ZVwiLCBmdW5jdGlvbihuKSB7XG4gICAgICBJKHRoaXMucGFyZW50Tm9kZSkuc2VsZWN0KFwibGluZS50aHJlc2hvbGQtbGluZVwiKS5jbGFzc2VkKFwiYWN0aXZlXCIsICEwKSwgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRocmVzaG9sZC5TSE9XLCB7XG4gICAgICAgIGV2ZW50OiBuLFxuICAgICAgICBob3ZlcmVkRWxlbWVudDogSSh0aGlzKSxcbiAgICAgICAgZGF0dW06IEkodGhpcykuZGF0dW0oKVxuICAgICAgfSk7XG4gICAgfSkub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihuKSB7XG4gICAgICBJKHRoaXMucGFyZW50Tm9kZSkuc2VsZWN0KFwibGluZS50aHJlc2hvbGQtbGluZVwiKS5jbGFzc2VkKFwiYWN0aXZlXCIsICExKSwgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRocmVzaG9sZC5ISURFLCB7XG4gICAgICAgIGV2ZW50OiBuLFxuICAgICAgICBob3ZlcmVkRWxlbWVudDogSSh0aGlzKSxcbiAgICAgICAgZGF0dW06IEkodGhpcykuZGF0dW0oKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIGprIGV4dGVuZHMgbXQge1xuICBjb25zdHJ1Y3Rvcih0LCBuKSB7XG4gICAgc3VwZXIodCwgbiksIHRoaXMudHlwZSA9IFwiaGlnaGxpZ2h0XCIsIHRoaXMucmVuZGVyVHlwZSA9IHJ0LlNWRywgdGhpcy5wb3NpdGlvblNlcnZpY2UgPSBuZXcgbW8oKSwgdGhpcy5oaWdobGlnaHRTdHJva2VXaWR0aCA9IDE7XG4gIH1cbiAgcmVuZGVyKHQgPSAhMSkge1xuICAgIGNvbnN0IG4gPSB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcImF4ZXNcIiksIHIgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhuKS5mb3JFYWNoKChjKSA9PiB7XG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhHKS5pbmNsdWRlcyhjKSkge1xuICAgICAgICBjb25zdCB1ID0gbltjXTtcbiAgICAgICAgdS5oaWdobGlnaHRzICYmIHUuaGlnaGxpZ2h0cy5kYXRhLmxlbmd0aCA+IDAgJiYgci5wdXNoKHtcbiAgICAgICAgICBheGlzUG9zaXRpb246IGMsXG4gICAgICAgICAgaGlnaGxpZ2h0U3RhcnRNYXBzVG86IHUuaGlnaGxpZ2h0cy5oaWdobGlnaHRTdGFydE1hcHNUbyxcbiAgICAgICAgICBoaWdobGlnaHRFbmRNYXBzVG86IHUuaGlnaGxpZ2h0cy5oaWdobGlnaHRFbmRNYXBzVG8sXG4gICAgICAgICAgbGFiZWxNYXBzVG86IHUuaGlnaGxpZ2h0cy5sYWJlbE1hcHNUbyxcbiAgICAgICAgICBoaWdobGlnaHQ6IHUuaGlnaGxpZ2h0cy5kYXRhLFxuICAgICAgICAgIGNvbG9yOiB1LmhpZ2hsaWdodHMuY29sb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0Q29tcG9uZW50Q29udGFpbmVyKHtcbiAgICAgIGFyaWFMYWJlbDogXCJoaWdobGlnaHQgYXJlYXNcIixcbiAgICAgIHdpdGhpbkNoYXJ0Q2xpcDogITBcbiAgICB9KS5zZWxlY3RBbGwoXCJnLmF4aXMtaGlnaGxpZ2h0XCIpLmRhdGEociwgKGMpID0+IGMuYXhpc1Bvc2l0aW9uKTtcbiAgICBpLmV4aXQoKS5hdHRyKFwib3BhY2l0eVwiLCAwKS5yZW1vdmUoKTtcbiAgICBjb25zdCBzID0gaS5lbnRlcigpLmFwcGVuZChcImdcIikubWVyZ2UoaSk7XG4gICAgcy5hdHRyKFwiY2xhc3NcIiwgKGMpID0+IGBheGlzLWhpZ2hsaWdodCAke2MuYXhpc1Bvc2l0aW9ufWApO1xuICAgIGNvbnN0IGEgPSBzLnNlbGVjdEFsbChcImcuaGlnaGxpZ2h0LWdyb3VwXCIpLmRhdGEoXG4gICAgICAoYykgPT4gYy5oaWdobGlnaHQubWFwKCh1KSA9PiAodS5heGlzUG9zaXRpb24gPSBjLmF4aXNQb3NpdGlvbiwgdS5oaWdobGlnaHRTdGFydE1hcHNUbyA9IGMuaGlnaGxpZ2h0U3RhcnRNYXBzVG8sIHUubGFiZWxNYXBzVG8gPSBjLmxhYmVsTWFwc1RvLCB1LmNvbG9yID0gYy5jb2xvciwgdS5oaWdobGlnaHRFbmRNYXBzVG8gPSBjLmhpZ2hsaWdodEVuZE1hcHNUbywgdSkpXG4gICAgKTtcbiAgICBhLmV4aXQoKS5hdHRyKFwib3BhY2l0eVwiLCAwKS5yZW1vdmUoKTtcbiAgICBjb25zdCBvID0gYS5lbnRlcigpLmFwcGVuZChcImdcIik7XG4gICAgby5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJjbGFzc1wiLCBcImhpZ2hsaWdodC1iYXJcIiksIG8uYXBwZW5kKFwibGluZVwiKS5hdHRyKFwiY2xhc3NcIiwgXCJoaWdobGlnaHQtbGluZVwiKSwgby5tZXJnZShhKS5hdHRyKFwiY2xhc3NcIiwgXCJoaWdobGlnaHQtZ3JvdXBcIik7XG4gICAgY29uc3QgbCA9IHRoaXM7XG4gICAgcy5lYWNoKGZ1bmN0aW9uKHsgYXhpc1Bvc2l0aW9uOiBjIH0pIHtcbiAgICAgIGNvbnN0IHUgPSBsLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRNYWluWFNjYWxlKCksIGQgPSBsLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRNYWluWVNjYWxlKCksIFtoLCBwXSA9IHUucmFuZ2UoKSwgW2YsIGddID0gZC5yYW5nZSgpLCB7IGNhcnRlc2lhblNjYWxlczogbSB9ID0gbC5zZXJ2aWNlcywgdiA9IG0uZ2V0T3JpZW50YXRpb24oKSwgeCA9IChNKSA9PiBtLmdldERvbWFpblZhbHVlKE0pLCBfID0gKE0pID0+IG0uZ2V0UmFuZ2VWYWx1ZShNKSwgW0UsIGJdID0gRW4oXG4gICAgICAgIHgsXG4gICAgICAgIF8sXG4gICAgICAgIHZcbiAgICAgICksIFMgPSBJKHRoaXMpO1xuICAgICAgYyA9PT0gRy5UT1AgfHwgYyA9PT0gRy5CT1RUT00gPyBTLnNlbGVjdEFsbChcInJlY3QuaGlnaGxpZ2h0LWJhclwiKS50cmFuc2l0aW9uKCkuY2FsbChcbiAgICAgICAgKE0pID0+IGwuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICB0cmFuc2l0aW9uOiBNLFxuICAgICAgICAgIG5hbWU6IFwiaGlnaGxpZ2h0LWJhci11cGRhdGVcIixcbiAgICAgICAgICBhbmltYXRlOiB0XG4gICAgICAgIH0pXG4gICAgICApLmF0dHIoXCJ5XCIsIE1hdGgubWF4KGcgKyBsLmhpZ2hsaWdodFN0cm9rZVdpZHRoLCAwKSkuYXR0cihcImhlaWdodFwiLCBNYXRoLm1heChmIC0gMiAqIGwuaGlnaGxpZ2h0U3Ryb2tlV2lkdGgsIDApKS5hdHRyKFwieFwiLCAoeyBoaWdobGlnaHRTdGFydE1hcHNUbzogTSwgLi4uRCB9KSA9PiBFKERbTV0pKS5hdHRyKFxuICAgICAgICBcIndpZHRoXCIsXG4gICAgICAgICh7IGhpZ2hsaWdodFN0YXJ0TWFwc1RvOiBNLCBoaWdobGlnaHRFbmRNYXBzVG86IEQsIC4uLkEgfSkgPT4gTWF0aC5tYXgoRShBW0RdKSAtIEUoQVtNXSksIDApXG4gICAgICApLnN0eWxlKFwic3Ryb2tlXCIsICh7IGNvbG9yOiBNLCBsYWJlbE1hcHNUbzogRCwgLi4uQSB9KSA9PiBNICYmIE0uc2NhbGVbQVtEXV0gPyBNLnNjYWxlW0FbRF1dIDogbnVsbCkuc3R5bGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIFwiMiwgMlwiKS5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIGwuaGlnaGxpZ2h0U3Ryb2tlV2lkdGggKyBcInB4XCIpLnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIDAuMSkuc3R5bGUoXCJmaWxsXCIsICh7IGNvbG9yOiBNLCBsYWJlbE1hcHNUbzogRCwgLi4uQSB9KSA9PiBNICYmIE0uc2NhbGVbQVtEXV0gPyBNLnNjYWxlW0FbRF1dIDogbnVsbCkgOiBTLnNlbGVjdEFsbChcInJlY3QuaGlnaGxpZ2h0LWJhclwiKS50cmFuc2l0aW9uKCkuY2FsbChcbiAgICAgICAgKE0pID0+IGwuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICB0cmFuc2l0aW9uOiBNLFxuICAgICAgICAgIG5hbWU6IFwiaGlnaGxpZ2h0LWJhci11cGRhdGVcIixcbiAgICAgICAgICBhbmltYXRlOiB0XG4gICAgICAgIH0pXG4gICAgICApLmF0dHIoXCJ4XCIsIGgpLmF0dHIoXCJ3aWR0aFwiLCBNYXRoLm1heChwIC0gaCwgMCkpLmF0dHIoXCJ5XCIsICh7IGhpZ2hsaWdodEVuZE1hcHNUbzogTSwgLi4uRCB9KSA9PiBiKERbTV0pKS5hdHRyKFxuICAgICAgICBcImhlaWdodFwiLFxuICAgICAgICAoeyBoaWdobGlnaHRTdGFydE1hcHNUbzogTSwgaGlnaGxpZ2h0RW5kTWFwc1RvOiBELCAuLi5BIH0pID0+IE1hdGgubWF4KGIoQVtNXSkgLSBiKEFbRF0pLCAwKVxuICAgICAgKS5zdHlsZShcInN0cm9rZVwiLCAoeyBjb2xvcjogTSwgbGFiZWxNYXBzVG86IEQsIC4uLkEgfSkgPT4gTSAmJiBNLnNjYWxlW0FbRF1dID8gTS5zY2FsZVtBW0RdXSA6IG51bGwpLnN0eWxlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcIjIsIDJcIikuYXR0cihcInN0cm9rZS13aWR0aFwiLCBsLmhpZ2hsaWdodFN0cm9rZVdpZHRoICsgXCJweFwiKS5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCAwLjEpLnN0eWxlKFwiZmlsbFwiLCAoeyBjb2xvcjogTSwgbGFiZWxNYXBzVG86IEQsIC4uLkEgfSkgPT4gTSAmJiBNLnNjYWxlW0FbRF1dID8gTS5zY2FsZVtBW0RdXSA6IG51bGwpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyB4diBleHRlbmRzIGN1IHtcbiAgZ2V0SXRlbXModCkge1xuICAgIGlmICh0LmRldGFpbC5pdGVtcylcbiAgICAgIHJldHVybiB0LmRldGFpbC5pdGVtcztcbiAgICBjb25zdCB7IGRhdGE6IG4gfSA9IHQuZGV0YWlsO1xuICAgIGlmICghbiB8fCAhbi5sZW5ndGggfHwgIW5bMF0pXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgciA9IHRoaXMuZ2V0T3B0aW9ucygpLCB7IGNhcnRlc2lhblNjYWxlczogaSB9ID0gdGhpcy5zZXJ2aWNlcywgcyA9IGkuZ2V0RG9tYWluSWRlbnRpZmllcigpLCBhID0gaS5pc0R1YWxBeGVzKCksIHsgZ3JvdXBNYXBzVG86IG8gfSA9IHIuZGF0YSwgbCA9IGkuZ2V0RG9tYWluTGFiZWwoKTtcbiAgICBsZXQgYyA9IGkuZ2V0UmFuZ2VMYWJlbCgpO1xuICAgIGNvbnN0IHUgPSBuWzBdW3NdO1xuICAgIGxldCBkO1xuICAgIGlmIChuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgaCA9IG5bMF0sIHAgPSBpLmdldFJhbmdlSWRlbnRpZmllcihoKTtcbiAgICAgIGlmIChhKSB7XG4gICAgICAgIGNvbnN0IGcgPSBpLmdldFJhbmdlQXhpc1Bvc2l0aW9uKHtcbiAgICAgICAgICBkYXR1bTogaCxcbiAgICAgICAgICBncm91cHM6IFtoW29dXVxuICAgICAgICB9KTtcbiAgICAgICAgYyA9IGkuZ2V0U2NhbGVMYWJlbChnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGYgPSBoW3BdO1xuICAgICAgZCA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGxhYmVsOiBsLFxuICAgICAgICAgIHZhbHVlOiB1XG4gICAgICAgIH0sXG4gICAgICAgIC4uLkFycmF5LmlzQXJyYXkoZikgJiYgZi5sZW5ndGggPT09IDIgPyBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6IFwiU3RhcnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmWzBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogXCJFbmRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmWzFdXG4gICAgICAgICAgfVxuICAgICAgICBdIDogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiBjLFxuICAgICAgICAgICAgdmFsdWU6IGhbcF1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIF0sIHQuZGV0YWlsLmFkZGl0aW9uYWxJdGVtcyAmJiB0LmRldGFpbC5hZGRpdGlvbmFsSXRlbXMuZm9yRWFjaChcbiAgICAgICAgKGcpID0+IGQucHVzaCh7XG4gICAgICAgICAgbGFiZWw6IGcubGFiZWwsXG4gICAgICAgICAgdmFsdWU6IGcudmFsdWVcbiAgICAgICAgfSlcbiAgICAgICksIGQucHVzaCh7XG4gICAgICAgIGxhYmVsOiBndChyLCBcImxvY2FsZS50cmFuc2xhdGlvbnMuZ3JvdXBcIikgfHwgZ3QociwgXCJ0b29sdGlwLmdyb3VwTGFiZWxcIiksXG4gICAgICAgIHZhbHVlOiBoW29dLFxuICAgICAgICBjb2xvcjogdGhpcy5tb2RlbC5nZXRGaWxsQ29sb3IoaFtvXSksXG4gICAgICAgIGNsYXNzOiB0aGlzLm1vZGVsLmdldENvbG9yQ2xhc3NOYW1lKHtcbiAgICAgICAgICBjbGFzc05hbWVUeXBlczogW2l0LlRPT0xUSVBdLFxuICAgICAgICAgIGRhdGFHcm91cE5hbWU6IGhbb11cbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobi5sZW5ndGggPiAxICYmIChkID0gW1xuICAgICAge1xuICAgICAgICBsYWJlbDogbCxcbiAgICAgICAgdmFsdWU6IHVcbiAgICAgIH1cbiAgICBdLCBkID0gZC5jb25jYXQoXG4gICAgICBuLm1hcCgoaCkgPT4ge1xuICAgICAgICBjb25zdCBwID0gaFtpLmdldFJhbmdlSWRlbnRpZmllcihoKV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGFiZWw6IGhbb10sXG4gICAgICAgICAgdmFsdWU6IEFycmF5LmlzQXJyYXkocCkgJiYgcC5sZW5ndGggPT09IDIgPyBgJHtwWzBdfSAtICR7cFsxXX1gIDogcCxcbiAgICAgICAgICBjb2xvcjogdGhpcy5tb2RlbC5nZXRGaWxsQ29sb3IoaFtvXSksXG4gICAgICAgICAgY2xhc3M6IHRoaXMubW9kZWwuZ2V0Q29sb3JDbGFzc05hbWUoe1xuICAgICAgICAgICAgY2xhc3NOYW1lVHlwZXM6IFtpdC5UT09MVElQXSxcbiAgICAgICAgICAgIGRhdGFHcm91cE5hbWU6IGhbb11cbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfSkuc29ydCgoaCwgcCkgPT4gcC52YWx1ZSAtIGgudmFsdWUpXG4gICAgKSwgIWEgJiYgeShyLCBcInRvb2x0aXBcIiwgXCJzaG93VG90YWxcIikgPT09ICEwKSkge1xuICAgICAgY29uc3QgaCA9IGkuZ2V0UmFuZ2VJZGVudGlmaWVyKCk7XG4gICAgICBkLnB1c2goe1xuICAgICAgICBsYWJlbDogZ3QociwgXCJsb2NhbGUudHJhbnNsYXRpb25zLnRvdGFsXCIpIHx8IGd0KHIsIFwidG9vbHRpcC50b3RhbExhYmVsXCIpIHx8IFwiVG90YWxcIixcbiAgICAgICAgdmFsdWU6IG4ucmVkdWNlKFxuICAgICAgICAgIChwLCBmKSA9PiBwICsgZltoXSxcbiAgICAgICAgICAwXG4gICAgICAgICksXG4gICAgICAgIGJvbGQ6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGQ7XG4gIH1cbn1cbmZ1bmN0aW9uIG9wKGUsIHQpIHtcbiAgbGV0IG47XG4gIGlmICh0ID09PSB2b2lkIDApXG4gICAgZm9yIChjb25zdCByIG9mIGUpXG4gICAgICByICE9IG51bGwgJiYgKG4gPCByIHx8IG4gPT09IHZvaWQgMCAmJiByID49IHIpICYmIChuID0gcik7XG4gIGVsc2Uge1xuICAgIGxldCByID0gLTE7XG4gICAgZm9yIChsZXQgaSBvZiBlKVxuICAgICAgKGkgPSB0KGksICsrciwgZSkpICE9IG51bGwgJiYgKG4gPCBpIHx8IG4gPT09IHZvaWQgMCAmJiBpID49IGkpICYmIChuID0gaSk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBXayhlLCB0KSB7XG4gIGxldCBuO1xuICBpZiAodCA9PT0gdm9pZCAwKVxuICAgIGZvciAoY29uc3QgciBvZiBlKVxuICAgICAgciAhPSBudWxsICYmIChuID4gciB8fCBuID09PSB2b2lkIDAgJiYgciA+PSByKSAmJiAobiA9IHIpO1xuICBlbHNlIHtcbiAgICBsZXQgciA9IC0xO1xuICAgIGZvciAobGV0IGkgb2YgZSlcbiAgICAgIChpID0gdChpLCArK3IsIGUpKSAhPSBudWxsICYmIChuID4gaSB8fCBuID09PSB2b2lkIDAgJiYgaSA+PSBpKSAmJiAobiA9IGkpO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gbGwoZSwgdCkge1xuICBsZXQgbiA9IDA7XG4gIGlmICh0ID09PSB2b2lkIDApXG4gICAgZm9yIChsZXQgciBvZiBlKVxuICAgICAgKHIgPSArcikgJiYgKG4gKz0gcik7XG4gIGVsc2Uge1xuICAgIGxldCByID0gLTE7XG4gICAgZm9yIChsZXQgaSBvZiBlKVxuICAgICAgKGkgPSArdChpLCArK3IsIGUpKSAmJiAobiArPSBpKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHFrKGUpIHtcbiAgcmV0dXJuIGUuZGVwdGg7XG59XG5mdW5jdGlvbiBZayhlLCB0KSB7XG4gIHJldHVybiB0IC0gMSAtIGUuaGVpZ2h0O1xufVxuZnVuY3Rpb24gYnYoZSwgdCkge1xuICByZXR1cm4gZS5zb3VyY2VMaW5rcy5sZW5ndGggPyBlLmRlcHRoIDogdCAtIDE7XG59XG5mdW5jdGlvbiB6cyhlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGxwKGUsIHQpIHtcbiAgcmV0dXJuIFBhKGUuc291cmNlLCB0LnNvdXJjZSkgfHwgZS5pbmRleCAtIHQuaW5kZXg7XG59XG5mdW5jdGlvbiBjcChlLCB0KSB7XG4gIHJldHVybiBQYShlLnRhcmdldCwgdC50YXJnZXQpIHx8IGUuaW5kZXggLSB0LmluZGV4O1xufVxuZnVuY3Rpb24gUGEoZSwgdCkge1xuICByZXR1cm4gZS55MCAtIHQueTA7XG59XG5mdW5jdGlvbiBjbChlKSB7XG4gIHJldHVybiBlLnZhbHVlO1xufVxuZnVuY3Rpb24gWGsoZSkge1xuICByZXR1cm4gZS5pbmRleDtcbn1cbmZ1bmN0aW9uIFprKGUpIHtcbiAgcmV0dXJuIGUubm9kZXM7XG59XG5mdW5jdGlvbiBLayhlKSB7XG4gIHJldHVybiBlLmxpbmtzO1xufVxuZnVuY3Rpb24gdXAoZSwgdCkge1xuICBjb25zdCBuID0gZS5nZXQodCk7XG4gIGlmICghbikgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZzogXCIgKyB0KTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBocCh7IG5vZGVzOiBlIH0pIHtcbiAgZm9yIChjb25zdCB0IG9mIGUpIHtcbiAgICBsZXQgbiA9IHQueTAsIHIgPSBuO1xuICAgIGZvciAoY29uc3QgaSBvZiB0LnNvdXJjZUxpbmtzKVxuICAgICAgaS55MCA9IG4gKyBpLndpZHRoIC8gMiwgbiArPSBpLndpZHRoO1xuICAgIGZvciAoY29uc3QgaSBvZiB0LnRhcmdldExpbmtzKVxuICAgICAgaS55MSA9IHIgKyBpLndpZHRoIC8gMiwgciArPSBpLndpZHRoO1xuICB9XG59XG5mdW5jdGlvbiBRaygpIHtcbiAgbGV0IGUgPSAwLCB0ID0gMCwgbiA9IDEsIHIgPSAxLCBpID0gMjQsIHMgPSA4LCBhLCBvID0gWGssIGwgPSBidiwgYywgdSwgZCA9IFprLCBoID0gS2ssIHAgPSA2O1xuICBmdW5jdGlvbiBmKCkge1xuICAgIGNvbnN0IE8gPSB7IG5vZGVzOiBkLmFwcGx5KG51bGwsIGFyZ3VtZW50cyksIGxpbmtzOiBoLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcbiAgICByZXR1cm4gZyhPKSwgbShPKSwgdihPKSwgeChPKSwgYihPKSwgaHAoTyksIE87XG4gIH1cbiAgZi51cGRhdGUgPSBmdW5jdGlvbihPKSB7XG4gICAgcmV0dXJuIGhwKE8pLCBPO1xuICB9LCBmLm5vZGVJZCA9IGZ1bmN0aW9uKE8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvID0gdHlwZW9mIE8gPT0gXCJmdW5jdGlvblwiID8gTyA6IHpzKE8pLCBmKSA6IG87XG4gIH0sIGYubm9kZUFsaWduID0gZnVuY3Rpb24oTykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGwgPSB0eXBlb2YgTyA9PSBcImZ1bmN0aW9uXCIgPyBPIDogenMoTyksIGYpIDogbDtcbiAgfSwgZi5ub2RlU29ydCA9IGZ1bmN0aW9uKE8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjID0gTywgZikgOiBjO1xuICB9LCBmLm5vZGVXaWR0aCA9IGZ1bmN0aW9uKE8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpID0gK08sIGYpIDogaTtcbiAgfSwgZi5ub2RlUGFkZGluZyA9IGZ1bmN0aW9uKE8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzID0gYSA9ICtPLCBmKSA6IHM7XG4gIH0sIGYubm9kZXMgPSBmdW5jdGlvbihPKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZCA9IHR5cGVvZiBPID09IFwiZnVuY3Rpb25cIiA/IE8gOiB6cyhPKSwgZikgOiBkO1xuICB9LCBmLmxpbmtzID0gZnVuY3Rpb24oTykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGggPSB0eXBlb2YgTyA9PSBcImZ1bmN0aW9uXCIgPyBPIDogenMoTyksIGYpIDogaDtcbiAgfSwgZi5saW5rU29ydCA9IGZ1bmN0aW9uKE8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1ID0gTywgZikgOiB1O1xuICB9LCBmLnNpemUgPSBmdW5jdGlvbihPKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZSA9IHQgPSAwLCBuID0gK09bMF0sIHIgPSArT1sxXSwgZikgOiBbbiAtIGUsIHIgLSB0XTtcbiAgfSwgZi5leHRlbnQgPSBmdW5jdGlvbihPKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZSA9ICtPWzBdWzBdLCBuID0gK09bMV1bMF0sIHQgPSArT1swXVsxXSwgciA9ICtPWzFdWzFdLCBmKSA6IFtbZSwgdF0sIFtuLCByXV07XG4gIH0sIGYuaXRlcmF0aW9ucyA9IGZ1bmN0aW9uKE8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwID0gK08sIGYpIDogcDtcbiAgfTtcbiAgZnVuY3Rpb24gZyh7IG5vZGVzOiBPLCBsaW5rczogdyB9KSB7XG4gICAgZm9yIChjb25zdCBbaywgVV0gb2YgTy5lbnRyaWVzKCkpXG4gICAgICBVLmluZGV4ID0gaywgVS5zb3VyY2VMaW5rcyA9IFtdLCBVLnRhcmdldExpbmtzID0gW107XG4gICAgY29uc3QgTCA9IG5ldyBNYXAoTy5tYXAoKGssIFUpID0+IFtvKGssIFUsIE8pLCBrXSkpO1xuICAgIGZvciAoY29uc3QgW2ssIFVdIG9mIHcuZW50cmllcygpKSB7XG4gICAgICBVLmluZGV4ID0gaztcbiAgICAgIGxldCB7IHNvdXJjZTogWiwgdGFyZ2V0OiBqIH0gPSBVO1xuICAgICAgdHlwZW9mIFogIT0gXCJvYmplY3RcIiAmJiAoWiA9IFUuc291cmNlID0gdXAoTCwgWikpLCB0eXBlb2YgaiAhPSBcIm9iamVjdFwiICYmIChqID0gVS50YXJnZXQgPSB1cChMLCBqKSksIFouc291cmNlTGlua3MucHVzaChVKSwgai50YXJnZXRMaW5rcy5wdXNoKFUpO1xuICAgIH1cbiAgICBpZiAodSAhPSBudWxsKVxuICAgICAgZm9yIChjb25zdCB7IHNvdXJjZUxpbmtzOiBrLCB0YXJnZXRMaW5rczogVSB9IG9mIE8pXG4gICAgICAgIGsuc29ydCh1KSwgVS5zb3J0KHUpO1xuICB9XG4gIGZ1bmN0aW9uIG0oeyBub2RlczogTyB9KSB7XG4gICAgZm9yIChjb25zdCB3IG9mIE8pXG4gICAgICB3LnZhbHVlID0gdy5maXhlZFZhbHVlID09PSB2b2lkIDAgPyBNYXRoLm1heChsbCh3LnNvdXJjZUxpbmtzLCBjbCksIGxsKHcudGFyZ2V0TGlua3MsIGNsKSkgOiB3LmZpeGVkVmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gdih7IG5vZGVzOiBPIH0pIHtcbiAgICBjb25zdCB3ID0gTy5sZW5ndGg7XG4gICAgbGV0IEwgPSBuZXcgU2V0KE8pLCBrID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgVSA9IDA7XG4gICAgZm9yICg7IEwuc2l6ZTsgKSB7XG4gICAgICBmb3IgKGNvbnN0IFogb2YgTCkge1xuICAgICAgICBaLmRlcHRoID0gVTtcbiAgICAgICAgZm9yIChjb25zdCB7IHRhcmdldDogaiB9IG9mIFouc291cmNlTGlua3MpXG4gICAgICAgICAgay5hZGQoaik7XG4gICAgICB9XG4gICAgICBpZiAoKytVID4gdykgdGhyb3cgbmV3IEVycm9yKFwiY2lyY3VsYXIgbGlua1wiKTtcbiAgICAgIEwgPSBrLCBrID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24geCh7IG5vZGVzOiBPIH0pIHtcbiAgICBjb25zdCB3ID0gTy5sZW5ndGg7XG4gICAgbGV0IEwgPSBuZXcgU2V0KE8pLCBrID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgVSA9IDA7XG4gICAgZm9yICg7IEwuc2l6ZTsgKSB7XG4gICAgICBmb3IgKGNvbnN0IFogb2YgTCkge1xuICAgICAgICBaLmhlaWdodCA9IFU7XG4gICAgICAgIGZvciAoY29uc3QgeyBzb3VyY2U6IGogfSBvZiBaLnRhcmdldExpbmtzKVxuICAgICAgICAgIGsuYWRkKGopO1xuICAgICAgfVxuICAgICAgaWYgKCsrVSA+IHcpIHRocm93IG5ldyBFcnJvcihcImNpcmN1bGFyIGxpbmtcIik7XG4gICAgICBMID0gaywgayA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIF8oeyBub2RlczogTyB9KSB7XG4gICAgY29uc3QgdyA9IG9wKE8sIChVKSA9PiBVLmRlcHRoKSArIDEsIEwgPSAobiAtIGUgLSBpKSAvICh3IC0gMSksIGsgPSBuZXcgQXJyYXkodyk7XG4gICAgZm9yIChjb25zdCBVIG9mIE8pIHtcbiAgICAgIGNvbnN0IFogPSBNYXRoLm1heCgwLCBNYXRoLm1pbih3IC0gMSwgTWF0aC5mbG9vcihsLmNhbGwobnVsbCwgVSwgdykpKSk7XG4gICAgICBVLmxheWVyID0gWiwgVS54MCA9IGUgKyBaICogTCwgVS54MSA9IFUueDAgKyBpLCBrW1pdID8ga1taXS5wdXNoKFUpIDoga1taXSA9IFtVXTtcbiAgICB9XG4gICAgaWYgKGMpIGZvciAoY29uc3QgVSBvZiBrKVxuICAgICAgVS5zb3J0KGMpO1xuICAgIHJldHVybiBrO1xuICB9XG4gIGZ1bmN0aW9uIEUoTykge1xuICAgIGNvbnN0IHcgPSBXayhPLCAoTCkgPT4gKHIgLSB0IC0gKEwubGVuZ3RoIC0gMSkgKiBhKSAvIGxsKEwsIGNsKSk7XG4gICAgZm9yIChjb25zdCBMIG9mIE8pIHtcbiAgICAgIGxldCBrID0gdDtcbiAgICAgIGZvciAoY29uc3QgVSBvZiBMKSB7XG4gICAgICAgIFUueTAgPSBrLCBVLnkxID0gayArIFUudmFsdWUgKiB3LCBrID0gVS55MSArIGE7XG4gICAgICAgIGZvciAoY29uc3QgWiBvZiBVLnNvdXJjZUxpbmtzKVxuICAgICAgICAgIFoud2lkdGggPSBaLnZhbHVlICogdztcbiAgICAgIH1cbiAgICAgIGsgPSAociAtIGsgKyBhKSAvIChMLmxlbmd0aCArIDEpO1xuICAgICAgZm9yIChsZXQgVSA9IDA7IFUgPCBMLmxlbmd0aDsgKytVKSB7XG4gICAgICAgIGNvbnN0IFogPSBMW1VdO1xuICAgICAgICBaLnkwICs9IGsgKiAoVSArIDEpLCBaLnkxICs9IGsgKiAoVSArIDEpO1xuICAgICAgfVxuICAgICAgSChMKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYihPKSB7XG4gICAgY29uc3QgdyA9IF8oTyk7XG4gICAgYSA9IE1hdGgubWluKHMsIChyIC0gdCkgLyAob3AodywgKEwpID0+IEwubGVuZ3RoKSAtIDEpKSwgRSh3KTtcbiAgICBmb3IgKGxldCBMID0gMDsgTCA8IHA7ICsrTCkge1xuICAgICAgY29uc3QgayA9IE1hdGgucG93KDAuOTksIEwpLCBVID0gTWF0aC5tYXgoMSAtIGssIChMICsgMSkgLyBwKTtcbiAgICAgIE0odywgaywgVSksIFModywgaywgVSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIFMoTywgdywgTCkge1xuICAgIGZvciAobGV0IGsgPSAxLCBVID0gTy5sZW5ndGg7IGsgPCBVOyArK2spIHtcbiAgICAgIGNvbnN0IFogPSBPW2tdO1xuICAgICAgZm9yIChjb25zdCBqIG9mIFopIHtcbiAgICAgICAgbGV0IEYgPSAwLCBZID0gMDtcbiAgICAgICAgZm9yIChjb25zdCB7IHNvdXJjZTogUSwgdmFsdWU6IHEgfSBvZiBqLnRhcmdldExpbmtzKSB7XG4gICAgICAgICAgbGV0IHR0ID0gcSAqIChqLmxheWVyIC0gUS5sYXllcik7XG4gICAgICAgICAgRiArPSBQKFEsIGopICogdHQsIFkgKz0gdHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoWSA+IDApKSBjb250aW51ZTtcbiAgICAgICAgbGV0IG90ID0gKEYgLyBZIC0gai55MCkgKiB3O1xuICAgICAgICBqLnkwICs9IG90LCBqLnkxICs9IG90LCAkKGopO1xuICAgICAgfVxuICAgICAgYyA9PT0gdm9pZCAwICYmIFouc29ydChQYSksIEQoWiwgTCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIE0oTywgdywgTCkge1xuICAgIGZvciAobGV0IGsgPSBPLmxlbmd0aCwgVSA9IGsgLSAyOyBVID49IDA7IC0tVSkge1xuICAgICAgY29uc3QgWiA9IE9bVV07XG4gICAgICBmb3IgKGNvbnN0IGogb2YgWikge1xuICAgICAgICBsZXQgRiA9IDAsIFkgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHsgdGFyZ2V0OiBRLCB2YWx1ZTogcSB9IG9mIGouc291cmNlTGlua3MpIHtcbiAgICAgICAgICBsZXQgdHQgPSBxICogKFEubGF5ZXIgLSBqLmxheWVyKTtcbiAgICAgICAgICBGICs9IEIoaiwgUSkgKiB0dCwgWSArPSB0dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShZID4gMCkpIGNvbnRpbnVlO1xuICAgICAgICBsZXQgb3QgPSAoRiAvIFkgLSBqLnkwKSAqIHc7XG4gICAgICAgIGoueTAgKz0gb3QsIGoueTEgKz0gb3QsICQoaik7XG4gICAgICB9XG4gICAgICBjID09PSB2b2lkIDAgJiYgWi5zb3J0KFBhKSwgRChaLCBMKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gRChPLCB3KSB7XG4gICAgY29uc3QgTCA9IE8ubGVuZ3RoID4+IDEsIGsgPSBPW0xdO1xuICAgIFIoTywgay55MCAtIGEsIEwgLSAxLCB3KSwgQShPLCBrLnkxICsgYSwgTCArIDEsIHcpLCBSKE8sIHIsIE8ubGVuZ3RoIC0gMSwgdyksIEEoTywgdCwgMCwgdyk7XG4gIH1cbiAgZnVuY3Rpb24gQShPLCB3LCBMLCBrKSB7XG4gICAgZm9yICg7IEwgPCBPLmxlbmd0aDsgKytMKSB7XG4gICAgICBjb25zdCBVID0gT1tMXSwgWiA9ICh3IC0gVS55MCkgKiBrO1xuICAgICAgWiA+IDFlLTYgJiYgKFUueTAgKz0gWiwgVS55MSArPSBaKSwgdyA9IFUueTEgKyBhO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBSKE8sIHcsIEwsIGspIHtcbiAgICBmb3IgKDsgTCA+PSAwOyAtLUwpIHtcbiAgICAgIGNvbnN0IFUgPSBPW0xdLCBaID0gKFUueTEgLSB3KSAqIGs7XG4gICAgICBaID4gMWUtNiAmJiAoVS55MCAtPSBaLCBVLnkxIC09IFopLCB3ID0gVS55MCAtIGE7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uICQoeyBzb3VyY2VMaW5rczogTywgdGFyZ2V0TGlua3M6IHcgfSkge1xuICAgIGlmICh1ID09PSB2b2lkIDApIHtcbiAgICAgIGZvciAoY29uc3QgeyBzb3VyY2U6IHsgc291cmNlTGlua3M6IEwgfSB9IG9mIHcpXG4gICAgICAgIEwuc29ydChjcCk7XG4gICAgICBmb3IgKGNvbnN0IHsgdGFyZ2V0OiB7IHRhcmdldExpbmtzOiBMIH0gfSBvZiBPKVxuICAgICAgICBMLnNvcnQobHApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBIKE8pIHtcbiAgICBpZiAodSA9PT0gdm9pZCAwKVxuICAgICAgZm9yIChjb25zdCB7IHNvdXJjZUxpbmtzOiB3LCB0YXJnZXRMaW5rczogTCB9IG9mIE8pXG4gICAgICAgIHcuc29ydChjcCksIEwuc29ydChscCk7XG4gIH1cbiAgZnVuY3Rpb24gUChPLCB3KSB7XG4gICAgbGV0IEwgPSBPLnkwIC0gKE8uc291cmNlTGlua3MubGVuZ3RoIC0gMSkgKiBhIC8gMjtcbiAgICBmb3IgKGNvbnN0IHsgdGFyZ2V0OiBrLCB3aWR0aDogVSB9IG9mIE8uc291cmNlTGlua3MpIHtcbiAgICAgIGlmIChrID09PSB3KSBicmVhaztcbiAgICAgIEwgKz0gVSArIGE7XG4gICAgfVxuICAgIGZvciAoY29uc3QgeyBzb3VyY2U6IGssIHdpZHRoOiBVIH0gb2Ygdy50YXJnZXRMaW5rcykge1xuICAgICAgaWYgKGsgPT09IE8pIGJyZWFrO1xuICAgICAgTCAtPSBVO1xuICAgIH1cbiAgICByZXR1cm4gTDtcbiAgfVxuICBmdW5jdGlvbiBCKE8sIHcpIHtcbiAgICBsZXQgTCA9IHcueTAgLSAody50YXJnZXRMaW5rcy5sZW5ndGggLSAxKSAqIGEgLyAyO1xuICAgIGZvciAoY29uc3QgeyBzb3VyY2U6IGssIHdpZHRoOiBVIH0gb2Ygdy50YXJnZXRMaW5rcykge1xuICAgICAgaWYgKGsgPT09IE8pIGJyZWFrO1xuICAgICAgTCArPSBVICsgYTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB7IHRhcmdldDogaywgd2lkdGg6IFUgfSBvZiBPLnNvdXJjZUxpbmtzKSB7XG4gICAgICBpZiAoayA9PT0gdykgYnJlYWs7XG4gICAgICBMIC09IFU7XG4gICAgfVxuICAgIHJldHVybiBMO1xuICB9XG4gIHJldHVybiBmO1xufVxudmFyIGFjID0gTWF0aC5QSSwgb2MgPSAyICogYWMsIFpuID0gMWUtNiwgSmsgPSBvYyAtIFpuO1xuZnVuY3Rpb24gbGMoKSB7XG4gIHRoaXMuX3gwID0gdGhpcy5feTAgPSAvLyBzdGFydCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgdGhpcy5feDEgPSB0aGlzLl95MSA9IG51bGwsIHRoaXMuXyA9IFwiXCI7XG59XG5mdW5jdGlvbiBfdigpIHtcbiAgcmV0dXJuIG5ldyBsYygpO1xufVxubGMucHJvdG90eXBlID0gX3YucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogbGMsXG4gIG1vdmVUbzogZnVuY3Rpb24oZSwgdCkge1xuICAgIHRoaXMuXyArPSBcIk1cIiArICh0aGlzLl94MCA9IHRoaXMuX3gxID0gK2UpICsgXCIsXCIgKyAodGhpcy5feTAgPSB0aGlzLl95MSA9ICt0KTtcbiAgfSxcbiAgY2xvc2VQYXRoOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MSAhPT0gbnVsbCAmJiAodGhpcy5feDEgPSB0aGlzLl94MCwgdGhpcy5feTEgPSB0aGlzLl95MCwgdGhpcy5fICs9IFwiWlwiKTtcbiAgfSxcbiAgbGluZVRvOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgdGhpcy5fICs9IFwiTFwiICsgKHRoaXMuX3gxID0gK2UpICsgXCIsXCIgKyAodGhpcy5feTEgPSArdCk7XG4gIH0sXG4gIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uKGUsIHQsIG4sIHIpIHtcbiAgICB0aGlzLl8gKz0gXCJRXCIgKyArZSArIFwiLFwiICsgK3QgKyBcIixcIiArICh0aGlzLl94MSA9ICtuKSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3IpO1xuICB9LFxuICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbihlLCB0LCBuLCByLCBpLCBzKSB7XG4gICAgdGhpcy5fICs9IFwiQ1wiICsgK2UgKyBcIixcIiArICt0ICsgXCIsXCIgKyArbiArIFwiLFwiICsgK3IgKyBcIixcIiArICh0aGlzLl94MSA9ICtpKSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3MpO1xuICB9LFxuICBhcmNUbzogZnVuY3Rpb24oZSwgdCwgbiwgciwgaSkge1xuICAgIGUgPSArZSwgdCA9ICt0LCBuID0gK24sIHIgPSArciwgaSA9ICtpO1xuICAgIHZhciBzID0gdGhpcy5feDEsIGEgPSB0aGlzLl95MSwgbyA9IG4gLSBlLCBsID0gciAtIHQsIGMgPSBzIC0gZSwgdSA9IGEgLSB0LCBkID0gYyAqIGMgKyB1ICogdTtcbiAgICBpZiAoaSA8IDApIHRocm93IG5ldyBFcnJvcihcIm5lZ2F0aXZlIHJhZGl1czogXCIgKyBpKTtcbiAgICBpZiAodGhpcy5feDEgPT09IG51bGwpXG4gICAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDEgPSBlKSArIFwiLFwiICsgKHRoaXMuX3kxID0gdCk7XG4gICAgZWxzZSBpZiAoZCA+IFpuKSBpZiAoIShNYXRoLmFicyh1ICogbyAtIGwgKiBjKSA+IFpuKSB8fCAhaSlcbiAgICAgIHRoaXMuXyArPSBcIkxcIiArICh0aGlzLl94MSA9IGUpICsgXCIsXCIgKyAodGhpcy5feTEgPSB0KTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBoID0gbiAtIHMsIHAgPSByIC0gYSwgZiA9IG8gKiBvICsgbCAqIGwsIGcgPSBoICogaCArIHAgKiBwLCBtID0gTWF0aC5zcXJ0KGYpLCB2ID0gTWF0aC5zcXJ0KGQpLCB4ID0gaSAqIE1hdGgudGFuKChhYyAtIE1hdGguYWNvcygoZiArIGQgLSBnKSAvICgyICogbSAqIHYpKSkgLyAyKSwgXyA9IHggLyB2LCBFID0geCAvIG07XG4gICAgICBNYXRoLmFicyhfIC0gMSkgPiBabiAmJiAodGhpcy5fICs9IFwiTFwiICsgKGUgKyBfICogYykgKyBcIixcIiArICh0ICsgXyAqIHUpKSwgdGhpcy5fICs9IFwiQVwiICsgaSArIFwiLFwiICsgaSArIFwiLDAsMCxcIiArICsodSAqIGggPiBjICogcCkgKyBcIixcIiArICh0aGlzLl94MSA9IGUgKyBFICogbykgKyBcIixcIiArICh0aGlzLl95MSA9IHQgKyBFICogbCk7XG4gICAgfVxuICB9LFxuICBhcmM6IGZ1bmN0aW9uKGUsIHQsIG4sIHIsIGksIHMpIHtcbiAgICBlID0gK2UsIHQgPSArdCwgbiA9ICtuLCBzID0gISFzO1xuICAgIHZhciBhID0gbiAqIE1hdGguY29zKHIpLCBvID0gbiAqIE1hdGguc2luKHIpLCBsID0gZSArIGEsIGMgPSB0ICsgbywgdSA9IDEgXiBzLCBkID0gcyA/IHIgLSBpIDogaSAtIHI7XG4gICAgaWYgKG4gPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJuZWdhdGl2ZSByYWRpdXM6IFwiICsgbik7XG4gICAgdGhpcy5feDEgPT09IG51bGwgPyB0aGlzLl8gKz0gXCJNXCIgKyBsICsgXCIsXCIgKyBjIDogKE1hdGguYWJzKHRoaXMuX3gxIC0gbCkgPiBabiB8fCBNYXRoLmFicyh0aGlzLl95MSAtIGMpID4gWm4pICYmICh0aGlzLl8gKz0gXCJMXCIgKyBsICsgXCIsXCIgKyBjKSwgbiAmJiAoZCA8IDAgJiYgKGQgPSBkICUgb2MgKyBvYyksIGQgPiBKayA/IHRoaXMuXyArPSBcIkFcIiArIG4gKyBcIixcIiArIG4gKyBcIiwwLDEsXCIgKyB1ICsgXCIsXCIgKyAoZSAtIGEpICsgXCIsXCIgKyAodCAtIG8pICsgXCJBXCIgKyBuICsgXCIsXCIgKyBuICsgXCIsMCwxLFwiICsgdSArIFwiLFwiICsgKHRoaXMuX3gxID0gbCkgKyBcIixcIiArICh0aGlzLl95MSA9IGMpIDogZCA+IFpuICYmICh0aGlzLl8gKz0gXCJBXCIgKyBuICsgXCIsXCIgKyBuICsgXCIsMCxcIiArICsoZCA+PSBhYykgKyBcIixcIiArIHUgKyBcIixcIiArICh0aGlzLl94MSA9IGUgKyBuICogTWF0aC5jb3MoaSkpICsgXCIsXCIgKyAodGhpcy5feTEgPSB0ICsgbiAqIE1hdGguc2luKGkpKSkpO1xuICB9LFxuICByZWN0OiBmdW5jdGlvbihlLCB0LCBuLCByKSB7XG4gICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gwID0gdGhpcy5feDEgPSArZSkgKyBcIixcIiArICh0aGlzLl95MCA9IHRoaXMuX3kxID0gK3QpICsgXCJoXCIgKyArbiArIFwidlwiICsgK3IgKyBcImhcIiArIC1uICsgXCJaXCI7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fO1xuICB9XG59O1xuZnVuY3Rpb24gZHAoZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGU7XG4gIH07XG59XG5mdW5jdGlvbiB0RChlKSB7XG4gIHJldHVybiBlWzBdO1xufVxuZnVuY3Rpb24gZUQoZSkge1xuICByZXR1cm4gZVsxXTtcbn1cbnZhciBuRCA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbmZ1bmN0aW9uIHJEKGUpIHtcbiAgcmV0dXJuIGUuc291cmNlO1xufVxuZnVuY3Rpb24gaUQoZSkge1xuICByZXR1cm4gZS50YXJnZXQ7XG59XG5mdW5jdGlvbiBzRChlKSB7XG4gIHZhciB0ID0gckQsIG4gPSBpRCwgciA9IHRELCBpID0gZUQsIHMgPSBudWxsO1xuICBmdW5jdGlvbiBhKCkge1xuICAgIHZhciBvLCBsID0gbkQuY2FsbChhcmd1bWVudHMpLCBjID0gdC5hcHBseSh0aGlzLCBsKSwgdSA9IG4uYXBwbHkodGhpcywgbCk7XG4gICAgaWYgKHMgfHwgKHMgPSBvID0gX3YoKSksIGUocywgK3IuYXBwbHkodGhpcywgKGxbMF0gPSBjLCBsKSksICtpLmFwcGx5KHRoaXMsIGwpLCArci5hcHBseSh0aGlzLCAobFswXSA9IHUsIGwpKSwgK2kuYXBwbHkodGhpcywgbCkpLCBvKSByZXR1cm4gcyA9IG51bGwsIG8gKyBcIlwiIHx8IG51bGw7XG4gIH1cbiAgcmV0dXJuIGEuc291cmNlID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQgPSBvLCBhKSA6IHQ7XG4gIH0sIGEudGFyZ2V0ID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4gPSBvLCBhKSA6IG47XG4gIH0sIGEueCA9IGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyID0gdHlwZW9mIG8gPT0gXCJmdW5jdGlvblwiID8gbyA6IGRwKCtvKSwgYSkgOiByO1xuICB9LCBhLnkgPSBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaSA9IHR5cGVvZiBvID09IFwiZnVuY3Rpb25cIiA/IG8gOiBkcCgrbyksIGEpIDogaTtcbiAgfSwgYS5jb250ZXh0ID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHMgPSBvID8/IG51bGwsIGEpIDogcztcbiAgfSwgYTtcbn1cbmZ1bmN0aW9uIGFEKGUsIHQsIG4sIHIsIGkpIHtcbiAgZS5tb3ZlVG8odCwgbiksIGUuYmV6aWVyQ3VydmVUbyh0ID0gKHQgKyByKSAvIDIsIG4sIHQsIGksIHIsIGkpO1xufVxuZnVuY3Rpb24gb0QoKSB7XG4gIHJldHVybiBzRChhRCk7XG59XG5mdW5jdGlvbiBsRChlKSB7XG4gIHJldHVybiBbZS5zb3VyY2UueDEsIGUueTBdO1xufVxuZnVuY3Rpb24gY0QoZSkge1xuICByZXR1cm4gW2UudGFyZ2V0LngwLCBlLnkxXTtcbn1cbmZ1bmN0aW9uIHVEKCkge1xuICByZXR1cm4gb0QoKS5zb3VyY2UobEQpLnRhcmdldChjRCk7XG59XG5jbGFzcyBoRCBleHRlbmRzIG10IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy50eXBlID0gXCJhbGx1dmlhbFwiLCB0aGlzLnJlbmRlclR5cGUgPSBydC5TVkcsIHRoaXMuZ3JhZGllbnRfaWQgPSBcImdyYWRpZW50LWlkLVwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogOTk5OTk5OTk5OTkpO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIHJlbmRlcih0ID0gITApIHtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoeyBhcmlhTGFiZWw6IFwiYWxsdXZpYWwgZ3JhcGhzXCIsIHdpdGhpbkNoYXJ0Q2xpcDogITAgfSk7XG4gICAgbi5odG1sKFwiXCIpO1xuICAgIGNvbnN0IHsgd2lkdGg6IHIsIGhlaWdodDogaSB9ID0gTi5nZXRTVkdFbGVtZW50U2l6ZShuLCB7XG4gICAgICB1c2VBdHRyczogITBcbiAgICB9KTtcbiAgICBpZiAociA8IDEgfHwgaSA8IDEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcyA9IHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLCBhID0gdGhpcy5tb2RlbC5nZXREaXNwbGF5RGF0YSgpLCBvID0geShcbiAgICAgIHRoaXMuZ2V0T3B0aW9ucygpLFxuICAgICAgXCJjb2xvclwiLFxuICAgICAgXCJncmFkaWVudFwiLFxuICAgICAgXCJlbmFibGVkXCJcbiAgICApO1xuICAgIGxldCBsID0gUGUubWluTm9kZVBhZGRpbmc7XG4gICAgcy5hbGx1dmlhbC5ub2RlUGFkZGluZyA+IFBlLm1pbk5vZGVQYWRkaW5nICYmIChsID0gcy5hbGx1dmlhbC5ub2RlUGFkZGluZyk7XG4gICAgY29uc3QgYyA9IHkocywgXCJhbGx1dmlhbFwiLCBcIm5vZGVBbGlnbm1lbnRcIik7XG4gICAgbGV0IHUgPSBidjtcbiAgICBjID09PSBqdC5MRUZUID8gdSA9IHFrIDogYyA9PT0ganQuUklHSFQgJiYgKHUgPSBZayk7XG4gICAgY29uc3QgZCA9IFFrKCkubm9kZUlkKCh4KSA9PiB4Lm5hbWUpLm5vZGVXaWR0aChQZS5ub2RlV2lkdGgpLm5vZGVQYWRkaW5nKGwpLm5vZGVBbGlnbih1KS5leHRlbnQoW1xuICAgICAgWzIsIDMwXSxcbiAgICAgIFtyIC0gMiwgaV1cbiAgICBdKTtcbiAgICB0aGlzLmdyYXBoID0gZCh7XG4gICAgICBub2Rlczogcy5hbGx1dmlhbC5ub2Rlcy5tYXAoKHgpID0+IE9iamVjdC5hc3NpZ24oe30sIHgpKSxcbiAgICAgIGxpbmtzOiBhLm1hcCgoeCkgPT4gT2JqZWN0LmFzc2lnbih7fSwgeCkpXG4gICAgfSksIHRoaXMuZ3JhcGgubm9kZXMgPSB0aGlzLmdyYXBoLm5vZGVzLmZpbHRlcigoeCkgPT4geC52YWx1ZSAhPT0gMCk7XG4gICAgY29uc3QgaCA9IHt9O1xuICAgIHRoaXMuZ3JhcGgubm9kZXMuZm9yRWFjaCgoeCkgPT4ge1xuICAgICAgY29uc3QgXyA9IHgueDA7XG4gICAgICB4LmNhdGVnb3J5ICYmIChoW19dID0geCA9PSBudWxsID8gdm9pZCAwIDogeC5jYXRlZ29yeSk7XG4gICAgfSksIG4uYXBwZW5kKFwiZ1wiKS5jbGFzc2VkKFwiaGVhZGVyLWFycm93c1wiLCAhMCkuc2VsZWN0QWxsKFwiZ1wiKS5kYXRhKE9iamVjdC5rZXlzKGgpKS5qb2luKFwiZ1wiKS5hdHRyKFwidHJhbnNmb3JtXCIsICh4KSA9PiBgdHJhbnNsYXRlKCR7eH0sIDApYCkuYXBwZW5kKFwidGV4dFwiKS5hdHRyKFxuICAgICAgXCJpZFwiLFxuICAgICAgKHgsIF8pID0+IHRoaXMuc2VydmljZXMuZG9tVXRpbHMuZ2VuZXJhdGVFbGVtZW50SURTdHJpbmcoYGFsbHV2aWFsLWNhdGVnb3J5LSR7X31gKVxuICAgICkuc3R5bGUoXCJmb250LXNpemVcIiwgXCIxNHB4XCIpLnRleHQoKHgpID0+IGhbeF0gPyBoW3hdIDogXCJcIikuYXR0cihcInlcIiwgMjApLmF0dHIoXCJ4XCIsICh4LCBfKSA9PiB7XG4gICAgICBjb25zdCBFID0gdGhpcy5zZXJ2aWNlcy5kb21VdGlscy5nZW5lcmF0ZUVsZW1lbnRJRFN0cmluZyhcbiAgICAgICAgYGFsbHV2aWFsLWNhdGVnb3J5LSR7X31gXG4gICAgICApLCB7IHdpZHRoOiBiIH0gPSBOLmdldFNWR0VsZW1lbnRTaXplKEkoYHRleHQjJHtFfWApLCB7XG4gICAgICAgIHVzZUJCb3g6ICEwXG4gICAgICB9KTtcbiAgICAgIGxldCBTID0gMDtcbiAgICAgIHJldHVybiB4ICsgUyA+PSBiICYmIChTID0gLWIgKyA0KSwgUztcbiAgICB9KTtcbiAgICBjb25zdCBwID0gbi5hcHBlbmQoXCJnXCIpLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKS5zZWxlY3RBbGwoXCJnXCIpLmRhdGEodGhpcy5ncmFwaC5saW5rcyk7XG4gICAgaWYgKHAuZXhpdCgpLnJlbW92ZSgpLCBvKSB7XG4gICAgICBjb25zdCB4ID0geSh0aGlzLmdldE9wdGlvbnMoKSwgXCJjb2xvclwiLCBcInNjYWxlXCIpO1xuICAgICAgeCAmJiBwLmVudGVyKCkuYXBwZW5kKFwibGluZWFyR3JhZGllbnRcIikuYXR0cihcImlkXCIsIChfKSA9PiBgJHt0aGlzLmdyYWRpZW50X2lkfS1saW5rLSR7Xy5pbmRleH1gKS5hdHRyKFwiZ3JhZGllbnRVbml0c1wiLCBcInVzZXJTcGFjZU9uVXNlXCIpLmNhbGwoXG4gICAgICAgIChfKSA9PiBfLmFwcGVuZChcInN0b3BcIikuYXR0cihcIm9mZnNldFwiLCBcIjAlXCIpLmF0dHIoXCJzdG9wLWNvbG9yXCIsIChFKSA9PiB4W0Uuc291cmNlLm5hbWVdKVxuICAgICAgKS5jYWxsKFxuICAgICAgICAoXykgPT4gXy5hcHBlbmQoXCJzdG9wXCIpLmF0dHIoXCJvZmZzZXRcIiwgXCIxMDAlXCIpLmF0dHIoXCJzdG9wLWNvbG9yXCIsIChFKSA9PiB4W0UudGFyZ2V0Lm5hbWVdKVxuICAgICAgKSwgcC5leGl0KCkucmVtb3ZlKCk7XG4gICAgfVxuICAgIHAuZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpLmNsYXNzZWQoXCJsaW5rXCIsICEwKS5hdHRyKFwiZFwiLCB1RCgpKS5hdHRyKFxuICAgICAgXCJpZFwiLFxuICAgICAgKHgpID0+IHRoaXMuc2VydmljZXMuZG9tVXRpbHMuZ2VuZXJhdGVFbGVtZW50SURTdHJpbmcoYGFsbHV2aWFsLWxpbmUtJHt4LmluZGV4fWApXG4gICAgKS5hdHRyKFwiY2xhc3NcIiwgKHgpID0+IHMuYWxsdXZpYWwubW9ub2Nocm9tZSA/IHRoaXMubW9kZWwuZ2V0Q29sb3JDbGFzc05hbWUoe1xuICAgICAgY2xhc3NOYW1lVHlwZXM6IFtpdC5TVFJPS0VdLFxuICAgICAgZGF0YUdyb3VwTmFtZTogMCxcbiAgICAgIG9yaWdpbmFsQ2xhc3NOYW1lOiBcImxpbmtcIlxuICAgIH0pIDogdGhpcy5tb2RlbC5nZXRDb2xvckNsYXNzTmFtZSh7XG4gICAgICBjbGFzc05hbWVUeXBlczogW2l0LlNUUk9LRV0sXG4gICAgICBkYXRhR3JvdXBOYW1lOiB4LnNvdXJjZS5pbmRleCxcbiAgICAgIG9yaWdpbmFsQ2xhc3NOYW1lOiBcImxpbmtcIlxuICAgIH0pKS5zdHlsZShcInN0cm9rZVwiLCAoeCkgPT4gbyA/IGB1cmwoIyR7dGhpcy5ncmFkaWVudF9pZH0tbGluay0ke3guaW5kZXh9KWAgOiB0aGlzLm1vZGVsLmdldEZpbGxDb2xvcih4LnNvdXJjZS5uYW1lLCBudWxsLCB7XG4gICAgICAuLi54LFxuICAgICAgc291cmNlOiB4LnNvdXJjZS5uYW1lLFxuICAgICAgdGFyZ2V0OiB4LnRhcmdldC5uYW1lXG4gICAgfSkpLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgKHgpID0+IE1hdGgubWF4KDEsIHgud2lkdGgpKS5zdHlsZShcInN0cm9rZS1vcGFjaXR5XCIsIFBlLm9wYWNpdHkuZGVmYXVsdCkuYXR0cihcbiAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgKHgpID0+IGAke3guc291cmNlLm5hbWV9IOKGkiAke3gudGFyZ2V0Lm5hbWV9ICgke3gudmFsdWV9JHtzLmFsbHV2aWFsLnVuaXRzID8gXCIgXCIgKyBzLmFsbHV2aWFsLnVuaXRzIDogXCJcIn0pYFxuICAgICk7XG4gICAgY29uc3QgZiA9IG4uYXBwZW5kKFwiZ1wiKS5zZWxlY3RBbGwoXCJnXCIpLmRhdGEodGhpcy5ncmFwaC5ub2RlcykuZW50ZXIoKS5hcHBlbmQoXCJnXCIpLmF0dHIoXG4gICAgICBcImlkXCIsXG4gICAgICAoeCkgPT4gdGhpcy5zZXJ2aWNlcy5kb21VdGlscy5nZW5lcmF0ZUVsZW1lbnRJRFN0cmluZyhgYWxsdXZpYWwtbm9kZS0ke3guaW5kZXh9YClcbiAgICApLmNsYXNzZWQoXCJub2RlLWdyb3VwXCIsICEwKS5hdHRyKFwidHJhbnNmb3JtXCIsICh4KSA9PiBgdHJhbnNsYXRlKCR7eC54MH0sICR7eC55MH0pYCk7XG4gICAgZi5hcHBlbmQoXCJyZWN0XCIpLmNsYXNzZWQoXCJub2RlXCIsICEwKS5hdHRyKFwiaGVpZ2h0XCIsICh4KSA9PiB4LnkxIC0geC55MCkuYXR0cihcIndpZHRoXCIsICh4KSA9PiB4LngxIC0geC54MCkuYXR0cihcImZpbGxcIiwgXCJibGFja1wiKTtcbiAgICBjb25zdCBnID0gZi5hcHBlbmQoXCJnXCIpLmF0dHIoXG4gICAgICBcImlkXCIsXG4gICAgICAoeCkgPT4gdGhpcy5zZXJ2aWNlcy5kb21VdGlscy5nZW5lcmF0ZUVsZW1lbnRJRFN0cmluZyhgYWxsdXZpYWwtbm9kZS10aXRsZS0ke3guaW5kZXh9YClcbiAgICApLCB7IGNvZGU6IG0sIG51bWJlcjogdiB9ID0geShzLCBcImxvY2FsZVwiKTtcbiAgICBnLmFwcGVuZChcInRleHRcIikuYXR0cihcbiAgICAgIFwiaWRcIixcbiAgICAgICh4KSA9PiB0aGlzLnNlcnZpY2VzLmRvbVV0aWxzLmdlbmVyYXRlRWxlbWVudElEU3RyaW5nKGBhbGx1dmlhbC1ub2RlLXRleHQtJHt4LmluZGV4fWApXG4gICAgKS5hdHRyKFwiY2xhc3NcIiwgXCJub2RlLXRleHRcIikuc3R5bGUoXCJmb250LXNpemVcIiwgXCIxMnB4XCIpLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcInN0YXJ0XCIpLmF0dHIoXCJmaWxsXCIsIFwid2hpdGVcIikuYXR0cihcInhcIiwgNCkuYXR0cihcImR5XCIsIDEzKS50ZXh0KCh4KSA9PiBgJHt4Lm5hbWV9ICgke3YoeC52YWx1ZSwgbSl9KWApLmF0dHIoXCJhcmlhLWxhYmVsXCIsICh4KSA9PiBgJHt4Lm5hbWV9ICgke3gudmFsdWV9KWApLCBnLmFwcGVuZChcInJlY3RcIikuY2xhc3NlZChcIm5vZGUtdGV4dC1iZ1wiLCAhMCkuYXR0cihcIndpZHRoXCIsICh4LCBfKSA9PiB7XG4gICAgICBjb25zdCBFID0gdGhpcy5zZXJ2aWNlcy5kb21VdGlscy5nZW5lcmF0ZUVsZW1lbnRJRFN0cmluZyhcbiAgICAgICAgYGFsbHV2aWFsLW5vZGUtdGV4dC0ke199YFxuICAgICAgKSwgeyB3aWR0aDogYiB9ID0gTi5nZXRTVkdFbGVtZW50U2l6ZShJKGB0ZXh0IyR7RX1gKSwge1xuICAgICAgICB1c2VCQm94OiAhMFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYiArIDg7XG4gICAgfSkuYXR0cihcImhlaWdodFwiLCAxOCkuYXR0cihcInN0cm9rZS13aWR0aFwiLCAyKS5sb3dlcigpLCBnLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgKHgsIF8pID0+IHtcbiAgICAgIGNvbnN0IEUgPSB0aGlzLnNlcnZpY2VzLmRvbVV0aWxzLmdlbmVyYXRlRWxlbWVudElEU3RyaW5nKFxuICAgICAgICBgYWxsdXZpYWwtbm9kZS10ZXh0LSR7X31gXG4gICAgICApLCB7IHdpZHRoOiBiIH0gPSBOLmdldFNWR0VsZW1lbnRTaXplKEkoYHRleHQjJHtFfWApLCB7XG4gICAgICAgIHVzZUJCb3g6ICEwXG4gICAgICB9KSwgUyA9ICh4LnkxIC0geC55MCkgLyAyIC0gOTtcbiAgICAgIGxldCBNID0geC54MSAtIHgueDA7XG4gICAgICByZXR1cm4geC54MSA+PSBiID8gTSA9IE0gLSAoYiArIDE2KSA6IE0gKz0gNCwgYHRyYW5zbGF0ZSgke019LCAke1N9KWA7XG4gICAgfSksIHRoaXMuYWRkTGluZUV2ZW50TGlzdGVuZXIoKSwgdGhpcy5hZGROb2RlRXZlbnRMaXN0ZW5lcigpO1xuICB9XG4gIGFkZExpbmVFdmVudExpc3RlbmVyKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldE9wdGlvbnMoKSwgbiA9IHRoaXMsIHsgbnVtYmVyOiByLCBjb2RlOiBpIH0gPSB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcImxvY2FsZVwiKSwgcyA9IGJhKChhLCBvID0gXCJtb3VzZW92ZXJcIikgPT4ge1xuICAgICAgY29uc3QgbCA9IG4ucGFyZW50LnNlbGVjdEFsbChcInBhdGgubGlua1wiKS50cmFuc2l0aW9uKCkuY2FsbChcbiAgICAgICAgKGMpID0+IG4uc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICB0cmFuc2l0aW9uOiBjLFxuICAgICAgICAgIG5hbWU6IFwiYWxsdXZpYWwtbGlua3MtbW91c2UtaGlnaGxpZ2h0XCJcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBvID09PSBcIm1vdXNlb3V0XCIgPyAoSShhKS5sb3dlcigpLCBsLnN0eWxlKFwic3Ryb2tlLW9wYWNpdHlcIiwgUGUub3BhY2l0eS5kZWZhdWx0KSkgOiBsLnN0eWxlKFwic3Ryb2tlLW9wYWNpdHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhID09PSB0aGlzID8gKEkodGhpcykucmFpc2UoKSwgUGUub3BhY2l0eS5zZWxlY3RlZCkgOiBQZS5vcGFjaXR5LnVuZm9jdXM7XG4gICAgICB9KTtcbiAgICB9LCAzMyk7XG4gICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwicGF0aC5saW5rXCIpLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKGEsIG8pIHtcbiAgICAgIGNvbnN0IGwgPSBJKHRoaXMpO1xuICAgICAgcyh0aGlzLCBcIm1vdXNlb3ZlclwiKSwgbC5jbGFzc2VkKFwibGluay1ob3ZlcmVkXCIsICEwKTtcbiAgICAgIGNvbnN0IGMgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMpLmdldFByb3BlcnR5VmFsdWUoXCJzdHJva2VcIik7XG4gICAgICBuLnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuQWxsdXZpYWwuTElORV9NT1VTRU9WRVIsIHtcbiAgICAgICAgZXZlbnQ6IGEsXG4gICAgICAgIGVsZW1lbnQ6IGwsXG4gICAgICAgIGRhdHVtOiBvXG4gICAgICB9KSwgbi5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuU0hPVywge1xuICAgICAgICBldmVudDogYSxcbiAgICAgICAgaG92ZXJlZEVsZW1lbnQ6IGwsXG4gICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6IG8udGFyZ2V0Lm5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogKHIoby52YWx1ZSwgaSkgPyBgJHtyKG8udmFsdWUsIGkpfWAgOiBcIi1cIikgKyAodC5hbGx1dmlhbC51bml0cyA/IGAgJHt0LmFsbHV2aWFsLnVuaXRzfWAgOiBcIlwiKSxcbiAgICAgICAgICAgIGNvbG9yOiBjLFxuICAgICAgICAgICAgbGFiZWxJY29uOiBuLmdldFJpZ2h0QXJyb3dJY29uKClcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0pO1xuICAgIH0pLm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKGEsIG8pIHtcbiAgICAgIG4uc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5BbGx1dmlhbC5MSU5FX01PVVNFTU9WRSwge1xuICAgICAgICBldmVudDogYSxcbiAgICAgICAgZWxlbWVudDogSSh0aGlzKSxcbiAgICAgICAgZGF0dW06IG9cbiAgICAgIH0pLCBuLnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5NT1ZFLCB7XG4gICAgICAgIGV2ZW50OiBhXG4gICAgICB9KTtcbiAgICB9KS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGEsIG8pIHtcbiAgICAgIG4uc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5BbGx1dmlhbC5MSU5FX0NMSUNLLCB7XG4gICAgICAgIGV2ZW50OiBhLFxuICAgICAgICBlbGVtZW50OiBJKHRoaXMpLFxuICAgICAgICBkYXR1bTogb1xuICAgICAgfSk7XG4gICAgfSkub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihhLCBvKSB7XG4gICAgICBjb25zdCBsID0gSSh0aGlzKTtcbiAgICAgIHModGhpcywgXCJtb3VzZW91dFwiKSwgbC5jbGFzc2VkKFwibGluay1ob3ZlcmVkXCIsICExKSwgbi5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkFsbHV2aWFsLkxJTkVfTU9VU0VPVVQsIHtcbiAgICAgICAgZXZlbnQ6IGEsXG4gICAgICAgIGVsZW1lbnQ6IGwsXG4gICAgICAgIGRhdHVtOiBvXG4gICAgICB9KSwgbi5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuSElERSwge1xuICAgICAgICBldmVudDogYSxcbiAgICAgICAgaG92ZXJlZEVsZW1lbnQ6IGxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGFkZE5vZGVFdmVudExpc3RlbmVyKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLCBuID0gYmEoKHIgPSBbXSwgaSA9IFwibW91c2VvdmVyXCIpID0+IHtcbiAgICAgIGlmIChpID09PSBcIm1vdXNlb3V0XCIgfHwgci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdC5wYXJlbnQuc2VsZWN0QWxsKFwicGF0aC5saW5rXCIpLmNsYXNzZWQoXCJsaW5rLWhvdmVyZWRcIiwgITEpLmRhdGEodGhpcy5ncmFwaC5saW5rcywgKHMpID0+IHMuaW5kZXgpLm9yZGVyKCkuc3R5bGUoXCJzdHJva2Utb3BhY2l0eVwiLCBQZS5vcGFjaXR5LmRlZmF1bHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0LnBhcmVudC5zZWxlY3RBbGwoXCJwYXRoLmxpbmtcIikudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAgIChzKSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgdHJhbnNpdGlvbjogcyxcbiAgICAgICAgICBuYW1lOiBcImFsbHV2aWFsLWxpbmstbW91c2UtaGlnaGxpZ2h0XCJcbiAgICAgICAgfSlcbiAgICAgICkuc3R5bGUoXCJzdHJva2Utb3BhY2l0eVwiLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiByLnNvbWUoKGEpID0+IGEgPT09IHMuaW5kZXgpID8gKEkodGhpcykuY2xhc3NlZChcImxpbmstaG92ZXJlZFwiLCAhMCkucmFpc2UoKSwgUGUub3BhY2l0eS5zZWxlY3RlZCkgOiBQZS5vcGFjaXR5LnVuZm9jdXM7XG4gICAgICB9KTtcbiAgICB9LCA2Nik7XG4gICAgdC5wYXJlbnQuc2VsZWN0QWxsKFwiLm5vZGUtZ3JvdXBcIikub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24ociwgaSkge1xuICAgICAgY29uc3QgcyA9IEkodGhpcyksIGEgPSBbXTtcbiAgICAgIGlmICh0LnRyYXZlcnNlKHsgbGluazogXCJzb3VyY2VMaW5rc1wiLCBub2RlOiBcInRhcmdldFwiIH0sIGksIGEpLCB0LnRyYXZlcnNlKHsgbGluazogXCJ0YXJnZXRMaW5rc1wiLCBub2RlOiBcInNvdXJjZVwiIH0sIGksIGEpLCBhLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBvID0gTWkocy5hdHRyKFwidHJhbnNmb3JtXCIpKTtcbiAgICAgICAgaWYgKHMuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7by54IC0gMn0sICR7by55fSlgKSwgcy5jbGFzc2VkKFwibm9kZS1ob3ZlcmVkXCIsICEwKS5zZWxlY3RBbGwoXCJyZWN0Lm5vZGVcIikuYXR0cihcIndpZHRoXCIsIDgpLCBpLngwIC0gMiA9PT0gMCkge1xuICAgICAgICAgIGNvbnN0IGMgPSB0LnNlcnZpY2VzLmRvbVV0aWxzLmdlbmVyYXRlRWxlbWVudElEU3RyaW5nKFxuICAgICAgICAgICAgYGFsbHV2aWFsLW5vZGUtdGl0bGUtJHtpLmluZGV4fWBcbiAgICAgICAgICApLCB1ID0gdC5wYXJlbnQuc2VsZWN0KGBnIyR7Y31gKSwgZCA9IE1pKHUuYXR0cihcInRyYW5zZm9ybVwiKSk7XG4gICAgICAgICAgdS5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHtkLnggKyA0fSwke2QueX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbCA9IHQuc2VydmljZXMuZG9tVXRpbHMuZ2VuZXJhdGVFbGVtZW50SURTdHJpbmcoXG4gICAgICAgICAgYGFsbHV2aWFsLW5vZGUtdGV4dC0ke2kuaW5kZXh9YFxuICAgICAgICApO1xuICAgICAgICB0LnBhcmVudC5zZWxlY3QoYHRleHQjJHtsfWApLnN0eWxlKFwiZm9udC13ZWlnaHRcIiwgXCJib2xkXCIpLCBuKGEsIFwibW91c2VvdmVyXCIpLCB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuQWxsdXZpYWwuTk9ERV9NT1VTRU9WRVIsIHtcbiAgICAgICAgICBldmVudDogcixcbiAgICAgICAgICBlbGVtZW50OiBzLFxuICAgICAgICAgIGRhdHVtOiBpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKHIsIGkpIHtcbiAgICAgIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5BbGx1dmlhbC5OT0RFX01PVVNFTU9WRSwge1xuICAgICAgICBldmVudDogcixcbiAgICAgICAgZWxlbWVudDogSSh0aGlzKSxcbiAgICAgICAgZGF0dW06IGlcbiAgICAgIH0pLCB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5NT1ZFLCB7XG4gICAgICAgIGV2ZW50OiByXG4gICAgICB9KTtcbiAgICB9KS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKHIsIGkpIHtcbiAgICAgIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5BbGx1dmlhbC5OT0RFX0NMSUNLLCB7XG4gICAgICAgIGV2ZW50OiByLFxuICAgICAgICBlbGVtZW50OiBJKHRoaXMpLFxuICAgICAgICBkYXR1bTogaVxuICAgICAgfSk7XG4gICAgfSkub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihyLCBpKSB7XG4gICAgICBjb25zdCBzID0gSSh0aGlzKSwgYSA9IE1pKHMuYXR0cihcInRyYW5zZm9ybVwiKSk7XG4gICAgICBpZiAocy5jbGFzc2VkKFwibm9kZS1ob3ZlcmVkXCIsICExKS5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHthLnggKyAyfSwgJHthLnl9KWApLnNlbGVjdChcInJlY3Qubm9kZVwiKS5hdHRyKFwid2lkdGhcIiwgUGUubm9kZVdpZHRoKSwgaS54MCAtIDIgPT09IDApIHtcbiAgICAgICAgY29uc3QgbCA9IHQuc2VydmljZXMuZG9tVXRpbHMuZ2VuZXJhdGVFbGVtZW50SURTdHJpbmcoXG4gICAgICAgICAgYGFsbHV2aWFsLW5vZGUtdGl0bGUtJHtpLmluZGV4fWBcbiAgICAgICAgKSwgYyA9IHQucGFyZW50LnNlbGVjdChgZyMke2x9YCksIHUgPSBNaShjLmF0dHIoXCJ0cmFuc2Zvcm1cIikpO1xuICAgICAgICBjLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke3UueCAtIDR9LCR7dS55fSlgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG8gPSB0LnNlcnZpY2VzLmRvbVV0aWxzLmdlbmVyYXRlRWxlbWVudElEU3RyaW5nKFxuICAgICAgICBgYWxsdXZpYWwtbm9kZS10ZXh0LSR7aS5pbmRleH1gXG4gICAgICApO1xuICAgICAgdC5wYXJlbnQuc2VsZWN0KGB0ZXh0IyR7b31gKS5zdHlsZShcImZvbnQtd2VpZ2h0XCIsIFwibm9ybWFsXCIpLCBuKFtdLCBcIm1vdXNlb3V0XCIpLCB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuQWxsdXZpYWwuTk9ERV9NT1VTRU9VVCwge1xuICAgICAgICBldmVudDogcixcbiAgICAgICAgZWxlbWVudDogcyxcbiAgICAgICAgZGF0dW06IGlcbiAgICAgIH0pLCB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5ISURFLCB7XG4gICAgICAgIGhvdmVyZWRFbGVtZW50OiBzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvLyBUcmF2ZXJzZSBncmFwaCBhbmQgZ2V0IGFsbCBjb25uZWN0ZWQgbGlua3MgdG8gbm9kZVxuICB0cmF2ZXJzZSh0LCBuLCByID0gW10pIHtcbiAgICBuW3QubGlua10ubWFwKChpKSA9PiAoci5wdXNoKGkuaW5kZXgpLCBpW3Qubm9kZV0pKS5mb3JFYWNoKChpKSA9PiB0aGlzLnRyYXZlcnNlKHQsIGksIHIpKTtcbiAgfVxuICBnZXRSaWdodEFycm93SWNvbigpIHtcbiAgICByZXR1cm4gYFxuXHRcdDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiYXJyb3ctcmlnaHRcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiB2aWV3Qm94PVwiMCAwIDMyIDMyXCI+XG5cdFx0XHQ8cG9seWdvbiBwb2ludHM9XCIxOCA2IDE2LjU3IDcuMzkzIDI0LjE1IDE1IDQgMTUgNCAxNyAyNC4xNSAxNyAxNi41NyAyNC41NzMgMTggMjYgMjggMTYgMTggNlwiLz5cblx0XHRcdDxyZWN0IHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiLz5cblx0XHQ8L3N2Zz5gO1xuICB9XG4gIC8vIFJlbW92ZSBldmVudCBsaXN0ZW5lcnNcbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnBhcmVudC5zZWxlY3RBbGwoXCJwYXRoLmxpbmUsLm5vZGUtZ3JvdXBcIikub24oXCJtb3VzZW92ZXJcIiwgbnVsbCkub24oXCJtb3VzZW1vdmVcIiwgbnVsbCkub24oXCJjbGlja1wiLCBudWxsKS5vbihcIm1vdXNlb3V0XCIsIG51bGwpO1xuICB9XG59XG5jbGFzcyBPZSBleHRlbmRzIG10IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy50eXBlID0gXCJncmlkXCIsIHRoaXMucmVuZGVyVHlwZSA9IHJ0LlNWRztcbiAgfVxuICByZW5kZXIodCA9ICEwKSB7XG4gICAgY29uc3QgbiA9IHkodGhpcy5nZXRPcHRpb25zKCksIFwiZ3JpZFwiLCBcInhcIiwgXCJlbmFibGVkXCIpLCByID0geSh0aGlzLmdldE9wdGlvbnMoKSwgXCJncmlkXCIsIFwieVwiLCBcImVuYWJsZWRcIik7XG4gICAgdGhpcy5kcmF3QmFja2Ryb3AobiwgciksICEoIW4gJiYgIXIpICYmIChuICYmIChOLmFwcGVuZE9yU2VsZWN0KHRoaXMuYmFja2Ryb3AsIFwiZy54LmdyaWRcIiksIHRoaXMuZHJhd1hHcmlkKHQpKSwgciAmJiAoTi5hcHBlbmRPclNlbGVjdCh0aGlzLmJhY2tkcm9wLCBcImcueS5ncmlkXCIpLCB0aGlzLmRyYXdZR3JpZCh0KSkpO1xuICB9XG4gIGRyYXdYR3JpZCh0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMucGFyZW50LCByID0gdGhpcy5iYWNrZHJvcC5hdHRyKFwiaGVpZ2h0XCIpLCBpID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0TWFpblhTY2FsZSgpLCBzID0gSmMoaSkudGlja1NpemVJbm5lcigtcikudGlja1NpemVPdXRlcigwKTtcbiAgICBpZiAoeSh0aGlzLmdldE9wdGlvbnMoKSwgXCJncmlkXCIsIFwieFwiLCBcImFsaWduV2l0aEF4aXNUaWNrc1wiKSkge1xuICAgICAgY29uc3QgbyA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpbkF4aXNQb3NpdGlvbigpLCBsID0geSh0aGlzLmdldE9wdGlvbnMoKSwgXCJheGVzXCIsIG8sIFwidGlja3NcIiwgXCJ2YWx1ZXNcIik7XG4gICAgICBsICYmIHMudGlja1ZhbHVlcyhsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbyA9IHkodGhpcy5nZXRPcHRpb25zKCksIFwiZ3JpZFwiLCBcInhcIiwgXCJudW1iZXJPZlRpY2tzXCIpO1xuICAgICAgcy50aWNrcyhvKTtcbiAgICB9XG4gICAgY29uc3QgYSA9IG4uc2VsZWN0KFwiLnguZ3JpZFwiKS5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHstdGhpcy5iYWNrZHJvcC5hdHRyKFwieFwiKX0sICR7cn0pYCk7XG4gICAgdCA/IGEudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAobykgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICB0cmFuc2l0aW9uOiBvLFxuICAgICAgICBuYW1lOiBcImdyaWQtdXBkYXRlXCIsXG4gICAgICAgIGFuaW1hdGU6IHRcbiAgICAgIH0pXG4gICAgKS5jYWxsKHMpIDogYS5jYWxsKHMpLCB0aGlzLmNsZWFuR3JpZChhKTtcbiAgfVxuICBkcmF3WUdyaWQodCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLnBhcmVudCwgciA9IHRoaXMuYmFja2Ryb3AuYXR0cihcIndpZHRoXCIpLCBpID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0TWFpbllTY2FsZSgpLCBzID0gTGcoaSkudGlja1NpemVJbm5lcigtcikudGlja1NpemVPdXRlcigwKTtcbiAgICBpZiAoeSh0aGlzLmdldE9wdGlvbnMoKSwgXCJncmlkXCIsIFwieVwiLCBcImFsaWduV2l0aEF4aXNUaWNrc1wiKSkge1xuICAgICAgY29uc3QgbyA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlQXhpc1Bvc2l0aW9uKCksIGwgPSB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcImF4ZXNcIiwgbywgXCJ0aWNrc1wiLCBcInZhbHVlc1wiKTtcbiAgICAgIGwgJiYgcy50aWNrVmFsdWVzKGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvID0geSh0aGlzLmdldE9wdGlvbnMoKSwgXCJncmlkXCIsIFwieVwiLCBcIm51bWJlck9mVGlja3NcIik7XG4gICAgICBzLnRpY2tzKG8pO1xuICAgIH1cbiAgICBjb25zdCBhID0gbi5zZWxlY3QoXCIueS5ncmlkXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgwLCAkey10aGlzLmJhY2tkcm9wLmF0dHIoXCJ5XCIpfSlgKTtcbiAgICB0ID8gYS50cmFuc2l0aW9uKCkuY2FsbChcbiAgICAgIChvKSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgIHRyYW5zaXRpb246IG8sXG4gICAgICAgIG5hbWU6IFwiZ3JpZC11cGRhdGVcIixcbiAgICAgICAgYW5pbWF0ZTogdFxuICAgICAgfSlcbiAgICApLmNhbGwocykgOiBhLmNhbGwocyksIHRoaXMuY2xlYW5HcmlkKGEpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0aHJlc2hvbGQgZm9yIHRoZSBncmlkbGluZSB0b29sdGlwcyBiYXNlZCBvbiB0aGUgbW91c2UgbG9jYXRpb24uXG4gICAqIENhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIG1vdXNlIHBvc2l0aW9uIGJldHdlZW4gdGhlIHR3byBjbG9zZXN0IGdyaWRsaW5lcyBvciBlZGdlcyBvZiBjaGFydC5cbiAgICovXG4gIGdldEdyaWRsaW5lVGhyZXNob2xkKHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5wYXJlbnQsIHIgPSBuLnNlbGVjdEFsbChcIi54LmdyaWQgLnRpY2tcIikubm9kZXMoKS5zb3J0KCh1LCBkKSA9PiBOdW1iZXIoZm4odSkudHgpIC0gTnVtYmVyKGZuKGQpLnR4KSk7XG4gICAgbGV0IGkgPSAtMTtcbiAgICBpZiAoIXIubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIHIuZm9yRWFjaCgodSkgPT4ge1xuICAgICAgdFswXSA+PSArZm4odSkudHggJiYgaSsrO1xuICAgIH0pO1xuICAgIGNvbnN0IHMgPSBpICsgMSA8IHIubGVuZ3RoID8gaSArIDEgOiByLmxlbmd0aCwgYSA9IHJbaV0sIG8gPSByW3NdO1xuICAgIGxldCBsO1xuICAgIGlmICghYSlcbiAgICAgIGwgPSArZm4obykudHg7XG4gICAgZWxzZSBpZiAobylcbiAgICAgIGwgPSArZm4obykudHggLSArZm4oYSkudHg7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCB1ID0gbi5zZWxlY3QoXCJyZWN0LmNoYXJ0LWdyaWQtYmFja2Ryb3BcIikubm9kZSgpO1xuICAgICAgbCA9IE4uZ2V0U1ZHRWxlbWVudFNpemUodSkud2lkdGggLSArZm4oYSkudHg7XG4gICAgfVxuICAgIGNvbnN0IHsgdGhyZXNob2xkOiBjIH0gPSB0aGlzLmdldE9wdGlvbnMoKS50b29sdGlwLmdyaWRsaW5lO1xuICAgIHJldHVybiBsICogYztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYWN0aXZlIGdyaWRsaW5lcyBiYXNlZCBvbiB0aGUgZ3JpZGxpbmUgdGhyZXNob2xkIGFuZCBtb3VzZSBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHBvc2l0aW9uIG1vdXNlIHBvc2l0b25cbiAgICovXG4gIGdldEFjdGl2ZUdyaWRsaW5lKHQpIHtcbiAgICBjb25zdCBuID0geSh0aGlzLmdldE9wdGlvbnMsIFwidG9vbHRpcFwiLCBcImdyaWRsaW5lXCIsIFwidGhyZXNob2xkXCIpLCByID0gbiB8fCB0aGlzLmdldEdyaWRsaW5lVGhyZXNob2xkKHQpO1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5zZWxlY3RBbGwoXCIueC5ncmlkIC50aWNrXCIpLmZpbHRlcihmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGkgPSBmbih0aGlzKSwgcyA9IHtcbiAgICAgICAgbWluOiBOdW1iZXIoaS50eCkgLSByLFxuICAgICAgICBtYXg6IE51bWJlcihpLnR4KSArIHJcbiAgICAgIH07XG4gICAgICByZXR1cm4gcy5taW4gPD0gdFswXSAmJiB0WzBdIDw9IHMubWF4O1xuICAgIH0pO1xuICB9XG4gIGRyYXdCYWNrZHJvcCh0LCBuKSB7XG4gICAgY29uc3QgciA9IHRoaXMucGFyZW50LCBpID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0TWFpblhTY2FsZSgpLCBzID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0TWFpbllTY2FsZSgpLCBbYSwgb10gPSBpLnJhbmdlKCksIFtsLCBjXSA9IHMucmFuZ2UoKTtcbiAgICB0aGlzLmJhY2tkcm9wID0gTi5hcHBlbmRPclNlbGVjdChyLCBcInN2Zy5jaGFydC1ncmlkLWJhY2tkcm9wXCIpLmF0dHIoXG4gICAgICBcInJvbGVcIixcbiAgICAgIFwicHJlc2VudGF0aW9uXCJcbiAgICApO1xuICAgIGNvbnN0IHUgPSBOLmFwcGVuZE9yU2VsZWN0KFxuICAgICAgdGhpcy5iYWNrZHJvcCxcbiAgICAgIHQgfHwgbiA/IFwicmVjdC5jaGFydC1ncmlkLWJhY2tkcm9wLnN0cm9rZWRcIiA6IFwicmVjdC5jaGFydC1ncmlkLWJhY2tkcm9wXCJcbiAgICApO1xuICAgIHRoaXMuYmFja2Ryb3AubWVyZ2UodSkuYXR0cihcInhcIiwgYSkuYXR0cihcInlcIiwgYykuYXR0cihcIndpZHRoXCIsIE1hdGguYWJzKG8gLSBhKSkuYXR0cihcImhlaWdodFwiLCBNYXRoLmFicyhsIC0gYykpLmxvd2VyKCksIHUuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKS5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKTtcbiAgfVxuICBjbGVhbkdyaWQodCkge1xuICAgIHQuc2VsZWN0QWxsKFwidGV4dFwiKS5yZW1vdmUoKSwgdC5zZWxlY3QoXCIuZG9tYWluXCIpLnJlbW92ZSgpO1xuICB9XG59XG5jbGFzcyBFdiBleHRlbmRzIG10IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy50eXBlID0gXCJhcmVhXCIsIHRoaXMucmVuZGVyVHlwZSA9IHJ0LlNWRywgdGhpcy5ncmFkaWVudF9pZCA9IFwiZ3JhZGllbnQtaWQtXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA5OTk5OTk5OTk5OSksIHRoaXMuaGFuZGxlTGVnZW5kT25Ib3ZlciA9ICh0KSA9PiB7XG4gICAgICBjb25zdCB7IGhvdmVyZWRFbGVtZW50OiBuIH0gPSB0LmRldGFpbDtcbiAgICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcInBhdGguYXJlYVwiKS50cmFuc2l0aW9uKFwibGVnZW5kLWhvdmVyLWFyZWFcIikuY2FsbChcbiAgICAgICAgKHIpID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICB0cmFuc2l0aW9uOiByLFxuICAgICAgICAgIG5hbWU6IFwibGVnZW5kLWhvdmVyLWFyZWFcIlxuICAgICAgICB9KVxuICAgICAgKS5hdHRyKFwib3BhY2l0eVwiLCAocikgPT4gci5uYW1lICE9PSBuLmRhdHVtKCkubmFtZSA/IHluLm9wYWNpdHkudW5zZWxlY3RlZCA6IHluLm9wYWNpdHkuc2VsZWN0ZWQpO1xuICAgIH0sIHRoaXMuaGFuZGxlTGVnZW5kTW91c2VPdXQgPSAoKSA9PiB7XG4gICAgICB0aGlzLnBhcmVudC5zZWxlY3RBbGwoXCJwYXRoLmFyZWFcIikudHJhbnNpdGlvbihcImxlZ2VuZC1tb3VzZW91dC1hcmVhXCIpLmNhbGwoXG4gICAgICAgICh0KSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgdHJhbnNpdGlvbjogdCxcbiAgICAgICAgICBuYW1lOiBcImxlZ2VuZC1tb3VzZW91dC1hcmVhXCJcbiAgICAgICAgfSlcbiAgICAgICkuYXR0cihcIm9wYWNpdHlcIiwgeW4ub3BhY2l0eS5zZWxlY3RlZCk7XG4gICAgfTtcbiAgfVxuICBpbml0KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnNlcnZpY2VzLmV2ZW50cztcbiAgICB0LmFkZEV2ZW50TGlzdGVuZXIoVC5MZWdlbmQuSVRFTV9IT1ZFUiwgdGhpcy5oYW5kbGVMZWdlbmRPbkhvdmVyKSwgdC5hZGRFdmVudExpc3RlbmVyKFQuTGVnZW5kLklURU1fTU9VU0VPVVQsIHRoaXMuaGFuZGxlTGVnZW5kTW91c2VPdXQpO1xuICB9XG4gIHJlbmRlcih0ID0gITApIHtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoeyBhcmlhTGFiZWw6IFwiYXJlYSBncmFwaHNcIiwgd2l0aGluQ2hhcnRDbGlwOiAhMCB9KSwgciA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgIGxldCBpID0gWzAsIDBdO1xuICAgIGNvbnN0IHsgY2FydGVzaWFuU2NhbGVzOiBzIH0gPSB0aGlzLnNlcnZpY2VzLCBhID0gcy5nZXRPcmllbnRhdGlvbigpLCBvID0gYXUoKS5jdXJ2ZSh0aGlzLnNlcnZpY2VzLmN1cnZlcy5nZXREM0N1cnZlKCkpLmRlZmluZWQoKGIpID0+IHtcbiAgICAgIGNvbnN0IFMgPSBzLmdldFJhbmdlSWRlbnRpZmllcigpO1xuICAgICAgcmV0dXJuIGJbU10gIT0gbnVsbDtcbiAgICB9KSwgbCA9IHRoaXMubW9kZWwuZ2V0R3JvdXBlZERhdGEodGhpcy5jb25maWdzLmdyb3VwcyksIGMgPSB5KHIsIFwiYm91bmRzXCIpLCB1ID0gYyAmJiBsICYmIGwubGVuZ3RoID09PSAxO1xuICAgICF1ICYmIGMgJiYgY29uc29sZS53YXJuKFxuICAgICAgYEJvdW5kcyBjYW4gb25seSBiZSBzaG93biB3aGVuIGhhdmluZyAxIHNpbmdsZSBkYXRhZ3JvdXAsIHlvdSd2ZSBzdXBwbGllZCAke2wubGVuZ3RofWBcbiAgICApO1xuICAgIGxldCBkID0gMDtcbiAgICBjb25zdCBoID0gKGIsIFMpID0+IHtcbiAgICAgIHkociwgXCJheGVzXCIsIGIsIFwiaW5jbHVkZVplcm9cIikgPT09ICExICYmIFNbMF0gPiAwICYmIFNbMV0gPiAwICYmIChkID0gU1swXSk7XG4gICAgfSwgcCA9IChiKSA9PiB1ID8gcy5nZXRCb3VuZGVkU2NhbGVkVmFsdWVzKGIpWzBdIDogcy5nZXRSYW5nZVZhbHVlKGQpLCBmID0gKGIpID0+IHUgPyBzLmdldEJvdW5kZWRTY2FsZWRWYWx1ZXMoYilbMV0gOiBzLmdldFJhbmdlVmFsdWUoYik7XG4gICAgYSA9PT0gRnQuVkVSVElDQUwgPyAoaSA9IHMuZ2V0TWFpbllTY2FsZSgpLmRvbWFpbigpLCBoKHMuZ2V0TWFpbllBeGlzUG9zaXRpb24oKSwgaSksIG8ueCgoYikgPT4gcy5nZXREb21haW5WYWx1ZShiKSkueTAoKGIpID0+IHAoYikpLnkxKChiKSA9PiBmKGIpKSkgOiAoaSA9IHMuZ2V0TWFpblhTY2FsZSgpLmRvbWFpbigpLCBoKHMuZ2V0TWFpblhBeGlzUG9zaXRpb24oKSwgaSksIG8ueDAoKGIpID0+IHAoYikpLngxKChiKSA9PiBmKGIpKS55KChiKSA9PiBzLmdldERvbWFpblZhbHVlKGIpKSk7XG4gICAgY29uc3QgZyA9IHkociwgXCJjb2xvclwiLCBcImdyYWRpZW50XCIsIFwiZW5hYmxlZFwiKSwgbSA9IGwgJiYgbC5sZW5ndGggPT09IDEgJiYgZztcbiAgICBsLmxlbmd0aCA+IDEgJiYgZyAmJiBjb25zb2xlLmVycm9yKFwiR3JhZGllbnRzIGNhbiBvbmx5IGJlIGVuYWJsZWQgd2hlbiBoYXZpbmcgMSBzaW5nbGUgZGF0YXNldFwiKTtcbiAgICBjb25zdCB2ID0gbi5zZWxlY3RBbGwoXCJwYXRoLmFyZWFcIikuZGF0YShsLCAoYikgPT4gYi5uYW1lKSwgeCA9IEkodGhpcy5zZXJ2aWNlcy5kb21VdGlscy5nZXRNYWluQ29udGFpbmVyKCkpO1xuICAgIGlmICh2LmV4aXQoKS5hdHRyKFwib3BhY2l0eVwiLCAwKS5yZW1vdmUoKSwgIWwubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChtKSB7XG4gICAgICBjb25zdCBiID0geC5zZWxlY3QoXG4gICAgICAgIGBwYXRoLiR7dGhpcy5tb2RlbC5nZXRDb2xvckNsYXNzTmFtZSh7XG4gICAgICAgICAgY2xhc3NOYW1lVHlwZXM6IFtpdC5TVFJPS0VdLFxuICAgICAgICAgIGRhdGFHcm91cE5hbWU6IGxbMF0ubmFtZVxuICAgICAgICB9KX1gXG4gICAgICApLm5vZGUoKTtcbiAgICAgIGxldCBTO1xuICAgICAgaWYgKGIpXG4gICAgICAgIFMgPSBnZXRDb21wdXRlZFN0eWxlKGIsIG51bGwpLmdldFByb3BlcnR5VmFsdWUoXG4gICAgICAgICAgXCJzdHJva2VcIlxuICAgICAgICApO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IE0gPSB5KHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLCBcImNvbG9yXCIsIFwic2NhbGVcIik7XG4gICAgICAgIGlmIChNICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgRCA9IE9iamVjdC5rZXlzKE0pO1xuICAgICAgICAgIFMgPSBNW0RbMF1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBObC5hcHBlbmRPclVwZGF0ZUxpbmVhckdyYWRpZW50KHtcbiAgICAgICAgc3ZnOiB0aGlzLnBhcmVudCxcbiAgICAgICAgaWQ6IHRoaXMuc2VydmljZXMuZG9tVXRpbHMuZ2VuZXJhdGVFbGVtZW50SURTdHJpbmcoXG4gICAgICAgICAgYCR7bFswXS5uYW1lLnJlcGxhY2UoXCIgXCIsIFwiXCIpfV8ke3RoaXMuZ3JhZGllbnRfaWR9YFxuICAgICAgICApLFxuICAgICAgICB4MTogXCIwJVwiLFxuICAgICAgICB4MjogXCIwJVwiLFxuICAgICAgICB5MTogXCIwJVwiLFxuICAgICAgICB5MjogXCIxMDAlXCIsXG4gICAgICAgIHN0b3BzOiBObC5nZXRTdG9wcyhpLCBTKVxuICAgICAgfSk7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLnBhcmVudC5zZWxlY3RBbGwoXCJkZWZzIGxpbmVhckdyYWRpZW50XCIpLmVtcHR5KCkgfHwgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwiZGVmcyBsaW5lYXJHcmFkaWVudFwiKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnBhcmVudE5vZGUucmVtb3ZlKCk7XG4gICAgICB9KTtcbiAgICBjb25zdCBfID0gdGhpcywgRSA9IHYuZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpO1xuICAgIG0gPyBFLm1lcmdlKHYpLnN0eWxlKFxuICAgICAgXCJmaWxsXCIsXG4gICAgICAoYikgPT4gYHVybCgjJHt0aGlzLnNlcnZpY2VzLmRvbVV0aWxzLmdlbmVyYXRlRWxlbWVudElEU3RyaW5nKFxuICAgICAgICBgJHtiLm5hbWUucmVwbGFjZShcIiBcIiwgXCJcIil9XyR7dGhpcy5ncmFkaWVudF9pZH1gXG4gICAgICApfSlgXG4gICAgKS5hdHRyKFwiY2xhc3NcIiwgXCJhcmVhXCIpLmF0dHIoXG4gICAgICBcImNsYXNzXCIsXG4gICAgICAoYikgPT4gdGhpcy5tb2RlbC5nZXRDb2xvckNsYXNzTmFtZSh7XG4gICAgICAgIGNsYXNzTmFtZVR5cGVzOiBbaXQuRklMTF0sXG4gICAgICAgIGRhdGFHcm91cE5hbWU6IGIubmFtZSxcbiAgICAgICAgb3JpZ2luYWxDbGFzc05hbWU6IFwiYXJlYVwiXG4gICAgICB9KVxuICAgICkuYXR0cihcImRcIiwgKGIpID0+IHtcbiAgICAgIGNvbnN0IHsgZGF0YTogUyB9ID0gYjtcbiAgICAgIHJldHVybiBvKFMpO1xuICAgIH0pIDogKEUuYXR0cihcIm9wYWNpdHlcIiwgMCkubWVyZ2UodikuYXR0cihcImNsYXNzXCIsIFwiYXJlYVwiKS5hdHRyKFxuICAgICAgXCJjbGFzc1wiLFxuICAgICAgKGIpID0+IHRoaXMubW9kZWwuZ2V0Q29sb3JDbGFzc05hbWUoe1xuICAgICAgICBjbGFzc05hbWVUeXBlczogW2l0LkZJTEwsIGl0LlNUUk9LRV0sXG4gICAgICAgIGRhdGFHcm91cE5hbWU6IGIubmFtZSxcbiAgICAgICAgb3JpZ2luYWxDbGFzc05hbWU6IFwiYXJlYVwiXG4gICAgICB9KVxuICAgICkuc3R5bGUoXCJmaWxsXCIsIChiKSA9PiBfLm1vZGVsLmdldEZpbGxDb2xvcihiLm5hbWUsIG51bGwsIGIuZGF0YSkpLnRyYW5zaXRpb24oKS5jYWxsKFxuICAgICAgKGIpID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgdHJhbnNpdGlvbjogYixcbiAgICAgICAgbmFtZTogXCJhcmVhLXVwZGF0ZS1lbnRlclwiLFxuICAgICAgICBhbmltYXRlOiB0XG4gICAgICB9KVxuICAgICkuYXR0cihcIm9wYWNpdHlcIiwgdSA/IDEgOiB5bi5vcGFjaXR5LnNlbGVjdGVkKS5hdHRyKFwiZFwiLCAoYikgPT4ge1xuICAgICAgY29uc3QgeyBkYXRhOiBTIH0gPSBiO1xuICAgICAgcmV0dXJuIG8oUyk7XG4gICAgfSksIHUgJiYgRS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIHluLm9wYWNpdHkuc2VsZWN0ZWQpLnN0eWxlKFwic3Ryb2tlXCIsIChiKSA9PiBfLm1vZGVsLmdldFN0cm9rZUNvbG9yKGIubmFtZSwgbnVsbCwgYi5kYXRhKSkuc3R5bGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIFwiMiwgMlwiKS5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDAuNyArIFwicHhcIikpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuc2VydmljZXMuZXZlbnRzO1xuICAgIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX0hPVkVSLCB0aGlzLmhhbmRsZUxlZ2VuZE9uSG92ZXIpLCB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoVC5MZWdlbmQuSVRFTV9NT1VTRU9VVCwgdGhpcy5oYW5kbGVMZWdlbmRNb3VzZU91dCk7XG4gIH1cbn1cbmNsYXNzIEZyIGV4dGVuZHMgbXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnR5cGUgPSBcImxpbmVcIiwgdGhpcy5yZW5kZXJUeXBlID0gcnQuU1ZHLCB0aGlzLmhhbmRsZUxlZ2VuZE9uSG92ZXIgPSAodCkgPT4ge1xuICAgICAgY29uc3QgeyBob3ZlcmVkRWxlbWVudDogbiB9ID0gdC5kZXRhaWw7XG4gICAgICB0aGlzLnBhcmVudC5zZWxlY3RBbGwoXCJwYXRoLmxpbmVcIikudHJhbnNpdGlvbihcImxlZ2VuZC1ob3Zlci1saW5lXCIpLmNhbGwoXG4gICAgICAgIChyKSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgdHJhbnNpdGlvbjogcixcbiAgICAgICAgICBuYW1lOiBcImxlZ2VuZC1ob3Zlci1saW5lXCJcbiAgICAgICAgfSlcbiAgICAgICkuYXR0cihcIm9wYWNpdHlcIiwgKHIpID0+IHIubmFtZSAhPT0gbi5kYXR1bSgpLm5hbWUgPyB2bi5vcGFjaXR5LnVuc2VsZWN0ZWQgOiB2bi5vcGFjaXR5LnNlbGVjdGVkKTtcbiAgICB9LCB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlT3V0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwicGF0aC5saW5lXCIpLnRyYW5zaXRpb24oXCJsZWdlbmQtbW91c2VvdXQtbGluZVwiKS5jYWxsKFxuICAgICAgICAodCkgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICAgIHRyYW5zaXRpb246IHQsXG4gICAgICAgICAgbmFtZTogXCJsZWdlbmQtbW91c2VvdXQtbGluZVwiXG4gICAgICAgIH0pXG4gICAgICApLmF0dHIoXCJvcGFjaXR5XCIsIHZuLm9wYWNpdHkuc2VsZWN0ZWQpO1xuICAgIH07XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBjb25zdCB7IGV2ZW50czogdCB9ID0gdGhpcy5zZXJ2aWNlcztcbiAgICB0LmFkZEV2ZW50TGlzdGVuZXIoVC5MZWdlbmQuSVRFTV9IT1ZFUiwgdGhpcy5oYW5kbGVMZWdlbmRPbkhvdmVyKSwgdC5hZGRFdmVudExpc3RlbmVyKFQuTGVnZW5kLklURU1fTU9VU0VPVVQsIHRoaXMuaGFuZGxlTGVnZW5kTW91c2VPdXQpO1xuICB9XG4gIHJlbmRlcih0ID0gITApIHtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoeyBhcmlhTGFiZWw6IFwibGluZXNcIiwgd2l0aGluQ2hhcnRDbGlwOiAhMCB9KSwgeyBjYXJ0ZXNpYW5TY2FsZXM6IHIsIGN1cnZlczogaSB9ID0gdGhpcy5zZXJ2aWNlcywgcyA9IChwKSA9PiByLmdldERvbWFpblZhbHVlKHApLCBhID0gKHApID0+IHIuZ2V0UmFuZ2VWYWx1ZShwKSwgW28sIGxdID0gRW4oXG4gICAgICBzLFxuICAgICAgYSxcbiAgICAgIHIuZ2V0T3JpZW50YXRpb24oKVxuICAgICksIGMgPSB0aGlzLmdldE9wdGlvbnMoKSwgdSA9IHhzKCkueChvKS55KGwpLmN1cnZlKGkuZ2V0RDNDdXJ2ZSgpKS5kZWZpbmVkKChwKSA9PiB7XG4gICAgICBjb25zdCBmID0gci5nZXRSYW5nZUlkZW50aWZpZXIocCk7XG4gICAgICByZXR1cm4gcFtmXSAhPSBudWxsO1xuICAgIH0pO1xuICAgIGxldCBkID0gW107XG4gICAgaWYgKHRoaXMuY29uZmlncy5zdGFja2VkKSB7XG4gICAgICBjb25zdCBwID0gT2JqZWN0LmtleXMoYy5heGVzKS5zb21lKChnKSA9PiBjLmF4ZXNbZ10ucGVyY2VudGFnZSksIHsgZ3JvdXBNYXBzVG86IGYgfSA9IGMuZGF0YTtcbiAgICAgIGQgPSB0aGlzLm1vZGVsLmdldFN0YWNrZWREYXRhKHtcbiAgICAgICAgZ3JvdXBzOiB0aGlzLmNvbmZpZ3MuZ3JvdXBzLFxuICAgICAgICBwZXJjZW50YWdlOiBwXG4gICAgICB9KS5tYXAoKGcpID0+IHtcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpbklkZW50aWZpZXIoZyksIHYgPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRSYW5nZUlkZW50aWZpZXIoZyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogeShnLCAwLCBmKSxcbiAgICAgICAgICBkYXRhOiBnLm1hcCgoeCkgPT4gKHtcbiAgICAgICAgICAgIFttXTogeC5kYXRhLnNoYXJlZFN0YWNrS2V5LFxuICAgICAgICAgICAgW2ZdOiB4W2ZdLFxuICAgICAgICAgICAgW3ZdOiB4WzFdXG4gICAgICAgICAgfSkpLFxuICAgICAgICAgIGhpZGRlbjogIU5DKGcsICh4KSA9PiB4WzBdICE9PSB4WzFdKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlXG4gICAgICBkID0gdGhpcy5tb2RlbC5nZXRHcm91cGVkRGF0YSh0aGlzLmNvbmZpZ3MuZ3JvdXBzKTtcbiAgICBjb25zdCBoID0gbi5zZWxlY3RBbGwoXCJwYXRoLmxpbmVcIikuZGF0YShkLCAocCkgPT4gcC5uYW1lKTtcbiAgICBoLmV4aXQoKS5hdHRyKFwib3BhY2l0eVwiLCAwKS5yZW1vdmUoKSwgaC5lbnRlcigpLmFwcGVuZChcInBhdGhcIikuY2xhc3NlZChcImxpbmVcIiwgITApLmF0dHIoXCJvcGFjaXR5XCIsIDApLm1lcmdlKGgpLmRhdGEoZCwgKHApID0+IHAubmFtZSkuYXR0cihcbiAgICAgIFwiY2xhc3NcIixcbiAgICAgIChwKSA9PiB0aGlzLm1vZGVsLmdldENvbG9yQ2xhc3NOYW1lKHtcbiAgICAgICAgY2xhc3NOYW1lVHlwZXM6IFtpdC5TVFJPS0VdLFxuICAgICAgICBkYXRhR3JvdXBOYW1lOiBwLm5hbWUsXG4gICAgICAgIG9yaWdpbmFsQ2xhc3NOYW1lOiBcImxpbmVcIlxuICAgICAgfSlcbiAgICApLnN0eWxlKFwic3Ryb2tlXCIsIChwKSA9PiB0aGlzLm1vZGVsLmdldFN0cm9rZUNvbG9yKHAubmFtZSwgbnVsbCwgcC5kYXRhKSkuYXR0cihcInJvbGVcIiwgaHQuR1JBUEhJQ1NfU1lNQk9MKS5hdHRyKFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIiwgXCJsaW5lXCIpLmF0dHIoXCJhcmlhLWxhYmVsXCIsIChwKSA9PiB7XG4gICAgICBjb25zdCB7IGRhdGE6IGYgfSA9IHA7XG4gICAgICByZXR1cm4gZi5tYXAoKGcpID0+IHtcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlSWRlbnRpZmllcihnKTtcbiAgICAgICAgcmV0dXJuIGdbbV07XG4gICAgICB9KS5qb2luKFwiLFwiKTtcbiAgICB9KS50cmFuc2l0aW9uKCkuY2FsbChcbiAgICAgIChwKSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgIHRyYW5zaXRpb246IHAsXG4gICAgICAgIG5hbWU6IFwibGluZS11cGRhdGUtZW50ZXJcIixcbiAgICAgICAgYW5pbWF0ZTogdFxuICAgICAgfSlcbiAgICApLmF0dHIoXCJvcGFjaXR5XCIsIChwKSA9PiBwLmhpZGRlbiA/IDAgOiAxKS5hdHRyKFwiZFwiLCAocCkgPT4ge1xuICAgICAgY29uc3QgeyBkYXRhOiBmIH0gPSBwO1xuICAgICAgcmV0dXJuIHUoZik7XG4gICAgfSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5zZXJ2aWNlcy5ldmVudHM7XG4gICAgdC5yZW1vdmVFdmVudExpc3RlbmVyKFQuTGVnZW5kLklURU1fSE9WRVIsIHRoaXMuaGFuZGxlTGVnZW5kT25Ib3ZlciksIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX01PVVNFT1VULCB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlT3V0KTtcbiAgfVxufVxuY29uc3QgcHAgPSA1O1xuZnVuY3Rpb24gZEQoZSwgdCkge1xuICByZXR1cm4gZSA+IHQgLSBwcCAmJiBlIDwgdCArIHBwO1xufVxuY2xhc3MgVm4gZXh0ZW5kcyBtdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IFwicnVsZXJcIiwgdGhpcy5yZW5kZXJUeXBlID0gcnQuU1ZHLCB0aGlzLmlzWEdyaWRFbmFibGVkID0geSh0aGlzLmdldE9wdGlvbnMoKSwgXCJncmlkXCIsIFwieFwiLCBcImVuYWJsZWRcIiksIHRoaXMuaXNZR3JpZEVuYWJsZWQgPSB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcImdyaWRcIiwgXCJ5XCIsIFwiZW5hYmxlZFwiKSwgdGhpcy5pc0V2ZW50TGlzdGVuZXJBZGRlZCA9ICExO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIHJlbmRlcih0ID0gITEpIHtcbiAgICBjb25zdCBuID0geSh0aGlzLmdldE9wdGlvbnMoKSwgXCJydWxlclwiLCBcImVuYWJsZWRcIik7XG4gICAgdGhpcy5kcmF3QmFja2Ryb3AoKSwgbiAmJiAhdGhpcy5pc0V2ZW50TGlzdGVuZXJBZGRlZCA/IHRoaXMuYWRkQmFja2Ryb3BFdmVudExpc3RlbmVycygpIDogIW4gJiYgdGhpcy5pc0V2ZW50TGlzdGVuZXJBZGRlZCAmJiB0aGlzLnJlbW92ZUJhY2tkcm9wRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICByZW1vdmVCYWNrZHJvcEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaXNFdmVudExpc3RlbmVyQWRkZWQgPSAhMSwgdGhpcy5iYWNrZHJvcC5vbihcIm1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXRcIiwgbnVsbCk7XG4gIH1cbiAgZm9ybWF0VG9vbHRpcERhdGEodCkge1xuICAgIHJldHVybiB0O1xuICB9XG4gIHNob3dSdWxlcih0LCBbbiwgcl0pIHtcbiAgICBjb25zdCBpID0gdGhpcy5wYXJlbnQsIHMgPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRPcmllbnRhdGlvbigpLCBhID0gdGhpcy5tb2RlbC5nZXREaXNwbGF5RGF0YSgpLCBvID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0UmFuZ2VTY2FsZSgpLCBbbCwgY10gPSBvLnJhbmdlKCksIHUgPSBzID09PSBGdC5IT1JJWk9OVEFMID8gciA6IG4sIGQgPSBOLmFwcGVuZE9yU2VsZWN0KGksIFwiZy5ydWxlclwiKS5hdHRyKFwiYXJpYS1sYWJlbFwiLCBcInJ1bGVyXCIpLCBoID0gTi5hcHBlbmRPclNlbGVjdChkLCBcImxpbmUucnVsZXItbGluZVwiKSwgcCA9IGkuc2VsZWN0QWxsKFwiW3JvbGU9Z3JhcGhpY3Mtc3ltYm9sXVwiKSwgZiA9IGEubWFwKChtKSA9PiAoe1xuICAgICAgZG9tYWluVmFsdWU6IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpblZhbHVlKG0pLFxuICAgICAgb3JpZ2luYWxEYXRhOiBtXG4gICAgfSkpLmZpbHRlcigobSkgPT4gZEQobS5kb21haW5WYWx1ZSwgdSkpO1xuICAgIGlmICh0aGlzLnBvaW50c1dpdGhpbkxpbmUgJiYgZi5sZW5ndGggPT09IHRoaXMucG9pbnRzV2l0aGluTGluZS5sZW5ndGggJiYgZi5tYXAoKG0pID0+IG0uZG9tYWluVmFsdWUpLmpvaW4oKSA9PT0gdGhpcy5wb2ludHNXaXRoaW5MaW5lLm1hcCgobSkgPT4gbS5kb21haW5WYWx1ZSkuam9pbigpKVxuICAgICAgcmV0dXJuIHRoaXMucG9pbnRzV2l0aGluTGluZSA9IGYsIHRoaXMuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLk1PVkUsIHtcbiAgICAgICAgbW91c2VQb3NpdGlvbjogW24sIHJdXG4gICAgICB9KTtcbiAgICB0aGlzLnBvaW50c1dpdGhpbkxpbmUgPSBmO1xuICAgIGNvbnN0IGcgPSB0aGlzLnBvaW50c1dpdGhpbkxpbmUucmVkdWNlKChtLCB2KSA9PiB7XG4gICAgICBpZiAobS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBtLnB1c2godiksIG07XG4gICAgICBjb25zdCB4ID0gbVswXS5kb21haW5WYWx1ZSwgXyA9IE1hdGguYWJzKHUgLSB2LmRvbWFpblZhbHVlKSwgRSA9IE1hdGguYWJzKHUgLSB4KTtcbiAgICAgIHJldHVybiBfID4gRSB8fCAoXyA8IEUgPyBtID0gW3ZdIDogbS5wdXNoKHYpKSwgbTtcbiAgICB9LCBbXSk7XG4gICAgaWYgKGcubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbSA9IGcubWFwKChFKSA9PiBFLm9yaWdpbmFsRGF0YSkuZmlsdGVyKChFKSA9PiB7XG4gICAgICAgIGNvbnN0IGIgPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRSYW5nZUlkZW50aWZpZXIoRSk7XG4gICAgICAgIHJldHVybiBFW2JdICE9IG51bGw7XG4gICAgICB9KSwgdiA9IGcubWFwKFxuICAgICAgICAoRSkgPT4gRS5kb21haW5WYWx1ZVxuICAgICAgKSwgeCA9IHAuZmlsdGVyKChFKSA9PiB7XG4gICAgICAgIGNvbnN0IGIgPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXREb21haW5WYWx1ZShFKTtcbiAgICAgICAgcmV0dXJuIHYuaW5jbHVkZXMoYik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZWxlbWVudHNUb0hpZ2hsaWdodCAmJiB0aGlzLmVsZW1lbnRzVG9IaWdobGlnaHQuc2l6ZSgpID4gMCAmJiAhQ2codGhpcy5lbGVtZW50c1RvSGlnaGxpZ2h0LCB4KSAmJiB0aGlzLmhpZGVSdWxlcigpLCB4LmRpc3BhdGNoKFwibW91c2VvdmVyXCIpLCB0aGlzLmVsZW1lbnRzVG9IaWdobGlnaHQgPSB4LCB0aGlzLnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5TSE9XLCB7XG4gICAgICAgIGV2ZW50OiB0LFxuICAgICAgICBtb3VzZVBvc2l0aW9uOiBbbiwgcl0sXG4gICAgICAgIGhvdmVyZWRFbGVtZW50OiBoLFxuICAgICAgICBkYXRhOiB0aGlzLmZvcm1hdFRvb2x0aXBEYXRhKG0pXG4gICAgICB9KSwgZC5hdHRyKFwib3BhY2l0eVwiLCAxKTtcbiAgICAgIGNvbnN0IF8gPSBnWzBdO1xuICAgICAgcyA9PT0gXCJob3Jpem9udGFsXCIgPyBoLmF0dHIoXCJ4MVwiLCBjKS5hdHRyKFwieDJcIiwgbCkuYXR0cihcInkxXCIsIF8uZG9tYWluVmFsdWUpLmF0dHIoXCJ5MlwiLCBfLmRvbWFpblZhbHVlKSA6IGguYXR0cihcInkxXCIsIGMpLmF0dHIoXCJ5MlwiLCBsKS5hdHRyKFwieDFcIiwgXy5kb21haW5WYWx1ZSkuYXR0cihcIngyXCIsIF8uZG9tYWluVmFsdWUpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5oaWRlUnVsZXIoKTtcbiAgfVxuICBoaWRlUnVsZXIoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMucGFyZW50LCBuID0gTi5hcHBlbmRPclNlbGVjdCh0LCBcImcucnVsZXJcIik7XG4gICAgdC5zZWxlY3RBbGwoXCJbcm9sZT1ncmFwaGljcy1zeW1ib2xdXCIpLmRpc3BhdGNoKFwibW91c2VvdXRcIiksIHRoaXMuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLkhJREUpLCBuLmF0dHIoXCJvcGFjaXR5XCIsIDApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIHRoZSBsaXN0ZW5lciBvbiB0aGUgWCBncmlkIHRvIHRyaWdnZXIgbXVsdGlwbGUgcG9pbnQgdG9vbHRpcHMgYWxvbmcgdGhlIHggYXhpcy5cbiAgICovXG4gIGFkZEJhY2tkcm9wRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5pc0V2ZW50TGlzdGVuZXJBZGRlZCA9ICEwO1xuICAgIGNvbnN0IHQgPSB0aGlzLCBuID0gdGhpcy5zZXJ2aWNlcy5kb21VdGlscy5nZXRIb2xkZXIoKSwgciA9IHRoaXMubW9kZWwuZ2V0RGlzcGxheURhdGEoKTtcbiAgICBsZXQgaSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIGNvbnN0IGEgPSBycihzLCB0LnBhcmVudC5ub2RlKCkpO1xuICAgICAgdC5zaG93UnVsZXIocywgYSk7XG4gICAgfTtcbiAgICBpZiAoci5sZW5ndGggPiAxMDApIHtcbiAgICAgIGNvbnN0IHMgPSByLmxlbmd0aCAlIDUwICogMTIuNTtcbiAgICAgIGkgPSBpdyhcbiAgICAgICAgZnVuY3Rpb24oYSkge1xuICAgICAgICAgIGNvbnN0IHsgbW91c2VQb3NpdGlvbjogbyB9ID0gdGhpcztcbiAgICAgICAgICB0LnNob3dSdWxlcihhLCBvKTtcbiAgICAgICAgfSxcbiAgICAgICAgcyxcbiAgICAgICAgblxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5iYWNrZHJvcC5vbihcIm1vdXNlbW92ZSBtb3VzZW92ZXJcIiwgaSkub24oXCJtb3VzZW91dFwiLCB0aGlzLmhpZGVSdWxlci5iaW5kKHRoaXMpKTtcbiAgfVxuICBkcmF3QmFja2Ryb3AoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMucGFyZW50O1xuICAgIHRoaXMuYmFja2Ryb3AgPSBOLmFwcGVuZE9yU2VsZWN0KHQsIFwic3ZnLmNoYXJ0LWdyaWQtYmFja2Ryb3BcIik7XG4gIH1cbn1cbmxldCBubiA9IGNsYXNzIGV4dGVuZHMgbXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnR5cGUgPSBcInNjYXR0ZXJcIiwgdGhpcy5yZW5kZXJUeXBlID0gcnQuU1ZHLCB0aGlzLmhhbmRsZUNoYXJ0SG9sZGVyT25Ib3ZlciA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5wYXJlbnQpIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBub3QgZGVmaW5lZFwiKTtcbiAgICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcImNpcmNsZS5kb3RcIikudHJhbnNpdGlvbihcImNoYXJ0LWhvbGRlci1ob3Zlci1zY2F0dGVyXCIpLmNhbGwoXG4gICAgICAgICh0KSA9PiB7XG4gICAgICAgICAgdmFyIG47XG4gICAgICAgICAgcmV0dXJuIChuID0gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IG4uc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHQsXG4gICAgICAgICAgICBuYW1lOiBcImNoYXJ0LWhvbGRlci1ob3Zlci1zY2F0dGVyXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKS5hdHRyKFwib3BhY2l0eVwiLCAxKTtcbiAgICB9LCB0aGlzLmhhbmRsZUNoYXJ0SG9sZGVyT25Nb3VzZU91dCA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5wYXJlbnQpIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBub3QgZGVmaW5lZFwiKTtcbiAgICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcImNpcmNsZS5kb3RcIikudHJhbnNpdGlvbihcImNoYXJ0LWhvbGRlci1tb3VzZW91dC1zY2F0dGVyXCIpLmNhbGwoXG4gICAgICAgICh0KSA9PiB7XG4gICAgICAgICAgdmFyIG47XG4gICAgICAgICAgcmV0dXJuIChuID0gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IG4uc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHQsXG4gICAgICAgICAgICBuYW1lOiBcImNoYXJ0LWhvbGRlci1tb3VzZW91dC1zY2F0dGVyXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKS5hdHRyKFwib3BhY2l0eVwiLCAwKTtcbiAgICB9LCB0aGlzLmhhbmRsZUxlZ2VuZE9uSG92ZXIgPSAodCkgPT4ge1xuICAgICAgY29uc3QgeyBob3ZlcmVkRWxlbWVudDogbiB9ID0gdC5kZXRhaWwsIHsgZ3JvdXBNYXBzVG86IHIgfSA9IHRoaXMuZ2V0T3B0aW9ucygpLmRhdGE7XG4gICAgICBpZiAoIXRoaXMucGFyZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQgbm90IGRlZmluZWRcIik7XG4gICAgICB0aGlzLnBhcmVudC5zZWxlY3RBbGwoXCJjaXJjbGUuZG90XCIpLnRyYW5zaXRpb24oXCJsZWdlbmQtaG92ZXItc2NhdHRlclwiKS5jYWxsKFxuICAgICAgICAoaSkgPT4ge1xuICAgICAgICAgIHZhciBzO1xuICAgICAgICAgIHJldHVybiAocyA9IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBzLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBpLFxuICAgICAgICAgICAgbmFtZTogXCJsZWdlbmQtaG92ZXItc2NhdHRlclwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICkuYXR0cihcIm9wYWNpdHlcIiwgKGkpID0+IGlbcl0gIT09IG4uZGF0dW0oKS5uYW1lID8gMC4zIDogMSk7XG4gICAgfSwgdGhpcy5oYW5kbGVMZWdlbmRNb3VzZU91dCA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5wYXJlbnQpIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBub3QgZGVmaW5lZFwiKTtcbiAgICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcImNpcmNsZS5kb3RcIikudHJhbnNpdGlvbihcImxlZ2VuZC1tb3VzZW91dC1zY2F0dGVyXCIpLmNhbGwoXG4gICAgICAgICh0KSA9PiB7XG4gICAgICAgICAgdmFyIG47XG4gICAgICAgICAgcmV0dXJuIChuID0gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IG4uc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHQsXG4gICAgICAgICAgICBuYW1lOiBcImxlZ2VuZC1tb3VzZW91dC1zY2F0dGVyXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKS5hdHRyKFwib3BhY2l0eVwiLCAxKTtcbiAgICB9O1xuICB9XG4gIGluaXQoKSB7XG4gICAgY29uc3QgeyBldmVudHM6IHQgfSA9IHRoaXMuc2VydmljZXM7XG4gICAgaWYgKCF0KSB0aHJvdyBuZXcgRXJyb3IoXCJTZXJ2aWNlcyBldmVudHMgYXJlIHVuZGVmaW5lZC5cIik7XG4gICAgdC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgVC5MZWdlbmQuSVRFTV9IT1ZFUixcbiAgICAgIHRoaXMuaGFuZGxlTGVnZW5kT25Ib3ZlclxuICAgICksIHQuYWRkRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX01PVVNFT1VULCB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlT3V0KTtcbiAgICBjb25zdCB7IGZhZGVJbk9uQ2hhcnRIb2xkZXJNb3VzZW92ZXI6IG4gfSA9IHRoaXMuY29uZmlncztcbiAgICBuICYmICh0LmFkZEV2ZW50TGlzdGVuZXIoVC5DaGFydC5NT1VTRU9WRVIsIHRoaXMuaGFuZGxlQ2hhcnRIb2xkZXJPbkhvdmVyKSwgdC5hZGRFdmVudExpc3RlbmVyKFQuQ2hhcnQuTU9VU0VPVVQsIHRoaXMuaGFuZGxlQ2hhcnRIb2xkZXJPbk1vdXNlT3V0KSk7XG4gIH1cbiAgZmlsdGVyQmFzZWRPblpvb21Eb21haW4odCkge1xuICAgIGNvbnN0IHsgY2FydGVzaWFuU2NhbGVzOiBuIH0gPSB0aGlzLnNlcnZpY2VzO1xuICAgIGlmICghbikgdGhyb3cgbmV3IEVycm9yKFwiU2VydmljZXMgY2FydGVzaWFuU2NhbGVzIGFyZSB1bmRlZmluZWQuXCIpO1xuICAgIGNvbnN0IHIgPSBuLmdldERvbWFpbklkZW50aWZpZXIodCksIGkgPSB0aGlzLm1vZGVsLmdldChcInpvb21Eb21haW5cIik7XG4gICAgcmV0dXJuIGkgIT09IHZvaWQgMCA/IHQuZmlsdGVyKFxuICAgICAgKHMpID0+IHNbcl0uZ2V0VGltZSgpID49IGlbMF0uZ2V0VGltZSgpICYmIHNbcl0uZ2V0VGltZSgpIDw9IGlbMV0uZ2V0VGltZSgpXG4gICAgKSA6IHQ7XG4gIH1cbiAgZ2V0U2NhdHRlckRhdGEoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0T3B0aW9ucygpLCB7IHN0YWNrZWQ6IG4gfSA9IHRoaXMuY29uZmlncztcbiAgICBsZXQgcjtcbiAgICBpZiAobikge1xuICAgICAgY29uc3QgaSA9IE9iamVjdC5rZXlzKHQuYXhlcykuc29tZSgocykgPT4gdC5heGVzW3NdLnBlcmNlbnRhZ2UpO1xuICAgICAgciA9IHRoaXMubW9kZWwuZ2V0U3RhY2tlZERhdGEoe1xuICAgICAgICBncm91cHM6IHRoaXMuY29uZmlncy5ncm91cHMsXG4gICAgICAgIHBlcmNlbnRhZ2U6IGlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IGNhcnRlc2lhblNjYWxlczogaSB9ID0gdGhpcy5zZXJ2aWNlcztcbiAgICAgIGlmICghaSkgdGhyb3cgbmV3IEVycm9yKFwiU2VydmljZXMgY2FydGVzaWFuU2NhbGVzIGFyZSB1bmRlZmluZWQuXCIpO1xuICAgICAgciA9IHRoaXMubW9kZWwuZ2V0RGlzcGxheURhdGEodGhpcy5jb25maWdzLmdyb3VwcykuZmlsdGVyKChzKSA9PiB7XG4gICAgICAgIGNvbnN0IGEgPSBpLmdldFJhbmdlSWRlbnRpZmllcihzKTtcbiAgICAgICAgcmV0dXJuIHNbYV0gIT09IHZvaWQgMCAmJiBzW2FdICE9PSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbHRlckJhc2VkT25ab29tRG9tYWluKHIpO1xuICB9XG4gIHJlbmRlcih0KSB7XG4gICAgaWYgKCEoeSh0aGlzLmdldE9wdGlvbnMoKSwgXCJwb2ludHNcIiwgXCJlbmFibGVkXCIpIHx8IHkodGhpcy5nZXRPcHRpb25zKCksIFwiYnViYmxlXCIsIFwiZW5hYmxlZFwiKSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0Q29tcG9uZW50Q29udGFpbmVyKHsgYXJpYUxhYmVsOiBcInNjYXR0ZXIgcG9pbnRzXCIsIHdpdGhpbkNoYXJ0Q2xpcDogITAgfSksIHIgPSB0aGlzLmdldE9wdGlvbnMoKSwgeyBncm91cE1hcHNUbzogaSB9ID0gci5kYXRhLCB7IGNhcnRlc2lhblNjYWxlczogcyB9ID0gdGhpcy5zZXJ2aWNlcztcbiAgICBpZiAoIXMpIHRocm93IG5ldyBFcnJvcihcIlNlcnZpY2VzIGNhcnRlc2lhblNjYWxlcyBhcmUgdW5kZWZpbmVkLlwiKTtcbiAgICBjb25zdCBhID0gcy5nZXREb21haW5JZGVudGlmaWVyKCksIG8gPSBuLnNlbGVjdEFsbChcImNpcmNsZS5kb3RcIikuZGF0YShcbiAgICAgIHRoaXMuZ2V0U2NhdHRlckRhdGEoKSxcbiAgICAgIChjKSA9PiBgJHtjW2ldfS0ke2NbYV19YFxuICAgICk7XG4gICAgby5leGl0KCkuYXR0cihcIm9wYWNpdHlcIiwgMCkucmVtb3ZlKCk7XG4gICAgY29uc3QgbCA9IG8uZW50ZXIoKS5hcHBlbmQoXCJjaXJjbGVcIikuY2xhc3NlZChcImRvdFwiLCAhMCkuYXR0cihcIm9wYWNpdHlcIiwgMCkubWVyZ2Uobyk7XG4gICAgdGhpcy5zdHlsZUNpcmNsZXMobCwgdCksIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICAvLyBBIHZhbHVlIGlzIGFuIGFub21hbHkgaWYgaXMgYWJvdmUgYWxsIGRlZmluZWQgZG9tYWluIGFuZCByYW5nZSB0aHJlc2hvbGRzXG4gIGlzRGF0YXBvaW50VGhyZXNob2xkQW5vbWFseSh0KSB7XG4gICAgY29uc3QgeyBoYW5kbGVUaHJlc2hvbGRzOiBuIH0gPSB0aGlzLmNvbmZpZ3M7XG4gICAgaWYgKCFuKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHsgY2FydGVzaWFuU2NhbGVzOiByIH0gPSB0aGlzLnNlcnZpY2VzO1xuICAgIGlmICghcikgdGhyb3cgbmV3IEVycm9yKFwiQ2FydGVzaWFuIHNjYWxlcyBzZXJ2aWNlIGlzIHVuZGVmaW5lZFwiKTtcbiAgICBjb25zdCBpID0gci5nZXRPcmllbnRhdGlvbigpLCBbcywgYV0gPSBFbihcbiAgICAgIHIuZ2V0SGlnaGVzdERvbWFpblRocmVzaG9sZCgpLFxuICAgICAgci5nZXRIaWdoZXN0UmFuZ2VUaHJlc2hvbGQoKSxcbiAgICAgIGlcbiAgICApLCBbbywgbF0gPSBFbihcbiAgICAgIChkKSA9PiByLmdldERvbWFpblZhbHVlKGQpLFxuICAgICAgKGQpID0+IHIuZ2V0UmFuZ2VWYWx1ZShkKSxcbiAgICAgIGlcbiAgICApLCBjID0gbyh0KSwgdSA9IGwodCk7XG4gICAgcmV0dXJuIGEgJiYgcyA/IHUgPD0gYS5zY2FsZVZhbHVlICYmIGMgPj0gcy5zY2FsZVZhbHVlIDogYSA/IHUgPD0gYS5zY2FsZVZhbHVlIDogcyA/IGMgPj0gcy5zY2FsZVZhbHVlIDogITE7XG4gIH1cbiAgc3R5bGVDaXJjbGVzKHQsIG4pIHtcbiAgICBjb25zdCByID0gdGhpcy5nZXRPcHRpb25zKCksIHsgZmlsbGVkOiBpLCBmaWxsT3BhY2l0eTogcyB9ID0gci5wb2ludHMsIHsgY2FydGVzaWFuU2NhbGVzOiBhIH0gPSB0aGlzLnNlcnZpY2VzO1xuICAgIGlmICghYSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FydGVzaWFuIHNjYWxlcyBzZXJ2aWNlIGlzIHVuZGVmaW5lZFwiKTtcbiAgICBjb25zdCB7IGdyb3VwTWFwc1RvOiBvIH0gPSByLmRhdGEsIGwgPSAocCkgPT4gYS5nZXREb21haW5WYWx1ZShwKSwgYyA9IChwKSA9PiBhLmdldFJhbmdlVmFsdWUocCksIFt1LCBkXSA9IEVuKFxuICAgICAgbCxcbiAgICAgIGMsXG4gICAgICBhLmdldE9yaWVudGF0aW9uKClcbiAgICApLCB7IGZhZGVJbk9uQ2hhcnRIb2xkZXJNb3VzZW92ZXI6IGggfSA9IHRoaXMuY29uZmlncztcbiAgICB0LnJhaXNlKCkuY2xhc3NlZChcImRvdFwiLCAhMCkuYXR0cihcImNsYXNzXCIsIChwKSA9PiB7XG4gICAgICBjb25zdCBmID0gYS5nZXREb21haW5JZGVudGlmaWVyKHApLCBnID0gdGhpcy5tb2RlbC5nZXRJc0ZpbGxlZChwW29dLCBwW2ZdLCBwLCBpKSA/IFtpdC5GSUxMLCBpdC5TVFJPS0VdIDogW2l0LlNUUk9LRV07XG4gICAgICByZXR1cm4gdGhpcy5tb2RlbC5nZXRDb2xvckNsYXNzTmFtZSh7XG4gICAgICAgIGNsYXNzTmFtZVR5cGVzOiBnLFxuICAgICAgICBkYXRhR3JvdXBOYW1lOiBwW29dLFxuICAgICAgICBvcmlnaW5hbENsYXNzTmFtZTogXCJkb3RcIlxuICAgICAgfSkgfHwgXCJcIjtcbiAgICB9KS5jbGFzc2VkKFwidGhyZXNob2xkLWFub21hbHlcIiwgKHApID0+IHRoaXMuaXNEYXRhcG9pbnRUaHJlc2hvbGRBbm9tYWx5KHApKS5jbGFzc2VkKFwiZmlsbGVkXCIsIChwKSA9PiB7XG4gICAgICBjb25zdCBmID0gYS5nZXREb21haW5JZGVudGlmaWVyKHApO1xuICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZ2V0SXNGaWxsZWQocFtvXSwgcFtmXSwgcCwgaSk7XG4gICAgfSkuY2xhc3NlZChcInVuZmlsbGVkXCIsIChwKSA9PiB7XG4gICAgICBjb25zdCBmID0gYS5nZXREb21haW5JZGVudGlmaWVyKHApO1xuICAgICAgcmV0dXJuICF0aGlzLm1vZGVsLmdldElzRmlsbGVkKHBbb10sIHBbZl0sIHAsIGkpO1xuICAgIH0pLnRyYW5zaXRpb24oKS5jYWxsKFxuICAgICAgKHApID0+IHtcbiAgICAgICAgdmFyIGY7XG4gICAgICAgIHJldHVybiAoZiA9IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBmLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgdHJhbnNpdGlvbjogcCxcbiAgICAgICAgICBuYW1lOiBcInNjYXR0ZXItdXBkYXRlLWVudGVyXCIsXG4gICAgICAgICAgYW5pbWF0ZTogblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApLmF0dHIoXCJjeFwiLCB1KS5hdHRyKFwiY3lcIiwgZCkuYXR0cihcInJcIiwgci5wb2ludHMucmFkaXVzKS5zdHlsZShcImZpbGxcIiwgKHApID0+IHtcbiAgICAgIGNvbnN0IGYgPSBhLmdldERvbWFpbklkZW50aWZpZXIocCk7XG4gICAgICBpZiAodGhpcy5tb2RlbC5nZXRJc0ZpbGxlZChwW29dLCBwW2ZdLCBwLCBpKSlcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZ2V0RmlsbENvbG9yKHBbb10sIHBbZl0sIHApO1xuICAgIH0pLnN0eWxlKFwic3Ryb2tlXCIsIChwKSA9PiB7XG4gICAgICBjb25zdCBmID0gYS5nZXREb21haW5JZGVudGlmaWVyKHApO1xuICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZ2V0U3Ryb2tlQ29sb3IocFtvXSwgcFtmXSwgcCk7XG4gICAgfSkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCBpID8gcyA6IDEpLmF0dHIoXCJvcGFjaXR5XCIsIGggPyAwIDogMSkuYXR0cihcInJvbGVcIiwgaHQuR1JBUEhJQ1NfU1lNQk9MKS5hdHRyKFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIiwgXCJwb2ludFwiKS5hdHRyKFwiYXJpYS1sYWJlbFwiLCAocCkgPT4ge1xuICAgICAgY29uc3QgZiA9IGEuZ2V0UmFuZ2VJZGVudGlmaWVyKHApO1xuICAgICAgcmV0dXJuIHBbZl07XG4gICAgfSksIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICAvLyBFeHRlbmRlZCBpbiBidWJibGUgZ3JhcGhzXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGdldFRvb2x0aXBBZGRpdGlvbmFsSXRlbXModCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLCB7IGdyb3VwTWFwc1RvOiBuIH0gPSB0LmdldE9wdGlvbnMoKS5kYXRhO1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBub3QgZGVmaW5lZFwiKTtcbiAgICB0aGlzLnBhcmVudC5zZWxlY3RBbGwoXCJjaXJjbGVcIikub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24ociwgaSkge1xuICAgICAgdmFyIHMsIGE7XG4gICAgICBjb25zdCBvID0gSSh0aGlzKTtcbiAgICAgIG8uY2xhc3NlZChcImhvdmVyZWRcIiwgITApLmF0dHIoXG4gICAgICAgIFwiY2xhc3NcIixcbiAgICAgICAgKGwpID0+IHQubW9kZWwuZ2V0Q29sb3JDbGFzc05hbWUoe1xuICAgICAgICAgIGNsYXNzTmFtZVR5cGVzOiBbaXQuRklMTF0sXG4gICAgICAgICAgZGF0YUdyb3VwTmFtZTogbFtuXSxcbiAgICAgICAgICBvcmlnaW5hbENsYXNzTmFtZTogby5hdHRyKFwiY2xhc3NcIilcbiAgICAgICAgfSlcbiAgICAgICkuc3R5bGUoXCJmaWxsXCIsIChsKSA9PiB7XG4gICAgICAgIHZhciBjO1xuICAgICAgICBjb25zdCB1ID0gKGMgPSB0LnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IGMuZ2V0RG9tYWluSWRlbnRpZmllcihsKTtcbiAgICAgICAgcmV0dXJuIHQubW9kZWwuZ2V0RmlsbENvbG9yKGxbbl0sIGxbdV0sIGwpO1xuICAgICAgfSkuY2xhc3NlZChcInVuZmlsbGVkXCIsICExKSwgKHMgPSB0LnNlcnZpY2VzLmV2ZW50cykgPT0gbnVsbCB8fCBzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLlNIT1csIHtcbiAgICAgICAgZXZlbnQ6IHIsXG4gICAgICAgIGhvdmVyZWRFbGVtZW50OiBvLFxuICAgICAgICBkYXRhOiBbaV0sXG4gICAgICAgIGFkZGl0aW9uYWxJdGVtczogdC5nZXRUb29sdGlwQWRkaXRpb25hbEl0ZW1zKGkpXG4gICAgICB9KSwgKGEgPSB0LnNlcnZpY2VzLmV2ZW50cykgPT0gbnVsbCB8fCBhLmRpc3BhdGNoRXZlbnQoVC5TY2F0dGVyLlNDQVRURVJfTU9VU0VPVkVSLCB7XG4gICAgICAgIGV2ZW50OiByLFxuICAgICAgICBlbGVtZW50OiBvLFxuICAgICAgICBkYXR1bTogaVxuICAgICAgfSk7XG4gICAgfSkub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24ociwgaSkge1xuICAgICAgdmFyIHMsIGE7XG4gICAgICBjb25zdCBvID0gSSh0aGlzKTtcbiAgICAgIChzID0gdC5zZXJ2aWNlcy5ldmVudHMpID09IG51bGwgfHwgcy5kaXNwYXRjaEV2ZW50KFQuU2NhdHRlci5TQ0FUVEVSX01PVVNFTU9WRSwge1xuICAgICAgICBldmVudDogcixcbiAgICAgICAgZWxlbWVudDogbyxcbiAgICAgICAgZGF0dW06IGlcbiAgICAgIH0pLCAoYSA9IHQuc2VydmljZXMuZXZlbnRzKSA9PSBudWxsIHx8IGEuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuTU9WRSwge1xuICAgICAgICBldmVudDogclxuICAgICAgfSk7XG4gICAgfSkub24oXCJjbGlja1wiLCBmdW5jdGlvbihyLCBpKSB7XG4gICAgICB2YXIgcztcbiAgICAgIChzID0gdC5zZXJ2aWNlcy5ldmVudHMpID09IG51bGwgfHwgcy5kaXNwYXRjaEV2ZW50KFQuU2NhdHRlci5TQ0FUVEVSX0NMSUNLLCB7XG4gICAgICAgIGV2ZW50OiByLFxuICAgICAgICBlbGVtZW50OiBJKHRoaXMpLFxuICAgICAgICBkYXR1bTogaVxuICAgICAgfSk7XG4gICAgfSkub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihyLCBpKSB7XG4gICAgICB2YXIgcywgYSwgbztcbiAgICAgIGNvbnN0IGwgPSBJKHRoaXMpO1xuICAgICAgaWYgKGwuY2xhc3NlZChcImhvdmVyZWRcIiwgITEpLCAhdC5jb25maWdzLmZpbGxlZCkge1xuICAgICAgICBjb25zdCB7IGZpbGxlZDogYyB9ID0gdC5nZXRPcHRpb25zKCkucG9pbnRzLCB1ID0gKHMgPSB0LnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IHMuZ2V0RG9tYWluSWRlbnRpZmllcihpKSwgZCA9IHQubW9kZWwuZ2V0SXNGaWxsZWQoXG4gICAgICAgICAgaVtuXSxcbiAgICAgICAgICBpW3VdLFxuICAgICAgICAgIGksXG4gICAgICAgICAgY1xuICAgICAgICApO1xuICAgICAgICBsLmNsYXNzZWQoXCJ1bmZpbGxlZFwiLCAhZCkuc3R5bGUoXCJmaWxsXCIsIChoKSA9PiBkIHx8IGMgPyB0Lm1vZGVsLmdldEZpbGxDb2xvcihoW25dLCBoW3VdLCBoKSA6IG51bGwpO1xuICAgICAgfVxuICAgICAgKGEgPSB0LnNlcnZpY2VzLmV2ZW50cykgPT0gbnVsbCB8fCBhLmRpc3BhdGNoRXZlbnQoVC5TY2F0dGVyLlNDQVRURVJfTU9VU0VPVVQsIHtcbiAgICAgICAgZXZlbnQ6IHIsXG4gICAgICAgIGVsZW1lbnQ6IGwsXG4gICAgICAgIGRhdHVtOiBpXG4gICAgICB9KSwgKG8gPSB0LnNlcnZpY2VzLmV2ZW50cykgPT0gbnVsbCB8fCBvLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLkhJREUsIHtcbiAgICAgICAgaG92ZXJlZEVsZW1lbnQ6IGxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdmFyIHQ7XG4gICAgKHQgPSB0aGlzLnBhcmVudCkgPT0gbnVsbCB8fCB0LnNlbGVjdEFsbChcImNpcmNsZVwiKS5vbihcIm1vdXNlbW92ZVwiLCBudWxsKS5vbihcIm1vdXNlb3V0XCIsIG51bGwpO1xuICAgIGNvbnN0IHsgZXZlbnRzOiBuIH0gPSB0aGlzLnNlcnZpY2VzO1xuICAgIGlmICghbikgdGhyb3cgbmV3IEVycm9yKFwiU2VydmljZXMgZXZlbnRzIHVuZGVmaW5lZFwiKTtcbiAgICBuLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBULkxlZ2VuZC5JVEVNX0hPVkVSLFxuICAgICAgdGhpcy5oYW5kbGVMZWdlbmRPbkhvdmVyXG4gICAgKSwgbi5yZW1vdmVFdmVudExpc3RlbmVyKFQuTGVnZW5kLklURU1fTU9VU0VPVVQsIHRoaXMuaGFuZGxlTGVnZW5kTW91c2VPdXQpLCBuLnJlbW92ZUV2ZW50TGlzdGVuZXIoVC5DaGFydC5NT1VTRU9WRVIsIHRoaXMuaGFuZGxlQ2hhcnRIb2xkZXJPbkhvdmVyKSwgbi5yZW1vdmVFdmVudExpc3RlbmVyKFQuQ2hhcnQuTU9VU0VPVVQsIHRoaXMuaGFuZGxlQ2hhcnRIb2xkZXJPbk1vdXNlT3V0KTtcbiAgfVxufTtcbmNsYXNzIE92IGV4dGVuZHMgbXQge1xuICBjb25zdHJ1Y3Rvcih0LCBuLCByKSB7XG4gICAgc3VwZXIodCwgbiwgciksIHRoaXMudHlwZSA9IFwiYXhlc1wiLCB0aGlzLnJlbmRlclR5cGUgPSBydC5TVkcsIHRoaXMudHJ1bmNhdGlvbiA9IHtcbiAgICAgIFtHLkxFRlRdOiAhMSxcbiAgICAgIFtHLlJJR0hUXTogITEsXG4gICAgICBbRy5UT1BdOiAhMSxcbiAgICAgIFtHLkJPVFRPTV06ICExXG4gICAgfSwgciAmJiAodGhpcy5jb25maWdzID0gciksIHRoaXMubWFyZ2lucyA9IHRoaXMuY29uZmlncy5tYXJnaW5zO1xuICB9XG4gIHJlbmRlcih0ID0gITApIHtcbiAgICBjb25zdCB7IHBvc2l0aW9uOiBuIH0gPSB0aGlzLmNvbmZpZ3MsIHIgPSB0aGlzLmdldE9wdGlvbnMoKSwgaSA9IHkociwgXCJheGVzXCIsIG4sIFwidmlzaWJsZVwiKSwgcyA9IHRoaXMuZ2V0Q29tcG9uZW50Q29udGFpbmVyKHtcbiAgICAgIGFyaWFMYWJlbDogXCJheGVzXCJcbiAgICB9KSwgeyB3aWR0aDogYSwgaGVpZ2h0OiBvIH0gPSBOLmdldFNWR0VsZW1lbnRTaXplKHMsIHtcbiAgICAgIHVzZUF0dHJzOiAhMFxuICAgIH0pLCBsID0gTi5hcHBlbmRPclNlbGVjdChzLCBgZy5heGlzLiR7bn1gKTtcbiAgICBsZXQgYywgdTtcbiAgICBpZiAobiA9PT0gRy5CT1RUT00gfHwgbiA9PT0gRy5UT1AgPyAoYyA9IHRoaXMuY29uZmlncy5heGVzW0cuTEVGVF0gPyB0aGlzLm1hcmdpbnMubGVmdCA6IDAsIHUgPSB0aGlzLmNvbmZpZ3MuYXhlc1tHLlJJR0hUXSA/IGEgLSB0aGlzLm1hcmdpbnMucmlnaHQgOiBhKSA6IChjID0gbyAtIHRoaXMubWFyZ2lucy5ib3R0b20sIHUgPSB0aGlzLm1hcmdpbnMudG9wKSwgIXRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzKSB0aHJvdyBuZXcgRXJyb3IoXCJTZXJ2aWNlcyBjYXJ0ZXNpYW5TY2FsZXMgdW5kZWZpbmVkXCIpO1xuICAgIGNvbnN0IGQgPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRTY2FsZUJ5UG9zaXRpb24obik7XG4gICAgdGhpcy5zY2FsZVR5cGUgPT09IGV0LkxBQkVMUyB8fCB0aGlzLnNjYWxlVHlwZSA9PT0gZXQuTEFCRUxTX1JBVElPID8gZC5yYW5nZVJvdW5kKFtjLCB1XSkgOiBkLnJhbmdlKFtjLCB1XSk7XG4gICAgbGV0IGg7XG4gICAgc3dpdGNoIChuKSB7XG4gICAgICBjYXNlIEcuTEVGVDpcbiAgICAgICAgaCA9IExnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRy5CT1RUT006XG4gICAgICAgIGggPSBKYztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEcuUklHSFQ6XG4gICAgICAgIGggPSBqQztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEcuVE9QOlxuICAgICAgICBoID0gRkM7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsLmF0dHIoXCJhcmlhLWxhYmVsXCIsIGAke259IGF4aXNgKTtcbiAgICBjb25zdCBwID0gIWwuc2VsZWN0KFwiZy50aWNrc1wiKS5lbXB0eSgpO1xuICAgIGxldCBmID0gTi5hcHBlbmRPclNlbGVjdChsLCBcImcudGlja3NcIik7XG4gICAgcCB8fCAoZi5hdHRyKFwicm9sZVwiLCBgJHtodC5HUkFQSElDU19PQkpFQ1R9ICR7aHQuR1JPVVB9YCksIGYuYXR0cihcImFyaWEtbGFiZWxcIiwgYCR7bn0gdGlja3NgKSk7XG4gICAgY29uc3QgZyA9IE4uYXBwZW5kT3JTZWxlY3QobCwgXCJnLnRpY2tzLmludmlzaWJsZVwiKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLCAhMCkuYXR0cihcImFyaWEtbGFiZWxcIiwgYGludmlzaWJsZSAke259IHRpY2tzYCksIG0gPSB5KHIsIFwiYXhlc1wiLCBuKSwgdiA9IHRoaXMuc2NhbGVUeXBlID09PSBldC5USU1FIHx8IG0uc2NhbGVUeXBlID09PSBldC5USU1FLCB4ID0gbiA9PT0gRy5MRUZUIHx8IG4gPT09IEcuUklHSFQsIF8gPSB0aGlzLm1vZGVsLmdldChcInpvb21Eb21haW5cIik7XG4gICAgaWYgKF8gJiYgdiAmJiAheCAmJiBkLmRvbWFpbihfKSwgIWkpIHtcbiAgICAgIGYuYXR0cihcImFyaWEtaGlkZGVuXCIsICEwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgRSA9IHkobSwgXCJzY2FsZVR5cGVcIiksIGIgPSB5KHIsIFwiZGF0YVwiLCBcImxvYWRpbmdcIiksIFMgPSB5KG0sIFwidGlja3NcIiwgXCJudW1iZXJcIiksIE0gPSB5KG0sIFwidGlja3NcIiwgXCJ2YWx1ZXNcIiksIEQgPSB5KG0sIFwidHJ1bmNhdGlvblwiLCBcInR5cGVcIiksIEEgPSB5KG0sIFwidHJ1bmNhdGlvblwiLCBcInRocmVzaG9sZFwiKSwgUiA9IHkobSwgXCJ0cnVuY2F0aW9uXCIsIFwibnVtQ2hhcmFjdGVyXCIpLCAkID0gUyAhPT0gbnVsbCwgSCA9IHkociwgXCJ0aW1lU2NhbGVcIiksIFAgPSBOLmFwcGVuZE9yU2VsZWN0KGcsIFwiZy50aWNrXCIpLCBCID0gTi5hcHBlbmRPclNlbGVjdChQLCBcInRleHRcIikudGV4dChcIjBcIiksIE8gPSBOLmdldFNWR0VsZW1lbnRTaXplKEIubm9kZSgpLCB7XG4gICAgICB1c2VCQm94OiAhMFxuICAgIH0pLmhlaWdodDtcbiAgICBQLnJlbW92ZSgpO1xuICAgIGNvbnN0IHcgPSB0aGlzLnNjYWxlVHlwZSB8fCBtLnNjYWxlVHlwZSB8fCBldC5MSU5FQVIsIEwgPSBoKGQpLnRpY2tTaXplT3V0ZXIoMCk7XG4gICAgaWYgKGQudGlja3MpIHtcbiAgICAgIGxldCBxO1xuICAgICAgaWYgKCQgPyBxID0gUyA6IChxID0gUG4udGlja3MubnVtYmVyLCB4ICYmIChxID0gdGhpcy5nZXROdW1iZXJPZkZpdHRpbmdUaWNrcyhcbiAgICAgICAgbyxcbiAgICAgICAgTyxcbiAgICAgICAgUG4udGlja3MudmVydGljYWxTcGFjZVJhdGlvXG4gICAgICApKSksIGQudGlja3MoKS5sZW5ndGggPT09IDEgJiYgZC50aWNrcygpWzBdID09PSAwICYmIChxID0gMCksIEwudGlja3MocSksIHYpXG4gICAgICAgIGlmICghZC50aWNrcyhxKS5sZW5ndGgpXG4gICAgICAgICAgTC50aWNrVmFsdWVzKFtdKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3QgdHQgPSB5KHIsIFwidGltZVNjYWxlXCIsIFwiYWRkU3BhY2VPbkVkZ2VzXCIpLCBsdCA9IHkociwgXCJheGVzXCIsIG4sIFwiZG9tYWluXCIpLCB6ID0gZC5jb3B5KCk7XG4gICAgICAgICAgdHQgJiYgIWx0ICYmIHoubmljZShxKTtcbiAgICAgICAgICBjb25zdCBXID0gei50aWNrcyhxKTtcbiAgICAgICAgICB0dCAmJiBXLmxlbmd0aCA+IDIgJiYgIWx0ICYmIChXLnNwbGljZShXLmxlbmd0aCAtIDEsIDEpLCBXLnNwbGljZSgwLCAxKSksIEwudGlja1ZhbHVlcyhXKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgaztcbiAgICBjb25zdCBVID0geShtLCBcInRpY2tzXCIsIFwiZm9ybWF0dGVyXCIpLCB7IGNvZGU6IFosIG51bWJlcjogaiB9ID0geShyLCBcImxvY2FsZVwiKTtcbiAgICBpZiAodikge1xuICAgICAgY29uc3QgcSA9IERsKFxuICAgICAgICBMLnRpY2tWYWx1ZXMoKSxcbiAgICAgICAgeShyLCBcInRpbWVTY2FsZVwiLCBcInRpbWVJbnRlcnZhbFwiKVxuICAgICAgKTtcbiAgICAgIFUgPT09IG51bGwgPyBrID0gKHR0LCBsdCkgPT4ga2wodHQsIGx0LCBMLnRpY2tWYWx1ZXMoKSwgcSwgSCwgci5sb2NhbGUpIDogayA9ICh0dCwgbHQpID0+IHtcbiAgICAgICAgY29uc3QgeiA9IGtsKFxuICAgICAgICAgIHR0LFxuICAgICAgICAgIGx0LFxuICAgICAgICAgIEwudGlja1ZhbHVlcygpLFxuICAgICAgICAgIHEsXG4gICAgICAgICAgSCxcbiAgICAgICAgICByLmxvY2FsZVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gVSh0dCwgbHQsIHopO1xuICAgICAgfTtcbiAgICB9IGVsc2VcbiAgICAgIFUgPT09IG51bGwgPyB3ID09PSBldC5MSU5FQVIgJiYgKGsgPSAocSkgPT4gaihxLCBaKSkgOiBrID0gVTtcbiAgICBMLnRpY2tGb3JtYXQoayk7XG4gICAgY29uc3QgW0YsIFldID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0U2NhbGVCeVBvc2l0aW9uKG4pLmRvbWFpbigpO1xuICAgIGxldCBvdDtcbiAgICBpZiAoTSkge1xuICAgICAgaWYgKHYpXG4gICAgICAgIE0uZm9yRWFjaCgocSwgdHQpID0+IHtcbiAgICAgICAgICBxLmdldFRpbWUgPT09IHZvaWQgMCAmJiAoTVt0dF0gPSBuZXcgRGF0ZShxKSk7XG4gICAgICAgIH0pLCBvdCA9IE0uZmlsdGVyKChxKSA9PiB7XG4gICAgICAgICAgY29uc3QgdHQgPSBxLmdldFRpbWUoKTtcbiAgICAgICAgICByZXR1cm4gdHQgPj0gbmV3IERhdGUoRikuZ2V0VGltZSgpICYmIHR0IDw9IG5ldyBEYXRlKFkpLmdldFRpbWUoKTtcbiAgICAgICAgfSk7XG4gICAgICBlbHNlIGlmIChFID09PSBldC5MQUJFTFMpIHtcbiAgICAgICAgY29uc3QgcSA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFNjYWxlQnlQb3NpdGlvbihuKS5kb21haW4oKTtcbiAgICAgICAgb3QgPSBNLmZpbHRlcigodHQpID0+IHEuaW5jbHVkZXModHQpKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBvdCA9IE0uZmlsdGVyKFxuICAgICAgICAgIChxKSA9PiBxID49IEYgJiYgcSA8PSBZXG4gICAgICAgICk7XG4gICAgICBMLnRpY2tWYWx1ZXMob3QpO1xuICAgIH1cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgIGNhc2UgRy5MRUZUOlxuICAgICAgICBmLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke3RoaXMubWFyZ2lucy5sZWZ0fSwgMClgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEcuQk9UVE9NOlxuICAgICAgICBmLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgwLCAke28gLSB0aGlzLm1hcmdpbnMuYm90dG9tfSlgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEcuUklHSFQ6XG4gICAgICAgIGYuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7YSAtIHRoaXMubWFyZ2lucy5yaWdodH0sIDApYCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHLlRPUDpcbiAgICAgICAgZi5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoMCwgJHt0aGlzLm1hcmdpbnMudG9wfSlgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IFEgPSB0aGlzLm1vZGVsLmlzRGF0YUVtcHR5KCk7XG4gICAgaWYgKG0udGl0bGUpIHtcbiAgICAgIGNvbnN0IHEgPSBOLmFwcGVuZE9yU2VsZWN0KGwsIFwidGV4dC5heGlzLXRpdGxlXCIpLmh0bWwoXG4gICAgICAgIFEgfHwgYiA/IFwiXCIgOiBlbihtLnRpdGxlKVxuICAgICAgKSwgdHQgPSB5KG0sIFwidGl0bGVPcmllbnRhdGlvblwiKTtcbiAgICAgIGxldCBsdDtcbiAgICAgIHN3aXRjaCAobikge1xuICAgICAgICBjYXNlIEcuTEVGVDpcbiAgICAgICAgICB0dCA9PT0gZmwuUklHSFQgPyBxLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJyb3RhdGUoOTApXCIpLmF0dHIoXCJ5XCIsIDApLmF0dHIoXCJ4XCIsIGQucmFuZ2UoKVswXSAvIDIpLmF0dHIoXCJkeVwiLCBcIi0wLjVlbVwiKS5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpIDogcS5hdHRyKFwidHJhbnNmb3JtXCIsIFwicm90YXRlKC05MClcIikuYXR0cihcInlcIiwgMCkuYXR0cihcInhcIiwgLShkLnJhbmdlKClbMF0gLyAyKSkuYXR0cihcImR5XCIsIFwiMC43NWVtXCIpLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRy5CT1RUT006XG4gICAgICAgICAgcS5hdHRyKFxuICAgICAgICAgICAgXCJ0cmFuc2Zvcm1cIixcbiAgICAgICAgICAgIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbnMubGVmdCAvIDIgKyBkLnJhbmdlKClbMV0gLyAyfSwgJHtvICsgNH0pYFxuICAgICAgICAgICkuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHLlJJR0hUOlxuICAgICAgICAgIHR0ID09PSBmbC5MRUZUID8gcS5hdHRyKFwidHJhbnNmb3JtXCIsIFwicm90YXRlKC05MClcIikuYXR0cihcInlcIiwgYSkuYXR0cihcInhcIiwgLShkLnJhbmdlKClbMF0gLyAyKSkuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKSA6IHEuYXR0cihcInRyYW5zZm9ybVwiLCBcInJvdGF0ZSg5MClcIikuYXR0cihcInlcIiwgLWEpLmF0dHIoXCJ4XCIsIGQucmFuZ2UoKVswXSAvIDIpLmF0dHIoXCJkeVwiLCBcIjAuNzVlbVwiKS5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEcuVE9QOlxuICAgICAgICAgIGx0ID0gTi5nZXRTVkdFbGVtZW50U2l6ZShxLCB7XG4gICAgICAgICAgICB1c2VCQm94OiAhMFxuICAgICAgICAgIH0pLmhlaWdodCwgcS5hdHRyKFxuICAgICAgICAgICAgXCJ0cmFuc2Zvcm1cIixcbiAgICAgICAgICAgIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbnMubGVmdCAvIDIgKyBkLnJhbmdlKClbMV0gLyAyfSwgJHtsdCAvIDJ9KWBcbiAgICAgICAgICApLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2KSB7XG4gICAgICBjb25zdCBxID0gRGwoXG4gICAgICAgIEwudGlja1ZhbHVlcygpLFxuICAgICAgICB5KHIsIFwidGltZVNjYWxlXCIsIFwidGltZUludGVydmFsXCIpXG4gICAgICApLCB0dCA9IEguc2hvd0RheU5hbWUsIGx0ID0gZjtcbiAgICAgIHQgJiYgKGYgPSBmLnRyYW5zaXRpb24oKS5jYWxsKFxuICAgICAgICAoeikgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICAgIHRyYW5zaXRpb246IHosXG4gICAgICAgICAgbmFtZTogXCJheGlzLXVwZGF0ZVwiLFxuICAgICAgICAgIGFuaW1hdGU6IHRcbiAgICAgICAgfSlcbiAgICAgICkpLCBmID0gZi5jYWxsKEwpLCBsdC5zZWxlY3RBbGwoXCIudGlja1wiKS5kYXRhKEwudGlja1ZhbHVlcygpLCBkKS5vcmRlcigpLnNlbGVjdChcInRleHRcIikuYXR0cihcbiAgICAgICAgXCJjbGFzc1wiLFxuICAgICAgICAoeiwgVykgPT4gR20oeiwgVywgTC50aWNrVmFsdWVzKCksIHEsIHR0KSA/IFwidGljay1sYWJlbC0tcHJpbWFyeVwiIDogXCJ0aWNrLWxhYmVsXCJcbiAgICAgICk7XG4gICAgfSBlbHNlXG4gICAgICAhdCB8fCAhcCA/IGYgPSBmLmNhbGwoTCkgOiBmID0gZi50cmFuc2l0aW9uKCkuY2FsbChcbiAgICAgICAgKHEpID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICB0cmFuc2l0aW9uOiBxLFxuICAgICAgICAgIG5hbWU6IFwiYXhpcy11cGRhdGVcIixcbiAgICAgICAgICBhbmltYXRlOiB0XG4gICAgICAgIH0pXG4gICAgICApLmNhbGwoTCk7XG4gICAgaWYgKGcuY2FsbChMKSwgbiA9PT0gRy5CT1RUT00gfHwgbiA9PT0gRy5UT1ApIHtcbiAgICAgIGxldCBxID0gITE7XG4gICAgICBjb25zdCB0dCA9IHkobSwgXCJ0aWNrc1wiLCBcInJvdGF0aW9uXCIpO1xuICAgICAgaWYgKHR0ID09PSBXcy5BTFdBWVMpXG4gICAgICAgIHEgPSAhMDtcbiAgICAgIGVsc2UgaWYgKHR0ID09PSBXcy5ORVZFUilcbiAgICAgICAgcSA9ICExO1xuICAgICAgZWxzZSBpZiAoIXR0IHx8IHR0ID09PSBXcy5BVVRPKVxuICAgICAgICBpZiAoZC5zdGVwKVxuICAgICAgICAgIHEgPSBnLnNlbGVjdEFsbChcImcudGljayB0ZXh0XCIpLm5vZGVzKCkuc29tZShcbiAgICAgICAgICAgIChsdCkgPT4gTi5nZXRTVkdFbGVtZW50U2l6ZShsdCwge1xuICAgICAgICAgICAgICB1c2VCQm94OiAhMFxuICAgICAgICAgICAgfSkud2lkdGggPj0gZC5zdGVwKClcbiAgICAgICAgICApO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBxID0gITE7XG4gICAgICAgICAgY29uc3QgbHQgPSBnLmFwcGVuZChcInRleHRcIikudGV4dChcIkFcIiksIHogPSBOLmdldFNWR0VsZW1lbnRTaXplKGx0Lm5vZGUoKSwge1xuICAgICAgICAgICAgdXNlQkJveDogITBcbiAgICAgICAgICB9KS53aWR0aDtcbiAgICAgICAgICBsZXQgVztcbiAgICAgICAgICBnLnNlbGVjdEFsbChcImcudGlja1wiKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc3QgWCA9IEkodGhpcyksIFYgPSBwYXJzZUZsb2F0KHkoZm4odGhpcyksIFwidHhcIikpO1xuICAgICAgICAgICAgViAhPT0gbnVsbCAmJiBXICsgWC50ZXh0KCkubGVuZ3RoICogeiAqIDAuOCA+PSBWICYmIChxID0gITApLCBXID0gVjtcbiAgICAgICAgICB9KSwgbHQucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIHEgPyAoJCB8fCAoTC50aWNrcyhcbiAgICAgICAgdGhpcy5nZXROdW1iZXJPZkZpdHRpbmdUaWNrcyhhLCBPLCBQbi50aWNrcy5ob3Jpem9udGFsU3BhY2VSYXRpbylcbiAgICAgICksIGcuY2FsbChMKSwgZi5jYWxsKEwpKSwgbC5zZWxlY3RBbGwoXCJnLnRpY2tzIGcudGljayB0ZXh0XCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJyb3RhdGUoLTQ1KVwiKS5hdHRyKFwidGV4dC1hbmNob3JcIiwgbiA9PT0gRy5UT1AgPyBcInN0YXJ0XCIgOiBcImVuZFwiKSkgOiBsLnNlbGVjdEFsbChcImcudGlja3MgZy50aWNrIHRleHRcIikuYXR0cihcInRyYW5zZm9ybVwiLCBudWxsKS5hdHRyKFwidGV4dC1hbmNob3JcIiwgbnVsbCk7XG4gICAgfVxuICAgIGlmIChiID8gbC5hdHRyKFwib3BhY2l0eVwiLCAwKSA6IGwuYXR0cihcIm9wYWNpdHlcIiwgMSksIGYuc2VsZWN0QWxsKFwiZy50aWNrXCIpLmF0dHIoXCJhcmlhLWxhYmVsXCIsIChxKSA9PiBxKSwgZy5zZWxlY3RBbGwoXCJnLnRpY2tcIikuYXR0cihcImFyaWEtbGFiZWxcIiwgKHEpID0+IHEpLCBEICE9PSBWZS5OT05FICYmIEUgPT09IGV0LkxBQkVMUyAmJiAhTSkge1xuICAgICAgY29uc3QgcSA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFNjYWxlRG9tYWluKG4pO1xuICAgICAgaWYgKHEubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB0dCA9IHMuc2VsZWN0KGBnLmF4aXMuJHtufSBnLnRpY2tzIGcudGlja2ApLmh0bWwoKTtcbiAgICAgICAgbC5zZWxlY3RBbGwoXCJnLnRpY2tzIGcudGlja1wiKS5odG1sKHR0KTtcbiAgICAgICAgY29uc3QgbHQgPSB0aGlzO1xuICAgICAgICBsLnNlbGVjdEFsbChcImcudGljayB0ZXh0XCIpLmRhdGEocSkudGV4dChmdW5jdGlvbih6KSB7XG4gICAgICAgICAgcmV0dXJuIHoubGVuZ3RoID4gQSA/IChsdC50cnVuY2F0aW9uW25dID0gITAsIGVzKHosIEQsIFIpKSA6IHo7XG4gICAgICAgIH0pLCB0aGlzLmdldEludmlzaWJsZUF4aXNSZWYoKS5zZWxlY3RBbGwoXCJnLnRpY2sgdGV4dFwiKS5kYXRhKHEpLnRleHQoZnVuY3Rpb24oeikge1xuICAgICAgICAgIHJldHVybiB6Lmxlbmd0aCA+IEEgPyBlcyh6LCBELCBSKSA6IHo7XG4gICAgICAgIH0pLCBsLnNlbGVjdEFsbChcImcudGlja3NcIikuaHRtbCh0aGlzLmdldEludmlzaWJsZUF4aXNSZWYoKS5odG1sKCkpLCBsLnNlbGVjdEFsbChcImcudGljayB0ZXh0XCIpLmRhdGEocSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoKSwgeyBwb3NpdGlvbjogbiB9ID0gdGhpcy5jb25maWdzLCByID0gTi5hcHBlbmRPclNlbGVjdCh0LCBgZy5heGlzLiR7bn1gKSwgaSA9IHRoaXMuZ2V0T3B0aW9ucygpLCBzID0geShpLCBcImF4ZXNcIiwgbiksIGEgPSB5KHMsIFwic2NhbGVUeXBlXCIpLCBvID0geShzLCBcInRydW5jYXRpb25cIiwgXCJ0aHJlc2hvbGRcIiksIGwgPSB0aGlzO1xuICAgIHIuc2VsZWN0QWxsKFwiZy50aWNrIHRleHRcIikub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oYywgdSkge1xuICAgICAgbC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkF4aXMuTEFCRUxfTU9VU0VPVkVSLCB7XG4gICAgICAgIGV2ZW50OiBjLFxuICAgICAgICBlbGVtZW50OiBJKHRoaXMpLFxuICAgICAgICBkYXR1bTogdVxuICAgICAgfSksIGEgPT09IGV0LkxBQkVMUyAmJiB1Lmxlbmd0aCA+IG8gJiYgbC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuU0hPVywge1xuICAgICAgICBldmVudDogYyxcbiAgICAgICAgaG92ZXJlZEVsZW1lbnQ6IEkodGhpcyksXG4gICAgICAgIGNvbnRlbnQ6IHVcbiAgICAgIH0pO1xuICAgIH0pLm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKGMsIHUpIHtcbiAgICAgIGwuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5BeGlzLkxBQkVMX01PVVNFTU9WRSwge1xuICAgICAgICBldmVudDogYyxcbiAgICAgICAgZWxlbWVudDogSSh0aGlzKSxcbiAgICAgICAgZGF0dW06IHVcbiAgICAgIH0pLCBhID09PSBldC5MQUJFTFMgJiYgdS5sZW5ndGggPiBvICYmIGwuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLk1PVkUsIHtcbiAgICAgICAgZXZlbnQ6IGNcbiAgICAgIH0pO1xuICAgIH0pLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oYywgdSkge1xuICAgICAgbC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkF4aXMuTEFCRUxfQ0xJQ0ssIHtcbiAgICAgICAgZXZlbnQ6IGMsXG4gICAgICAgIGVsZW1lbnQ6IEkodGhpcyksXG4gICAgICAgIGRhdHVtOiB1XG4gICAgICB9KTtcbiAgICB9KS5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKGMsIHUpIHtcbiAgICAgIGwuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5BeGlzLkxBQkVMX01PVVNFT1VULCB7XG4gICAgICAgIGV2ZW50OiBjLFxuICAgICAgICBlbGVtZW50OiBJKHRoaXMpLFxuICAgICAgICBkYXR1bTogdVxuICAgICAgfSksIGEgPT09IGV0LkxBQkVMUyAmJiBsLnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5ISURFKTtcbiAgICB9KTtcbiAgfVxuICBnZXRJbnZpc2libGVBeGlzUmVmKCkge1xuICAgIGNvbnN0IHsgcG9zaXRpb246IHQgfSA9IHRoaXMuY29uZmlncztcbiAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoKS5zZWxlY3QoYGcuYXhpcy4ke3R9IGcudGlja3MuaW52aXNpYmxlYCk7XG4gIH1cbiAgZ2V0VGl0bGVSZWYoKSB7XG4gICAgY29uc3QgeyBwb3NpdGlvbjogdCB9ID0gdGhpcy5jb25maWdzO1xuICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudENvbnRhaW5lcigpLnNlbGVjdChgZy5heGlzLiR7dH0gdGV4dC5heGlzLXRpdGxlYCk7XG4gIH1cbiAgZ2V0TnVtYmVyT2ZGaXR0aW5nVGlja3ModCwgbiwgcikge1xuICAgIGNvbnN0IGkgPSBNYXRoLmZsb29yKHQgLyAobiAqIHIpKTtcbiAgICByZXR1cm4gTWcoaSwgMiwgUG4udGlja3MubnVtYmVyKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldENvbXBvbmVudENvbnRhaW5lcigpLCB7IHBvc2l0aW9uOiBuIH0gPSB0aGlzLmNvbmZpZ3M7XG4gICAgTi5hcHBlbmRPclNlbGVjdCh0LCBgZy5heGlzLiR7bn1gKS5zZWxlY3RBbGwoXCJnLnRpY2sgdGV4dFwiKS5vbihcIm1vdXNlb3ZlclwiLCBudWxsKS5vbihcIm1vdXNlbW92ZVwiLCBudWxsKS5vbihcIm1vdXNlb3V0XCIsIG51bGwpO1xuICB9XG59XG5jbGFzcyBwRCBleHRlbmRzIE92IHtcbiAgY29uc3RydWN0b3IodCwgbiwgcikge1xuICAgIHN1cGVyKHQsIG4sIHIpO1xuICB9XG4gIHJlbmRlcih0ID0gITApIHtcbiAgICBzdXBlci5yZW5kZXIodCksIHN1cGVyLmRlc3Ryb3koKTtcbiAgICBjb25zdCBuID0gdGhpcy5jb25maWdzLnBvc2l0aW9uLCByID0gdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoe1xuICAgICAgYXJpYUxhYmVsOiBcImF4ZXNcIlxuICAgIH0pLCBpID0gTi5hcHBlbmRPclNlbGVjdChyLCBgZy5heGlzLiR7bn1gKSwgcyA9IHRoaXM7XG4gICAgaS5zZWxlY3RBbGwoXCJnLnRpY2tcIikuZWFjaChmdW5jdGlvbihhLCBvKSB7XG4gICAgICBjb25zdCBsID0gSSh0aGlzKTtcbiAgICAgIGwuY2xhc3NlZChcInRpY2staG92ZXJcIiwgITApLmF0dHIoXCJ0YWJpbmRleFwiLCBvID09PSAwID8gMCA6IC0xKTtcbiAgICAgIGNvbnN0IGMgPSBsLnNlbGVjdChcInRleHRcIiksIHsgd2lkdGg6IHUsIGhlaWdodDogZCB9ID0gTi5nZXRTVkdFbGVtZW50U2l6ZShjLCB7XG4gICAgICAgIHVzZUJCb3g6ICEwXG4gICAgICB9KSwgaCA9IE4uYXBwZW5kT3JTZWxlY3QobCwgXCJyZWN0LmF4aXMtaG9sZGVyXCIpO1xuICAgICAgbGV0IHAgPSAwLCBmID0gMDtcbiAgICAgIHN3aXRjaCAobikge1xuICAgICAgICBjYXNlIEcuTEVGVDpcbiAgICAgICAgICBwID0gLXUgKyBOdW1iZXIoYy5hdHRyKFwieFwiKSksIGYgPSAtKGQgLyAyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHLlJJR0hUOlxuICAgICAgICAgIHAgPSBNYXRoLmFicyhOdW1iZXIoYy5hdHRyKFwieFwiKSkpLCBmID0gLShkIC8gMik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRy5UT1A6XG4gICAgICAgICAgcCA9IC0odSAvIDIpLCBmID0gLWQgKyBOdW1iZXIoYy5hdHRyKFwieVwiKSkgLyAyLCBzLnRydW5jYXRpb25bbl0gJiYgKHAgPSAwLCBoLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJyb3RhdGUoLTQ1KVwiKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRy5CT1RUT006XG4gICAgICAgICAgcCA9IC0odSAvIDIpLCBmID0gZCAvIDIgLSAyLCBzLnRydW5jYXRpb25bbl0gJiYgKHAgPSAtdSwgaC5hdHRyKFwidHJhbnNmb3JtXCIsIFwicm90YXRlKC00NSlcIikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaC5hdHRyKFwieFwiLCBwIC0gUG4uaG92ZXIucmVjdGFuZ2xlUGFkZGluZykuYXR0cihcInlcIiwgZikuYXR0cihcIndpZHRoXCIsIHUgKyBQbi5ob3Zlci5yZWN0YW5nbGVQYWRkaW5nICogMikuYXR0cihcImhlaWdodFwiLCBkKS5sb3dlcigpO1xuICAgIH0pLCB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0Q29tcG9uZW50Q29udGFpbmVyKCksIHsgcG9zaXRpb246IG4gfSA9IHRoaXMuY29uZmlncywgciA9IE4uYXBwZW5kT3JTZWxlY3QodCwgYGcuYXhpcy4ke259YCksIGkgPSB0aGlzLmdldE9wdGlvbnMoKSwgcyA9IHkoaSwgXCJheGVzXCIsIG4pLCBhID0geShzLCBcInNjYWxlVHlwZVwiKSwgbyA9IHkocywgXCJ0cnVuY2F0aW9uXCIsIFwidGhyZXNob2xkXCIpLCBsID0gdGhpcztcbiAgICByLnNlbGVjdEFsbChcImcudGljay50aWNrLWhvdmVyXCIpLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKGMpIHtcbiAgICAgIGNvbnN0IHUgPSBJKHRoaXMpLnNlbGVjdChcInRleHRcIiksIGQgPSB1LmRhdHVtKCk7XG4gICAgICBsLnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuQXhpcy5MQUJFTF9NT1VTRU9WRVIsIHtcbiAgICAgICAgZXZlbnQ6IGMsXG4gICAgICAgIGVsZW1lbnQ6IHUsXG4gICAgICAgIGRhdHVtOiBkXG4gICAgICB9KSwgYSA9PT0gZXQuTEFCRUxTICYmIGQubGVuZ3RoID4gbyAmJiBsLnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5TSE9XLCB7XG4gICAgICAgIGV2ZW50OiBjLFxuICAgICAgICBlbGVtZW50OiB1LFxuICAgICAgICBkYXR1bTogZFxuICAgICAgfSk7XG4gICAgfSkub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24oYykge1xuICAgICAgY29uc3QgdSA9IEkodGhpcykuc2VsZWN0KFwidGV4dFwiKSwgZCA9IHUuZGF0dW0oKTtcbiAgICAgIGwuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5BeGlzLkxBQkVMX01PVVNFTU9WRSwge1xuICAgICAgICBldmVudDogYyxcbiAgICAgICAgZWxlbWVudDogdSxcbiAgICAgICAgZGF0dW06IGRcbiAgICAgIH0pLCBsLnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5NT1ZFLCB7XG4gICAgICAgIGV2ZW50OiBjXG4gICAgICB9KTtcbiAgICB9KS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGMpIHtcbiAgICAgIGwuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5BeGlzLkxBQkVMX0NMSUNLLCB7XG4gICAgICAgIGV2ZW50OiBjLFxuICAgICAgICBlbGVtZW50OiBJKHRoaXMpLnNlbGVjdChcInRleHRcIiksXG4gICAgICAgIGRhdHVtOiBJKHRoaXMpLnNlbGVjdChcInRleHRcIikuZGF0dW0oKVxuICAgICAgfSk7XG4gICAgfSkub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihjKSB7XG4gICAgICBsLnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuQXhpcy5MQUJFTF9NT1VTRU9VVCwge1xuICAgICAgICBldmVudDogYyxcbiAgICAgICAgZWxlbWVudDogSSh0aGlzKS5zZWxlY3QoXCJ0ZXh0XCIpLFxuICAgICAgICBkYXR1bTogSSh0aGlzKS5zZWxlY3QoXCJ0ZXh0XCIpLmRhdHVtKClcbiAgICAgIH0pLCBhID09PSBldC5MQUJFTFMgJiYgbC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuSElERSk7XG4gICAgfSkub24oXCJmb2N1c1wiLCBmdW5jdGlvbihjKSB7XG4gICAgICBjb25zdCB1ID0geyBjbGllbnRYOiAwLCBjbGllbnRZOiAwIH07XG4gICAgICBpZiAoYy50YXJnZXQpIHtcbiAgICAgICAgYy50YXJnZXQuZm9jdXMoKTtcbiAgICAgICAgY29uc3QgZCA9IGMudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB1LmNsaWVudFggPSBkLngsIHUuY2xpZW50WSA9IGQueTtcbiAgICAgIH1cbiAgICAgIGwuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5BeGlzLkxBQkVMX0ZPQ1VTLCB7XG4gICAgICAgIGV2ZW50OiB7IC4uLmMsIC4uLnUgfSxcbiAgICAgICAgZWxlbWVudDogSSh0aGlzKSxcbiAgICAgICAgZGF0dW06IEkodGhpcykuc2VsZWN0KFwidGV4dFwiKS5kYXR1bSgpXG4gICAgICB9KTtcbiAgICB9KS5vbihcImJsdXJcIiwgZnVuY3Rpb24oYykge1xuICAgICAgbC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkF4aXMuTEFCRUxfQkxVUiwge1xuICAgICAgICBldmVudDogYyxcbiAgICAgICAgZWxlbWVudDogSSh0aGlzKSxcbiAgICAgICAgZGF0dW06IEkodGhpcykuc2VsZWN0KFwidGV4dFwiKS5kYXR1bSgpXG4gICAgICB9KTtcbiAgICB9KS5vbihcImtleWRvd25cIiwgZnVuY3Rpb24oYykge1xuICAgICAgYy5rZXkgJiYgYy5rZXkgPT09IFwiRXNjYXBlXCIgJiYgKGwuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLkhJREUpLCBsLnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuQXhpcy5MQUJFTF9CTFVSLCB7XG4gICAgICAgIGV2ZW50OiBjLFxuICAgICAgICBlbGVtZW50OiBJKHRoaXMpLFxuICAgICAgICBkYXR1bTogSSh0aGlzKS5zZWxlY3QoXCJ0ZXh0XCIpLmRhdHVtKClcbiAgICAgIH0pKSwgbiA9PT0gRy5MRUZUIHx8IG4gPT09IEcuUklHSFQgPyBjLmtleSAmJiBjLmtleSA9PT0gXCJBcnJvd1VwXCIgPyBsLmdvTmV4dCh0aGlzLCBjKSA6IGMua2V5ICYmIGMua2V5ID09PSBcIkFycm93RG93blwiICYmIGwuZ29QcmV2aW91cyh0aGlzLCBjKSA6IGMua2V5ICYmIGMua2V5ID09PSBcIkFycm93TGVmdFwiID8gbC5nb1ByZXZpb3VzKHRoaXMsIGMpIDogYy5rZXkgJiYgYy5rZXkgPT09IFwiQXJyb3dSaWdodFwiICYmIGwuZ29OZXh0KHRoaXMsIGMpO1xuICAgIH0pO1xuICB9XG4gIC8vIEZvY3VzIG9uIHRoZSBuZXh0IEhUTUwgZWxlbWVudCBzaWJsaW5nXG4gIGdvTmV4dCh0LCBuKSB7XG4gICAgdC5uZXh0RWxlbWVudFNpYmxpbmcgJiYgdC5uZXh0RWxlbWVudFNpYmxpbmcudGFnTmFtZSAhPT0gXCJwYXRoXCIgJiYgdC5uZXh0RWxlbWVudFNpYmxpbmcuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJmb2N1c1wiKSksIG4ucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICAvLyBGb2N1cyBvbiB0aGUgcHJldmlvdXMgSFRNTCBlbGVtZW50IHNpYmxpbmdcbiAgZ29QcmV2aW91cyh0LCBuKSB7XG4gICAgdC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICYmIHQucHJldmlvdXNFbGVtZW50U2libGluZy50YWdOYW1lICE9PSBcInBhdGhcIiAmJiB0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJmb2N1c1wiKSksIG4ucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldENvbXBvbmVudENvbnRhaW5lcigpLCB7IHBvc2l0aW9uOiBuIH0gPSB0aGlzLmNvbmZpZ3M7XG4gICAgTi5hcHBlbmRPclNlbGVjdCh0LCBgZy5heGlzLiR7bn1gKS5zZWxlY3RBbGwoXCJnLnRpY2sudGljay1ob3ZlclwiKS5vbihcIm1vdXNlb3ZlclwiLCBudWxsKS5vbihcIm1vdXNlbW92ZVwiLCBudWxsKS5vbihcIm1vdXNlb3V0XCIsIG51bGwpLm9uKFwiZm9jdXNcIiwgbnVsbCkub24oXCJibHVyXCIsIG51bGwpO1xuICB9XG59XG5jbGFzcyBmZSBleHRlbmRzIG10IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy50eXBlID0gXCIyRC1heGVzXCIsIHRoaXMucmVuZGVyVHlwZSA9IHJ0LlNWRywgdGhpcy5jaGlsZHJlbiA9IHt9LCB0aGlzLnRocmVzaG9sZHMgPSBbXSwgdGhpcy5tYXJnaW5zID0ge1xuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwXG4gICAgfTtcbiAgfVxuICByZW5kZXIodCA9ICExKSB7XG4gICAgY29uc3QgbiA9IHt9LCByID0gT2JqZWN0LmtleXMoRyksIGkgPSB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcImF4ZXNcIik7XG4gICAgci5mb3JFYWNoKChhKSA9PiB7XG4gICAgICBpW0dbYV1dICYmIChuW0dbYV1dID0gITApO1xuICAgIH0pLCB0aGlzLmNvbmZpZ3MuYXhlcyA9IG4sIHIuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgY29uc3QgbyA9IEdbYV07XG4gICAgICBpZiAodGhpcy5jb25maWdzLmF4ZXNbb10gJiYgIXRoaXMuY2hpbGRyZW5bb10pIHtcbiAgICAgICAgY29uc3QgbCA9IHtcbiAgICAgICAgICBwb3NpdGlvbjogbyxcbiAgICAgICAgICBheGVzOiB0aGlzLmNvbmZpZ3MuYXhlcyxcbiAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbnNcbiAgICAgICAgfSwgYyA9IHRoaXMubW9kZWwuYXhpc0ZsYXZvciA9PT0gR2EuREVGQVVMVCA/IG5ldyBPdih0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzLCBsKSA6IG5ldyBwRCh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzLCBsKTtcbiAgICAgICAgYy5zZXRNb2RlbCh0aGlzLm1vZGVsKSwgYy5zZXRTZXJ2aWNlcyh0aGlzLnNlcnZpY2VzKSwgYy5zZXRQYXJlbnQodGhpcy5wYXJlbnQpLCB0aGlzLmNoaWxkcmVuW29dID0gYztcbiAgICAgIH1cbiAgICB9KSwgT2JqZWN0LmtleXModGhpcy5jaGlsZHJlbikuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgdGhpcy5jaGlsZHJlblthXS5yZW5kZXIodCk7XG4gICAgfSk7XG4gICAgY29uc3QgcyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKHRoaXMuY2hpbGRyZW4pLmZvckVhY2goKGEpID0+IHtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLmNoaWxkcmVuW2FdLCBsID0gby5jb25maWdzLnBvc2l0aW9uLCBjID0gby5nZXRJbnZpc2libGVBeGlzUmVmKCksIHsgd2lkdGg6IHUsIGhlaWdodDogZCB9ID0gTi5nZXRTVkdFbGVtZW50U2l6ZShjLCB7IHVzZUJCb3g6ICEwIH0pO1xuICAgICAgbGV0IGg7XG4gICAgICBzd2l0Y2ggKG8uZ2V0VGl0bGVSZWYoKS5lbXB0eSgpID8gaCA9IDAgOiAoaCA9IE4uZ2V0U1ZHRWxlbWVudFNpemUoby5nZXRUaXRsZVJlZigpLCB7XG4gICAgICAgIHVzZUJCb3g6ICEwXG4gICAgICB9KS5oZWlnaHQsIChsID09PSBHLkxFRlQgfHwgbCA9PT0gRy5SSUdIVCkgJiYgKGggKz0gNSkpLCBsKSB7XG4gICAgICAgIGNhc2UgRy5UT1A6XG4gICAgICAgICAgcy50b3AgPSBkICsgaDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHLkJPVFRPTTpcbiAgICAgICAgICBzLmJvdHRvbSA9IGQgKyBoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEcuTEVGVDpcbiAgICAgICAgICBzLmxlZnQgPSB1ICsgaDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHLlJJR0hUOlxuICAgICAgICAgIHMucmlnaHQgPSB1ICsgaDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KSwgdGhpcy5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkF4aXMuUkVOREVSX0NPTVBMRVRFKSwgT2JqZWN0LmtleXMocykuc29tZShcbiAgICAgIChhKSA9PiB0aGlzLm1hcmdpbnNbYV0gIT09IHNbYV1cbiAgICApICYmICh0aGlzLm1hcmdpbnMgPSBPYmplY3QuYXNzaWduKHRoaXMubWFyZ2lucywgcyksIHRoaXMubW9kZWwuc2V0KHsgYXhlc01hcmdpbnM6IHRoaXMubWFyZ2lucyB9LCB7IHNraXBVcGRhdGU6ICEwIH0pLCB0aGlzLnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuWm9vbUJhci5VUERBVEUpLCBPYmplY3Qua2V5cyh0aGlzLmNoaWxkcmVuKS5mb3JFYWNoKChhKSA9PiB7XG4gICAgICBjb25zdCBvID0gdGhpcy5jaGlsZHJlblthXTtcbiAgICAgIG8ubWFyZ2lucyA9IHRoaXMubWFyZ2lucztcbiAgICB9KSwgdGhpcy5yZW5kZXIoITApKTtcbiAgfVxufVxuY2xhc3MgY2UgZXh0ZW5kcyBtdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IFwic2tlbGV0b25cIjtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gIC8vIEB0cy1pZ25vcmVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICByZW5kZXIodCA9ICEwKSB7XG4gICAgY29uc3QgbiA9IHkodGhpcy5nZXRPcHRpb25zKCksIFwiZGF0YVwiLCBcImxvYWRpbmdcIik7XG4gICAgbiA/IHRoaXMucmVuZGVyU2tlbGV0b24obikgOiB0aGlzLnJlbW92ZVNrZWxldG9uKCk7XG4gIH1cbiAgcmVuZGVyU2tlbGV0b24odCkge1xuICAgIGlmICh0aGlzLmNvbmZpZ3Muc2tlbGV0b24gPT09IHp0LkdSSUQpXG4gICAgICB0aGlzLnJlbmRlckdyaWRTa2VsZXRvbih0KTtcbiAgICBlbHNlIGlmICh0aGlzLmNvbmZpZ3Muc2tlbGV0b24gPT09IHp0LlZFUlRfT1JfSE9SSVopXG4gICAgICB0aGlzLnJlbmRlclZlcnRPckhvcml6U2tlbGV0b24odCk7XG4gICAgZWxzZSBpZiAodGhpcy5jb25maWdzLnNrZWxldG9uID09PSB6dC5QSUUpXG4gICAgICB0aGlzLnJlbmRlclBpZVNrZWxldG9uKHQpO1xuICAgIGVsc2UgaWYgKHRoaXMuY29uZmlncy5za2VsZXRvbiA9PT0genQuRE9OVVQpXG4gICAgICB0aGlzLnJlbmRlckRvbnV0U2tlbGV0b24odCk7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dGhpcy5jb25maWdzLnNrZWxldG9ufVwiIGlzIG5vdCBhIHZhbGlkIFNrZWxldG9uIHR5cGUuYCk7XG4gIH1cbiAgcmVuZGVyR3JpZFNrZWxldG9uKHQpIHtcbiAgICB0aGlzLnNldFNjYWxlcygpLCB0aGlzLmRyYXdCYWNrZHJvcCh0KSwgdGhpcy5kcmF3WEdyaWQodCksIHRoaXMuZHJhd1lHcmlkKHQpLCB0ICYmIHRoaXMuc2V0U2hpbW1lckVmZmVjdChcInNoaW1tZXItbGluZXNcIik7XG4gIH1cbiAgcmVuZGVyVmVydE9ySG9yaXpTa2VsZXRvbih0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldE9yaWVudGF0aW9uKCk7XG4gICAgdGhpcy5zZXRTY2FsZXMoKSwgdGhpcy5kcmF3QmFja2Ryb3AodCksIG4gPT09IEZ0LlZFUlRJQ0FMICYmIHRoaXMuZHJhd1lHcmlkKHQpLCBuID09PSBGdC5IT1JJWk9OVEFMICYmIHRoaXMuZHJhd1hHcmlkKHQpLCB0aGlzLnNldFNoaW1tZXJFZmZlY3QoXCJzaGltbWVyLWxpbmVzXCIpO1xuICB9XG4gIHJlbmRlclBpZVNrZWxldG9uKHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5jb21wdXRlT3V0ZXJSYWRpdXMoKTtcbiAgICB0aGlzLmRyYXdSaW5nKG4sIDAsIHQpLCB0ICYmIHRoaXMuc2V0U2hpbW1lckVmZmVjdChcInNoaW1tZXItYXJlYXNcIik7XG4gIH1cbiAgcmVuZGVyRG9udXRTa2VsZXRvbih0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMuY29tcHV0ZU91dGVyUmFkaXVzKCksIHIgPSB0aGlzLmNvbXB1dGVJbm5lclJhZGl1cygpO1xuICAgIHRoaXMuZHJhd1JpbmcobiwgciwgdCksIHQgJiYgdGhpcy5zZXRTaGltbWVyRWZmZWN0KFwic2hpbW1lci1hcmVhc1wiKTtcbiAgfVxuICBzZXRTY2FsZXMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldE1haW5YU2NhbGUoKS5yYW5nZSgpLCBuID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0TWFpbllTY2FsZSgpLnJhbmdlKCk7XG4gICAgdGhpcy54U2NhbGUgPSBGZSgpLmRvbWFpbihbMCwgMV0pLnJhbmdlKHQpLCB0aGlzLnlTY2FsZSA9IEZlKCkuZG9tYWluKFswLCAxXSkucmFuZ2Uobik7XG4gIH1cbiAgZHJhd0JhY2tkcm9wKHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5wYXJlbnQsIHsgd2lkdGg6IHIsIGhlaWdodDogaSB9ID0gTi5nZXRTVkdFbGVtZW50U2l6ZShuLCB7XG4gICAgICB1c2VBdHRyczogITBcbiAgICB9KTtcbiAgICB0aGlzLmJhY2tkcm9wID0gTi5hcHBlbmRPclNlbGVjdChuLCBcInN2Zy5jaGFydC1za2VsZXRvbi5EQUlJXCIpLmF0dHIoXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpLmF0dHIoXCJ3aWR0aFwiLCByKS5hdHRyKFwiaGVpZ2h0XCIsIGkpO1xuICAgIGNvbnN0IHMgPSBOLmFwcGVuZE9yU2VsZWN0KHRoaXMuYmFja2Ryb3AsIFwicmVjdC5jaGFydC1za2VsZXRvbi1iYWNrZHJvcFwiKTtcbiAgICBzLmF0dHIoXCJ3aWR0aFwiLCBcIjEwMCVcIikuYXR0cihcImhlaWdodFwiLCBcIjEwMCVcIik7XG4gICAgY29uc3QgW2FdID0gdGhpcy54U2NhbGUucmFuZ2UoKSwgWywgb10gPSB0aGlzLnlTY2FsZS5yYW5nZSgpO1xuICAgIHRoaXMuYmFja2Ryb3AubWVyZ2UocykuYXR0cihcInhcIiwgYSkuYXR0cihcInlcIiwgbyksIHMuY2xhc3NlZChcInNoaW1tZXItZWZmZWN0LWxpbmVzXCIsIHQpLmNsYXNzZWQoXCJlbXB0eS1zdGF0ZS1saW5lc1wiLCAhdCkuc3R5bGUoXG4gICAgICBcInN0cm9rZVwiLFxuICAgICAgdCA/IGB1cmwoIyR7dGhpcy5zZXJ2aWNlcy5kb21VdGlscy5nZW5lcmF0ZUVsZW1lbnRJRFN0cmluZyhcInNoaW1tZXItbGluZXNcIil9KWAgOiBudWxsXG4gICAgKTtcbiAgfVxuICBkcmF3WEdyaWQodCkge1xuICAgIGNvbnN0IG4gPSArdGhpcy5iYWNrZHJvcC5hdHRyKFwid2lkdGhcIiksIHIgPSB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcImdyaWRcIiwgXCJ4XCIsIFwibnVtYmVyT2ZUaWNrc1wiKSwgaSA9IHRoaXMueFNjYWxlLnRpY2tzKHIpLm1hcCgobykgPT4gbyAqIG4pLCBzID0gTi5hcHBlbmRPclNlbGVjdCh0aGlzLmJhY2tkcm9wLCBcImcueC5za2VsZXRvblwiKSwgYSA9IHMuc2VsZWN0QWxsKFwibGluZVwiKS5kYXRhKGkpO1xuICAgIGEuZW50ZXIoKS5hcHBlbmQoXCJsaW5lXCIpLm1lcmdlKGEpLmF0dHIoXCJ4MVwiLCAobykgPT4gbykuYXR0cihcIngyXCIsIChvKSA9PiBvKS5hdHRyKFwieTFcIiwgMCkuYXR0cihcInkyXCIsIFwiMTAwJVwiKSwgcy5zZWxlY3RBbGwoXCJsaW5lXCIpLmNsYXNzZWQoXCJzaGltbWVyLWVmZmVjdC1saW5lc1wiLCB0KS5jbGFzc2VkKFwiZW1wdHktc3RhdGUtbGluZXNcIiwgIXQpLnN0eWxlKFxuICAgICAgXCJzdHJva2VcIixcbiAgICAgIHQgPyBgdXJsKCMke3RoaXMuc2VydmljZXMuZG9tVXRpbHMuZ2VuZXJhdGVFbGVtZW50SURTdHJpbmcoXCJzaGltbWVyLWxpbmVzXCIpfSlgIDogbnVsbFxuICAgICk7XG4gIH1cbiAgZHJhd1lHcmlkKHQpIHtcbiAgICBjb25zdCBuID0gK3RoaXMuYmFja2Ryb3AuYXR0cihcImhlaWdodFwiKSwgciA9IHRoaXMuYmFja2Ryb3AuYXR0cihcIndpZHRoXCIpLCBpID0geSh0aGlzLmdldE9wdGlvbnMoKSwgXCJncmlkXCIsIFwieVwiLCBcIm51bWJlck9mVGlja3NcIiksIHMgPSB0aGlzLnhTY2FsZS50aWNrcyhpKS5tYXAoKGwpID0+IGwgKiBuKSwgYSA9IE4uYXBwZW5kT3JTZWxlY3QodGhpcy5iYWNrZHJvcCwgXCJnLnkuc2tlbGV0b25cIiksIG8gPSBhLnNlbGVjdEFsbChcImxpbmVcIikuZGF0YShzKTtcbiAgICBvLmVudGVyKCkuYXBwZW5kKFwibGluZVwiKS5tZXJnZShvKS5hdHRyKFwieDFcIiwgMCkuYXR0cihcIngyXCIsIHIpLmF0dHIoXCJ5MVwiLCAobCkgPT4gbCkuYXR0cihcInkyXCIsIChsKSA9PiBsKSwgYS5zZWxlY3RBbGwoXCJsaW5lXCIpLmNsYXNzZWQoXCJzaGltbWVyLWVmZmVjdC1saW5lc1wiLCB0KS5jbGFzc2VkKFwiZW1wdHktc3RhdGUtbGluZXNcIiwgIXQpLnN0eWxlKFxuICAgICAgXCJzdHJva2VcIixcbiAgICAgIHQgPyBgdXJsKCMke3RoaXMuc2VydmljZXMuZG9tVXRpbHMuZ2VuZXJhdGVFbGVtZW50SURTdHJpbmcoXCJzaGltbWVyLWxpbmVzXCIpfSlgIDogbnVsbFxuICAgICk7XG4gIH1cbiAgZHJhd1JpbmcodCwgbiwgciA9ICEwKSB7XG4gICAgY29uc3QgaSA9IHRoaXMucGFyZW50LCB7IHdpZHRoOiBzLCBoZWlnaHQ6IGEgfSA9IE4uZ2V0U1ZHRWxlbWVudFNpemUoaSwge1xuICAgICAgdXNlQXR0cnM6ICEwXG4gICAgfSksIG8gPSBOLmFwcGVuZE9yU2VsZWN0KGksIFwic3ZnLmNoYXJ0LXNrZWxldG9uXCIpLmF0dHIoXCJ3aWR0aFwiLCBzKS5hdHRyKFwiaGVpZ2h0XCIsIGEpLmF0dHIoXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpLCBsID0gbiA9PT0gMCA/IFwicGllXCIgOiBcImRvbnV0XCIsIGMgPSB5KHRoaXMuZ2V0T3B0aW9ucygpLCBsLCBcImFsaWdubWVudFwiKTtcbiAgICBOLmFwcGVuZE9yU2VsZWN0KG8sIFwicmVjdC5jaGFydC1za2VsZXRvbi1hcmVhLWNvbnRhaW5lclwiKS5hdHRyKFwid2lkdGhcIiwgcykuYXR0cihcImhlaWdodFwiLCBhKS5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgY29uc3QgdSA9IGFzKCkuaW5uZXJSYWRpdXMobikub3V0ZXJSYWRpdXModCkuc3RhcnRBbmdsZSgwKS5lbmRBbmdsZShNYXRoLlBJICogMiksIGQgPSB0ICsgTWF0aC5hYnMoTXQucmFkaXVzT2Zmc2V0KSwgaCA9IHQgKyAoTWF0aC5taW4ocywgYSkgLSB0ICogMikgLyAyLCBwID0gTi5hcHBlbmRPclNlbGVjdChvLCBcInBhdGhcIikuYXR0cihcImNsYXNzXCIsIFwic2tlbGV0b24tYXJlYS1zaGFwZVwiKS5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHtkfSwgJHtofSlgKS5hdHRyKFwiZFwiLCB1KS5jbGFzc2VkKFwic2hpbW1lci1lZmZlY3QtYXJlYXNcIiwgcikuY2xhc3NlZChcImVtcHR5LXN0YXRlLWFyZWFzXCIsICFyKS5zdHlsZShcbiAgICAgIFwiZmlsbFwiLFxuICAgICAgciA/IGB1cmwoIyR7dGhpcy5zZXJ2aWNlcy5kb21VdGlscy5nZW5lcmF0ZUVsZW1lbnRJRFN0cmluZyhcInNoaW1tZXItYXJlYXNcIil9KWAgOiBudWxsXG4gICAgKTtcbiAgICBsZXQgZiA9IHQgKyBNdC54T2Zmc2V0O1xuICAgIGMgPT09IGp0LkNFTlRFUiA/IGYgPSBzIC8gMiA6IGMgPT09IGp0LlJJR0hUICYmIChmID0gcyAtIHQgLSBNdC54T2Zmc2V0KTtcbiAgICBjb25zdCBnID0gdCArIE10LnlPZmZzZXQ7XG4gICAgcC5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHtmfSwgJHtnfSlgKTtcbiAgfVxuICAvLyBzYW1lIGxvZ2ljIGluIHBpZVxuICBjb21wdXRlT3V0ZXJSYWRpdXMoKSB7XG4gICAgY29uc3QgeyB3aWR0aDogdCwgaGVpZ2h0OiBuIH0gPSBOLmdldFNWR0VsZW1lbnRTaXplKHRoaXMucGFyZW50LCB7XG4gICAgICB1c2VBdHRyczogITBcbiAgICB9KTtcbiAgICByZXR1cm4gTWF0aC5taW4odCwgbikgLyAyICsgTXQucmFkaXVzT2Zmc2V0O1xuICB9XG4gIC8vIHNhbWUgbG9naWMgaW4gZG9udXRcbiAgY29tcHV0ZUlubmVyUmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbXB1dGVPdXRlclJhZGl1cygpICogKDMgLyA0KTtcbiAgfVxuICBzZXRTaGltbWVyRWZmZWN0KHQpIHtcbiAgICBjb25zdCBuID0gXCJzdG9wLWJnLXNoaW1tZXJcIiwgciA9IFwic3RvcC1zaGltbWVyXCIsIGkgPSB0aGlzLnBhcmVudC5zZWxlY3QoXCIuY2hhcnQtc2tlbGV0b25cIiksIHsgd2lkdGg6IHMgfSA9IE4uZ2V0U1ZHRWxlbWVudFNpemUodGhpcy5wYXJlbnQsIHtcbiAgICAgIHVzZUF0dHJzOiAhMFxuICAgIH0pLCBhID0gMCwgbyA9IHMsIGwgPSBOLmFwcGVuZE9yU2VsZWN0KGksIFwiZGVmc1wiKS5sb3dlcigpLCBjID0gTi5hcHBlbmRPclNlbGVjdChsLCBcImxpbmVhckdyYWRpZW50XCIpLmF0dHIoXCJpZFwiLCB0aGlzLnNlcnZpY2VzLmRvbVV0aWxzLmdlbmVyYXRlRWxlbWVudElEU3RyaW5nKHQpKS5hdHRyKFwiY2xhc3NcIiwgdCkuYXR0cihcIngxXCIsIGEgLSAzICogMC4yICogcykuYXR0cihcIngyXCIsIG8pLmF0dHIoXCJ5MVwiLCAwKS5hdHRyKFwieTJcIiwgMCkuYXR0cihcImdyYWRpZW50VW5pdHNcIiwgXCJ1c2VyU3BhY2VPblVzZVwiKS5hdHRyKFwiZ3JhZGllbnRUcmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCwgMClcIiksIHUgPSBgXG5cdFx0XHQ8c3RvcCBjbGFzcz1cIiR7bn1cIiBvZmZzZXQ9XCIke2F9XCI+PC9zdG9wPlxuXHRcdFx0PHN0b3AgY2xhc3M9XCIke3J9XCIgb2Zmc2V0PVwiJHthICsgMC4yfVwiPjwvc3RvcD5cblx0XHRcdDxzdG9wIGNsYXNzPVwiJHtufVwiIG9mZnNldD1cIiR7YSArIDIgKiAwLjJ9XCI+PC9zdG9wPlxuXHRcdGA7XG4gICAgYy5odG1sKHUpLCBkKCk7XG4gICAgZnVuY3Rpb24gZCgpIHtcbiAgICAgIGMuYXR0cihcImdyYWRpZW50VHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHthIC0gMyAqIDAuMiAqIHN9LCAwKWApLnRyYW5zaXRpb24oKS5kdXJhdGlvbigyZTMpLmRlbGF5KDFlMykuZWFzZShYQykuYXR0cihcImdyYWRpZW50VHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHtvICsgMyAqIDAuMiAqIHN9LCAwKWApLm9uKFwiZW5kXCIsIGQpO1xuICAgIH1cbiAgfVxuICByZW1vdmVTa2VsZXRvbigpIHtcbiAgICB0aGlzLnBhcmVudC5zZWxlY3QoXCIuY2hhcnQtc2tlbGV0b25cIikucmVtb3ZlKCk7XG4gIH1cbn1cbmNsYXNzIGZEIGV4dGVuZHMgbXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnR5cGUgPSBcImJveHBsb3RcIiwgdGhpcy5yZW5kZXJUeXBlID0gcnQuU1ZHO1xuICB9XG4gIHJlbmRlcih0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0Q29tcG9uZW50Q29udGFpbmVyKHsgYXJpYUxhYmVsOiBcImJveCBwbG90c1wiLCB3aXRoaW5DaGFydENsaXA6ICEwIH0pLCByID0gdGhpcy5nZXRPcHRpb25zKCksIHsgZ3JvdXBNYXBzVG86IGkgfSA9IHIuZGF0YSwgcyA9IHRoaXMubW9kZWwuZ2V0RGF0YUdyb3VwTmFtZXMoKSwgYSA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldE1haW5YU2NhbGUoKSwgbyA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldE1haW5ZU2NhbGUoKSwgW2wsIGNdID0gYS5yYW5nZSgpLCBbdSwgZF0gPSBvLnJhbmdlKCksIGggPSBjIC0gbCwgcCA9IHUgLSBkO1xuICAgIGlmIChoID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgY2FydGVzaWFuU2NhbGVzOiBmIH0gPSB0aGlzLnNlcnZpY2VzLCBnID0gZi5nZXRPcmllbnRhdGlvbigpLCBtID0gZyA9PT0gRnQuVkVSVElDQUwsIFt2LCB4XSA9IEVuKFxuICAgICAgKCQpID0+IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpblZhbHVlKCQpLFxuICAgICAgKCQpID0+IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlVmFsdWUoJCksXG4gICAgICBnXG4gICAgKSwgXyA9IE1hdGguZmxvb3IoKG0gPyBoIDogcCkgLyBzLmxlbmd0aCksIEUgPSBNYXRoLm1pbihfIC8gMiwgMTYpLCBiID0gdGhpcy5tb2RlbC5nZXRCb3hwbG90RGF0YSgpLCBTID0gbi5zZWxlY3RBbGwoXCIuYm94LWdyb3VwXCIpLmRhdGEoYik7XG4gICAgUy5leGl0KCkucmVtb3ZlKCk7XG4gICAgY29uc3QgTSA9IFMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcImJveC1ncm91cFwiKSwgRCA9IFMubWVyZ2UoTSk7XG4gICAgTS5hcHBlbmQoXCJwYXRoXCIpLm1lcmdlKFMuc2VsZWN0KFwicGF0aC52ZXJ0aWNhbC1saW5lLnN0YXJ0XCIpKS5hdHRyKFxuICAgICAgXCJjbGFzc1wiLFxuICAgICAgKCkgPT4gdGhpcy5tb2RlbC5nZXRDb2xvckNsYXNzTmFtZSh7XG4gICAgICAgIGNsYXNzTmFtZVR5cGVzOiBbaXQuU1RST0tFXSxcbiAgICAgICAgb3JpZ2luYWxDbGFzc05hbWU6IFwidmVydGljYWwtbGluZSBzdGFydFwiXG4gICAgICB9KVxuICAgICkuYXR0cihcInN0cm9rZS13aWR0aFwiLCBUZS5zdHJva2VXaWR0aC5kZWZhdWx0KS5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIikudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAoJCkgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICB0cmFuc2l0aW9uOiAkLFxuICAgICAgICBuYW1lOiBcImJveHBsb3QtdXBkYXRlLXZlcnRpY2Fsc3RhcnRsaW5lXCIsXG4gICAgICAgIGFuaW1hdGU6IHRcbiAgICAgIH0pXG4gICAgKS5hdHRyKFwiZFwiLCAoJCkgPT4ge1xuICAgICAgY29uc3QgSCA9IGYuZ2V0RG9tYWluVmFsdWUoJFtpXSksIFAgPSBILCBCID0gZi5nZXRSYW5nZVZhbHVlKCQud2hpc2tlcnMubWluKSwgTyA9IGYuZ2V0UmFuZ2VWYWx1ZSgkLnF1YXJ0aWxlcy5xXzI1KTtcbiAgICAgIHJldHVybiBhZSh7IHgwOiBILCB4MTogUCwgeTA6IEIsIHkxOiBPIH0sIGcpO1xuICAgIH0pLCBNLmFwcGVuZChcInBhdGhcIikubWVyZ2UoUy5zZWxlY3QoXCJwYXRoLnZlcnRpY2FsLWxpbmUuZW5kXCIpKS5hdHRyKFxuICAgICAgXCJjbGFzc1wiLFxuICAgICAgKCkgPT4gdGhpcy5tb2RlbC5nZXRDb2xvckNsYXNzTmFtZSh7XG4gICAgICAgIGNsYXNzTmFtZVR5cGVzOiBbaXQuU1RST0tFXSxcbiAgICAgICAgb3JpZ2luYWxDbGFzc05hbWU6IFwidmVydGljYWwtbGluZSBlbmRcIlxuICAgICAgfSlcbiAgICApLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgVGUuc3Ryb2tlV2lkdGguZGVmYXVsdCkuYXR0cihcImZpbGxcIiwgXCJub25lXCIpLnRyYW5zaXRpb24oKS5jYWxsKFxuICAgICAgKCQpID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgdHJhbnNpdGlvbjogJCxcbiAgICAgICAgbmFtZTogXCJib3hwbG90LXVwZGF0ZS12ZXJ0aWNhbGVuZGxpbmVcIixcbiAgICAgICAgYW5pbWF0ZTogdFxuICAgICAgfSlcbiAgICApLmF0dHIoXCJkXCIsICgkKSA9PiB7XG4gICAgICBjb25zdCBIID0gZi5nZXREb21haW5WYWx1ZSgkW2ldKSwgUCA9IEgsIEIgPSBmLmdldFJhbmdlVmFsdWUoJC53aGlza2Vycy5tYXgpLCBPID0gZi5nZXRSYW5nZVZhbHVlKCQucXVhcnRpbGVzLnFfNzUpO1xuICAgICAgcmV0dXJuIGFlKHsgeDA6IEgsIHgxOiBQLCB5MDogQiwgeTE6IE8gfSwgZyk7XG4gICAgfSksIE0uYXBwZW5kKFwicGF0aFwiKS5tZXJnZShTLnNlbGVjdChcInBhdGguYm94XCIpKS5hdHRyKFxuICAgICAgXCJjbGFzc1wiLFxuICAgICAgKCkgPT4gdGhpcy5tb2RlbC5nZXRDb2xvckNsYXNzTmFtZSh7XG4gICAgICAgIGNsYXNzTmFtZVR5cGVzOiBbaXQuRklMTCwgaXQuU1RST0tFXSxcbiAgICAgICAgb3JpZ2luYWxDbGFzc05hbWU6IFwiYm94XCJcbiAgICAgIH0pXG4gICAgKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIFRlLmJveC5vcGFjaXR5LmRlZmF1bHQpLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgVGUuc3Ryb2tlV2lkdGguZGVmYXVsdCkuYXR0cihcInJvbGVcIiwgaHQuR1JBUEhJQ1NfU1lNQk9MKS5hdHRyKFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIiwgXCJib3hcIikuYXR0cihcImFyaWEtbGFiZWxcIiwgKCQpID0+ICRbaV0pLnRyYW5zaXRpb24oKS5jYWxsKFxuICAgICAgKCQpID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgdHJhbnNpdGlvbjogJCxcbiAgICAgICAgbmFtZTogXCJib3hwbG90LXVwZGF0ZS1xdWFydGlsZXNcIixcbiAgICAgICAgYW5pbWF0ZTogdFxuICAgICAgfSlcbiAgICApLmF0dHIoXCJkXCIsICgkKSA9PiB7XG4gICAgICBjb25zdCBIID0gZi5nZXREb21haW5WYWx1ZSgkW2ldKSAtIEUgLyAyLCBQID0gSCArIEUsIEIgPSBmLmdldFJhbmdlVmFsdWUoXG4gICAgICAgIE1hdGhbbSA/IFwibWF4XCIgOiBcIm1pblwiXSgkLnF1YXJ0aWxlcy5xXzc1LCAkLnF1YXJ0aWxlcy5xXzI1KVxuICAgICAgKSwgTyA9IEIgKyBNYXRoLmFicyhcbiAgICAgICAgZi5nZXRSYW5nZVZhbHVlKCQucXVhcnRpbGVzLnFfNzUpIC0gZi5nZXRSYW5nZVZhbHVlKCQucXVhcnRpbGVzLnFfMjUpXG4gICAgICApO1xuICAgICAgcmV0dXJuIGFlKHsgeDA6IEgsIHgxOiBQLCB5MDogQiwgeTE6IE8gfSwgZyk7XG4gICAgfSksIE0uYXBwZW5kKFwicGF0aFwiKS5tZXJnZShTLnNlbGVjdChcInBhdGguaGlnaGxpZ2h0LWFyZWFcIikpLmF0dHIoXCJjbGFzc1wiLCBcImhpZ2hsaWdodC1hcmVhXCIpLmF0dHIoXCJvcGFjaXR5XCIsIDApLmF0dHIoXCJkXCIsICgkKSA9PiB7XG4gICAgICBjb25zdCBIID0gZi5nZXREb21haW5WYWx1ZSgkW2ldKSAtIEUgLyAyLCBQID0gSCArIEUsIEIgPSBmLmdldFJhbmdlVmFsdWUoJC53aGlza2Vycy5taW4pLCBPID0gZi5nZXRSYW5nZVZhbHVlKCQud2hpc2tlcnMubWF4KTtcbiAgICAgIHJldHVybiBhZSh7IHgwOiBILCB4MTogUCwgeTA6IEIsIHkxOiBPIH0sIGcpO1xuICAgIH0pLCBNLmFwcGVuZChcInBhdGhcIikubWVyZ2UoUy5zZWxlY3QoXCJwYXRoLndoaXNrZXIuc3RhcnRcIikpLmF0dHIoXG4gICAgICBcImNsYXNzXCIsXG4gICAgICAoKSA9PiB0aGlzLm1vZGVsLmdldENvbG9yQ2xhc3NOYW1lKHtcbiAgICAgICAgY2xhc3NOYW1lVHlwZXM6IFtpdC5TVFJPS0VdLFxuICAgICAgICBvcmlnaW5hbENsYXNzTmFtZTogXCJ3aGlza2VyIHN0YXJ0XCJcbiAgICAgIH0pXG4gICAgKS5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIFRlLnN0cm9rZVdpZHRoLnRoaWNrZXIpLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKS50cmFuc2l0aW9uKCkuY2FsbChcbiAgICAgICgkKSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgIHRyYW5zaXRpb246ICQsXG4gICAgICAgIG5hbWU6IFwiYm94cGxvdC11cGRhdGUtc3RhcnRpbmd3aGlza2VyXCIsXG4gICAgICAgIGFuaW1hdGU6IHRcbiAgICAgIH0pXG4gICAgKS5hdHRyKFwiZFwiLCAoJCkgPT4ge1xuICAgICAgY29uc3QgSCA9IGYuZ2V0RG9tYWluVmFsdWUoJFtpXSkgLSBFIC8gNCwgUCA9IEggKyBFIC8gMiwgQiA9IGYuZ2V0UmFuZ2VWYWx1ZSgkLndoaXNrZXJzLm1pbiksIE8gPSBmLmdldFJhbmdlVmFsdWUoJC53aGlza2Vycy5taW4pO1xuICAgICAgcmV0dXJuIGFlKHsgeDA6IEgsIHgxOiBQLCB5MDogQiwgeTE6IE8gfSwgZyk7XG4gICAgfSksIE0uYXBwZW5kKFwicGF0aFwiKS5tZXJnZShTLnNlbGVjdChcInBhdGgubWVkaWFuXCIpKS5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIikuYXR0cihcbiAgICAgIFwiY2xhc3NcIixcbiAgICAgICgpID0+IHRoaXMubW9kZWwuZ2V0Q29sb3JDbGFzc05hbWUoe1xuICAgICAgICBjbGFzc05hbWVUeXBlczogW2l0LlNUUk9LRV0sXG4gICAgICAgIG9yaWdpbmFsQ2xhc3NOYW1lOiBcIm1lZGlhblwiXG4gICAgICB9KVxuICAgICkuYXR0cihcInN0cm9rZS13aWR0aFwiLCAyKS50cmFuc2l0aW9uKCkuY2FsbChcbiAgICAgICgkKSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgIHRyYW5zaXRpb246ICQsXG4gICAgICAgIG5hbWU6IFwiYm94cGxvdC11cGRhdGUtbWVkaWFuXCIsXG4gICAgICAgIGFuaW1hdGU6IHRcbiAgICAgIH0pXG4gICAgKS5hdHRyKFwiZFwiLCAoJCkgPT4ge1xuICAgICAgY29uc3QgSCA9IGYuZ2V0RG9tYWluVmFsdWUoJFtpXSkgLSBFIC8gMiwgUCA9IEggKyBFLCBCID0gZi5nZXRSYW5nZVZhbHVlKCQucXVhcnRpbGVzLnFfNTApO1xuICAgICAgcmV0dXJuIGFlKHsgeDA6IEgsIHgxOiBQLCB5MDogQiwgeTE6IEIgfSwgZyk7XG4gICAgfSksIE0uYXBwZW5kKFwicGF0aFwiKS5tZXJnZShTLnNlbGVjdChcInBhdGgud2hpc2tlci5lbmRcIikpLmF0dHIoXG4gICAgICBcImNsYXNzXCIsXG4gICAgICAoKSA9PiB0aGlzLm1vZGVsLmdldENvbG9yQ2xhc3NOYW1lKHtcbiAgICAgICAgY2xhc3NOYW1lVHlwZXM6IFtpdC5TVFJPS0VdLFxuICAgICAgICBvcmlnaW5hbENsYXNzTmFtZTogXCJ3aGlza2VyIGVuZFwiXG4gICAgICB9KVxuICAgICkuYXR0cihcInN0cm9rZS13aWR0aFwiLCBUZS5zdHJva2VXaWR0aC50aGlja2VyKS5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIikudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAoJCkgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICB0cmFuc2l0aW9uOiAkLFxuICAgICAgICBuYW1lOiBcImJveHBsb3QtdXBkYXRlLWVuZGluZ3doaXNrZXJcIixcbiAgICAgICAgYW5pbWF0ZTogdFxuICAgICAgfSlcbiAgICApLmF0dHIoXCJkXCIsICgkKSA9PiB7XG4gICAgICBjb25zdCBIID0gZi5nZXREb21haW5WYWx1ZSgkW2ldKSAtIEUgLyA0LCBQID0gSCArIEUgLyAyLCBCID0gZi5nZXRSYW5nZVZhbHVlKCQud2hpc2tlcnMubWF4KSwgTyA9IGYuZ2V0UmFuZ2VWYWx1ZSgkLndoaXNrZXJzLm1heCk7XG4gICAgICByZXR1cm4gYWUoeyB4MDogSCwgeDE6IFAsIHkwOiBCLCB5MTogTyB9LCBnKTtcbiAgICB9KTtcbiAgICBjb25zdCBBID0gRC5zZWxlY3RBbGwoXCJjaXJjbGUub3V0bGllclwiKS5kYXRhKFxuICAgICAgKCQpID0+ICQub3V0bGllcnMubWFwKChIKSA9PiAoe1xuICAgICAgICBtaW46ICQud2hpc2tlcnMubWluLFxuICAgICAgICBtYXg6ICQud2hpc2tlcnMubWF4LFxuICAgICAgICBbaV06ICRbaV0sXG4gICAgICAgIHZhbHVlOiBIXG4gICAgICB9KSlcbiAgICApO1xuICAgIEEuZXhpdCgpLnJlbW92ZSgpO1xuICAgIGNvbnN0IFIgPSBBLmVudGVyKCkuYXBwZW5kKFwiY2lyY2xlXCIpO1xuICAgIEEubWVyZ2UoUikuYXR0cihcInJcIiwgVGUuY2lyY2xlLnJhZGl1cykuYXR0cihcbiAgICAgIFwiY2xhc3NcIixcbiAgICAgICgpID0+IHRoaXMubW9kZWwuZ2V0Q29sb3JDbGFzc05hbWUoe1xuICAgICAgICBjbGFzc05hbWVUeXBlczogW2l0LkZJTEwsIGl0LlNUUk9LRV0sXG4gICAgICAgIG9yaWdpbmFsQ2xhc3NOYW1lOiBcIm91dGxpZXJcIlxuICAgICAgfSlcbiAgICApLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgVGUuY2lyY2xlLm9wYWNpdHkuZGVmYXVsdCkuYXR0cihcImN4XCIsIHYpLnRyYW5zaXRpb24oKS5jYWxsKFxuICAgICAgKCQpID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgdHJhbnNpdGlvbjogJCxcbiAgICAgICAgbmFtZTogXCJib3hwbG90LXVwZGF0ZS1jaXJjbGVzXCIsXG4gICAgICAgIGFuaW1hdGU6IHRcbiAgICAgIH0pXG4gICAgKS5hdHRyKFwiY3lcIiwgeCksIHRoaXMuYWRkQm94RXZlbnRMaXN0ZW5lcnMoKSwgdGhpcy5hZGRDaXJjbGVFdmVudExpc3RlbmVycygpO1xuICB9XG4gIGFkZEJveEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLCBuID0gdGhpcy5nZXRPcHRpb25zKCksIHsgZ3JvdXBNYXBzVG86IHIgfSA9IG4uZGF0YTtcbiAgICB0aGlzLnBhcmVudC5zZWxlY3RBbGwoXCJwYXRoLmhpZ2hsaWdodC1hcmVhXCIpLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKGksIHMpIHtcbiAgICAgIGNvbnN0IGEgPSBJKHRoaXMpO1xuICAgICAgSSh0aGlzLnBhcmVudE5vZGUpLnNlbGVjdChcInBhdGguYm94XCIpLmNsYXNzZWQoXCJob3ZlcmVkXCIsICEwKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIFRlLmJveC5vcGFjaXR5LmhvdmVyZWQpLCB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5TSE9XLCB7XG4gICAgICAgIGV2ZW50OiBpLFxuICAgICAgICBob3ZlcmVkRWxlbWVudDogYSxcbiAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogeShuLCBcImxvY2FsZVwiLCBcInRyYW5zbGF0aW9uc1wiLCBcImdyb3VwXCIpIHx8IHkobiwgXCJ0b29sdGlwXCIsIFwiZ3JvdXBMYWJlbFwiKSB8fCBcIkdyb3VwXCIsXG4gICAgICAgICAgICB2YWx1ZTogc1tyXSxcbiAgICAgICAgICAgIGNsYXNzOiB0Lm1vZGVsLmdldENvbG9yQ2xhc3NOYW1lKHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lVHlwZXM6IFtpdC5UT09MVElQXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiBcIk1pbmltdW1cIixcbiAgICAgICAgICAgIHZhbHVlOiBzLndoaXNrZXJzLm1pblxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6IFwiUTFcIixcbiAgICAgICAgICAgIHZhbHVlOiBzLnF1YXJ0aWxlcy5xXzI1XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogXCJNZWRpYW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBzLnF1YXJ0aWxlcy5xXzUwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogXCJRM1wiLFxuICAgICAgICAgICAgdmFsdWU6IHMucXVhcnRpbGVzLnFfNzVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiBcIk1heGltdW1cIixcbiAgICAgICAgICAgIHZhbHVlOiBzLndoaXNrZXJzLm1heFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6IFwiSVFSXCIsXG4gICAgICAgICAgICB2YWx1ZTogcy5xdWFydGlsZXMucV83NSAtIHMucXVhcnRpbGVzLnFfMjVcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0pLCB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuQm94cGxvdC5CT1hfTU9VU0VPVkVSLCB7XG4gICAgICAgIGV2ZW50OiBpLFxuICAgICAgICBlbGVtZW50OiBhLFxuICAgICAgICBkYXR1bTogc1xuICAgICAgfSk7XG4gICAgfSkub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24oaSwgcykge1xuICAgICAgY29uc3QgYSA9IEkodGhpcyk7XG4gICAgICB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuQm94cGxvdC5CT1hfTU9VU0VNT1ZFLCB7XG4gICAgICAgIGV2ZW50OiBpLFxuICAgICAgICBlbGVtZW50OiBhLFxuICAgICAgICBkYXR1bTogc1xuICAgICAgfSksIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLk1PVkUsIHtcbiAgICAgICAgZXZlbnQ6IGlcbiAgICAgIH0pO1xuICAgIH0pLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oaSwgcykge1xuICAgICAgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkJveHBsb3QuQk9YX0NMSUNLLCB7XG4gICAgICAgIGV2ZW50OiBpLFxuICAgICAgICBlbGVtZW50OiBJKHRoaXMpLFxuICAgICAgICBkYXR1bTogc1xuICAgICAgfSk7XG4gICAgfSkub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihpLCBzKSB7XG4gICAgICBjb25zdCBhID0gSSh0aGlzKTtcbiAgICAgIEkodGhpcy5wYXJlbnROb2RlKS5zZWxlY3QoXCJwYXRoLmJveFwiKS5jbGFzc2VkKFwiaG92ZXJlZFwiLCAhMSkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCBUZS5ib3gub3BhY2l0eS5kZWZhdWx0KSwgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkJveHBsb3QuQk9YX01PVVNFT1VULCB7XG4gICAgICAgIGV2ZW50OiBpLFxuICAgICAgICBlbGVtZW50OiBhLFxuICAgICAgICBkYXR1bTogc1xuICAgICAgfSksIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLkhJREUsIHtcbiAgICAgICAgaG92ZXJlZEVsZW1lbnQ6IGFcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGFkZENpcmNsZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLCBuID0gdGhpcy5nZXRPcHRpb25zKCksIHsgZ3JvdXBNYXBzVG86IHIgfSA9IG4uZGF0YSwgaSA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlSWRlbnRpZmllcigpO1xuICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcImNpcmNsZVwiKS5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbihzLCBhKSB7XG4gICAgICBjb25zdCBvID0gSSh0aGlzKTtcbiAgICAgIG8uY2xhc3NlZChcImhvdmVyZWRcIiwgITApLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgVGUuY2lyY2xlLm9wYWNpdHkuaG92ZXJlZCkuY2xhc3NlZChcInVuZmlsbGVkXCIsICExKSwgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuU0hPVywge1xuICAgICAgICBldmVudDogcyxcbiAgICAgICAgaG92ZXJlZEVsZW1lbnQ6IG8sXG4gICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6IHkobiwgXCJsb2NhbGVcIiwgXCJ0cmFuc2xhdGlvbnNcIiwgXCJncm91cFwiKSB8fCB5KG4sIFwidG9vbHRpcFwiLCBcImdyb3VwTGFiZWxcIikgfHwgXCJHcm91cFwiLFxuICAgICAgICAgICAgdmFsdWU6IGFbcl0sXG4gICAgICAgICAgICBjbGFzczogdC5tb2RlbC5nZXRDb2xvckNsYXNzTmFtZSh7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZVR5cGVzOiBbaXQuVE9PTFRJUF1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogXCJPdXRsaWVyXCIsXG4gICAgICAgICAgICB2YWx1ZTogYVtpXVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSksIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Cb3hwbG90Lk9VVExJRVJfTU9VU0VPVkVSLCB7XG4gICAgICAgIGV2ZW50OiBzLFxuICAgICAgICBlbGVtZW50OiBvLFxuICAgICAgICBkYXR1bTogYVxuICAgICAgfSk7XG4gICAgfSkub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24ocywgYSkge1xuICAgICAgY29uc3QgbyA9IEkodGhpcyk7XG4gICAgICB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuQm94cGxvdC5PVVRMSUVSX01PVVNFTU9WRSwge1xuICAgICAgICBldmVudDogcyxcbiAgICAgICAgZWxlbWVudDogbyxcbiAgICAgICAgZGF0dW06IGFcbiAgICAgIH0pLCB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5NT1ZFLCB7XG4gICAgICAgIGV2ZW50OiBzXG4gICAgICB9KTtcbiAgICB9KS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKHMsIGEpIHtcbiAgICAgIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Cb3hwbG90Lk9VVExJRVJfQ0xJQ0ssIHtcbiAgICAgICAgZXZlbnQ6IHMsXG4gICAgICAgIGVsZW1lbnQ6IEkodGhpcyksXG4gICAgICAgIGRhdHVtOiBhXG4gICAgICB9KTtcbiAgICB9KS5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKHMsIGEpIHtcbiAgICAgIGNvbnN0IG8gPSBJKHRoaXMpO1xuICAgICAgby5jbGFzc2VkKFwiaG92ZXJlZFwiLCAhMSkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCBUZS5jaXJjbGUub3BhY2l0eS5kZWZhdWx0KSwgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkJveHBsb3QuT1VUTElFUl9NT1VTRU9VVCwge1xuICAgICAgICBldmVudDogcyxcbiAgICAgICAgZWxlbWVudDogbyxcbiAgICAgICAgZGF0dW06IGFcbiAgICAgIH0pLCB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5ISURFLCB7XG4gICAgICAgIGhvdmVyZWRFbGVtZW50OiBvXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3Mgc2kgZXh0ZW5kcyBtdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IFwiemVyby1saW5lXCIsIHRoaXMucmVuZGVyVHlwZSA9IHJ0LlNWRztcbiAgfVxuICByZW5kZXIodCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRSYW5nZUF4aXNQb3NpdGlvbih7XG4gICAgICBncm91cHM6IHRoaXMuY29uZmlncy5ncm91cHNcbiAgICB9KSwgciA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFNjYWxlQnlQb3NpdGlvbihuKSwgW2ksIHNdID0gci5kb21haW4oKSwgYSA9IGkgPiAwICYmIHMgPCAwIHx8IGkgPCAwICYmIHMgPiAwLCBvID0gdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoe1xuICAgICAgaXNQcmVzZW50YXRpb25hbDogITBcbiAgICB9KTtcbiAgICBpZiAoIWEpIHtcbiAgICAgIG8uc2VsZWN0QWxsKFwibGluZS5kb21haW5cIikucmVtb3ZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtsLCBjXSA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpblNjYWxlKCkucmFuZ2UoKTtcbiAgICBsZXQgdSA9ICtyKDApICsgMC41O1xuICAgIHUgfHwgKHUgPSByLnJhbmdlKClbMF0pO1xuICAgIGNvbnN0IGQgPSBQbShcbiAgICAgIHtcbiAgICAgICAgeDA6IGwsXG4gICAgICAgIHgxOiBjLFxuICAgICAgICB5MDogdSxcbiAgICAgICAgeTE6IHVcbiAgICAgIH0sXG4gICAgICB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRPcmllbnRhdGlvbigpXG4gICAgKTtcbiAgICBOLmFwcGVuZE9yU2VsZWN0KG8sIFwibGluZS5kb21haW5cIikudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAoaCkgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICB0cmFuc2l0aW9uOiBoLFxuICAgICAgICBuYW1lOiBcInplcm8tbGluZS11cGRhdGVcIixcbiAgICAgICAgYW5pbWF0ZTogdFxuICAgICAgfSlcbiAgICApLmF0dHIoXCJ5MVwiLCBkLnkwKS5hdHRyKFwieTJcIiwgZC55MSkuYXR0cihcIngxXCIsIGQueDApLmF0dHIoXCJ4MlwiLCBkLngxKTtcbiAgfVxufVxuY2xhc3MgbUQgZXh0ZW5kcyBubiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IFwiYnViYmxlXCIsIHRoaXMucmVuZGVyVHlwZSA9IHJ0LlNWRztcbiAgfVxuICBnZXRSYWRpdXNTY2FsZSh0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0T3B0aW9ucygpLCB7IHJhZGl1c01hcHNUbzogciB9ID0gbi5idWJibGUsIGkgPSB0LmRhdGEoKSwgcyA9IGkubWFwKChjKSA9PiBjW3JdKS5maWx0ZXIoKGMpID0+IGMpLCBhID0gTi5nZXRIVE1MRWxlbWVudFNpemUodGhpcy5zZXJ2aWNlcy5kb21VdGlscy5nZXRNYWluQ29udGFpbmVyKCkpLCBvID0gcy5sZW5ndGggPiAwLCBsID0gbyA/IHplKHMpIDogWzEsIDFdO1xuICAgIHJldHVybiBGZSgpLmRvbWFpbihsKS5yYW5nZShvID8gbi5idWJibGUucmFkaXVzUmFuZ2UoYSwgaSkgOiBbNCwgNF0pO1xuICB9XG4gIHN0eWxlQ2lyY2xlcyh0LCBuKSB7XG4gICAgY29uc3QgciA9IHRoaXMuZ2V0T3B0aW9ucygpLCB7IHJhZGl1c01hcHNUbzogaSB9ID0gci5idWJibGUsIHMgPSB0aGlzLmdldFJhZGl1c1NjYWxlKHQpLCB7IGdyb3VwTWFwc1RvOiBhIH0gPSByLmRhdGEsIHsgY2FydGVzaWFuU2NhbGVzOiBvIH0gPSB0aGlzLnNlcnZpY2VzLCBsID0gKGgpID0+IG8uZ2V0RG9tYWluVmFsdWUoaCksIGMgPSAoaCkgPT4gby5nZXRSYW5nZVZhbHVlKGgpLCBbdSwgZF0gPSBFbihcbiAgICAgIGwsXG4gICAgICBjLFxuICAgICAgby5nZXRPcmllbnRhdGlvbigpXG4gICAgKTtcbiAgICB0LnJhaXNlKCkuY2xhc3NlZChcImRvdFwiLCAhMCkuYXR0cihcInJvbGVcIiwgaHQuR1JBUEhJQ1NfU1lNQk9MKS5hdHRyKFwiYXJpYS1sYWJlbFwiLCAoaCkgPT4ge1xuICAgICAgY29uc3QgcCA9IG8uZ2V0UmFuZ2VJZGVudGlmaWVyKGgpO1xuICAgICAgcmV0dXJuIGhbcF07XG4gICAgfSkudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAoaCkgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICB0cmFuc2l0aW9uOiBoLFxuICAgICAgICBuYW1lOiBcImJ1YmJsZS11cGRhdGUtZW50ZXJcIixcbiAgICAgICAgYW5pbWF0ZTogblxuICAgICAgfSlcbiAgICApLmF0dHIoXCJjeFwiLCB1KS5hdHRyKFwiY3lcIiwgZCkuYXR0cihcInJcIiwgKGgpID0+IHMoaFtpXSB8fCAxKSkuYXR0cihcbiAgICAgIFwiY2xhc3NcIixcbiAgICAgIChoKSA9PiB0aGlzLm1vZGVsLmdldENvbG9yQ2xhc3NOYW1lKHtcbiAgICAgICAgY2xhc3NOYW1lVHlwZXM6IFtpdC5GSUxMLCBpdC5TVFJPS0VdLFxuICAgICAgICBkYXRhR3JvdXBOYW1lOiBoW2FdLFxuICAgICAgICBvcmlnaW5hbENsYXNzTmFtZTogXCJkb3RcIlxuICAgICAgfSlcbiAgICApLnN0eWxlKFwiZmlsbFwiLCAoaCkgPT4ge1xuICAgICAgY29uc3QgcCA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpbklkZW50aWZpZXIoaCk7XG4gICAgICByZXR1cm4gdGhpcy5tb2RlbC5nZXRGaWxsQ29sb3IoaFthXSwgaFtwXSwgaCk7XG4gICAgfSkuc3R5bGUoXCJzdHJva2VcIiwgKGgpID0+IHtcbiAgICAgIGNvbnN0IHAgPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXREb21haW5JZGVudGlmaWVyKGgpO1xuICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZ2V0U3Ryb2tlQ29sb3IoaFthXSwgaFtwXSwgaCk7XG4gICAgfSkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCByLmJ1YmJsZS5maWxsT3BhY2l0eSkuYXR0cihcIm9wYWNpdHlcIiwgMSk7XG4gIH1cbiAgZ2V0VG9vbHRpcEFkZGl0aW9uYWxJdGVtcyh0KSB7XG4gICAgY29uc3QgbiA9IHkodGhpcy5nZXRPcHRpb25zKCksIFwiYnViYmxlXCIpO1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGxhYmVsOiB5KG4sIFwicmFkaXVzTGFiZWxcIiksXG4gICAgICAgIHZhbHVlOiB0W3kobiwgXCJyYWRpdXNNYXBzVG9cIildXG4gICAgICB9XG4gICAgXTtcbiAgfVxufVxuY2xhc3MgZ0QgZXh0ZW5kcyBtdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IFwiYnVsbGV0XCIsIHRoaXMucmVuZGVyVHlwZSA9IHJ0LlNWRywgdGhpcy5oYW5kbGVMZWdlbmRPbkhvdmVyID0gKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgaG92ZXJlZEVsZW1lbnQ6IG4gfSA9IHQuZGV0YWlsLCB7IGdyb3VwTWFwc1RvOiByIH0gPSB0aGlzLmdldE9wdGlvbnMoKS5kYXRhO1xuICAgICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwicGF0aC5iYXJcIikudHJhbnNpdGlvbihcImxlZ2VuZC1ob3Zlci1zaW1wbGUtYmFyXCIpLmNhbGwoXG4gICAgICAgIChpKSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgdHJhbnNpdGlvbjogaSxcbiAgICAgICAgICBuYW1lOiBcImxlZ2VuZC1ob3Zlci1zaW1wbGUtYmFyXCJcbiAgICAgICAgfSlcbiAgICAgICkuYXR0cihcIm9wYWNpdHlcIiwgKGkpID0+IGlbcl0gIT09IG4uZGF0dW0oKS5uYW1lID8gMC4zIDogMSk7XG4gICAgfSwgdGhpcy5oYW5kbGVMZWdlbmRNb3VzZU91dCA9ICgpID0+IHtcbiAgICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcInBhdGguYmFyXCIpLnRyYW5zaXRpb24oXCJsZWdlbmQtbW91c2VvdXQtc2ltcGxlLWJhclwiKS5jYWxsKFxuICAgICAgICAodCkgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICAgIHRyYW5zaXRpb246IHQsXG4gICAgICAgICAgbmFtZTogXCJsZWdlbmQtbW91c2VvdXQtc2ltcGxlLWJhclwiXG4gICAgICAgIH0pXG4gICAgICApLmF0dHIoXCJvcGFjaXR5XCIsIDEpO1xuICAgIH07XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5zZXJ2aWNlcy5ldmVudHM7XG4gICAgdC5hZGRFdmVudExpc3RlbmVyKFQuTGVnZW5kLklURU1fSE9WRVIsIHRoaXMuaGFuZGxlTGVnZW5kT25Ib3ZlciksIHQuYWRkRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX01PVVNFT1VULCB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlT3V0KTtcbiAgfVxuICByZW5kZXIodCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldE9wdGlvbnMoKSwgeyBncm91cE1hcHNUbzogciB9ID0gbi5kYXRhLCBpID0gdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoeyBhcmlhTGFiZWw6IFwiYnVsbGV0IGdyYXBoc1wiLCB3aXRoaW5DaGFydENsaXA6ICEwIH0pLCBzID0gdGhpcy5tb2RlbC5nZXREaXNwbGF5RGF0YSh0aGlzLmNvbmZpZ3MuZ3JvdXBzKSwgYSA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlU2NhbGUoKSwgbyA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlSWRlbnRpZmllcigpLCBbbCwgY10gPSBhLnJhbmdlKCksIFssIHVdID0gYS5kb21haW4oKSwgZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGcgPSBbXTtcbiAgICAgIHMuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICB2LnJhbmdlcyA/IHYucmFuZ2VzLmZvckVhY2goKHgsIF8pID0+IHtcbiAgICAgICAgICB4ICE9IG51bGwgJiYgeCA8IHUgJiYgZy5wdXNoKHtcbiAgICAgICAgICAgIGRhdHVtOiB2LFxuICAgICAgICAgICAgdmFsdWU6IHgsXG4gICAgICAgICAgICBvcmRlcjogXyArIDFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkgOiBnLnB1c2goe1xuICAgICAgICAgIGRhdHVtOiB2LFxuICAgICAgICAgIG9yZGVyOiAxXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBtID0gTi5hcHBlbmRPclNlbGVjdChpLCBcImcucmFuZ2UtYm94ZXNcIikuc2VsZWN0QWxsKFwicGF0aC5yYW5nZS1ib3hcIikuZGF0YShnLCAodikgPT4gYCR7dltyXX0tJHt2Lm9yZGVyfWApO1xuICAgICAgbS5leGl0KCkuYXR0cihcIm9wYWNpdHlcIiwgMCkucmVtb3ZlKCksIG0uZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpLmF0dHIoXCJvcGFjaXR5XCIsIDApLm1lcmdlKG0pLmF0dHIoXCJjbGFzc1wiLCAodikgPT4gYHJhbmdlLWJveCBvcmRlci0ke3Yub3JkZXJ9YCkudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAgICh2KSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgdHJhbnNpdGlvbjogdixcbiAgICAgICAgICBuYW1lOiBcImJ1bGxldC1yYW5nZS1ib3gtdXBkYXRlLWVudGVyXCIsXG4gICAgICAgICAgYW5pbWF0ZTogdFxuICAgICAgICB9KVxuICAgICAgKS5hdHRyKFwiZFwiLCAodikgPT4ge1xuICAgICAgICBsZXQgeCwgXywgRSwgYjtcbiAgICAgICAgcmV0dXJuIHYub3JkZXIgPT09IDEgPyAoeCA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpblZhbHVlKHYuZGF0dW0pIC0gMTYgLyAyLCBfID0geCArIDE2LCBFID0gYyAtIDIsIGIgPSBsICsgMSkgOiAoeCA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpblZhbHVlKHYuZGF0dW0pIC0gMTYgLyAyLCBfID0geCArIDE2LCBFID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0UmFuZ2VWYWx1ZSh2LnZhbHVlKSwgYiA9IGMpLCBhZShcbiAgICAgICAgICB7IHgwOiB4LCB4MTogXywgeTA6IEUsIHkxOiBiIH0sXG4gICAgICAgICAgdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0T3JpZW50YXRpb24oKVxuICAgICAgICApO1xuICAgICAgfSkuYXR0cihcIm9wYWNpdHlcIiwgMSk7XG4gICAgfSwgaCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGcgPSBOLmFwcGVuZE9yU2VsZWN0KGksIFwiZy5iYXJzXCIpLnNlbGVjdEFsbChcInBhdGguYmFyXCIpLmRhdGEocywgKG0pID0+IG1bcl0pO1xuICAgICAgZy5leGl0KCkuYXR0cihcIm9wYWNpdHlcIiwgMCkucmVtb3ZlKCksIGcuZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpLmF0dHIoXCJvcGFjaXR5XCIsIDApLm1lcmdlKGcpLmNsYXNzZWQoXCJiYXJcIiwgITApLnRyYW5zaXRpb24oKS5jYWxsKFxuICAgICAgICAobSkgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICAgIHRyYW5zaXRpb246IG0sXG4gICAgICAgICAgbmFtZTogXCJidWxsZXQtYmFyLXVwZGF0ZS1lbnRlclwiLFxuICAgICAgICAgIGFuaW1hdGU6IHRcbiAgICAgICAgfSlcbiAgICAgICkuYXR0cihcbiAgICAgICAgXCJjbGFzc1wiLFxuICAgICAgICAobSkgPT4gdGhpcy5tb2RlbC5nZXRDb2xvckNsYXNzTmFtZSh7XG4gICAgICAgICAgY2xhc3NOYW1lVHlwZXM6IFtpdC5GSUxMXSxcbiAgICAgICAgICBkYXRhR3JvdXBOYW1lOiBtW3JdLFxuICAgICAgICAgIG9yaWdpbmFsQ2xhc3NOYW1lOiBcImJhclwiXG4gICAgICAgIH0pXG4gICAgICApLnN0eWxlKFwiZmlsbFwiLCAobSkgPT4ge1xuICAgICAgICBjb25zdCB2ID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0RG9tYWluSWRlbnRpZmllcihtKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZ2V0RmlsbENvbG9yKG1bcl0sIG1bdl0sIG0pO1xuICAgICAgfSkuYXR0cihcImRcIiwgKG0pID0+IHtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpblZhbHVlKG0pIC0gNCwgeCA9IHYgKyA4LCBfID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0UmFuZ2VWYWx1ZSgwKSArIDEsIEUgPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRSYW5nZVZhbHVlKG0pO1xuICAgICAgICByZXR1cm4gYWUoXG4gICAgICAgICAgeyB4MDogdiwgeDE6IHgsIHkwOiBfLCB5MTogRSB9LFxuICAgICAgICAgIHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldE9yaWVudGF0aW9uKClcbiAgICAgICAgKTtcbiAgICAgIH0pLmF0dHIoXCJvcGFjaXR5XCIsIDEpLmF0dHIoXCJyb2xlXCIsIGh0LkdSQVBISUNTX1NZTUJPTCkuYXR0cihcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCIsIFwiYmFyXCIpLmF0dHIoXCJhcmlhLWxhYmVsXCIsIChtKSA9PiBtLnZhbHVlKTtcbiAgICB9LCBwID0gKCkgPT4ge1xuICAgICAgY29uc3QgZyA9IE4uYXBwZW5kT3JTZWxlY3QoaSwgXCJnLm1hcmtlcnNcIikuc2VsZWN0QWxsKFwicGF0aC5tYXJrZXJcIikuZGF0YShcbiAgICAgICAgcy5maWx0ZXIoKG0pID0+IHkobSwgXCJtYXJrZXJcIikgIT09IG51bGwpLFxuICAgICAgICAobSkgPT4gbVtyXVxuICAgICAgKTtcbiAgICAgIGcuZXhpdCgpLmF0dHIoXCJvcGFjaXR5XCIsIDApLnJlbW92ZSgpLCBnLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwib3BhY2l0eVwiLCAwKS5tZXJnZShnKS5jbGFzc2VkKFwibWFya2VyXCIsICEwKS50cmFuc2l0aW9uKCkuY2FsbChcbiAgICAgICAgKG0pID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICB0cmFuc2l0aW9uOiBtLFxuICAgICAgICAgIG5hbWU6IFwiYnVsbGV0LW1hcmtlci11cGRhdGUtZW50ZXJcIixcbiAgICAgICAgICBhbmltYXRlOiB0XG4gICAgICAgIH0pXG4gICAgICApLmF0dHIoXCJkXCIsIChtKSA9PiB7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXREb21haW5WYWx1ZShtKSAtIDEyLCB4ID0gdiArIDI0LCBfID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0UmFuZ2VWYWx1ZShtLm1hcmtlcik7XG4gICAgICAgIHJldHVybiBhZShcbiAgICAgICAgICB7IHgwOiB2LCB4MTogeCwgeTA6IF8sIHkxOiBfIH0sXG4gICAgICAgICAgdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0T3JpZW50YXRpb24oKVxuICAgICAgICApO1xuICAgICAgfSkuYXR0cihcIm9wYWNpdHlcIiwgMSk7XG4gICAgfSwgZiA9ICgpID0+IHtcbiAgICAgIGxldCBnID0gW107XG4gICAgICBzLmZpbHRlcigodikgPT4geSh2LCBcIm1hcmtlclwiKSAhPT0gbnVsbCkuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICBjb25zdCB4ID0gdi5tYXJrZXIsIF8gPSB2W29dO1xuICAgICAgICBnID0gZy5jb25jYXQoW1xuICAgICAgICAgIHsgZGF0dW06IHYsIHZhbHVlOiB4ICogMC4yNSwgYmFyVmFsdWU6IF8gfSxcbiAgICAgICAgICB7IGRhdHVtOiB2LCB2YWx1ZTogeCAqIDAuNSwgYmFyVmFsdWU6IF8gfSxcbiAgICAgICAgICB7IGRhdHVtOiB2LCB2YWx1ZTogeCAqIDAuNzUsIGJhclZhbHVlOiBfIH1cbiAgICAgICAgXSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG0gPSBOLmFwcGVuZE9yU2VsZWN0KGksIFwiZy5xdWFydGlsZXNcIikuc2VsZWN0QWxsKFwicGF0aC5xdWFydGlsZVwiKS5kYXRhKGcsICh2KSA9PiB2W3JdKTtcbiAgICAgIG0uZXhpdCgpLmF0dHIoXCJvcGFjaXR5XCIsIDApLnJlbW92ZSgpLCBtLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwib3BhY2l0eVwiLCAwKS5tZXJnZShtKS5hdHRyKFwiY2xhc3NcIiwgKHYpID0+IGBxdWFydGlsZSAke3YudmFsdWUgPD0gdi5iYXJWYWx1ZSA/IFwib3Zlci1iYXJcIiA6IFwiXCJ9YCkudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAgICh2KSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgdHJhbnNpdGlvbjogdixcbiAgICAgICAgICBuYW1lOiBcImJ1bGxldC1xdWFydGlsZS11cGRhdGUtZW50ZXJcIixcbiAgICAgICAgICBhbmltYXRlOiB0XG4gICAgICAgIH0pXG4gICAgICApLmF0dHIoXCJkXCIsICh7IGRhdHVtOiB2LCB2YWx1ZTogeCB9KSA9PiB7XG4gICAgICAgIGxldCBfID0gNDtcbiAgICAgICAgdi5yYW5nZXMgJiYgdi5yYW5nZXMuaW5kZXhPZih4KSAhPT0gLTEgJiYgKF8gPSA4KTtcbiAgICAgICAgY29uc3QgRSA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpblZhbHVlKHYpIC0gXyAvIDIsIGIgPSBFICsgXywgUyA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlVmFsdWUoeCk7XG4gICAgICAgIHJldHVybiBhZShcbiAgICAgICAgICB7IHgwOiBFLCB4MTogYiwgeTA6IFMsIHkxOiBTIH0sXG4gICAgICAgICAgdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0T3JpZW50YXRpb24oKVxuICAgICAgICApO1xuICAgICAgfSkuYXR0cihcIm9wYWNpdHlcIiwgMSk7XG4gICAgfTtcbiAgICBkKCksIGgoKSwgcCgpLCBmKCksIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICBjb25zdCB0ID0gdGhpcywgbiA9IHRoaXMuZ2V0T3B0aW9ucygpLCB7IGdyb3VwTWFwc1RvOiByIH0gPSBuLmRhdGEsIGkgPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRSYW5nZUlkZW50aWZpZXIoKSwgeyBjb2RlOiBzLCBudW1iZXI6IGEgfSA9IHkobiwgXCJsb2NhbGVcIik7XG4gICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwicGF0aC5iYXJcIikub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24obywgbCkge1xuICAgICAgY29uc3QgYyA9IEkodGhpcyk7XG4gICAgICBjLmNsYXNzZWQoXCJob3ZlcmVkXCIsICEwKSwgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkJhci5CQVJfTU9VU0VPVkVSLCB7XG4gICAgICAgIGV2ZW50OiBvLFxuICAgICAgICBlbGVtZW50OiBjLFxuICAgICAgICBkYXR1bTogbFxuICAgICAgfSk7XG4gICAgICBjb25zdCB1ID0geShuLCBcImJ1bGxldFwiLCBcInBlcmZvcm1hbmNlQXJlYVRpdGxlc1wiKSwgZCA9IHQubW9kZWwuZ2V0TWF0Y2hpbmdSYW5nZUluZGV4Rm9yRGF0YXBvaW50KGwpO1xuICAgICAgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuU0hPVywge1xuICAgICAgICBldmVudDogbyxcbiAgICAgICAgaG92ZXJlZEVsZW1lbnQ6IGMsXG4gICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6IHkobiwgXCJsb2NhbGVcIiwgXCJ0cmFuc2xhdGlvbnNcIiwgXCJncm91cFwiKSB8fCB5KG4sIFwidG9vbHRpcFwiLCBcImdyb3VwTGFiZWxcIikgfHwgXCJHcm91cFwiLFxuICAgICAgICAgICAgdmFsdWU6IGxbcl0sXG4gICAgICAgICAgICBjbGFzczogdC5tb2RlbC5nZXRDb2xvckNsYXNzTmFtZSh7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZVR5cGVzOiBbaXQuVE9PTFRJUF0sXG4gICAgICAgICAgICAgIGRhdGFHcm91cE5hbWU6IGxbcl1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogXCJWYWx1ZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGxbaV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiBcIlRhcmdldFwiLFxuICAgICAgICAgICAgdmFsdWU6IGwubWFya2VyXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogXCJQZXJjZW50YWdlXCIsXG4gICAgICAgICAgICB2YWx1ZTogYCR7YShNYXRoLmZsb29yKGxbaV0gLyBsLm1hcmtlciAqIDEwMCksIHMpfSVgXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogXCJQZXJmb3JtYW5jZVwiLFxuICAgICAgICAgICAgdmFsdWU6IHVbZF1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0pO1xuICAgIH0pLm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKG8sIGwpIHtcbiAgICAgIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5CYXIuQkFSX01PVVNFTU9WRSwge1xuICAgICAgICBldmVudDogbyxcbiAgICAgICAgZWxlbWVudDogSSh0aGlzKSxcbiAgICAgICAgZGF0dW06IGxcbiAgICAgIH0pLCB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5NT1ZFLCB7XG4gICAgICAgIGV2ZW50OiBvXG4gICAgICB9KTtcbiAgICB9KS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKG8sIGwpIHtcbiAgICAgIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5CYXIuQkFSX0NMSUNLLCB7XG4gICAgICAgIGV2ZW50OiBvLFxuICAgICAgICBlbGVtZW50OiBJKHRoaXMpLFxuICAgICAgICBkYXR1bTogbFxuICAgICAgfSk7XG4gICAgfSkub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihvLCBsKSB7XG4gICAgICBjb25zdCBjID0gSSh0aGlzKTtcbiAgICAgIGMuY2xhc3NlZChcImhvdmVyZWRcIiwgITEpLCB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuQmFyLkJBUl9NT1VTRU9VVCwge1xuICAgICAgICBldmVudDogbyxcbiAgICAgICAgZWxlbWVudDogYyxcbiAgICAgICAgZGF0dW06IGxcbiAgICAgIH0pLCB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5ISURFLCB7XG4gICAgICAgIGhvdmVyZWRFbGVtZW50OiBjXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcInBhdGguYmFyXCIpLm9uKFwibW91c2VvdmVyXCIsIG51bGwpLm9uKFwibW91c2Vtb3ZlXCIsIG51bGwpLm9uKFwibW91c2VvdXRcIiwgbnVsbCk7XG4gICAgY29uc3QgdCA9IHRoaXMuc2VydmljZXMuZXZlbnRzO1xuICAgIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX0hPVkVSLCB0aGlzLmhhbmRsZUxlZ2VuZE9uSG92ZXIpLCB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoVC5MZWdlbmQuSVRFTV9NT1VTRU9VVCwgdGhpcy5oYW5kbGVMZWdlbmRNb3VzZU91dCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHZEKGUpIHtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiB5RChlKSB7XG4gIGlmIChlID09IG51bGwpIHJldHVybiB2RDtcbiAgdmFyIHQsIG4sIHIgPSBlLnNjYWxlWzBdLCBpID0gZS5zY2FsZVsxXSwgcyA9IGUudHJhbnNsYXRlWzBdLCBhID0gZS50cmFuc2xhdGVbMV07XG4gIHJldHVybiBmdW5jdGlvbihvLCBsKSB7XG4gICAgbCB8fCAodCA9IG4gPSAwKTtcbiAgICB2YXIgYyA9IDIsIHUgPSBvLmxlbmd0aCwgZCA9IG5ldyBBcnJheSh1KTtcbiAgICBmb3IgKGRbMF0gPSAodCArPSBvWzBdKSAqIHIgKyBzLCBkWzFdID0gKG4gKz0gb1sxXSkgKiBpICsgYTsgYyA8IHU7ICkgZFtjXSA9IG9bY10sICsrYztcbiAgICByZXR1cm4gZDtcbiAgfTtcbn1cbmZ1bmN0aW9uIHhEKGUsIHQpIHtcbiAgZm9yICh2YXIgbiwgciA9IGUubGVuZ3RoLCBpID0gciAtIHQ7IGkgPCAtLXI7ICkgbiA9IGVbaV0sIGVbaSsrXSA9IGVbcl0sIGVbcl0gPSBuO1xufVxuZnVuY3Rpb24gYkQoZSwgdCkge1xuICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAodCA9IGUub2JqZWN0c1t0XSksIHQudHlwZSA9PT0gXCJHZW9tZXRyeUNvbGxlY3Rpb25cIiA/IHsgdHlwZTogXCJGZWF0dXJlQ29sbGVjdGlvblwiLCBmZWF0dXJlczogdC5nZW9tZXRyaWVzLm1hcChmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIGZwKGUsIG4pO1xuICB9KSB9IDogZnAoZSwgdCk7XG59XG5mdW5jdGlvbiBmcChlLCB0KSB7XG4gIHZhciBuID0gdC5pZCwgciA9IHQuYmJveCwgaSA9IHQucHJvcGVydGllcyA9PSBudWxsID8ge30gOiB0LnByb3BlcnRpZXMsIHMgPSB1dShlLCB0KTtcbiAgcmV0dXJuIG4gPT0gbnVsbCAmJiByID09IG51bGwgPyB7IHR5cGU6IFwiRmVhdHVyZVwiLCBwcm9wZXJ0aWVzOiBpLCBnZW9tZXRyeTogcyB9IDogciA9PSBudWxsID8geyB0eXBlOiBcIkZlYXR1cmVcIiwgaWQ6IG4sIHByb3BlcnRpZXM6IGksIGdlb21ldHJ5OiBzIH0gOiB7IHR5cGU6IFwiRmVhdHVyZVwiLCBpZDogbiwgYmJveDogciwgcHJvcGVydGllczogaSwgZ2VvbWV0cnk6IHMgfTtcbn1cbmZ1bmN0aW9uIHV1KGUsIHQpIHtcbiAgdmFyIG4gPSB5RChlLnRyYW5zZm9ybSksIHIgPSBlLmFyY3M7XG4gIGZ1bmN0aW9uIGkodSwgZCkge1xuICAgIGQubGVuZ3RoICYmIGQucG9wKCk7XG4gICAgZm9yICh2YXIgaCA9IHJbdSA8IDAgPyB+dSA6IHVdLCBwID0gMCwgZiA9IGgubGVuZ3RoOyBwIDwgZjsgKytwKVxuICAgICAgZC5wdXNoKG4oaFtwXSwgcCkpO1xuICAgIHUgPCAwICYmIHhEKGQsIGYpO1xuICB9XG4gIGZ1bmN0aW9uIHModSkge1xuICAgIHJldHVybiBuKHUpO1xuICB9XG4gIGZ1bmN0aW9uIGEodSkge1xuICAgIGZvciAodmFyIGQgPSBbXSwgaCA9IDAsIHAgPSB1Lmxlbmd0aDsgaCA8IHA7ICsraCkgaSh1W2hdLCBkKTtcbiAgICByZXR1cm4gZC5sZW5ndGggPCAyICYmIGQucHVzaChkWzBdKSwgZDtcbiAgfVxuICBmdW5jdGlvbiBvKHUpIHtcbiAgICBmb3IgKHZhciBkID0gYSh1KTsgZC5sZW5ndGggPCA0OyApIGQucHVzaChkWzBdKTtcbiAgICByZXR1cm4gZDtcbiAgfVxuICBmdW5jdGlvbiBsKHUpIHtcbiAgICByZXR1cm4gdS5tYXAobyk7XG4gIH1cbiAgZnVuY3Rpb24gYyh1KSB7XG4gICAgdmFyIGQgPSB1LnR5cGUsIGg7XG4gICAgc3dpdGNoIChkKSB7XG4gICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6XG4gICAgICAgIHJldHVybiB7IHR5cGU6IGQsIGdlb21ldHJpZXM6IHUuZ2VvbWV0cmllcy5tYXAoYykgfTtcbiAgICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgICBoID0gcyh1LmNvb3JkaW5hdGVzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgICBoID0gdS5jb29yZGluYXRlcy5tYXAocyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICAgICAgaCA9IGEodS5hcmNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6XG4gICAgICAgIGggPSB1LmFyY3MubWFwKGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICAgIGggPSBsKHUuYXJjcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOlxuICAgICAgICBoID0gdS5hcmNzLm1hcChsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogZCwgY29vcmRpbmF0ZXM6IGggfTtcbiAgfVxuICByZXR1cm4gYyh0KTtcbn1cbmZ1bmN0aW9uIF9EKGUsIHQpIHtcbiAgdmFyIG4gPSB7fSwgciA9IHt9LCBpID0ge30sIHMgPSBbXSwgYSA9IC0xO1xuICB0LmZvckVhY2goZnVuY3Rpb24oYywgdSkge1xuICAgIHZhciBkID0gZS5hcmNzW2MgPCAwID8gfmMgOiBjXSwgaDtcbiAgICBkLmxlbmd0aCA8IDMgJiYgIWRbMV1bMF0gJiYgIWRbMV1bMV0gJiYgKGggPSB0WysrYV0sIHRbYV0gPSBjLCB0W3VdID0gaCk7XG4gIH0pLCB0LmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgIHZhciB1ID0gbyhjKSwgZCA9IHVbMF0sIGggPSB1WzFdLCBwLCBmO1xuICAgIGlmIChwID0gaVtkXSlcbiAgICAgIGlmIChkZWxldGUgaVtwLmVuZF0sIHAucHVzaChjKSwgcC5lbmQgPSBoLCBmID0gcltoXSkge1xuICAgICAgICBkZWxldGUgcltmLnN0YXJ0XTtcbiAgICAgICAgdmFyIGcgPSBmID09PSBwID8gcCA6IHAuY29uY2F0KGYpO1xuICAgICAgICByW2cuc3RhcnQgPSBwLnN0YXJ0XSA9IGlbZy5lbmQgPSBmLmVuZF0gPSBnO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJbcC5zdGFydF0gPSBpW3AuZW5kXSA9IHA7XG4gICAgZWxzZSBpZiAocCA9IHJbaF0pXG4gICAgICBpZiAoZGVsZXRlIHJbcC5zdGFydF0sIHAudW5zaGlmdChjKSwgcC5zdGFydCA9IGQsIGYgPSBpW2RdKSB7XG4gICAgICAgIGRlbGV0ZSBpW2YuZW5kXTtcbiAgICAgICAgdmFyIG0gPSBmID09PSBwID8gcCA6IGYuY29uY2F0KHApO1xuICAgICAgICByW20uc3RhcnQgPSBmLnN0YXJ0XSA9IGlbbS5lbmQgPSBwLmVuZF0gPSBtO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJbcC5zdGFydF0gPSBpW3AuZW5kXSA9IHA7XG4gICAgZWxzZVxuICAgICAgcCA9IFtjXSwgcltwLnN0YXJ0ID0gZF0gPSBpW3AuZW5kID0gaF0gPSBwO1xuICB9KTtcbiAgZnVuY3Rpb24gbyhjKSB7XG4gICAgdmFyIHUgPSBlLmFyY3NbYyA8IDAgPyB+YyA6IGNdLCBkID0gdVswXSwgaDtcbiAgICByZXR1cm4gZS50cmFuc2Zvcm0gPyAoaCA9IFswLCAwXSwgdS5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgIGhbMF0gKz0gcFswXSwgaFsxXSArPSBwWzFdO1xuICAgIH0pKSA6IGggPSB1W3UubGVuZ3RoIC0gMV0sIGMgPCAwID8gW2gsIGRdIDogW2QsIGhdO1xuICB9XG4gIGZ1bmN0aW9uIGwoYywgdSkge1xuICAgIGZvciAodmFyIGQgaW4gYykge1xuICAgICAgdmFyIGggPSBjW2RdO1xuICAgICAgZGVsZXRlIHVbaC5zdGFydF0sIGRlbGV0ZSBoLnN0YXJ0LCBkZWxldGUgaC5lbmQsIGguZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgIG5bcCA8IDAgPyB+cCA6IHBdID0gMTtcbiAgICAgIH0pLCBzLnB1c2goaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsKGksIHIpLCBsKHIsIGkpLCB0LmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgIG5bYyA8IDAgPyB+YyA6IGNdIHx8IHMucHVzaChbY10pO1xuICB9KSwgcztcbn1cbmZ1bmN0aW9uIEVEKGUpIHtcbiAgZm9yICh2YXIgdCA9IC0xLCBuID0gZS5sZW5ndGgsIHIsIGkgPSBlW24gLSAxXSwgcyA9IDA7ICsrdCA8IG47ICkgciA9IGksIGkgPSBlW3RdLCBzICs9IHJbMF0gKiBpWzFdIC0gclsxXSAqIGlbMF07XG4gIHJldHVybiBNYXRoLmFicyhzKTtcbn1cbmZ1bmN0aW9uIE9EKGUpIHtcbiAgcmV0dXJuIHV1KGUsIFNELmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xufVxuZnVuY3Rpb24gU0QoZSwgdCkge1xuICB2YXIgbiA9IHt9LCByID0gW10sIGkgPSBbXTtcbiAgdC5mb3JFYWNoKHMpO1xuICBmdW5jdGlvbiBzKGwpIHtcbiAgICBzd2l0Y2ggKGwudHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOlxuICAgICAgICBsLmdlb21ldHJpZXMuZm9yRWFjaChzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiUG9seWdvblwiOlxuICAgICAgICBhKGwuYXJjcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOlxuICAgICAgICBsLmFyY3MuZm9yRWFjaChhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGEobCkge1xuICAgIGwuZm9yRWFjaChmdW5jdGlvbihjKSB7XG4gICAgICBjLmZvckVhY2goZnVuY3Rpb24odSkge1xuICAgICAgICAoblt1ID0gdSA8IDAgPyB+dSA6IHVdIHx8IChuW3VdID0gW10pKS5wdXNoKGwpO1xuICAgICAgfSk7XG4gICAgfSksIHIucHVzaChsKTtcbiAgfVxuICBmdW5jdGlvbiBvKGwpIHtcbiAgICByZXR1cm4gRUQodXUoZSwgeyB0eXBlOiBcIlBvbHlnb25cIiwgYXJjczogW2xdIH0pLmNvb3JkaW5hdGVzWzBdKTtcbiAgfVxuICByZXR1cm4gci5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcbiAgICBpZiAoIWwuXykge1xuICAgICAgdmFyIGMgPSBbXSwgdSA9IFtsXTtcbiAgICAgIGZvciAobC5fID0gMSwgaS5wdXNoKGMpOyBsID0gdS5wb3AoKTsgKVxuICAgICAgICBjLnB1c2gobCksIGwuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgZC5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIG5baCA8IDAgPyB+aCA6IGhdLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICBwLl8gfHwgKHAuXyA9IDEsIHUucHVzaChwKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9KSwgci5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcbiAgICBkZWxldGUgbC5fO1xuICB9KSwge1xuICAgIHR5cGU6IFwiTXVsdGlQb2x5Z29uXCIsXG4gICAgYXJjczogaS5tYXAoZnVuY3Rpb24obCkge1xuICAgICAgdmFyIGMgPSBbXSwgdTtcbiAgICAgIGlmIChsLmZvckVhY2goZnVuY3Rpb24oZykge1xuICAgICAgICBnLmZvckVhY2goZnVuY3Rpb24obSkge1xuICAgICAgICAgIG0uZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICBuW3YgPCAwID8gfnYgOiB2XS5sZW5ndGggPCAyICYmIGMucHVzaCh2KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KSwgYyA9IF9EKGUsIGMpLCAodSA9IGMubGVuZ3RoKSA+IDEpXG4gICAgICAgIGZvciAodmFyIGQgPSAxLCBoID0gbyhjWzBdKSwgcCwgZjsgZCA8IHU7ICsrZClcbiAgICAgICAgICAocCA9IG8oY1tkXSkpID4gaCAmJiAoZiA9IGNbMF0sIGNbMF0gPSBjW2RdLCBjW2RdID0gZiwgaCA9IHApO1xuICAgICAgcmV0dXJuIGM7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGwpIHtcbiAgICAgIHJldHVybiBsLmxlbmd0aCA+IDA7XG4gICAgfSlcbiAgfTtcbn1cbmNsYXNzIFREIGV4dGVuZHMgVm4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnR5cGUgPSBcInJ1bGVyLWJpbm5lZFwiLCB0aGlzLnJlbmRlclR5cGUgPSBydC5TVkc7XG4gIH1cbiAgc2hvd1J1bGVyKHQsIFtuLCByXSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLnBhcmVudCwgcyA9IHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLCB7IGNhcnRlc2lhblNjYWxlczogYSB9ID0gdGhpcy5zZXJ2aWNlcywgbyA9IGEuZ2V0T3JpZW50YXRpb24oKSwgbCA9IGEuZ2V0UmFuZ2VTY2FsZSgpLCBbYywgdV0gPSBsLnJhbmdlKCksIGQgPSBhLmdldERvbWFpblNjYWxlKCksIGggPSBkLmludmVydChcbiAgICAgIG8gPT09IEZ0LlZFUlRJQ0FMID8gbiA6IHJcbiAgICApLCBwID0gTi5hcHBlbmRPclNlbGVjdChpLCBcImcucnVsZXJcIikuYXR0cihcImFyaWEtbGFiZWxcIiwgXCJydWxlclwiKSwgZiA9IE4uYXBwZW5kT3JTZWxlY3QocCwgXCJsaW5lLnJ1bGVyLWxpbmVcIiksIGcgPSBpLnNlbGVjdEFsbChcIltyb2xlPWdyYXBoaWNzLXN5bWJvbF1cIikuZmlsdGVyKChtKSA9PiB7XG4gICAgICBpZiAocGFyc2VGbG9hdChndChtLCBcImRhdGEueDBcIikpIDw9IGggJiYgcGFyc2VGbG9hdChndChtLCBcImRhdGEueDFcIikpID49IGgpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICB9KTtcbiAgICBpZiAoZy5zaXplKCkgPiAwKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzVG9IaWdobGlnaHQgJiYgdGhpcy5lbGVtZW50c1RvSGlnaGxpZ2h0LnNpemUoKSA+IDAgJiYgIUNnKHRoaXMuZWxlbWVudHNUb0hpZ2hsaWdodCwgZykgJiYgdGhpcy5oaWRlUnVsZXIoKSwgZy5kaXNwYXRjaChcIm1vdXNlb3ZlclwiKSwgdGhpcy5lbGVtZW50c1RvSGlnaGxpZ2h0ID0gZztcbiAgICAgIGNvbnN0IG0gPSBJKGcubm9kZXMoKVswXSkuZGF0dW0oKSwgdiA9IHBhcnNlRmxvYXQoZ3QobSwgXCJkYXRhLngwXCIpKSwgeCA9IHBhcnNlRmxvYXQoZ3QobSwgXCJkYXRhLngxXCIpKSwgXyA9IHRoaXMubW9kZWwuZ2V0QWN0aXZlRGF0YUdyb3VwTmFtZXMoKSwgRSA9IF8ucmV2ZXJzZSgpLm1hcCgoYikgPT4gKHtcbiAgICAgICAgbGFiZWw6IGIsXG4gICAgICAgIHZhbHVlOiBndChtLCBgZGF0YS4ke2J9YCksXG4gICAgICAgIGNsYXNzOiB0aGlzLm1vZGVsLmdldENvbG9yQ2xhc3NOYW1lKHtcbiAgICAgICAgICBjbGFzc05hbWVUeXBlczogW2l0LlRPT0xUSVBdLFxuICAgICAgICAgIGRhdGFHcm91cE5hbWU6IGJcbiAgICAgICAgfSlcbiAgICAgIH0pKS5maWx0ZXIoKGIpID0+IGIudmFsdWUgIT09IDApO1xuICAgICAgaWYgKEUubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5TSE9XLCB7XG4gICAgICAgICAgZXZlbnQ6IHQsXG4gICAgICAgICAgbW91c2VQb3NpdGlvbjogW24sIHJdLFxuICAgICAgICAgIGhvdmVyZWRFbGVtZW50OiBmLFxuICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxhYmVsOiBndChzLCBcImJpbnMucmFuZ2VMYWJlbFwiKSB8fCBcIlJhbmdlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBgJHt2fSDigJMgJHt4fWBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAuLi5FLFxuICAgICAgICAgICAgLi4ueShzLCBcInRvb2x0aXBcIiwgXCJzaG93VG90YWxcIikgPT09ICEwID8gW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGFiZWw6IGd0KHMsIFwibG9jYWxlLnRyYW5zbGF0aW9ucy50b3RhbFwiKSB8fCBndChzLCBcInRvb2x0aXAudG90YWxMYWJlbFwiKSB8fCBcIlRvdGFsXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IF8ucmVkdWNlKFxuICAgICAgICAgICAgICAgICAgKFMsIE0pID0+IFMgKyBwYXJzZUZsb2F0KGd0KG0sIGBkYXRhLiR7TX1gKSksXG4gICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdIDogW11cbiAgICAgICAgICBdXG4gICAgICAgIH0pLCBwLmF0dHIoXCJvcGFjaXR5XCIsIDEpO1xuICAgICAgICBjb25zdCBiID0gZCgodiArIHgpIC8gMik7XG4gICAgICAgIG8gPT09IFwiaG9yaXpvbnRhbFwiID8gZi5hdHRyKFwieDFcIiwgdSkuYXR0cihcIngyXCIsIGMpLmF0dHIoXCJ5MVwiLCBiKS5hdHRyKFwieTJcIiwgYikgOiBmLmF0dHIoXCJ5MVwiLCB1KS5hdHRyKFwieTJcIiwgYykuYXR0cihcIngxXCIsIGIpLmF0dHIoXCJ4MlwiLCBiKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aGlzLmhpZGVSdWxlcigpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5oaWRlUnVsZXIoKTtcbiAgfVxufVxuY2xhc3MgVWEgZXh0ZW5kcyBWbiB7XG4gIGZvcm1hdFRvb2x0aXBEYXRhKHQpIHtcbiAgICByZXR1cm4gdC5yZXZlcnNlKCk7XG4gIH1cbn1cbmNvbnN0IHdEID0gKGUsIHQpID0+IHtcbiAgY29uc3QgbiA9IGUueCwgciA9IGUueSwgaSA9IHQueCwgcyA9IHQueSwgYSA9IFJnKCk7XG4gIHJldHVybiBhLm1vdmVUbyhuLCByKSwgYS5saW5lVG8oaSwgcyksIGEudG9TdHJpbmcoKTtcbn0sICREID0ge1xuICBkOiBcIk03IDB2OEwwIDR6XCJcbn0sIE1EID0ge1xuICBkOiBcIk0wIDB2OGw3LTR6XCJcbn0sIENEID0ge1xuICBkOiBcIk01LjMyIDkuNTEzYTQuNzUgNC43NSAwIDEwMC05LjUgNC43NSA0Ljc1IDAgMDAwIDkuNXpcIlxufSwgQUQgPSB7XG4gIGQ6IFwiTTUuMDM1MTc2NTQtMWUtN2w0Ljk5OTk5OTk2IDUtNC45OTk5OTk5NiA1LTUtNUwyLjQ1MTc4NDQgMi41ODMzOTIwNHpcIlxufSwgTEQgPSB7XG4gIGQ6IFwiTTAgLjQ0OTc0NzQ3aDh2OEgwdi0zLjY4MzAzMzF6XCJcbn0sIGtEID0ge1xuICBkOiBcIk0wIDBoMS41djhIMHpcIlxufTtcbmNsYXNzIFN2IGV4dGVuZHMgbHUge1xuICBjb25zdHJ1Y3Rvcih0LCBuLCByKSB7XG4gICAgc3VwZXIodCwgbiwgciksIHRoaXMudHlwZSA9IFwiY29sb3ItbGVnZW5kXCIsIHRoaXMucmVuZGVyVHlwZSA9IHJ0LlNWRywgdGhpcy5ncmFkaWVudF9pZCA9IGBncmFkaWVudC1pZC0ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDk5OTk5OTk5OTk5KX1gLCB0aGlzLmhhbmRsZUF4aXNDb21wbGV0ZUV2ZW50ID0gKCkgPT4ge1xuICAgICAgY29uc3QgaSA9IHRoaXMuZ2V0Q29tcG9uZW50Q29udGFpbmVyKCksIHsgd2lkdGg6IHMgfSA9IE4uZ2V0U1ZHRWxlbWVudFNpemUoaSwge1xuICAgICAgICB1c2VBdHRyczogITBcbiAgICAgIH0pLCBhID0geSh0aGlzLmdldE9wdGlvbnMoKSwgXCJkYXRhXCIsIFwibG9hZGluZ1wiKTtcbiAgICAgIGlmIChzID4gSXQuY29sb3IuYmFyV2lkdGggJiYgIWEpIHtcbiAgICAgICAgY29uc3QgbyA9IHkodGhpcy5nZXRPcHRpb25zKCksIFwiaGVhdG1hcFwiLCBcImNvbG9yTGVnZW5kXCIsIFwidGl0bGVcIiksIHsgY2FydGVzaWFuU2NhbGVzOiBsIH0gPSB0aGlzLnNlcnZpY2VzLCBjID0gbC5nZXRNYWluWFNjYWxlKCkucmFuZ2UoKTtcbiAgICAgICAgaWYgKGNbMF0gPiAxICYmIChpLnNlbGVjdChcImcubGVnZW5kXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke2NbMF19LCAwKWApLCBvKSkge1xuICAgICAgICAgIGNvbnN0IHsgd2lkdGg6IHUgfSA9IE4uZ2V0U1ZHRWxlbWVudFNpemUoXG4gICAgICAgICAgICBpLnNlbGVjdChcImcubGVnZW5kLXRpdGxlXCIpLnNlbGVjdChcInRleHRcIiksXG4gICAgICAgICAgICB7IHVzZUJCb3g6ICEwIH1cbiAgICAgICAgICApLCBkID0gY1swXSAtIHUgLSA5O1xuICAgICAgICAgIGQgPiAxID8gaS5zZWxlY3QoXCJnLmxlZ2VuZC10aXRsZVwiKS5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHtkfSwgMClgKSA6IChpLnNlbGVjdChcImcubGVnZW5kXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke2NbMF19LCAxNilgKSwgaS5zZWxlY3QoXCJnLmxlZ2VuZC10aXRsZVwiKS5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHtjWzBdfSwgMClgKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICBpLnNlbGVjdChcImcubGVnZW5kLXRpdGxlXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCwgMClcIik7XG4gICAgfSwgdGhpcy5jaGFydFR5cGUgPSByLmNoYXJ0VHlwZTtcbiAgfVxuICBpbml0KCkge1xuICAgIHRoaXMuY2hhcnRUeXBlID09PSBcImhlYXRtYXBcIiAmJiB0aGlzLnNlcnZpY2VzLmV2ZW50cy5hZGRFdmVudExpc3RlbmVyKFQuQXhpcy5SRU5ERVJfQ09NUExFVEUsIHRoaXMuaGFuZGxlQXhpc0NvbXBsZXRlRXZlbnQpO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIHJlbmRlcih0ID0gITEpIHtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRPcHRpb25zKCksIHIgPSB0aGlzLmdldENvbXBvbmVudENvbnRhaW5lcih7XG4gICAgICBhcmlhTGFiZWw6IFwibGVnZW5kXCJcbiAgICB9KSwgeyB3aWR0aDogaSB9ID0gTi5nZXRTVkdFbGVtZW50U2l6ZShyLCB7XG4gICAgICB1c2VBdHRyczogITBcbiAgICB9KSwgcyA9IHkobiwgXCJjb2xvclwiLCBcImdyYWRpZW50XCIsIFwiY29sb3JzXCIpLCBhID0geShuLCB0aGlzLmNoYXJ0VHlwZSwgXCJjb2xvckxlZ2VuZFwiLCBcInR5cGVcIik7XG4gICAgbGV0IG8gPSB5KG4sIFwiY29sb3JcIiwgXCJwYWlyaW5nXCIsIFwib3B0aW9uXCIpO1xuICAgIGNvbnN0IGwgPSB5KG4sIFwiaGVhdG1hcFwiLCBcImNvbG9yTGVnZW5kXCIsIFwidGl0bGVcIik7XG4gICAgaWYgKHkodGhpcy5nZXRPcHRpb25zKCksIFwiZGF0YVwiLCBcImxvYWRpbmdcIikpIHtcbiAgICAgIHIuaHRtbChcIlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYyA9ICFCZShzKSwgdSA9IHptKHRoaXMubW9kZWwuZ2V0RGlzcGxheURhdGEoKSksIGQgPSAhKGkgPD0gSXQuY29sb3IuYmFyV2lkdGgpLCBoID0gZCA/IEl0LmNvbG9yLmJhcldpZHRoIDogaSwgcCA9IE4uYXBwZW5kT3JTZWxlY3QociwgXCJnLmxlZ2VuZFwiKSwgZiA9IE4uYXBwZW5kT3JTZWxlY3QocCwgXCJnLmxlZ2VuZC1heGlzXCIpO1xuICAgIGlmIChsKSB7XG4gICAgICBjb25zdCBBID0gTi5hcHBlbmRPclNlbGVjdChyLCBcImcubGVnZW5kLXRpdGxlXCIpO1xuICAgICAgTi5hcHBlbmRPclNlbGVjdChBLCBcInRleHRcIikudGV4dChsKS5hdHRyKFwiZHlcIiwgXCIwLjdlbVwiKSwgcC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsIDE2KVwiKTtcbiAgICB9XG4gICAgY29uc3QgZyA9IHVbMF0gPCAwICYmIHVbMV0gPiAwID8gXCJkaXZlcmdlXCIgOiBcIm1vbm9cIjtcbiAgICAobyA8IDEgJiYgbyA+IDQgJiYgZyA9PT0gXCJtb25vXCIgfHwgbyA8IDEgJiYgbyA+IDIgJiYgZyA9PT0gXCJkaXZlcmdlXCIpICYmIChvID0gMSk7XG4gICAgbGV0IG0gPSBbXTtcbiAgICBjb25zdCB2ID0gZyA9PT0gXCJkaXZlcmdlXCIgPyAxNyA6IDExO1xuICAgIGlmIChjKVxuICAgICAgbSA9IHM7XG4gICAgZWxzZVxuICAgICAgZm9yIChsZXQgQSA9IDE7IEEgPCB2ICsgMTsgQSsrKVxuICAgICAgICBtLnB1c2goXG4gICAgICAgICAgYSA9PT0gcXMuTElORUFSID8gYHN0b3AtY29sb3ItJHtnfS0ke299LSR7QX1gIDogYGZpbGwtJHtnfS0ke299LSR7QX1gXG4gICAgICAgICk7XG4gICAgY29uc3QgeCA9IHhlKHVbMF0sIHVbMV0pLCBfID0gWUMoeCwgMyksIEUgPSBGZSgpLmRvbWFpbih1KS5yYW5nZShbMCwgaF0pLCBiID0gSmMoRSkudGlja1NpemUoMCkudGlja1ZhbHVlcyhfKSwgeyBjb2RlOiBTLCBudW1iZXI6IE0gfSA9IHkobiwgXCJsb2NhbGVcIik7XG4gICAgYi50aWNrRm9ybWF0KChBKSA9PiBNKEEsIFMpKTtcbiAgICBsZXQgRDtcbiAgICBzd2l0Y2ggKGEpIHtcbiAgICAgIGNhc2UgcXMuTElORUFSOlxuICAgICAgICB0aGlzLmRyYXdMaW5lYXIobSwgcCwgaCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBxcy5RVUFOVElaRTpcbiAgICAgICAgRCA9IHRoaXMuZHJhd1F1YW50aXplKFxuICAgICAgICAgIG0sXG4gICAgICAgICAgZyxcbiAgICAgICAgICBjLFxuICAgICAgICAgIHAsXG4gICAgICAgICAgaFxuICAgICAgICApLCBFLnJhbmdlKFtELCBoXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJFbnRlcmVkIGNvbG9yIGxlZ2VuZCB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cbiAgICBmLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgwLCR7SXQuY29sb3IuYXhpc1lUcmFuc2xhdGlvbn0pYCkuY2FsbChiKSwgZi5zZWxlY3QoXCIuZG9tYWluXCIpLnJlbW92ZSgpLCBmLnNlbGVjdChcImcudGljazpsYXN0LW9mLXR5cGUgdGV4dFwiKS5zdHlsZShcInRleHQtYW5jaG9yXCIsIGQgPyBcIm1pZGRsZVwiIDogXCJlbmRcIiksIGYuc2VsZWN0KFwiZy50aWNrOmZpcnN0LW9mLXR5cGUgdGV4dFwiKS5zdHlsZShcbiAgICAgIFwidGV4dC1hbmNob3JcIixcbiAgICAgIGQgJiYgdGhpcy5jaGFydFR5cGUgIT09IFwiY2hvcm9wbGV0aFwiID8gXCJtaWRkbGVcIiA6IFwic3RhcnRcIlxuICAgICk7XG4gIH1cbiAgLy8gUmVuZGVycyBncmFkaWVudCBsZWdlbmRcbiAgZHJhd0xpbmVhcih0LCBuLCByKSB7XG4gICAgY29uc3QgaSA9IDEwMCAvICh0Lmxlbmd0aCAtIDEpO1xuICAgIE4uYXBwZW5kT3JTZWxlY3QobiwgXCJsaW5lYXJHcmFkaWVudFwiKS5hdHRyKFwiaWRcIiwgYCR7dGhpcy5ncmFkaWVudF9pZH0tbGVnZW5kYCkuc2VsZWN0QWxsKFwic3RvcFwiKS5kYXRhKHQpLmVudGVyKCkuYXBwZW5kKFwic3RvcFwiKS5hdHRyKFwib2Zmc2V0XCIsIChzLCBhKSA9PiBgJHthICogaX0lYCkuYXR0cihcImNsYXNzXCIsIChzLCBhKSA9PiB0W2FdKS5hdHRyKFwic3RvcC1jb2xvclwiLCAocykgPT4gcyksIE4uYXBwZW5kT3JTZWxlY3QobiwgXCJyZWN0XCIpLmF0dHIoXCJ3aWR0aFwiLCByKS5hdHRyKFwiaGVpZ2h0XCIsIEl0LmNvbG9yLmJhckhlaWdodCkuc3R5bGUoXCJmaWxsXCIsIGB1cmwoIyR7dGhpcy5ncmFkaWVudF9pZH0tbGVnZW5kKWApO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHF1YW50aXplZCBsZWdlbmRcbiAgICogQHJldHVybnMgbnVtYmVyIChyYW5nZSBzdGFydClcbiAgICovXG4gIGRyYXdRdWFudGl6ZSh0LCBuLCByLCBpLCBzKSB7XG4gICAgIXIgJiYgbiA9PT0gXCJkaXZlcmdlXCIgJiYgdC5zcGxpY2UodC5sZW5ndGggLyAyLCAxKTtcbiAgICBjb25zdCBhID0gZ3MoKS5kb21haW4odCkucmFuZ2UoWzAsIHNdKTtcbiAgICByZXR1cm4gTi5hcHBlbmRPclNlbGVjdChpLCBcImcucXVhbnRpemVkLXJlY3RcIikuc2VsZWN0QWxsKFwicmVjdFwiKS5kYXRhKGEuZG9tYWluKCkpLmpvaW4oXCJyZWN0XCIpLmF0dHIoXCJ4XCIsIChvKSA9PiBhKG8pKS5hdHRyKFwieVwiLCAwKS5hdHRyKFwid2lkdGhcIiwgTWF0aC5tYXgoMCwgYS5iYW5kd2lkdGgoKSAtIDEpKS5hdHRyKFwiaGVpZ2h0XCIsIEl0LmNvbG9yLmJhckhlaWdodCkuYXR0cihcImNsYXNzXCIsIChvKSA9PiBvKS5hdHRyKFwiZmlsbFwiLCAobykgPT4gbyksICghciAmJiBuKSA9PT0gXCJtb25vXCIgPyBhLmJhbmR3aWR0aCgpIC0gMSA6IDA7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNoYXJ0VHlwZSA9PT0gXCJoZWF0bWFwXCIgJiYgdGhpcy5zZXJ2aWNlcy5ldmVudHMucmVtb3ZlRXZlbnRMaXN0ZW5lcihULkF4aXMuUkVOREVSX0NPTVBMRVRFLCB0aGlzLmhhbmRsZUF4aXNDb21wbGV0ZUV2ZW50KTtcbiAgfVxufVxuY2xhc3MgREQgZXh0ZW5kcyBicyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IFwibWV0ZXItdGl0bGVcIiwgdGhpcy5yZW5kZXJUeXBlID0gcnQuU1ZHO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIHJlbmRlcih0ID0gITEpIHtcbiAgICBjb25zdCBuID0geSh0aGlzLm1vZGVsLmdldERpc3BsYXlEYXRhKCksIDApLCByID0gdGhpcy5nZXRPcHRpb25zKCksIGkgPSB0aGlzLmdldENvbXBvbmVudENvbnRhaW5lcih7XG4gICAgICBhcmlhTGFiZWw6IFwibWV0ZXIgdGl0bGVcIlxuICAgIH0pLCB7IGdyb3VwTWFwc1RvOiBzIH0gPSByLmRhdGEsIGEgPSByLmxvY2FsZS50cmFuc2xhdGlvbnMubWV0ZXIudGl0bGU7XG4gICAgaWYgKHkociwgXCJtZXRlclwiLCBcInByb3BvcnRpb25hbFwiKSlcbiAgICAgIHRoaXMuZGlzcGxheVRvdGFsKCksIHRoaXMuZGlzcGxheUJyZWFrZG93blRpdGxlKCk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBjID0gaS5zZWxlY3RBbGwoXCJ0ZXh0Lm1ldGVyLXRpdGxlXCIpLmRhdGEoYSA/IFthXSA6IFtuW3NdXSk7XG4gICAgICBjLmVudGVyKCkuYXBwZW5kKFwidGV4dFwiKS5jbGFzc2VkKFwibWV0ZXItdGl0bGVcIiwgITApLm1lcmdlKGMpLmF0dHIoXCJ4XCIsIDApLmF0dHIoXCJ5XCIsIFwiMWVtXCIpLnRleHQoKHUpID0+IHUpLCBjLmV4aXQoKS5yZW1vdmUoKSwgdGhpcy5hcHBlbmRQZXJjZW50YWdlKCk7XG4gICAgfVxuICAgIHRoaXMuZGlzcGxheVN0YXR1cygpO1xuICAgIGNvbnN0IG8gPSB0aGlzLmdldE1heFRpdGxlV2lkdGgoKSwgbCA9IE4uYXBwZW5kT3JTZWxlY3QoaSwgXCJ0ZXh0Lm1ldGVyLXRpdGxlXCIpO1xuICAgIG8gPiAwICYmIGwubm9kZSgpLmdldENvbXB1dGVkVGV4dExlbmd0aCgpID4gbyAmJiB0aGlzLnRydW5jYXRlVGl0bGUobCwgbyk7XG4gIH1cbiAgZGlzcGxheUJyZWFrZG93blRpdGxlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldENvbXBvbmVudENvbnRhaW5lcigpLCBuID0gdGhpcy5nZXRPcHRpb25zKCksIHIgPSB0aGlzLm1vZGVsLmdldE1heGltdW1Eb21haW4oXG4gICAgICB0aGlzLm1vZGVsLmdldERpc3BsYXlEYXRhKClcbiAgICApLCBpID0geShuLCBcIm1ldGVyXCIsIFwicHJvcG9ydGlvbmFsXCIsIFwidG90YWxcIiksIHMgPSB5KG4sIFwibWV0ZXJcIiwgXCJwcm9wb3J0aW9uYWxcIiwgXCJ1bml0XCIpID8geShuLCBcIm1ldGVyXCIsIFwicHJvcG9ydGlvbmFsXCIsIFwidW5pdFwiKSA6IFwiXCI7XG4gICAgbGV0IGE7XG4gICAgaWYgKHIgPT09IGkpXG4gICAgICBhID0gbnVsbDtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHUgPSBpICE9PSBudWxsID8gaSAtIHIgOiByLCBkID0geShuLCBcIm1ldGVyXCIsIFwicHJvcG9ydGlvbmFsXCIsIFwiYnJlYWtkb3duRm9ybWF0dGVyXCIpLCB7IGNvZGU6IGgsIG51bWJlcjogcCB9ID0geShuLCBcImxvY2FsZVwiKTtcbiAgICAgIGEgPSBkICE9PSBudWxsID8gZCh7XG4gICAgICAgIGRhdGFzZXRzVG90YWw6IHIsXG4gICAgICAgIHRvdGFsOiBpXG4gICAgICB9KSA6IGAke3AociwgaCl9ICR7c30gdXNlZCAoJHtwKHUsIGgpfSAke3N9IGF2YWlsYWJsZSlgO1xuICAgIH1cbiAgICBjb25zdCBvID0gdC5zZWxlY3RBbGwoXCJ0ZXh0LnByb3BvcnRpb25hbC1tZXRlci10aXRsZVwiKS5kYXRhKFthXSk7XG4gICAgby5lbnRlcigpLmFwcGVuZChcInRleHRcIikuY2xhc3NlZChcInByb3BvcnRpb25hbC1tZXRlci10aXRsZVwiLCAhMCkubWVyZ2UobykuYXR0cihcInhcIiwgMCkuYXR0cihcInlcIiwgXCIxZW1cIikudGV4dCgodSkgPT4gdSksIG8uZXhpdCgpLnJlbW92ZSgpO1xuICAgIGNvbnN0IGwgPSB0aGlzLmdldE1heFRpdGxlV2lkdGgoKSwgYyA9IE4uYXBwZW5kT3JTZWxlY3QodCwgXCJ0ZXh0LnByb3BvcnRpb25hbC1tZXRlci10aXRsZVwiKTtcbiAgICBsID4gMCAmJiBjLm5vZGUoKS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKSA+IGwgJiYgdGhpcy50cnVuY2F0ZVRpdGxlKGMsIGwpO1xuICB9XG4gIC8vIHNob3cgdGhlIHRvdGFsIGZvciBwcm9wIG1ldGVyXG4gIGRpc3BsYXlUb3RhbCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoKSwgbiA9IHRoaXMuZ2V0T3B0aW9ucygpLCByID0geShuLCBcIm1ldGVyXCIsIFwicHJvcG9ydGlvbmFsXCIsIFwidG90YWxcIiksIGkgPSByID8geShuLCBcIm1ldGVyXCIsIFwicHJvcG9ydGlvbmFsXCIsIFwidG90YWxcIikgOiB0aGlzLm1vZGVsLmdldE1heGltdW1Eb21haW4odGhpcy5tb2RlbC5nZXREaXNwbGF5RGF0YSgpKSwgcyA9IHkobiwgXCJtZXRlclwiLCBcInByb3BvcnRpb25hbFwiLCBcInVuaXRcIikgPyB5KG4sIFwibWV0ZXJcIiwgXCJwcm9wb3J0aW9uYWxcIiwgXCJ1bml0XCIpIDogXCJcIiwgYSA9IHkobiwgXCJtZXRlclwiLCBcInByb3BvcnRpb25hbFwiLCBcInRvdGFsRm9ybWF0dGVyXCIpLCB7IGNvZGU6IG8sIG51bWJlcjogbCB9ID0geShuLCBcImxvY2FsZVwiKSwgYyA9IGEgIT09IG51bGwgPyBhKGkpIDogYCR7bChyLCBvKX0gJHtzfSB0b3RhbGAsIHUgPSBOLmdldEhUTUxFbGVtZW50U2l6ZSh0aGlzLnBhcmVudC5ub2RlKCkpLndpZHRoLCBkID0gdC5zZWxlY3RBbGwoXCJ0ZXh0LnByb3BvcnRpb25hbC1tZXRlci10b3RhbFwiKS5kYXRhKFtjXSk7XG4gICAgZC5lbnRlcigpLmFwcGVuZChcInRleHRcIikuY2xhc3NlZChcInByb3BvcnRpb25hbC1tZXRlci10b3RhbFwiLCAhMCkubWVyZ2UoZCkuYXR0cihcbiAgICAgIFwieFwiLFxuICAgICAgdGhpcy5tb2RlbC5nZXRTdGF0dXMoKSAmJiB0eXBlb2YgdSAhPSBcInN0cmluZ1wiID8gdSAtIFp0LnRvdGFsLnBhZGRpbmdSaWdodCA6IHVcbiAgICApLmF0dHIoXCJ5XCIsIFwiMWVtXCIpLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKS50ZXh0KChoKSA9PiBoKSwgZC5leGl0KCkucmVtb3ZlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIGNvcnJlc3BvbmRpbmcgc3RhdHVzIGJhc2VkIG9uIHRoZSB2YWx1ZSBhbmQgdGhlIHBlYWsuXG4gICAqL1xuICBkaXNwbGF5U3RhdHVzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLCBuID0gdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoKSwgciA9IE4uZ2V0SFRNTEVsZW1lbnRTaXplKHRoaXMucGFyZW50Lm5vZGUoKSkud2lkdGggfHwgMCwgaSA9IHRoaXMubW9kZWwuZ2V0U3RhdHVzKCksIHMgPSBadC5zdGF0dXMuaW5kaWNhdG9yU2l6ZSAvIDIsIGEgPSBOLmFwcGVuZE9yU2VsZWN0KG4sIFwiZy5zdGF0dXMtaW5kaWNhdG9yXCIpLmF0dHIoXCJjbGFzc1wiLCBpICE9PSBudWxsID8gYHN0YXR1cy1pbmRpY2F0b3Igc3RhdHVzLS0ke2l9YCA6IFwiXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke3IgLSBzfSwgMClgKSwgbyA9IGkgPyBbaV0gOiBbXSwgbCA9IGEuc2VsZWN0QWxsKFwiY2lyY2xlLnN0YXR1c1wiKS5kYXRhKG8pO1xuICAgIGwuZW50ZXIoKS5hcHBlbmQoXCJjaXJjbGVcIikubWVyZ2UobCkuYXR0cihcImNsYXNzXCIsIFwic3RhdHVzXCIpLmF0dHIoXCJyXCIsIHMpLmF0dHIoXCJjeFwiLCAwKS5hdHRyKFwiY3lcIiwgOCk7XG4gICAgY29uc3QgYyA9IGEuc2VsZWN0QWxsKFwicGF0aC5pbm5lckZpbGxcIikuZGF0YShvKTtcbiAgICBjLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKS5tZXJnZShjKS5hdHRyKFwiZFwiLCB0LmdldFN0YXR1c0ljb25QYXRoU3RyaW5nKGkpKS5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoLSR7c30sIDApYCkuYXR0cihcImNsYXNzXCIsIFwiaW5uZXJGaWxsXCIpLCBjLmV4aXQoKS5yZW1vdmUoKSwgbC5leGl0KCkucmVtb3ZlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIGFzc29jaWF0ZWQgcGVyY2VudGFnZSB0byB0aGUgZW5kIG9mIHRoZSB0aXRsZVxuICAgKi9cbiAgYXBwZW5kUGVyY2VudGFnZSgpIHtcbiAgICBjb25zdCB0ID0geSh0aGlzLm1vZGVsLmdldERpc3BsYXlEYXRhKCksIDAsIFwidmFsdWVcIiksIHsgY29kZTogbiwgbnVtYmVyOiByIH0gPSB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcImxvY2FsZVwiKSwgaSA9IHRoaXMuZ2V0Q29tcG9uZW50Q29udGFpbmVyKCksIHMgPSBOLmFwcGVuZE9yU2VsZWN0KGksIFwidGV4dC5tZXRlci10aXRsZVwiKSwgYSA9IHkodGhpcy5nZXRPcHRpb25zKCksIFwibWV0ZXJcIiwgXCJzdGF0dXNCYXJcIiwgXCJwZXJjZW50YWdlSW5kaWNhdG9yXCIsIFwiZW5hYmxlZFwiKSA9PT0gITAgPyBbdF0gOiBbXSwgbyA9IGkuc2VsZWN0QWxsKFwidGV4dC5wZXJjZW50LXZhbHVlXCIpLmRhdGEoYSksIGwgPSBadC5zdGF0dXNCYXIucGFkZGluZ1JpZ2h0O1xuICAgIG8uZW50ZXIoKS5hcHBlbmQoXCJ0ZXh0XCIpLmNsYXNzZWQoXCJwZXJjZW50LXZhbHVlXCIsICEwKS5tZXJnZShvKS50ZXh0KChjKSA9PiBgJHtjICE9IG51bGwgPyByKGMsIG4pIDogMH0lYCkuYXR0cihcInhcIiwgK3MuYXR0cihcInhcIikgKyBzLm5vZGUoKS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKSArIGwpLmF0dHIoXCJ5XCIsIHMuYXR0cihcInlcIikpLCBvLmV4aXQoKS5yZW1vdmUoKTtcbiAgfVxuICAvKipcbiAgICogVXNlcyB0aGUgcGFyZW50IGNsYXNzIHRydW5jYXRlIGxvZ2ljXG4gICAqIEBwYXJhbSB0aXRsZSBkMyBzZWxlY3Rpb24gb2YgdGl0bGUgZWxlbWVudCB0aGF0IHdpbGwgYmUgdHJ1bmNhdGVkXG4gICAqIEBwYXJhbSBtYXhXaWR0aCB0aGUgbWF4IHdpZHRoIHRoZSB0aXRsZSBjYW4gdGFrZVxuICAgKi9cbiAgdHJ1bmNhdGVUaXRsZSh0LCBuKSB7XG4gICAgc3VwZXIudHJ1bmNhdGVUaXRsZSh0LCBuKTtcbiAgICBjb25zdCByID0gTi5hcHBlbmRPclNlbGVjdCh0aGlzLnBhcmVudCwgXCJ0c3BhblwiKSwgaSA9IFp0LnN0YXR1c0Jhci5wYWRkaW5nUmlnaHQsIHMgPSBNYXRoLmNlaWwoci5ub2RlKCkuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkpO1xuICAgIE4uYXBwZW5kT3JTZWxlY3QodGhpcy5wYXJlbnQsIFwidGV4dC5wZXJjZW50LXZhbHVlXCIpLmF0dHIoXG4gICAgICBcInhcIixcbiAgICAgICt0LmF0dHIoXCJ4XCIpICsgdC5ub2RlKCkuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkgKyBzICsgaVxuICAgICk7XG4gIH1cbiAgLy8gY29tcHV0ZXMgdGhlIG1heGltdW0gc3BhY2UgYSB0aXRsZSBjYW4gdGFrZVxuICBnZXRNYXhUaXRsZVdpZHRoKCkge1xuICAgIGNvbnN0IHQgPSB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcIm1ldGVyXCIsIFwicHJvcG9ydGlvbmFsXCIpLCBuID0gTi5nZXRIVE1MRWxlbWVudFNpemUodGhpcy5wYXJlbnQubm9kZSgpKS53aWR0aDtcbiAgICBpZiAodCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgciA9IE4uYXBwZW5kT3JTZWxlY3QodGhpcy5wYXJlbnQsIFwidGV4dC5wcm9wb3J0aW9uYWwtbWV0ZXItdG90YWxcIikubm9kZSgpLCBpID0gTi5nZXRTVkdFbGVtZW50U2l6ZShyLCB7XG4gICAgICAgIHVzZUJCb3g6ICEwXG4gICAgICB9KS53aWR0aDtcbiAgICAgIHJldHVybiBuIC0gaSAtIFp0LnRvdGFsLnBhZGRpbmdMZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByID0gTi5hcHBlbmRPclNlbGVjdCh0aGlzLnBhcmVudCwgXCJ0ZXh0LnBlcmNlbnQtdmFsdWVcIiksIGkgPSBadC5zdGF0dXNCYXIucGFkZGluZ1JpZ2h0LCBzID0gci5ub2RlKCkuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCksIGEgPSBOLmFwcGVuZE9yU2VsZWN0KHRoaXMucGFyZW50LCBcImcuc3RhdHVzLWluZGljYXRvclwiKS5ub2RlKCksIG8gPSBOLmdldFNWR0VsZW1lbnRTaXplKGEsIHsgdXNlQkJveDogITAgfSkud2lkdGggKyBadC5zdGF0dXMucGFkZGluZ0xlZnQ7XG4gICAgICByZXR1cm4gbiAtIHMgLSBpIC0gbztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgYXNzb2NpYXRlZCBzdGF0dXMgaWNvbiBmb3IgdGhlIGRhdGFcbiAgICogQHBhcmFtIHN0YXR1cyB0aGUgYWN0aXZlIHN0YXR1cyBmb3IgdGhlIG1ldGVyIGNoYXJ0XG4gICAqL1xuICBnZXRTdGF0dXNJY29uUGF0aFN0cmluZyh0KSB7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICBjYXNlIGpzLlNVQ0NFU1M6XG4gICAgICAgIHJldHVybiBcIk02Ljg3NSAxMS4zMTI1IDMuNzUgOC4xODc1IDQuNzQzNzUgNy4yNSA2Ljg3NSA5LjM0Mzc1IDExLjUwNjI1IDQuNzUgMTIuNSA1LjczNzUgWlwiO1xuICAgICAgY2FzZSBqcy5EQU5HRVI6XG4gICAgICAgIHJldHVybiBcIk0xMC43IDExLjUgNC41IDUuMyA1LjMgNC41IDExLjUgMTAuNyBaXCI7XG4gICAgICBjYXNlIGpzLldBUk5JTkc6XG4gICAgICAgIHJldHVybiBcIk03LjkzNzUsMTEuMTI1IEM3LjQxOTczMzA1LDExLjEyNSA3LDExLjU0NDczMyA3LDEyLjA2MjUgQzcsMTIuNTgwMjY3IDcuNDE5NzMzMDUsMTMgNy45Mzc1LDEzIEM4LjQ1NTI2Njk1LDEzIDguODc1LDEyLjU4MDI2NyA4Ljg3NSwxMi4wNjI1IEM4Ljg3NSwxMS41NDQ3MzMgOC40NTUyNjY5NSwxMS4xMjUgNy45Mzc1LDExLjEyNSBNNy4zMTI1LCAzIDguNTYyNSwgMyA4LjU2MjUsIDkuODc1IDcuMzEyNSwgOS44NzUsIDcuMzEyNSwgMyBaXCI7XG4gICAgfVxuICB9XG59XG5jbGFzcyBodSBleHRlbmRzIG10IHtcbiAgLy8gR2V0cyB0aGUgY29ycmVjdCB3aWR0aCBmb3IgYmFycyBiYXNlZCBvbiBvcHRpb25zICYgY29uZmlndXJhdGlvbnNcbiAgZ2V0QmFyV2lkdGgoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgIGlmICh0LmJhcnMud2lkdGgpXG4gICAgICByZXR1cm4gdC5iYXJzLndpZHRoO1xuICAgIGNvbnN0IG4gPSB0aGlzLm1vZGVsLmdldERpc3BsYXlEYXRhKCkubGVuZ3RoLCByID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0TWFpblhTY2FsZSgpLCBpID0gTi5nZXRTVkdFbGVtZW50U2l6ZSh0aGlzLnBhcmVudCwge1xuICAgICAgdXNlQXR0cnM6ICEwXG4gICAgfSkud2lkdGg7XG4gICAgaWYgKCFyLnN0ZXApIHtcbiAgICAgIGNvbnN0IHMgPSB5KHQsIFwiYmFyc1wiLCBcInNwYWNpbmdGYWN0b3JcIik7XG4gICAgICByZXR1cm4gTWF0aC5taW4odC5iYXJzLm1heFdpZHRoLCBpICogcyAvIG4pO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5taW4odC5iYXJzLm1heFdpZHRoLCByLnN0ZXAoKSAvIDIpO1xuICB9XG4gIGlzT3V0c2lkZVpvb21lZERvbWFpbih0LCBuKSB7XG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0RGlzcGxheURhdGEoKS5sZW5ndGggPD0gMSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCByID0gdGhpcy5tb2RlbC5nZXQoXCJ6b29tRG9tYWluXCIpO1xuICAgIGlmIChyICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXREb21haW5TY2FsZSgpO1xuICAgICAgcmV0dXJuIHQgPCBpKHJbMF0pIHx8IG4gPiBpKHJbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmNsYXNzIFJEIGV4dGVuZHMgbXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnR5cGUgPSBcImNpcmNsZS1wYWNrXCIsIHRoaXMucmVuZGVyVHlwZSA9IHJ0LlNWRywgdGhpcy5oYW5kbGVMZWdlbmRPbkhvdmVyID0gKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgaG92ZXJlZEVsZW1lbnQ6IG4gfSA9IHQuZGV0YWlsO1xuICAgICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwiY2lyY2xlLm5vZGVcIikudHJhbnNpdGlvbihcImxlZ2VuZC1ob3Zlci1jaXJjbGVwYWNrXCIpLmNhbGwoXG4gICAgICAgIChyKSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgdHJhbnNpdGlvbjogcixcbiAgICAgICAgICBuYW1lOiBcImxlZ2VuZC1ob3Zlci1jaXJjbGVwYWNrXCJcbiAgICAgICAgfSlcbiAgICAgICkuYXR0cihcIm9wYWNpdHlcIiwgKHIpID0+IHIuZGF0YS5kYXRhR3JvdXBOYW1lID09PSBuLmRhdHVtKCkubmFtZSA/IDEgOiBDci5jaXJjbGVzLmZpbGxPcGFjaXR5KTtcbiAgICB9LCB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlT3V0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwiY2lyY2xlLm5vZGVcIikudHJhbnNpdGlvbihcImxlZ2VuZC1tb3VzZW91dC1jaXJjbGVwYWNrXCIpLmNhbGwoXG4gICAgICAgICh0KSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgdHJhbnNpdGlvbjogdCxcbiAgICAgICAgICBuYW1lOiBcImxlZ2VuZC1tb3VzZW91dC1jaXJjbGVwYWNrXCJcbiAgICAgICAgfSlcbiAgICAgICkuYXR0cihcIm9wYWNpdHlcIiwgMSk7XG4gICAgfTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gIC8vIEB0cy1pZ25vcmVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICByZW5kZXIodCA9ICEwKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0Q29tcG9uZW50Q29udGFpbmVyKHtcbiAgICAgIGFyaWFMYWJlbDogXCJjaXJjbGUgcGFja3NcIixcbiAgICAgIHdpdGhpbkNoYXJ0Q2xpcDogITBcbiAgICB9KSwgeyB3aWR0aDogciwgaGVpZ2h0OiBpIH0gPSBOLmdldFNWR0VsZW1lbnRTaXplKHRoaXMucGFyZW50LCB7XG4gICAgICB1c2VBdHRyczogITBcbiAgICB9KTtcbiAgICBpZiAociA8IDEgfHwgaSA8IDEpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHMgPSB0aGlzLm1vZGVsLmdldERpc3BsYXlEYXRhKCk7XG4gICAgY29uc3QgYSA9IHRoaXMubW9kZWwuaGFzUGFyZW50Tm9kZSgpLCBvID0gdGhpcy5tb2RlbC5nZXRIaWVyYXJjaHlMZXZlbCgpLCBsID0gdGhpcy5nZXRPcHRpb25zKCksIGMgPSB5KGwsIFwiY2FudmFzWm9vbVwiLCBcImVuYWJsZWRcIik7XG4gICAgYSAmJiB5KHMsIDAsIFwiY2hpbGRyZW5cIikgJiYgKHMgPSB5KHMsIDAsIFwiY2hpbGRyZW5cIikpO1xuICAgIGNvbnN0IHUgPSB5cyh7IGNoaWxkcmVuOiBzIH0pLnN1bSgoZikgPT4gZi52YWx1ZSkuc29ydCgoZiwgZykgPT4gZy52YWx1ZSAtIGYudmFsdWUpLCBkID0gVkwoKS5zaXplKFtyLCBpXSkucGFkZGluZygoZikgPT4gZi5kZXB0aCA+PSAxID8gQ3IucGFkZGluZy5jaGlsZHJlbiArIDMgOiBDci5wYWRkaW5nLm1haW5Hcm91cCArIDMpKHUpLmRlc2NlbmRhbnRzKCkuc3BsaWNlKDEpLmZpbHRlcigoZikgPT4gZi5kZXB0aCA8PSBvKSwgaCA9IG4uc2VsZWN0QWxsKFwiY2lyY2xlLm5vZGVcIikuZGF0YShkKTtcbiAgICBoLmV4aXQoKS5hdHRyKFwid2lkdGhcIiwgMCkuYXR0cihcImhlaWdodFwiLCAwKS5yZW1vdmUoKTtcbiAgICBjb25zdCBwID0gaC5lbnRlcigpLmFwcGVuZChcImNpcmNsZVwiKS5jbGFzc2VkKFwibm9kZVwiLCAhMCk7XG4gICAgcC5tZXJnZShoKS5hdHRyKFwiY2xhc3NcIiwgKGYpID0+IHtcbiAgICAgIGNvbnN0IGcgPSBjICYmIG8gPT09IDMgPyB0aGlzLmdldFpvb21DbGFzcyhmKSA6IFwiXCI7XG4gICAgICByZXR1cm4gdGhpcy5tb2RlbC5nZXRDb2xvckNsYXNzTmFtZSh7XG4gICAgICAgIGNsYXNzTmFtZVR5cGVzOiBbaXQuRklMTCwgaXQuU1RST0tFXSxcbiAgICAgICAgZGF0YUdyb3VwTmFtZTogZi5kYXRhLmRhdGFHcm91cE5hbWUsXG4gICAgICAgIG9yaWdpbmFsQ2xhc3NOYW1lOiBmLmNoaWxkcmVuID8gYG5vZGUgJHtnfWAgOiBgbm9kZSBub2RlLWxlYWYgJHtnfWBcbiAgICAgIH0pO1xuICAgIH0pLnN0eWxlKFwiZmlsbFwiLCAoZikgPT4gdGhpcy5tb2RlbC5nZXRGaWxsQ29sb3IoZi5kYXRhLmRhdGFHcm91cE5hbWUsIG51bGwsIGYuZGF0YSkpLnN0eWxlKFwic3Ryb2tlXCIsIChmKSA9PiB0aGlzLm1vZGVsLmdldEZpbGxDb2xvcihmLmRhdGEuZGF0YUdyb3VwTmFtZSwgbnVsbCwgZi5kYXRhKSkuYXR0cihcImN4XCIsIChmKSA9PiBmLngpLmF0dHIoXCJjeVwiLCAoZikgPT4gZi55KS50cmFuc2l0aW9uKFwiY2lyY2xlcGFjay1sZWFmLXVwZGF0ZS1lbnRlclwiKS5jYWxsKFxuICAgICAgKGYpID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgdHJhbnNpdGlvbjogZixcbiAgICAgICAgbmFtZTogXCJjaXJjbGVwYWNrLWxlYWYtdXBkYXRlLWVudGVyXCJcbiAgICAgIH0pXG4gICAgKS5hdHRyKFwiclwiLCAoZikgPT4gZi5yKS5hdHRyKFwib3BhY2l0eVwiLCAxKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIENyLmNpcmNsZXMuZmlsbE9wYWNpdHkpLCBjID09PSAhMCAmJiB0aGlzLmZvY2FsICYmICh0aGlzLnNlcnZpY2VzLmNhbnZhc1pvb20uem9vbUluKHRoaXMuZm9jYWwsIHAsIE5yKSwgdGhpcy5zZXRCYWNrZ3JvdW5kTGlzdGVuZXJzKCkpLCBhIHx8IHRoaXMuYWRkTGVnZW5kTGlzdGVuZXJzKCksIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICAvLyB0dXJuIG9mZiB0aGUgaGlnaGxpZ2h0IGNsYXNzIG9uIGNoaWxkcmVuIGNpcmNsZXNcbiAgdW5oaWdobGlnaHRDaGlsZHJlbih0KSB7XG4gICAgY29uc3QgbiA9IHQubWFwKChyKSA9PiByLmRhdGEpO1xuICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcImNpcmNsZS5ub2RlXCIpLmZpbHRlcigocikgPT4gbi5zb21lKChpKSA9PiBpID09PSByLmRhdGEpICYmIHIuZGVwdGggPiAxKS5zdHlsZShcInN0cm9rZVwiLCAocikgPT4gdGhpcy5tb2RlbC5nZXRGaWxsQ29sb3Ioci5kYXRhLmRhdGFHcm91cE5hbWUsIG51bGwsIHIuZGF0YSkpO1xuICB9XG4gIC8vIGhpZ2hsaWdodCB0aGUgY2hpbGRyZW4gY2lyY2xlcyB3aXRoIGEgc3Ryb2tlXG4gIGhpZ2hsaWdodENoaWxkcmVuKHQpIHtcbiAgICBjb25zdCBuID0gdC5tYXAoKHIpID0+IHIuZGF0YSk7XG4gICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwiY2lyY2xlLm5vZGVcIikuZmlsdGVyKChyKSA9PiBuLnNvbWUoKGkpID0+IGkgPT09IHIuZGF0YSkgJiYgci5kZXB0aCA+IDEpLnN0eWxlKFwic3Ryb2tlXCIsIENyLmNpcmNsZXMuaG92ZXIuc3Ryb2tlKTtcbiAgfVxuICBnZXRab29tQ2xhc3ModCkge1xuICAgIHJldHVybiB0aGlzLm1vZGVsLmdldEhpZXJhcmNoeUxldmVsKCkgPT09IDMgJiYgdGhpcy5mb2NhbCAmJiAodC5kYXRhID09PSB0aGlzLmZvY2FsLmRhdGEgfHwgdGhpcy5mb2NhbC5jaGlsZHJlbi5zb21lKChuKSA9PiBuLmRhdGEgPT09IHQuZGF0YSkpID8gXCJmb2NhbFwiIDogXCJub24tZm9jYWxcIjtcbiAgfVxuICBhZGRMZWdlbmRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgeyBldmVudHM6IHQgfSA9IHRoaXMuc2VydmljZXM7XG4gICAgdC5hZGRFdmVudExpc3RlbmVyKFQuTGVnZW5kLklURU1fSE9WRVIsIHRoaXMuaGFuZGxlTGVnZW5kT25Ib3ZlciksIHQuYWRkRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX01PVVNFT1VULCB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlT3V0KTtcbiAgfVxuICByZW1vdmVCYWNrZ3JvdW5kTGlzdGVuZXJzKCkge1xuICAgIEkodGhpcy5zZXJ2aWNlcy5kb21VdGlscy5nZXRNYWluQ29udGFpbmVyKCkpLm9uKFwiY2xpY2tcIiwgKCkgPT4gbnVsbCk7XG4gIH1cbiAgc2V0QmFja2dyb3VuZExpc3RlbmVycygpIHtcbiAgICBjb25zdCB0ID0gSSh0aGlzLnNlcnZpY2VzLmRvbVV0aWxzLmdldE1haW5Db250YWluZXIoKSksIG4gPSB0aGlzLCByID0gdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwiY2lyY2xlLm5vZGVcIik7XG4gICAgdC5vbihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIG4uZm9jYWwgPSBudWxsLCBuLm1vZGVsLnVwZGF0ZUhpZXJhcmNoeUxldmVsKDIpLCB0LmNsYXNzZWQoXCJ6b29tZWQtaW5cIiwgITEpLCBuLnNlcnZpY2VzLmNhbnZhc1pvb20uem9vbU91dChyLCBOcik7XG4gICAgfSk7XG4gIH1cbiAgLy8gWm9vbSBpY29uIHRvIGJlIGFwcGVuZGVkIHRvIHRoZSBsYWJlbCBpbiB0aGUgdG9vbHRpcFxuICBnZXRab29tSWNvbigpIHtcbiAgICByZXR1cm4gYFxuXHRcdDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMTAgMTBcIj5cblx0XHRcdDxwb2x5Z29uIHBvaW50cz1cIjUuOTMgMy43MSA0LjQ1IDMuNzEgNC40NSAyLjIzIDMuNzEgMi4yMyAzLjcxIDMuNzEgMi4yMyAzLjcxIDIuMjMgNC40NSAzLjcxIDQuNDUgMy43MSA1LjkzIDQuNDUgNS45MyA0LjQ1IDQuNDUgNS45MyA0LjQ1IDUuOTMgMy43MVwiLz5cblx0XHRcdDxwYXRoIGQ9XCJNNy4yLDYuNjdhNCw0LDAsMCwwLDEtMi41OUE0LjA4LDQuMDgsMCwxLDAsNC4wNyw4LjE1aDBhNCw0LDAsMCwwLDIuNTktMUw5LjQ4LDEwLDEwLDkuNDhabS0zLjEyLjc3QTMuMzQsMy4zNCwwLDEsMSw3LjQxLDQuMDgsMy4zNCwzLjM0LDAsMCwxLDQuMDgsNy40NFpcIi8+XG5cdFx0PC9zdmc+YDtcbiAgfVxuICAvLyBhZGQgZXZlbnQgbGlzdGVuZXJzIGZvciB0b29sdGlwIG9uIHRoZSBjaXJjbGVzXG4gIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzO1xuICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcImNpcmNsZS5ub2RlXCIpLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKG4sIHIpIHtcbiAgICAgIGNvbnN0IGkgPSBJKHRoaXMpO1xuICAgICAgaS5jbGFzc2VkKFwiaG92ZXJlZFwiLCAhMCk7XG4gICAgICBjb25zdCBzID0gdC5tb2RlbC5nZXRIaWVyYXJjaHlMZXZlbCgpLCBhID0gcyA+IDIgJiYgIWkuY2xhc3NlZChcImZvY2FsXCIpLCBvID0geSh0Lm1vZGVsLmdldE9wdGlvbnMoKSwgXCJjYW52YXNab29tXCIsIFwiZW5hYmxlZFwiKTtcbiAgICAgIGxldCBsID0gITE7XG4gICAgICBpZiAoIWEpIHtcbiAgICAgICAgbGV0IGMgPSBbXSwgdSA9IFtdLCBkID0gbnVsbDtcbiAgICAgICAgaWYgKHIuY2hpbGRyZW4pIHtcbiAgICAgICAgICByLmRlcHRoID4gMSAmJiBvICYmIChsID0gITAsIGkuY2xhc3NlZChcImNsaWNrYWJsZVwiLCAhMCkpLCBjID0gci5jaGlsZHJlbi5tYXAoKGYpID0+IHtcbiAgICAgICAgICAgIGlmIChmICE9PSBudWxsKVxuICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGYuZGF0YS52YWx1ZSA9PSBcIm51bWJlclwiID8ge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBmLmRhdGEubmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZi5kYXRhLnZhbHVlXG4gICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgbGFiZWw6IGYuZGF0YS5uYW1lLFxuICAgICAgICAgICAgICAgIGxhYmVsSWNvbjogbyAmJiBzIDw9IDIgPyB0LmdldFpvb21JY29uKCkgOiBudWxsLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmLnZhbHVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgcCA9IHQubW9kZWwuZ2V0T3B0aW9ucygpO1xuICAgICAgICAgIHUgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxhYmVsOiBndChwLCBcImxvY2FsZS50cmFuc2xhdGlvbnMudG90YWxcIikgfHwgZ3QocCwgXCJ0b29sdGlwLnRvdGFsTGFiZWxcIikgfHwgXCJUb3RhbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogci52YWx1ZSxcbiAgICAgICAgICAgICAgYm9sZDogITBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLCB0LmhpZ2hsaWdodENoaWxkcmVuKHIuY2hpbGRyZW4pO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBkID0gci52YWx1ZTtcbiAgICAgICAgY29uc3QgaCA9IGdldENvbXB1dGVkU3R5bGUodGhpcywgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShcImZpbGxcIik7XG4gICAgICAgIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLlNIT1csIHtcbiAgICAgICAgICBldmVudDogbixcbiAgICAgICAgICBob3ZlcmVkRWxlbWVudDogaSxcbiAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb2xvcjogaCxcbiAgICAgICAgICAgICAgbGFiZWw6IHIuZGF0YS5uYW1lLFxuICAgICAgICAgICAgICBsYWJlbEljb246IGwgJiYgbyAmJiBzIDw9IDIgPyB0LmdldFpvb21JY29uKCkgOiBudWxsLFxuICAgICAgICAgICAgICB2YWx1ZTogZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICAuLi51XG4gICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5DaXJjbGVQYWNrLkNJUkNMRV9NT1VTRU9WRVIsIHtcbiAgICAgICAgZXZlbnQ6IG4sXG4gICAgICAgIGVsZW1lbnQ6IGksXG4gICAgICAgIGRhdHVtOiByXG4gICAgICB9KTtcbiAgICB9KS5vbihcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbihuLCByKSB7XG4gICAgICBjb25zdCBpID0gSSh0aGlzKTtcbiAgICAgIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5DaXJjbGVQYWNrLkNJUkNMRV9NT1VTRU1PVkUsIHtcbiAgICAgICAgZXZlbnQ6IG4sXG4gICAgICAgIGVsZW1lbnQ6IGksXG4gICAgICAgIGRhdHVtOiByXG4gICAgICB9KSwgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuTU9WRSwge1xuICAgICAgICBldmVudDogblxuICAgICAgfSk7XG4gICAgfSkub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihuLCByKSB7XG4gICAgICBjb25zdCBpID0gSSh0aGlzKTtcbiAgICAgIGkuY2xhc3NlZChcImhvdmVyZWRcIiwgITEpLCByLmNoaWxkcmVuICYmIHQudW5oaWdobGlnaHRDaGlsZHJlbihyLmNoaWxkcmVuKSwgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkNpcmNsZVBhY2suQ0lSQ0xFX01PVVNFT1VULCB7XG4gICAgICAgIGV2ZW50OiBuLFxuICAgICAgICBlbGVtZW50OiBpLFxuICAgICAgICBkYXR1bTogclxuICAgICAgfSksIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLkhJREUsIHtcbiAgICAgICAgaG92ZXJlZEVsZW1lbnQ6IGlcbiAgICAgIH0pO1xuICAgIH0pLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24obiwgcikge1xuICAgICAgY29uc3QgaSA9IEkodGhpcyksIHMgPSBpLmNsYXNzZWQoXCJub24tZm9jYWxcIiksIGEgPSB5KHQubW9kZWwuZ2V0T3B0aW9ucygpLCBcImNhbnZhc1pvb21cIiwgXCJlbmFibGVkXCIpO1xuICAgICAgaWYgKGEgJiYgdC5tb2RlbC5nZXRIaWVyYXJjaHlMZXZlbCgpID4gMikge1xuICAgICAgICBjb25zdCBvID0gdC5wYXJlbnQuc2VsZWN0QWxsKFwiY2lyY2xlLm5vZGVcIik7XG4gICAgICAgIEkodC5zZXJ2aWNlcy5kb21VdGlscy5nZXRNYWluQ29udGFpbmVyKCkpLmNsYXNzZWQoXCJ6b29tZWQtaW5cIiwgITEpLCB0LmZvY2FsID0gbnVsbCwgdC5tb2RlbC51cGRhdGVIaWVyYXJjaHlMZXZlbCgyKSwgdC5zZXJ2aWNlcy5jYW52YXNab29tLnpvb21PdXQobywgTnIpO1xuICAgICAgfSBlbHNlIGlmIChyLmRlcHRoID09PSAyICYmIHIuY2hpbGRyZW4gJiYgIXMgJiYgYSkge1xuICAgICAgICBjb25zdCBvID0gdC5wYXJlbnQuc2VsZWN0QWxsKFwiY2lyY2xlLm5vZGVcIik7XG4gICAgICAgIEkodC5zZXJ2aWNlcy5kb21VdGlscy5nZXRNYWluQ29udGFpbmVyKCkpLmNsYXNzZWQoXCJ6b29tZWQtaW5cIiwgITApLCB0LmZvY2FsID0gciwgdC5tb2RlbC51cGRhdGVIaWVyYXJjaHlMZXZlbCgzKSwgdC5zZXJ2aWNlcy5jYW52YXNab29tLnpvb21JbihyLCBvLCBOciksIG4uc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgICB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuQ2lyY2xlUGFjay5DSVJDTEVfQ0xJQ0ssIHtcbiAgICAgICAgZXZlbnQ6IG4sXG4gICAgICAgIGVsZW1lbnQ6IGksXG4gICAgICAgIGRhdHVtOiByXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcImNpcmNsZS5ub2RlXCIpLm9uKFwibW91c2VvdmVyXCIsIG51bGwpLm9uKFwibW91c2Vtb3ZlXCIsIG51bGwpLm9uKFwibW91c2VvdXRcIiwgbnVsbCkub24oXCJjbGlja1wiLCBudWxsKTtcbiAgICBjb25zdCB0ID0gdGhpcy5zZXJ2aWNlcy5ldmVudHM7XG4gICAgdC5yZW1vdmVFdmVudExpc3RlbmVyKFQuTGVnZW5kLklURU1fSE9WRVIsIHRoaXMuaGFuZGxlTGVnZW5kT25Ib3ZlciksIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX01PVVNFT1VULCB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlT3V0KSwgdGhpcy5yZW1vdmVCYWNrZ3JvdW5kTGlzdGVuZXJzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIElEKGUsIHQpIHtcbiAgY29uc3QgbiA9IGZzKHRoaXMuX2N1cnJlbnQsIGUpO1xuICByZXR1cm4gKHIpID0+ICh0aGlzLl9jdXJyZW50ID0gbihyKSwgdCh0aGlzLl9jdXJyZW50KSk7XG59XG5jbGFzcyBUdiBleHRlbmRzIG10IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy50eXBlID0gXCJwaWVcIiwgdGhpcy5yZW5kZXJUeXBlID0gcnQuU1ZHLCB0aGlzLmlzUmVuZGVyaW5nID0gITEsIHRoaXMuaGFuZGxlTGVnZW5kT25Ib3ZlciA9ICh0KSA9PiB7XG4gICAgICBjb25zdCB7IGhvdmVyZWRFbGVtZW50OiBuIH0gPSB0LmRldGFpbCwgeyBncm91cE1hcHNUbzogciB9ID0gdGhpcy5nZXRPcHRpb25zKCkuZGF0YTtcbiAgICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcInBhdGguc2xpY2VcIikudHJhbnNpdGlvbihcImxlZ2VuZC1ob3Zlci1iYXJcIikuY2FsbChcbiAgICAgICAgKGkpID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICB0cmFuc2l0aW9uOiBpLFxuICAgICAgICAgIG5hbWU6IFwibGVnZW5kLWhvdmVyLWJhclwiXG4gICAgICAgIH0pXG4gICAgICApLmF0dHIoXG4gICAgICAgIFwib3BhY2l0eVwiLFxuICAgICAgICAoaSkgPT4gaS5kYXRhW3JdICE9PSBuLmRhdHVtKCkubmFtZSA/IDAuMyA6IDFcbiAgICAgICk7XG4gICAgfSwgdGhpcy5oYW5kbGVMZWdlbmRNb3VzZU91dCA9ICgpID0+IHtcbiAgICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcInBhdGguc2xpY2VcIikudHJhbnNpdGlvbihcImxlZ2VuZC1tb3VzZW91dC1iYXJcIikuY2FsbChcbiAgICAgICAgKHQpID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICB0cmFuc2l0aW9uOiB0LFxuICAgICAgICAgIG5hbWU6IFwibGVnZW5kLW1vdXNlb3V0LWJhclwiXG4gICAgICAgIH0pXG4gICAgICApLmF0dHIoXCJvcGFjaXR5XCIsIDEpO1xuICAgIH07XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5zZXJ2aWNlcy5ldmVudHM7XG4gICAgdC5hZGRFdmVudExpc3RlbmVyKFQuTGVnZW5kLklURU1fSE9WRVIsIHRoaXMuaGFuZGxlTGVnZW5kT25Ib3ZlciksIHQuYWRkRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX01PVVNFT1VULCB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlT3V0KTtcbiAgfVxuICBnZXRJbm5lclJhZGl1cygpIHtcbiAgICByZXR1cm4gTXQuaW5uZXJSYWRpdXM7XG4gIH1cbiAgcmVuZGVyKHQgPSAhMCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLCByID0gdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoe1xuICAgICAgYXJpYUxhYmVsOiBcInBpZSBncmFwaFwiXG4gICAgfSksIGkgPSB0aGlzLmdldE9wdGlvbnMoKSwgeyBncm91cE1hcHNUbzogcyB9ID0gaS5kYXRhLCB7IHZhbHVlTWFwc1RvOiBhIH0gPSBpLnBpZTtcbiAgICB0aGlzLmlzUmVuZGVyaW5nID0gITA7XG4gICAgY29uc3QgbyA9IHRoaXMubW9kZWwuZ2V0RGlzcGxheURhdGEoKS5maWx0ZXIoKEEpID0+IEFbYV0gPiAwKSwgbCA9IHRoaXMuY29tcHV0ZVJhZGl1cygpO1xuICAgIHRoaXMuYXJjID0gYXMoKS5pbm5lclJhZGl1cyh0aGlzLmdldElubmVyUmFkaXVzKCkpLm91dGVyUmFkaXVzKGwpLCB0aGlzLmhvdmVyQXJjID0gYXMoKS5pbm5lclJhZGl1cyh0aGlzLmdldElubmVyUmFkaXVzKCkpLm91dGVyUmFkaXVzKGwgKyBNdC5ob3ZlckFyYy5vdXRlclJhZGl1c09mZnNldCk7XG4gICAgY29uc3QgYyA9IGNrKCkudmFsdWUoKEEpID0+IEFbYV0pLnNvcnQoeShpLCBcInBpZVwiLCBcInNvcnRGdW5jdGlvblwiKSkucGFkQW5nbGUoTXQucGFkQW5nbGUpKG8pLCB1ID0gTi5hcHBlbmRPclNlbGVjdChyLCBcImcuc2xpY2VzXCIpLmF0dHIoXCJyb2xlXCIsIGh0LkdST1VQKS5hdHRyKFwiZGF0YS1uYW1lXCIsIFwic2xpY2VzXCIpLnNlbGVjdEFsbChcInBhdGguc2xpY2VcIikuZGF0YShjLCAoQSkgPT4gQS5kYXRhW3NdKTtcbiAgICB1LmV4aXQoKS5hdHRyKFwib3BhY2l0eVwiLCAwKS5yZW1vdmUoKSwgdS5lbnRlcigpLmFwcGVuZChcInBhdGhcIikuY2xhc3NlZChcInNsaWNlXCIsICEwKS5hdHRyKFwib3BhY2l0eVwiLCAwKS5tZXJnZSh1KS5hdHRyKFxuICAgICAgXCJjbGFzc1wiLFxuICAgICAgKEEpID0+IHRoaXMubW9kZWwuZ2V0Q29sb3JDbGFzc05hbWUoe1xuICAgICAgICBjbGFzc05hbWVUeXBlczogW2l0LkZJTExdLFxuICAgICAgICBkYXRhR3JvdXBOYW1lOiBBLmRhdGFbc10sXG4gICAgICAgIG9yaWdpbmFsQ2xhc3NOYW1lOiBcInNsaWNlXCJcbiAgICAgIH0pXG4gICAgKS5zdHlsZShcImZpbGxcIiwgKEEpID0+IG4ubW9kZWwuZ2V0RmlsbENvbG9yKEEuZGF0YVtzXSwgbnVsbCwgQS5kYXRhKSkuYXR0cihcImRcIiwgdGhpcy5hcmMpLnRyYW5zaXRpb24oKS5jYWxsKFxuICAgICAgKEEpID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgdHJhbnNpdGlvbjogQSxcbiAgICAgICAgbmFtZTogXCJwaWVfc2xpY2VfZW50ZXJfdXBkYXRlXCIsXG4gICAgICAgIGFuaW1hdGU6IHRcbiAgICAgIH0pXG4gICAgKS5hdHRyKFwib3BhY2l0eVwiLCAxKS5hdHRyKFwicm9sZVwiLCBodC5HUkFQSElDU19TWU1CT0wpLmF0dHIoXCJhcmlhLXJvbGVkZXNjcmlwdGlvblwiLCBcInNsaWNlXCIpLmF0dHIoXG4gICAgICBcImFyaWEtbGFiZWxcIixcbiAgICAgIChBKSA9PiBgJHtBW2FdfSwgJHtMbyhBLmRhdGFbYV0sIG8sIGEpICsgXCIlXCJ9YFxuICAgICkuYXR0clR3ZWVuKFwiZFwiLCBmdW5jdGlvbihBKSB7XG4gICAgICByZXR1cm4gSUQuYmluZCh0aGlzKShBLCBuLmFyYyk7XG4gICAgfSkub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgbi5pc1JlbmRlcmluZyA9ICExO1xuICAgIH0pO1xuICAgIGNvbnN0IHsgY29kZTogZCwgbnVtYmVyOiBoIH0gPSB5KGksIFwibG9jYWxlXCIpLCBwID0gaS5waWUubGFiZWxzLmVuYWJsZWQsIGYgPSBwID8gYy5maWx0ZXIoKEEpID0+IEEuZGF0YVthXSA+IDApIDogW10sIGcgPSBOLmFwcGVuZE9yU2VsZWN0KHIsIFwiZy5sYWJlbHNcIikuYXR0cihcInJvbGVcIiwgaHQuR1JPVVApLmF0dHIoXCJkYXRhLW5hbWVcIiwgXCJsYWJlbHNcIikuc2VsZWN0QWxsKFwidGV4dC5waWUtbGFiZWxcIikuZGF0YShmLCAoQSkgPT4gQS5kYXRhW3NdKTtcbiAgICBnLmV4aXQoKS5hdHRyKFwib3BhY2l0eVwiLCAwKS5yZW1vdmUoKTtcbiAgICBjb25zdCBtID0gZy5lbnRlcigpLmFwcGVuZChcInRleHRcIikuY2xhc3NlZChcInBpZS1sYWJlbFwiLCAhMCksIHYgPSBbXTtcbiAgICBtLm1lcmdlKGcpLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikudGV4dCgoQSkgPT4gaS5waWUubGFiZWxzLmZvcm1hdHRlciA/IGkucGllLmxhYmVscy5mb3JtYXR0ZXIoe1xuICAgICAgLi4uQSxcbiAgICAgIHBlcmNlbnRhZ2VWYWx1ZTogTG8oXG4gICAgICAgIEEuZGF0YVthXSxcbiAgICAgICAgbyxcbiAgICAgICAgYSxcbiAgICAgICAgITBcbiAgICAgIClcbiAgICB9KSA6IGgoXG4gICAgICBMbyhBLmRhdGFbYV0sIG8sIGEpLFxuICAgICAgZFxuICAgICkgKyBcIiVcIikuZGF0dW0oZnVuY3Rpb24oQSkge1xuICAgICAgY29uc3QgUiA9IGwgKyA3LCAkID0gKEEuZW5kQW5nbGUgLSBBLnN0YXJ0QW5nbGUpIC8gMiArIEEuc3RhcnRBbmdsZSwgSCA9ICQgLyBNYXRoLlBJICogMTgwLCBQID0gdGhpcy5nZXRDb21wdXRlZFRleHRMZW5ndGgoKTtcbiAgICAgIHJldHVybiBBLnRleHRPZmZzZXRYID0gUCAvIDIsIEEudGV4dE9mZnNldFkgPSBIID4gOTAgJiYgSCA8IDI3MCA/IDEwIDogMCwgQS54UG9zaXRpb24gPSAoQS50ZXh0T2Zmc2V0WCArIFIpICogTWF0aC5zaW4oJCksIEEueVBvc2l0aW9uID0gKEEudGV4dE9mZnNldFkgKyBSKSAqIC1NYXRoLmNvcygkKSwgQTtcbiAgICB9KS5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKEEsIFIpIHtcbiAgICAgIGNvbnN0ICQgPSBmLmxlbmd0aCwgSCA9IChBLmVuZEFuZ2xlIC0gQS5zdGFydEFuZ2xlKSAqICgxODAgLyBNYXRoLlBJKTtcbiAgICAgIGlmIChSID49ICQgLSAyICYmIEggPCBNdC5jYWxsb3V0Lm1pblNsaWNlRGVncmVlKSB7XG4gICAgICAgIGxldCBQLCBCO1xuICAgICAgICByZXR1cm4gQS5pbmRleCA9PT0gJCAtIDEgPyAoUCA9IEEueFBvc2l0aW9uICsgTXQuY2FsbG91dC5vZmZzZXRYICsgTXQuY2FsbG91dC50ZXh0TWFyZ2luICsgQS50ZXh0T2Zmc2V0WCwgQiA9IEEueVBvc2l0aW9uIC0gTXQuY2FsbG91dC5vZmZzZXRZLCBBLmRpcmVjdGlvbiA9IEZzLlJJR0hULCB2LnB1c2goQSkpIDogKFAgPSBBLnhQb3NpdGlvbiAtIE10LmNhbGxvdXQub2Zmc2V0WCAtIEEudGV4dE9mZnNldFggLSBNdC5jYWxsb3V0LnRleHRNYXJnaW4sIEIgPSBBLnlQb3NpdGlvbiAtIE10LmNhbGxvdXQub2Zmc2V0WSwgQS5kaXJlY3Rpb24gPSBGcy5MRUZULCB2LnB1c2goQSkpLCBgdHJhbnNsYXRlKCR7UH0sICR7Qn0pYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7QS54UG9zaXRpb259LCAke0EueVBvc2l0aW9ufSlgO1xuICAgIH0pLCB0aGlzLnJlbmRlckNhbGxvdXRzKHYpO1xuICAgIGNvbnN0IHggPSB5KGksIFwiZG9udXRcIikgPyBcImRvbnV0XCIgOiBcInBpZVwiLCBfID0geShpLCB4LCBcImFsaWdubWVudFwiKSwgeyB3aWR0aDogRSB9ID0gTi5nZXRTVkdFbGVtZW50U2l6ZSh0aGlzLmdldFBhcmVudCgpLCB7XG4gICAgICB1c2VBdHRyczogITBcbiAgICB9KSwgYiA9IHAgPyBNdC54T2Zmc2V0IDogMCwgUyA9IHAgPyBNdC55T2Zmc2V0IDogMDtcbiAgICBsZXQgTSA9IGwgKyBiO1xuICAgIF8gPT09IGp0LkNFTlRFUiA/IE0gPSBFIC8gMiA6IF8gPT09IGp0LlJJR0hUICYmIChNID0gRSAtIGwgLSBNdC54T2Zmc2V0KTtcbiAgICBsZXQgRCA9IGwgKyBTO1xuICAgIHYubGVuZ3RoID4gMCAmJiAoRCArPSBNdC55T2Zmc2V0Q2FsbG91dCksIHIuYXR0cihcInhcIiwgTSArIDcpLmF0dHIoXCJ5XCIsIEQpLCB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgcmVuZGVyQ2FsbG91dHModCkge1xuICAgIGNvbnN0IG4gPSBOLmFwcGVuZE9yU2VsZWN0KHRoaXMuZ2V0Q29tcG9uZW50Q29udGFpbmVyKCksIFwiZy5jYWxsb3V0c1wiKS5hdHRyKFwicm9sZVwiLCBodC5HUk9VUCkuYXR0cihcImRhdGEtbmFtZVwiLCBcImNhbGxvdXRzXCIpLCByID0gbi5zZWxlY3RBbGwoXCJnLmNhbGxvdXRcIikuZGF0YSh0KTtcbiAgICByLmV4aXQoKS5yZW1vdmUoKTtcbiAgICBjb25zdCBpID0gci5lbnRlcigpLmFwcGVuZChcImdcIikuY2xhc3NlZChcImNhbGxvdXRcIiwgITApLmF0dHIoXCJyb2xlXCIsIGh0LkdST1VQKS5hdHRyKFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIiwgXCJsYWJlbCBjYWxsb3V0XCIpO1xuICAgIGkubWVyZ2UocikuZGF0dW0oZnVuY3Rpb24ocykge1xuICAgICAgY29uc3QgeyB4UG9zaXRpb246IGEsIHlQb3NpdGlvbjogbywgZGlyZWN0aW9uOiBsIH0gPSBzO1xuICAgICAgcmV0dXJuIGwgPT09IEZzLlJJR0hUID8gKHMuc3RhcnRQb3MgPSB7XG4gICAgICAgIHg6IGEsXG4gICAgICAgIHk6IG8gKyBzLnRleHRPZmZzZXRZXG4gICAgICB9LCBzLmVuZFBvcyA9IHtcbiAgICAgICAgeDogYSArIE10LmNhbGxvdXQub2Zmc2V0WCxcbiAgICAgICAgeTogbyAtIE10LmNhbGxvdXQub2Zmc2V0WSArIHMudGV4dE9mZnNldFlcbiAgICAgIH0sIHMuaW50ZXJzZWN0UG9pbnRYID0gcy5lbmRQb3MueCAtIE10LmNhbGxvdXQuaG9yaXpvbnRhbExpbmVMZW5ndGgpIDogKHMuc3RhcnRQb3MgPSB7XG4gICAgICAgIHg6IGEsXG4gICAgICAgIHk6IG8gKyBzLnRleHRPZmZzZXRZXG4gICAgICB9LCBzLmVuZFBvcyA9IHtcbiAgICAgICAgeDogYSAtIE10LmNhbGxvdXQub2Zmc2V0WCxcbiAgICAgICAgeTogbyAtIE10LmNhbGxvdXQub2Zmc2V0WSArIHMudGV4dE9mZnNldFlcbiAgICAgIH0sIHMuaW50ZXJzZWN0UG9pbnRYID0gcy5lbmRQb3MueCArIE10LmNhbGxvdXQuaG9yaXpvbnRhbExpbmVMZW5ndGgpLCBzO1xuICAgIH0pLCBpLmFwcGVuZChcImxpbmVcIikuY2xhc3NlZChcInZlcnRpY2FsLWxpbmVcIiwgITApLm1lcmdlKG4uc2VsZWN0QWxsKFwibGluZS52ZXJ0aWNhbC1saW5lXCIpKS5kYXR1bShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJKHRoaXMucGFyZW50Tm9kZSkuZGF0dW0oKTtcbiAgICB9KS5zdHlsZShcInN0cm9rZS13aWR0aFwiLCBcIjFweFwiKS5hdHRyKFwieDFcIiwgKHMpID0+IHMuc3RhcnRQb3MueCkuYXR0cihcInkxXCIsIChzKSA9PiBzLnN0YXJ0UG9zLnkpLmF0dHIoXCJ4MlwiLCAocykgPT4gcy5pbnRlcnNlY3RQb2ludFgpLmF0dHIoXCJ5MlwiLCAocykgPT4gcy5lbmRQb3MueSksIGkuYXBwZW5kKFwibGluZVwiKS5jbGFzc2VkKFwiaG9yaXpvbnRhbC1saW5lXCIsICEwKS5tZXJnZShuLnNlbGVjdEFsbChcImxpbmUuaG9yaXpvbnRhbC1saW5lXCIpKS5kYXR1bShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJKHRoaXMucGFyZW50Tm9kZSkuZGF0dW0oKTtcbiAgICB9KS5zdHlsZShcInN0cm9rZS13aWR0aFwiLCBcIjFweFwiKS5hdHRyKFwieDFcIiwgKHMpID0+IHMuaW50ZXJzZWN0UG9pbnRYKS5hdHRyKFwieTFcIiwgKHMpID0+IHMuZW5kUG9zLnkpLmF0dHIoXCJ4MlwiLCAocykgPT4gcy5lbmRQb3MueCkuYXR0cihcInkyXCIsIChzKSA9PiBzLmVuZFBvcy55KTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICBjb25zdCB0ID0gdGhpcztcbiAgICB0aGlzLnBhcmVudC5zZWxlY3RBbGwoXCJwYXRoLnNsaWNlXCIpLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKG4sIHIpIHtcbiAgICAgIGNvbnN0IGkgPSBJKHRoaXMpO1xuICAgICAgdC5pc1JlbmRlcmluZyB8fCBpLmNsYXNzZWQoXCJob3ZlcmVkXCIsICEwKS50cmFuc2l0aW9uKFwicGllX3NsaWNlX21vdXNlb3ZlclwiKS5jYWxsKFxuICAgICAgICAobykgPT4gdC5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICAgIHRyYW5zaXRpb246IG8sXG4gICAgICAgICAgbmFtZTogXCJwaWVfc2xpY2VfbW91c2VvdmVyXCJcbiAgICAgICAgfSlcbiAgICAgICkuYXR0cihcImRcIiwgdC5ob3ZlckFyYyksIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5QaWUuU0xJQ0VfTU9VU0VPVkVSLCB7XG4gICAgICAgIGV2ZW50OiBuLFxuICAgICAgICBlbGVtZW50OiBJKHRoaXMpLFxuICAgICAgICBkYXR1bTogclxuICAgICAgfSk7XG4gICAgICBjb25zdCB7IGdyb3VwTWFwc1RvOiBzIH0gPSB0LmdldE9wdGlvbnMoKS5kYXRhLCB7IHZhbHVlTWFwc1RvOiBhIH0gPSB0LmdldE9wdGlvbnMoKS5waWU7XG4gICAgICB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5TSE9XLCB7XG4gICAgICAgIGV2ZW50OiBuLFxuICAgICAgICBob3ZlcmVkRWxlbWVudDogaSxcbiAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogci5kYXRhW3NdLFxuICAgICAgICAgICAgdmFsdWU6IHIuZGF0YVthXVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgfSkub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24obiwgcikge1xuICAgICAgY29uc3QgaSA9IEkodGhpcyk7XG4gICAgICB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuUGllLlNMSUNFX01PVVNFTU9WRSwge1xuICAgICAgICBldmVudDogbixcbiAgICAgICAgZWxlbWVudDogaSxcbiAgICAgICAgZGF0dW06IHJcbiAgICAgIH0pLCB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5NT1ZFLCB7XG4gICAgICAgIGV2ZW50OiBuXG4gICAgICB9KTtcbiAgICB9KS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKG4sIHIpIHtcbiAgICAgIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5QaWUuU0xJQ0VfQ0xJQ0ssIHtcbiAgICAgICAgZXZlbnQ6IG4sXG4gICAgICAgIGVsZW1lbnQ6IEkodGhpcyksXG4gICAgICAgIGRhdHVtOiByXG4gICAgICB9KTtcbiAgICB9KS5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKG4sIHIpIHtcbiAgICAgIGNvbnN0IGkgPSBJKHRoaXMpO1xuICAgICAgQUMoKCkgPT4ge1xuICAgICAgICB0LmlzUmVuZGVyaW5nIHx8IGkuY2xhc3NlZChcImhvdmVyZWRcIiwgITEpLnRyYW5zaXRpb24oXCJwaWVfc2xpY2VfbW91c2VvdXRcIikuY2FsbChcbiAgICAgICAgICAocykgPT4gdC5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICAgICAgdHJhbnNpdGlvbjogcyxcbiAgICAgICAgICAgIG5hbWU6IFwicGllX3NsaWNlX21vdXNlb3V0XCJcbiAgICAgICAgICB9KVxuICAgICAgICApLmF0dHIoXCJkXCIsIHQuYXJjKTtcbiAgICAgIH0sIDEwMCksIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5QaWUuU0xJQ0VfTU9VU0VPVVQsIHtcbiAgICAgICAgZXZlbnQ6IG4sXG4gICAgICAgIGVsZW1lbnQ6IGksXG4gICAgICAgIGRhdHVtOiByXG4gICAgICB9KSwgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuSElERSwge1xuICAgICAgICBob3ZlcmVkRWxlbWVudDogaVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLy8gSGVscGVyIGZ1bmN0aW9uc1xuICBjb21wdXRlUmFkaXVzKCkge1xuICAgIGNvbnN0IHsgd2lkdGg6IHQsIGhlaWdodDogbiB9ID0gTi5nZXRTVkdFbGVtZW50U2l6ZSh0aGlzLnBhcmVudCwge1xuICAgICAgdXNlQXR0cnM6ICEwXG4gICAgfSksIHIgPSB0aGlzLmdldE9wdGlvbnMoKSwgaSA9IE1hdGgubWluKHQsIG4pIC8gMjtcbiAgICByZXR1cm4gci5waWUubGFiZWxzLmVuYWJsZWQgPyBpICsgTXQucmFkaXVzT2Zmc2V0IDogaTtcbiAgfVxufVxuY2xhc3MgTkQgZXh0ZW5kcyBUdiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IFwiZG9udXRcIiwgdGhpcy5yZW5kZXJUeXBlID0gcnQuU1ZHO1xuICB9XG4gIHJlbmRlcih0ID0gITApIHtcbiAgICBzdXBlci5yZW5kZXIodCk7XG4gICAgY29uc3QgbiA9IHRoaXM7XG4gICAgaWYgKHRoaXMubW9kZWwuaXNEYXRhRW1wdHkoKSkge1xuICAgICAgdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoe1xuICAgICAgICBhcmlhTGFiZWw6IFwiZG9udXQgZ3JhcGhcIlxuICAgICAgfSkuc2VsZWN0KFwiZy5jZW50ZXJcIikucmVtb3ZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHIgPSBOLmFwcGVuZE9yU2VsZWN0KFxuICAgICAgdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoe1xuICAgICAgICBhcmlhTGFiZWw6IFwiZG9udXQgZ3JhcGhcIlxuICAgICAgfSksXG4gICAgICBcImcuY2VudGVyXCJcbiAgICApLCBpID0gdGhpcy5nZXRPcHRpb25zKCksIHMgPSB0aGlzLmNvbXB1dGVSYWRpdXMoKSwgYSA9IHkoaSwgXCJkb251dFwiLCBcImNlbnRlclwiLCBcImxhYmVsXCIpO1xuICAgIE4uYXBwZW5kT3JTZWxlY3QociwgXCJ0ZXh0LmRvbnV0LWZpZ3VyZVwiKS5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikuc3R5bGUoXCJkb21pbmFudC1iYXNlbGluZVwiLCAoKSA9PiBhID09PSBudWxsIHx8IGEgPT09IFwiXCIgPyBcImNlbnRyYWxcIiA6IFwiaW5pdGlhbFwiKS5zdHlsZShcImZvbnQtc2l6ZVwiLCAoKSA9PiBpLmRvbnV0LmNlbnRlci5udW1iZXJGb250U2l6ZShzKSkudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAobykgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICB0cmFuc2l0aW9uOiBvLFxuICAgICAgICBuYW1lOiBcImRvbnV0LWZpZ3VyZS1lbnRlci11cGRhdGVcIixcbiAgICAgICAgYW5pbWF0ZTogdFxuICAgICAgfSlcbiAgICApLnR3ZWVuKFwidGV4dFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuLmNlbnRlck51bWJlclR3ZWVuKEkodGhpcykpO1xuICAgIH0pLCBhICE9PSBudWxsICYmIGEgIT09IFwiXCIgJiYgTi5hcHBlbmRPclNlbGVjdChyLCBcInRleHQuZG9udXQtdGl0bGVcIikuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpLnN0eWxlKFwiZm9udC1zaXplXCIsICgpID0+IGkuZG9udXQuY2VudGVyLnRpdGxlRm9udFNpemUocykpLmF0dHIoXCJ5XCIsIGkuZG9udXQuY2VudGVyLnRpdGxlWVBvc2l0aW9uKHMpKS50ZXh0KGEpO1xuICB9XG4gIGdldElubmVyUmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbXB1dGVSYWRpdXMoKSAqICgzIC8gNCk7XG4gIH1cbiAgY2VudGVyTnVtYmVyVHdlZW4odCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICBsZXQgciA9IHkobiwgXCJkb251dFwiLCBcImNlbnRlclwiLCBcIm51bWJlclwiKTtcbiAgICByID09PSBudWxsICYmIChyID0gdGhpcy5tb2RlbC5nZXREaXNwbGF5RGF0YSgpLnJlZHVjZSgobywgbCkgPT4gbyArIGxbbi5waWUudmFsdWVNYXBzVG9dLCAwKSk7XG4gICAgY29uc3QgaSA9IHBhcnNlSW50KHQudGV4dCgpLnJlcGxhY2UoL1ssIF0rL2csIFwiXCIpLCAxMCkgfHwgMDtcbiAgICBsZXQgcztcbiAgICBpICUgMSA9PT0gMCAmJiByICUgMSA9PT0gMCA/IHMgPSBobSA6IHMgPSB4ZTtcbiAgICBjb25zdCBhID0gcyhpLCByKTtcbiAgICByZXR1cm4gKG8pID0+IHtcbiAgICAgIGNvbnN0IHsgbnVtYmVyRm9ybWF0dGVyOiBsIH0gPSBuLmRvbnV0LmNlbnRlcjtcbiAgICAgIGlmIChsKVxuICAgICAgICB0LnRleHQobChhKG8pKSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBjb2RlOiBjLCBudW1iZXI6IHUgfSA9IHkobiwgXCJsb2NhbGVcIik7XG4gICAgICAgIHQudGV4dCh1KE1hdGguZmxvb3IoYShvKSksIGMpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5jb25zdCBtcCA9IFwiNCwxMCA4LDYgMTIsMTBcIiwgZ3AgPSBcIjEyLDYgOCwxMCA0LDZcIjtcbmNsYXNzIFBEIGV4dGVuZHMgbXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnR5cGUgPSBcImdhdWdlXCIsIHRoaXMucmVuZGVyVHlwZSA9IHJ0LlNWRztcbiAgfVxuICBnZXRWYWx1ZSgpIHtcbiAgICB2YXIgdDtcbiAgICByZXR1cm4gKCh0ID0gdGhpcy5tb2RlbC5nZXREYXRhKCkuZmluZCgobikgPT4gbi5ncm91cCA9PT0gXCJ2YWx1ZVwiKSkgPT0gbnVsbCA/IHZvaWQgMCA6IHQudmFsdWUpID8/IG51bGw7XG4gIH1cbiAgZ2V0VmFsdWVSYXRpbygpIHtcbiAgICByZXR1cm4gTWcodGhpcy5nZXRWYWx1ZSgpLCAwLCAxMDApIC8gMTAwO1xuICB9XG4gIGdldERlbHRhKCkge1xuICAgIHZhciB0O1xuICAgIHJldHVybiAoKHQgPSB0aGlzLm1vZGVsLmdldERhdGEoKS5maW5kKChuKSA9PiBuLmdyb3VwID09PSBcImRlbHRhXCIpKSA9PSBudWxsID8gdm9pZCAwIDogdC52YWx1ZSkgPz8gbnVsbDtcbiAgfVxuICBnZXRBcmNSYXRpbygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgcmV0dXJuIHkodCwgXCJnYXVnZVwiLCBcInR5cGVcIikgPT09IFJyLkZVTEwgPyAxIDogMC41O1xuICB9XG4gIGdldEFyY1NpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXJjUmF0aW8oKSAqIE1hdGguUEkgKiAyO1xuICB9XG4gIGdldFN0YXJ0QW5nbGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0QXJjU2l6ZSgpO1xuICAgIHJldHVybiB0ID09PSAyICogTWF0aC5QSSA/IDAgOiAtdCAvIDI7XG4gIH1cbiAgLy8gdXNlIHByb3ZpZGVkIGFycm93IGRpcmVjdGlvbiBvciBkZWZhdWx0IHRvIHVzaW5nIHRoZSBkZWx0YVxuICBnZXRBcnJvdyh0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgIHN3aXRjaCAoeShuLCBcImdhdWdlXCIsIFwiZGVsdGFBcnJvd1wiLCBcImRpcmVjdGlvblwiKSkge1xuICAgICAgY2FzZSBwbC5VUDpcbiAgICAgICAgcmV0dXJuIG1wO1xuICAgICAgY2FzZSBwbC5ET1dOOlxuICAgICAgICByZXR1cm4gZ3A7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdCA+IDAgPyBtcCA6IGdwO1xuICAgIH1cbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gIC8vIEB0cy1pZ25vcmVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICByZW5kZXIodCA9ICEwKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0Q29tcG9uZW50Q29udGFpbmVyKHtcbiAgICAgIGFyaWFMYWJlbDogXCJnYXVnZSBncmFwaFwiXG4gICAgfSkuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKS5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKSwgciA9IHRoaXMuZ2V0T3B0aW9ucygpLCBpID0gdGhpcy5nZXRWYWx1ZSgpLCBzID0gdGhpcy5nZXRWYWx1ZVJhdGlvKCksIGEgPSB0aGlzLmdldEFyY1NpemUoKSwgbyA9IHRoaXMuZ2V0U3RhcnRBbmdsZSgpLCBsID0gcyAqIGEsIGMgPSBvICsgbCwgdSA9IG8gKyBhLCBkID0gdGhpcy5jb21wdXRlUmFkaXVzKCksIGggPSB0aGlzLmdldElubmVyUmFkaXVzKCk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kQXJjID0gYXMoKS5pbm5lclJhZGl1cyhoKS5vdXRlclJhZGl1cyhkKS5zdGFydEFuZ2xlKGMpLmVuZEFuZ2xlKHUpLCB0aGlzLmFyYyA9IGFzKCkuaW5uZXJSYWRpdXMoaCkub3V0ZXJSYWRpdXMoZCkuc3RhcnRBbmdsZShvKS5lbmRBbmdsZShjKSwgTi5hcHBlbmRPclNlbGVjdChuLCBcInBhdGguYXJjLWJhY2tncm91bmRcIikuYXR0cihcImRcIiwgdGhpcy5iYWNrZ3JvdW5kQXJjKTtcbiAgICBjb25zdCBwID0gbi5zZWxlY3RBbGwoXCJwYXRoLmFyYy1mb3JlZ3JvdW5kXCIpLmRhdGEoW2ldKTtcbiAgICBwLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKS5tZXJnZShwKS5hdHRyKFxuICAgICAgXCJjbGFzc1wiLFxuICAgICAgdGhpcy5tb2RlbC5nZXRDb2xvckNsYXNzTmFtZSh7XG4gICAgICAgIGNsYXNzTmFtZVR5cGVzOiBbaXQuRklMTF0sXG4gICAgICAgIGRhdGFHcm91cE5hbWU6IFwidmFsdWVcIixcbiAgICAgICAgb3JpZ2luYWxDbGFzc05hbWU6IFwiYXJjLWZvcmVncm91bmRcIlxuICAgICAgfSlcbiAgICApLnN0eWxlKFwiZmlsbFwiLCAoKSA9PiB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcImNvbG9yXCIsIFwic2NhbGVcIiwgXCJ2YWx1ZVwiKSkuYXR0cihcImRcIiwgdGhpcy5hcmMpLmF0dHIoXCJyb2xlXCIsIGh0LkdSQVBISUNTX1NZTUJPTCkuYXR0cihcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCIsIFwidmFsdWVcIikuYXR0cihcImFyaWEtbGFiZWxcIiwgKHYpID0+IHYpLCB0aGlzLmRyYXdWYWx1ZU51bWJlcigpLCB0aGlzLmRyYXdEZWx0YSgpLCBwLmV4aXQoKS5yZW1vdmUoKTtcbiAgICBjb25zdCBmID0geShyLCBcImdhdWdlXCIsIFwiYWxpZ25tZW50XCIpLCB7IHdpZHRoOiBnIH0gPSBOLmdldFNWR0VsZW1lbnRTaXplKHRoaXMuZ2V0UGFyZW50KCksIHtcbiAgICAgIHVzZUF0dHJzOiAhMFxuICAgIH0pO1xuICAgIGxldCBtID0gZDtcbiAgICBmID09PSBqdC5DRU5URVIgPyBtID0gZyAvIDIgOiBmID09PSBqdC5SSUdIVCAmJiAobSA9IGcgLSBkKSwgbi5hdHRyKFwieFwiLCBtKS5hdHRyKFwieVwiLCBkKSwgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICB9XG4gIC8qKlxuICAgKiBkcmF3cyB0aGUgdmFsdWUgbnVtYmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgR2F1Z2UgY29tcG9uZW50IGluIHRoZSBjZW50ZXJcbiAgICovXG4gIGRyYXdWYWx1ZU51bWJlcigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoKSwgbiA9IHRoaXMuZ2V0T3B0aW9ucygpLCByID0geShuLCBcImdhdWdlXCIsIFwidHlwZVwiKSwgaSA9IHRoaXMuZ2V0VmFsdWUoKSwgcyA9IHRoaXMuZ2V0RGVsdGEoKSwgYSA9IHRoaXMuY29tcHV0ZVJhZGl1cygpLCBvID0geShuLCBcImdhdWdlXCIsIFwidmFsdWVGb250U2l6ZVwiKSwgbCA9IHkobiwgXCJnYXVnZVwiLCBcImRlbHRhRm9udFNpemVcIiksIGMgPSB5KG4sIFwiZ2F1Z2VcIiwgXCJudW1iZXJTcGFjaW5nXCIpLCB1ID0geShuLCBcImdhdWdlXCIsIFwic2hvd1BlcmNlbnRhZ2VTeW1ib2xcIik7XG4gICAgbGV0IGQgPSAwO1xuICAgIHIgPT09IFJyLkZVTEwgJiYgIXMgPyBkID0gbChhKSA6IHIgPT09IFJyLlNFTUkgJiYgcyAmJiAoZCA9IC0obChhKSArIGMpKTtcbiAgICBjb25zdCBoID0gTi5hcHBlbmRPclNlbGVjdCh0LCBcImcuZ2F1Z2UtbnVtYmVyc1wiKS5hdHRyKFxuICAgICAgXCJ0cmFuc2Zvcm1cIixcbiAgICAgIGB0cmFuc2xhdGUoMCwgJHtkfSlgXG4gICAgKSwgcCA9IG8oYSksIGYgPSBOLmFwcGVuZE9yU2VsZWN0KGgsIFwiZy5nYXVnZS12YWx1ZS1udW1iZXJcIiksIHsgY29kZTogZywgbnVtYmVyOiBtIH0gPSB5KG4sIFwibG9jYWxlXCIpLCB2ID0geShuLCBcImdhdWdlXCIsIFwibnVtYmVyRm9ybWF0dGVyXCIpLCB4ID0gZi5zZWxlY3RBbGwoXCJ0ZXh0LmdhdWdlLXZhbHVlLW51bWJlclwiKS5kYXRhKFtpXSk7XG4gICAgeC5lbnRlcigpLmFwcGVuZChcInRleHRcIikuYXR0cihcImNsYXNzXCIsIFwiZ2F1Z2UtdmFsdWUtbnVtYmVyXCIpLm1lcmdlKHgpLnN0eWxlKFwiZm9udC1zaXplXCIsIGAke3B9cHhgKS5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikudGV4dCgoQSkgPT4ge1xuICAgICAgbGV0IFI7XG4gICAgICByZXR1cm4gQSAhPSBudWxsID8gUiA9IE51bWJlcihBLnRvRml4ZWQoMikpICUgMSAhPT0gMCA/IEEudG9GaXhlZCgyKSA6IEEudG9GaXhlZCgpIDogUiA9IDAsIHYgPyB2KFIpIDogbShOdW1iZXIoUiksIGcpO1xuICAgIH0pO1xuICAgIGNvbnN0IHsgd2lkdGg6IF8gfSA9IE4uZ2V0U1ZHRWxlbWVudFNpemUoXG4gICAgICBOLmFwcGVuZE9yU2VsZWN0KHQsIFwidGV4dC5nYXVnZS12YWx1ZS1udW1iZXJcIiksXG4gICAgICB7IHVzZUJCb3g6ICEwIH1cbiAgICApLCBFID0gcCAvIDIsIGIgPSB1ID8gXCIlXCIgOiBcIlwiLCBTID0gTi5hcHBlbmRPclNlbGVjdChmLCBcInRleHQuZ2F1Z2UtdmFsdWUtc3ltYm9sXCIpLnN0eWxlKFwiZm9udC1zaXplXCIsIGAke0V9cHhgKS5hdHRyKFwieFwiLCBfIC8gMikudGV4dChiKSwgeyB3aWR0aDogTSwgaGVpZ2h0OiBEIH0gPSBOLmdldFNWR0VsZW1lbnRTaXplKFMsIHtcbiAgICAgIHVzZUJCb3g6ICEwXG4gICAgfSk7XG4gICAgUy5hdHRyKFwieVwiLCBgLSR7RCAvIDJ9cHhgKSwgZi5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoLSR7TSAvIDJ9LCAwKWApO1xuICB9XG4gIC8qKlxuICAgKiBhZGRzIHRoZSBkZWx0YSBudW1iZXIgZm9yIHRoZSBnYXVnZVxuICAgKi9cbiAgZHJhd0RlbHRhKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLCBuID0gdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoKSwgciA9IHRoaXMuZ2V0T3B0aW9ucygpLCBpID0gdGhpcy5nZXREZWx0YSgpLCB7IGNvZGU6IHMsIG51bWJlcjogYSB9ID0geShyLCBcImxvY2FsZVwiKTtcbiAgICBpZiAoaSkge1xuICAgICAgY29uc3QgbyA9IHRoaXMuY29tcHV0ZVJhZGl1cygpLCBsID0gaSA/IHkociwgXCJnYXVnZVwiLCBcImRlbHRhRm9udFNpemVcIikgOiAoKSA9PiAwLCBjID0gaSA/IHkociwgXCJnYXVnZVwiLCBcIm51bWJlckZvcm1hdHRlclwiKSA6ICgpID0+IG51bGwsIHUgPSB5KHIsIFwiZ2F1Z2VcIiwgXCJkZWx0YUFycm93XCIsIFwic2l6ZVwiKSwgZCA9IHkociwgXCJnYXVnZVwiLCBcIm51bWJlclNwYWNpbmdcIiksIGggPSB5KHIsIFwiZ2F1Z2VcIiwgXCJzaG93UGVyY2VudGFnZVN5bWJvbFwiKSwgcCA9IE4uYXBwZW5kT3JTZWxlY3QobiwgXCJnLmdhdWdlLW51bWJlcnNcIiksIGYgPSBOLmFwcGVuZE9yU2VsZWN0KHAsIFwiZy5nYXVnZS1kZWx0YVwiKS5hdHRyKFxuICAgICAgICBcInRyYW5zZm9ybVwiLFxuICAgICAgICBgdHJhbnNsYXRlKDAsICR7bChvKSArIGR9KWBcbiAgICAgICksIGcgPSBOLmFwcGVuZE9yU2VsZWN0KGYsIFwidGV4dC5nYXVnZS1kZWx0YS1udW1iZXJcIiksIG0gPSBoID8gXCIlXCIgOiBcIlwiO1xuICAgICAgZy5kYXRhKGkgPT09IG51bGwgPyBbXSA6IFtpXSksIGcuZW50ZXIoKS5hcHBlbmQoXCJ0ZXh0XCIpLmNsYXNzZWQoXCJnYXVnZS1kZWx0YS1udW1iZXJcIiwgITApLm1lcmdlKGcpLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKS5zdHlsZShcImZvbnQtc2l6ZVwiLCBgJHtsKG8pfXB4YCkudGV4dCgoRSkgPT4ge1xuICAgICAgICBsZXQgYjtcbiAgICAgICAgcmV0dXJuIEUgIT0gbnVsbCA/IGIgPSBOdW1iZXIoRS50b0ZpeGVkKDIpKSAlIDEgIT09IDAgPyBFLnRvRml4ZWQoMikgOiBFLnRvRml4ZWQoKSA6IGIgPSAwLCBjID8gYCR7YyhiKX0ke219YCA6IGAke2EoTnVtYmVyKGIpLCBzKX0ke219YDtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgeyB3aWR0aDogdiB9ID0gTi5nZXRTVkdFbGVtZW50U2l6ZShcbiAgICAgICAgTi5hcHBlbmRPclNlbGVjdChuLCBcIi5nYXVnZS1kZWx0YS1udW1iZXJcIiksXG4gICAgICAgIHsgdXNlQkJveDogITAgfVxuICAgICAgKSwgeCA9IHkociwgXCJnYXVnZVwiLCBcImRlbHRhQXJyb3dcIiwgXCJlbmFibGVkXCIpLCBfID0gZi5zZWxlY3RBbGwoXCJzdmcuZ2F1Z2UtZGVsdGEtYXJyb3dcIikuZGF0YShpICE9PSBudWxsICYmIHggPyBbaV0gOiBbXSk7XG4gICAgICBfLmVudGVyKCkuYXBwZW5kKFwic3ZnXCIpLm1lcmdlKF8pLmF0dHIoXCJjbGFzc1wiLCBcImdhdWdlLWRlbHRhLWFycm93XCIpLmF0dHIoXCJ4XCIsIC11KG8pIC0gdiAvIDIpLmF0dHIoXCJ5XCIsIC11KG8pIC8gMiAtIGwobykgKiAwLjM1KS5hdHRyKFwid2lkdGhcIiwgdShvKSkuYXR0cihcImhlaWdodFwiLCB1KG8pKS5hdHRyKFwidmlld0JveFwiLCBcIjAgMCAxNiAxNlwiKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBFID0gSSh0aGlzKTtcbiAgICAgICAgTi5hcHBlbmRPclNlbGVjdChFLCBcInJlY3QuZ2F1Z2UtZGVsdGEtYXJyb3ctYmFja2Ryb3BcIikuYXR0cihcIndpZHRoXCIsIFwiMTZcIikuYXR0cihcImhlaWdodFwiLCBcIjE2XCIpLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgY29uc3QgYiA9IHkociwgXCJnYXVnZVwiLCBcInN0YXR1c1wiKTtcbiAgICAgICAgTi5hcHBlbmRPclNlbGVjdChFLCBcInBvbHlnb24uZ2F1Z2UtZGVsdGEtYXJyb3dcIikuYXR0cihcImNsYXNzXCIsIGIgIT09IG51bGwgPyBgZ2F1Z2UtZGVsdGEtYXJyb3cgc3RhdHVzLS0ke2J9YCA6IFwiXCIpLmF0dHIoXCJwb2ludHNcIiwgdC5nZXRBcnJvdyhpKSk7XG4gICAgICB9KSwgXy5leGl0KCkucmVtb3ZlKCksIGcuZXhpdCgpLnJlbW92ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvID0gbi5zZWxlY3QoXCJnLmdhdWdlLWRlbHRhXCIpO1xuICAgICAgby5lbXB0eSgpIHx8IG8ucmVtb3ZlKCk7XG4gICAgfVxuICB9XG4gIGdldElubmVyUmFkaXVzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmNvbXB1dGVSYWRpdXMoKSwgbiA9IHkodGhpcy5nZXRPcHRpb25zKCksIFwiZ2F1Z2VcIiwgXCJhcmNXaWR0aFwiKTtcbiAgICByZXR1cm4gdCAtIG47XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXM7XG4gICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwicGF0aC5hcmMtZm9yZWdyb3VuZFwiKS5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbihuLCByKSB7XG4gICAgICB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuR2F1Z2UuQVJDX01PVVNFT1ZFUiwge1xuICAgICAgICBldmVudDogbixcbiAgICAgICAgZWxlbWVudDogSSh0aGlzKSxcbiAgICAgICAgZGF0dW06IHJcbiAgICAgIH0pO1xuICAgIH0pLm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKG4sIHIpIHtcbiAgICAgIGNvbnN0IGkgPSBJKHRoaXMpO1xuICAgICAgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkdhdWdlLkFSQ19NT1VTRU1PVkUsIHtcbiAgICAgICAgZXZlbnQ6IG4sXG4gICAgICAgIGVsZW1lbnQ6IGksXG4gICAgICAgIGRhdHVtOiByXG4gICAgICB9KTtcbiAgICB9KS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKG4sIHIpIHtcbiAgICAgIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5HYXVnZS5BUkNfQ0xJQ0ssIHtcbiAgICAgICAgZXZlbnQ6IG4sXG4gICAgICAgIGVsZW1lbnQ6IEkodGhpcyksXG4gICAgICAgIGRhdHVtOiByXG4gICAgICB9KTtcbiAgICB9KS5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKG4sIHIpIHtcbiAgICAgIGNvbnN0IGkgPSBJKHRoaXMpO1xuICAgICAgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkdhdWdlLkFSQ19NT1VTRU9VVCwge1xuICAgICAgICBldmVudDogbixcbiAgICAgICAgZWxlbWVudDogaSxcbiAgICAgICAgZGF0dW06IHJcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8vIEhlbHBlciBmdW5jdGlvbnNcbiAgY29tcHV0ZVJhZGl1cygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRPcHRpb25zKCksIG4gPSB5KHQsIFwiZ2F1Z2VcIiwgXCJ0eXBlXCIpLCB7IHdpZHRoOiByLCBoZWlnaHQ6IGkgfSA9IE4uZ2V0U1ZHRWxlbWVudFNpemUodGhpcy5wYXJlbnQsIHtcbiAgICAgIHVzZUF0dHJzOiAhMFxuICAgIH0pO1xuICAgIHJldHVybiBuID09PSBSci5TRU1JID8gTWF0aC5taW4ociAvIDIsIGkpIDogTWF0aC5taW4ociAvIDIsIGkgLyAyKTtcbiAgfVxufVxuY2xhc3Mgd3YgZXh0ZW5kcyBodSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IFwiZ3JvdXBlZC1iYXJcIiwgdGhpcy5yZW5kZXJUeXBlID0gcnQuU1ZHLCB0aGlzLnBhZGRpbmcgPSA1LCB0aGlzLmRlZmF1bHRTdGVwRmFjdG9yID0gNzAsIHRoaXMuaGFuZGxlTGVnZW5kT25Ib3ZlciA9ICh0KSA9PiB7XG4gICAgICBjb25zdCB7IGhvdmVyZWRFbGVtZW50OiBuIH0gPSB0LmRldGFpbCwgeyBncm91cE1hcHNUbzogciB9ID0gdGhpcy5nZXRPcHRpb25zKCkuZGF0YTtcbiAgICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcInBhdGguYmFyXCIpLnRyYW5zaXRpb24oXCJsZWdlbmQtaG92ZXItYmFyXCIpLmNhbGwoXG4gICAgICAgIChpKSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgdHJhbnNpdGlvbjogaSxcbiAgICAgICAgICBuYW1lOiBcImxlZ2VuZC1ob3Zlci1iYXJcIlxuICAgICAgICB9KVxuICAgICAgKS5hdHRyKFwib3BhY2l0eVwiLCAoaSkgPT4gaVtyXSAhPT0gbi5kYXR1bSgpLm5hbWUgPyAwLjMgOiAxKTtcbiAgICB9LCB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlT3V0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwicGF0aC5iYXJcIikudHJhbnNpdGlvbihcImxlZ2VuZC1tb3VzZW91dC1iYXJcIikuY2FsbChcbiAgICAgICAgKHQpID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICB0cmFuc2l0aW9uOiB0LFxuICAgICAgICAgIG5hbWU6IFwibGVnZW5kLW1vdXNlb3V0LWJhclwiXG4gICAgICAgIH0pXG4gICAgICApLmF0dHIoXCJvcGFjaXR5XCIsIDEpO1xuICAgIH07XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5zZXJ2aWNlcy5ldmVudHM7XG4gICAgdC5hZGRFdmVudExpc3RlbmVyKFQuTGVnZW5kLklURU1fSE9WRVIsIHRoaXMuaGFuZGxlTGVnZW5kT25Ib3ZlciksIHQuYWRkRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX01PVVNFT1VULCB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlT3V0KTtcbiAgfVxuICByZW5kZXIodCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLm1vZGVsLmdldERpc3BsYXlEYXRhKHRoaXMuY29uZmlncy5ncm91cHMpLCByID0gdGhpcy5nZXRPcHRpb25zKCksIHsgZ3JvdXBNYXBzVG86IGkgfSA9IHIuZGF0YTtcbiAgICB0aGlzLnNldEdyb3VwU2NhbGUoKTtcbiAgICBjb25zdCBzID0gdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoeyBhcmlhTGFiZWw6IFwiZ3JvdXBlZCBiYXIgZ3JhcGhzXCIsIHdpdGhpbkNoYXJ0Q2xpcDogITAgfSksIGEgPSBaaShcbiAgICAgIG4ubWFwKCh1KSA9PiB7XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXREb21haW5JZGVudGlmaWVyKHUpO1xuICAgICAgICByZXR1cm4gdVtkXSAmJiB0eXBlb2YgdVtkXS50b1N0cmluZyA9PSBcImZ1bmN0aW9uXCIgPyB1W2RdLnRvU3RyaW5nKCkgOiB1W2RdO1xuICAgICAgfSlcbiAgICApLCBvID0gcy5zZWxlY3RBbGwoXCJnLmJhcnNcIikuZGF0YShhLCAodSkgPT4gdSk7XG4gICAgby5leGl0KCkuYXR0cihcIm9wYWNpdHlcIiwgMCkucmVtb3ZlKCk7XG4gICAgY29uc3QgbCA9IG8uZW50ZXIoKS5hcHBlbmQoXCJnXCIpLmNsYXNzZWQoXCJiYXJzXCIsICEwKS5hdHRyKFwicm9sZVwiLCBodC5HUk9VUCkuYXR0cihcImRhdGEtbmFtZVwiLCBcImJhcnNcIikubWVyZ2Uobyk7XG4gICAgbC50cmFuc2l0aW9uKCkuY2FsbChcbiAgICAgICh1KSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgIHRyYW5zaXRpb246IHUsXG4gICAgICAgIG5hbWU6IFwiYmFyLWdyb3VwLXVwZGF0ZS1lbnRlclwiLFxuICAgICAgICBhbmltYXRlOiB0XG4gICAgICB9KVxuICAgICkuYXR0cihcInRyYW5zZm9ybVwiLCAodSkgPT4ge1xuICAgICAgY29uc3QgZCA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpblZhbHVlKHUpIC0gdGhpcy5nZXRHcm91cFdpZHRoKCkgLyAyO1xuICAgICAgcmV0dXJuIHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldE9yaWVudGF0aW9uKCkgPT09IEZ0LlZFUlRJQ0FMID8gYHRyYW5zbGF0ZSgke2R9LCAwKWAgOiBgdHJhbnNsYXRlKDAsICR7ZH0pYDtcbiAgICB9KTtcbiAgICBjb25zdCBjID0gbC5zZWxlY3RBbGwoXCJwYXRoLmJhclwiKS5kYXRhKFxuICAgICAgKHUpID0+IHRoaXMuZ2V0RGF0YUNvcnJlc3BvbmRpbmdUb0xhYmVsKHUpLFxuICAgICAgKHUpID0+IHVbaV1cbiAgICApO1xuICAgIGMuZXhpdCgpLmF0dHIoXCJvcGFjaXR5XCIsIDApLnJlbW92ZSgpLCBjLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwib3BhY2l0eVwiLCAwKS5tZXJnZShjKS5jbGFzc2VkKFwiYmFyXCIsICEwKS50cmFuc2l0aW9uKCkuY2FsbChcbiAgICAgICh1KSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgIHRyYW5zaXRpb246IHUsXG4gICAgICAgIG5hbWU6IFwiYmFyLXVwZGF0ZS1lbnRlclwiLFxuICAgICAgICBhbmltYXRlOiB0XG4gICAgICB9KVxuICAgICkuYXR0cihcbiAgICAgIFwiY2xhc3NcIixcbiAgICAgICh1KSA9PiB0aGlzLm1vZGVsLmdldENvbG9yQ2xhc3NOYW1lKHtcbiAgICAgICAgY2xhc3NOYW1lVHlwZXM6IFtpdC5GSUxMXSxcbiAgICAgICAgZGF0YUdyb3VwTmFtZTogdVtpXSxcbiAgICAgICAgb3JpZ2luYWxDbGFzc05hbWU6IFwiYmFyXCJcbiAgICAgIH0pXG4gICAgKS5zdHlsZShcImZpbGxcIiwgKHUpID0+IHtcbiAgICAgIGNvbnN0IGQgPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXREb21haW5JZGVudGlmaWVyKHUpO1xuICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZ2V0RmlsbENvbG9yKHVbaV0sIHVbZF0sIHUpO1xuICAgIH0pLmF0dHIoXCJkXCIsICh1KSA9PiB7XG4gICAgICBjb25zdCBkID0gdGhpcy5ncm91cFNjYWxlKHVbaV0pLCBoID0gdGhpcy5nZXRCYXJXaWR0aCgpLCBwID0gZCwgZiA9IGQgKyBoLCBnID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0UmFuZ2VBeGlzUG9zaXRpb24oeyBkYXR1bTogdSB9KSwgbSA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpbkxvd2VyQm91bmQoZyksIHYgPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRWYWx1ZVRocm91Z2hBeGlzUG9zaXRpb24oZywgbSksIHggPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRSYW5nZVZhbHVlKHUpLCBfID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0RG9tYWluVmFsdWUodSkgLSBoIC8gMiwgRSA9IF8gKyBoO1xuICAgICAgaWYgKCF0aGlzLmlzT3V0c2lkZVpvb21lZERvbWFpbihfLCBFKSlcbiAgICAgICAgcmV0dXJuIGFlKFxuICAgICAgICAgIHsgeDA6IHAsIHgxOiBmLCB5MDogdiwgeTE6IHggfSxcbiAgICAgICAgICB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRPcmllbnRhdGlvbigpXG4gICAgICAgICk7XG4gICAgfSkuYXR0cihcIm9wYWNpdHlcIiwgMSkuYXR0cihcInJvbGVcIiwgaHQuR1JBUEhJQ1NfU1lNQk9MKS5hdHRyKFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIiwgXCJiYXJcIikuYXR0cihcImFyaWEtbGFiZWxcIiwgKHUpID0+IHUudmFsdWUpLCB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXM7XG4gICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwicGF0aC5iYXJcIikub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24obiwgcikge1xuICAgICAgY29uc3QgaSA9IEkodGhpcyk7XG4gICAgICBpLmNsYXNzZWQoXCJob3ZlcmVkXCIsICEwKSwgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkJhci5CQVJfTU9VU0VPVkVSLCB7XG4gICAgICAgIGV2ZW50OiBuLFxuICAgICAgICBlbGVtZW50OiBpLFxuICAgICAgICBkYXR1bTogclxuICAgICAgfSksIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLlNIT1csIHtcbiAgICAgICAgZXZlbnQ6IG4sXG4gICAgICAgIGhvdmVyZWRFbGVtZW50OiBpLFxuICAgICAgICBkYXRhOiBbcl1cbiAgICAgIH0pO1xuICAgIH0pLm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKG4sIHIpIHtcbiAgICAgIGNvbnN0IGkgPSBJKHRoaXMpO1xuICAgICAgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkJhci5CQVJfTU9VU0VNT1ZFLCB7XG4gICAgICAgIGV2ZW50OiBuLFxuICAgICAgICBlbGVtZW50OiBpLFxuICAgICAgICBkYXR1bTogclxuICAgICAgfSksIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLk1PVkUsIHtcbiAgICAgICAgZXZlbnQ6IG5cbiAgICAgIH0pO1xuICAgIH0pLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24obiwgcikge1xuICAgICAgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkJhci5CQVJfQ0xJQ0ssIHtcbiAgICAgICAgZXZlbnQ6IG4sXG4gICAgICAgIGVsZW1lbnQ6IEkodGhpcyksXG4gICAgICAgIGRhdHVtOiByXG4gICAgICB9KTtcbiAgICB9KS5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKG4sIHIpIHtcbiAgICAgIGNvbnN0IGkgPSBJKHRoaXMpO1xuICAgICAgaS5jbGFzc2VkKFwiaG92ZXJlZFwiLCAhMSksIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5CYXIuQkFSX01PVVNFT1VULCB7XG4gICAgICAgIGV2ZW50OiBuLFxuICAgICAgICBlbGVtZW50OiBpLFxuICAgICAgICBkYXR1bTogclxuICAgICAgfSksIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLkhJREUsIHtcbiAgICAgICAgaG92ZXJlZEVsZW1lbnQ6IGlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwicGF0aC5iYXJcIikub24oXCJtb3VzZW92ZXJcIiwgbnVsbCkub24oXCJtb3VzZW1vdmVcIiwgbnVsbCkub24oXCJtb3VzZW91dFwiLCBudWxsKTtcbiAgICBjb25zdCB0ID0gdGhpcy5zZXJ2aWNlcy5ldmVudHM7XG4gICAgdC5yZW1vdmVFdmVudExpc3RlbmVyKFQuTGVnZW5kLklURU1fSE9WRVIsIHRoaXMuaGFuZGxlTGVnZW5kT25Ib3ZlciksIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX01PVVNFT1VULCB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlT3V0KTtcbiAgfVxuICBnZXREYXRhQ29ycmVzcG9uZGluZ1RvTGFiZWwodCkge1xuICAgIHJldHVybiB0aGlzLm1vZGVsLmdldERpc3BsYXlEYXRhKHRoaXMuY29uZmlncy5ncm91cHMpLmZpbHRlcigobikgPT4ge1xuICAgICAgY29uc3QgciA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpbklkZW50aWZpZXIobik7XG4gICAgICByZXR1cm4gbltyXS50b1N0cmluZygpID09PSB0O1xuICAgIH0pO1xuICB9XG4gIGdldEdyb3VwV2lkdGgoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMubW9kZWwuZ2V0R3JvdXBlZERhdGEodGhpcy5jb25maWdzLmdyb3VwcyksIG4gPSB0aGlzLmdldFRvdGFsR3JvdXBQYWRkaW5nKCk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QmFyV2lkdGgoKSAqIHQubGVuZ3RoICsgbjtcbiAgfVxuICBnZXREb21haW5TY2FsZVN0ZXAoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpblNjYWxlKCksIG4gPSB0aGlzLm1vZGVsLmdldEdyb3VwZWREYXRhKHRoaXMuY29uZmlncy5ncm91cHMpO1xuICAgIGxldCByID0gdGhpcy5kZWZhdWx0U3RlcEZhY3RvcjtcbiAgICBpZiAodHlwZW9mIHQuc3RlcCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gdC5zdGVwKCk7XG4gICAgZWxzZSBpZiAobi5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBpID0gbi5maW5kKChzKSA9PiB7XG4gICAgICAgIHZhciBhO1xuICAgICAgICByZXR1cm4gKChhID0gcy5kYXRhKSA9PSBudWxsID8gdm9pZCAwIDogYS5sZW5ndGgpID4gMTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGkpIHtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpbklkZW50aWZpZXIoaS5kYXRhWzBdKTtcbiAgICAgICAgciA9IE1hdGguYWJzKFxuICAgICAgICAgIHQoaS5kYXRhWzFdW3NdKSAtIHQoaS5kYXRhWzBdW3NdKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICBnZXRUb3RhbEdyb3VwUGFkZGluZygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5tb2RlbC5nZXRHcm91cGVkRGF0YSh0aGlzLmNvbmZpZ3MuZ3JvdXBzKTtcbiAgICByZXR1cm4gdC5sZW5ndGggPT09IDEgPyAwIDogTWF0aC5taW4oNSwgNSAqICh0aGlzLmdldERvbWFpblNjYWxlU3RlcCgpIC8gdGhpcy5kZWZhdWx0U3RlcEZhY3RvcikpICogKHQubGVuZ3RoIC0gMSk7XG4gIH1cbiAgLy8gR2V0cyB0aGUgY29ycmVjdCB3aWR0aCBmb3IgYmFycyBiYXNlZCBvbiBvcHRpb25zICYgY29uZmlndXJhdGlvbnNcbiAgZ2V0QmFyV2lkdGgoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0T3B0aW9ucygpLCBuID0geSh0LCBcImJhcnNcIiwgXCJ3aWR0aFwiKSwgciA9IHkodCwgXCJiYXJzXCIsIFwibWF4V2lkdGhcIik7XG4gICAgaWYgKG4gIT09IG51bGwgJiYgKHIgPT09IG51bGwgfHwgbiA8PSByKSlcbiAgICAgIHJldHVybiBuO1xuICAgIGNvbnN0IGkgPSB0aGlzLm1vZGVsLmdldEdyb3VwZWREYXRhKHRoaXMuY29uZmlncy5ncm91cHMpLmxlbmd0aCwgcyA9IHRoaXMuZ2V0VG90YWxHcm91cFBhZGRpbmcoKTtcbiAgICByZXR1cm4gTWF0aC5taW4oXG4gICAgICByLFxuICAgICAgKHRoaXMuZ2V0RG9tYWluU2NhbGVTdGVwKCkgLSBzKSAvIGlcbiAgICApO1xuICB9XG4gIHNldEdyb3VwU2NhbGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMubW9kZWwuZ2V0QWN0aXZlRGF0YUdyb3VwTmFtZXModGhpcy5jb25maWdzLmdyb3Vwcyk7XG4gICAgdGhpcy5ncm91cFNjYWxlID0gZ3MoKS5kb21haW4odCkucmFuZ2VSb3VuZChbMCwgdGhpcy5nZXRHcm91cFdpZHRoKCldKTtcbiAgfVxufVxuY2xhc3MgVUQgZXh0ZW5kcyBtdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IFwiaGVhdG1hcFwiLCB0aGlzLnJlbmRlclR5cGUgPSBydC5TVkcsIHRoaXMubWF0cml4ID0ge30sIHRoaXMueEJhbmR3aWR0aCA9IDAsIHRoaXMueUJhbmR3aWR0aCA9IDAsIHRoaXMudHJhbnNsYXRpb25Vbml0cyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSwgdGhpcy5oYW5kbGVBeGlzT25Ib3ZlciA9ICh0KSA9PiB7XG4gICAgICBjb25zdCB7IGRldGFpbDogbiB9ID0gdCwgeyBkYXR1bTogciB9ID0gbiwgaSA9IHRoaXMubW9kZWwuZ2V0VW5pcXVlUmFuZ2VzKCksIHMgPSB0aGlzLm1vZGVsLmdldFVuaXF1ZURvbWFpbigpLCBhID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0RG9tYWluTGFiZWwoKSwgbyA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlTGFiZWwoKSwgbCA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldE1haW5YU2NhbGUoKSwgYyA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldE1haW5ZU2NhbGUoKTtcbiAgICAgIGxldCB1ID0gXCJcIiwgZCA9IG51bGwsIGggPSBudWxsLCBwID0gbnVsbDtcbiAgICAgIHRoaXMubWF0cml4W3JdICE9PSB2b2lkIDAgPyAodSA9IGEsIGkuZm9yRWFjaCgoZikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubWF0cml4W3JdW2ZdLnZhbHVlID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBjb25zdCBnID0gdGhpcy5tYXRyaXhbcl1bZl0udmFsdWU7XG4gICAgICAgICAgaWYgKGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGQgPSBnLCBoID0gZywgcCA9IGc7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGQgKz0gZywgaCA9IGcgPCBoID8gZyA6IGgsIHAgPSBnID4gcCA/IGcgOiBwO1xuICAgICAgICB9XG4gICAgICB9KSkgOiAodSA9IG8sIHMuZm9yRWFjaCgoZikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubWF0cml4W2ZdW3JdLnZhbHVlID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBjb25zdCBnID0gdGhpcy5tYXRyaXhbZl1bcl0udmFsdWU7XG4gICAgICAgICAgaWYgKGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGQgPSBnLCBoID0gZywgcCA9IGc7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGQgKz0gZywgaCA9IGcgPCBoID8gZyA6IGgsIHAgPSBnID4gcCA/IGcgOiBwO1xuICAgICAgICB9XG4gICAgICB9KSksIGwocikgIT09IHZvaWQgMCA/IHRoaXMucGFyZW50LnNlbGVjdChcImcubXVsdGktY2VsbC5jb2x1bW4taGlnaGxpZ2h0XCIpLmNsYXNzZWQoXCJoaWdobGlnaHRlci1oaWRkZW5cIiwgITEpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke2wocil9LCAke0JuKGMucmFuZ2UoKSl9KWApIDogYyhyKSAhPT0gdm9pZCAwICYmIHRoaXMucGFyZW50LnNlbGVjdChcImcubXVsdGktY2VsbC5yb3ctaGlnaGxpZ2h0XCIpLmNsYXNzZWQoXCJoaWdobGlnaHRlci1oaWRkZW5cIiwgITEpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke0JuKGwucmFuZ2UoKSl9LCR7YyhyKX0pYCksIHRoaXMuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLlNIT1csIHtcbiAgICAgICAgZXZlbnQ6IG4uZXZlbnQsXG4gICAgICAgIGhvdmVyZWRFbGVtZW50OiBJKHQuZGV0YWlsLmVsZW1lbnQpLFxuICAgICAgICBpdGVtczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiB1LFxuICAgICAgICAgICAgdmFsdWU6IHIsXG4gICAgICAgICAgICBib2xkOiAhMFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6IFwiTWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogaCAhPT0gbnVsbCA/IGggOiBcIi1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6IFwiTWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogcCAhPT0gbnVsbCA/IHAgOiBcIi1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6IFwiQXZlcmFnZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGQgIT09IG51bGwgPyBkIC8gcy5sZW5ndGggOiBcIi1cIlxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgfSwgdGhpcy5oYW5kbGVBeGlzTW91c2VPdXQgPSAodCkgPT4ge1xuICAgICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwiZy5tdWx0aS1jZWxsXCIpLmNsYXNzZWQoXCJoaWdobGlnaHRlci1oaWRkZW5cIiwgITApLCB0aGlzLnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5ISURFLCB7XG4gICAgICAgIGV2ZW50OiB0XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIGluaXQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuc2VydmljZXMuZXZlbnRzO1xuICAgIHQuYWRkRXZlbnRMaXN0ZW5lcihULkF4aXMuTEFCRUxfTU9VU0VPVkVSLCB0aGlzLmhhbmRsZUF4aXNPbkhvdmVyKSwgdC5hZGRFdmVudExpc3RlbmVyKFQuQXhpcy5MQUJFTF9NT1VTRU9VVCwgdGhpcy5oYW5kbGVBeGlzTW91c2VPdXQpLCB0LmFkZEV2ZW50TGlzdGVuZXIoVC5BeGlzLkxBQkVMX0ZPQ1VTLCB0aGlzLmhhbmRsZUF4aXNPbkhvdmVyKSwgdC5hZGRFdmVudExpc3RlbmVyKFQuQXhpcy5MQUJFTF9CTFVSLCB0aGlzLmhhbmRsZUF4aXNNb3VzZU91dCk7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcmVuZGVyKHQgPSAhMCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldENvbXBvbmVudENvbnRhaW5lcih7IGFyaWFMYWJlbDogXCJoZWF0bWFwXCIsIHdpdGhpbkNoYXJ0Q2xpcDogITAgfSk7XG4gICAgbi5sb3dlcigpO1xuICAgIGNvbnN0IHsgY2FydGVzaWFuU2NhbGVzOiByIH0gPSB0aGlzLnNlcnZpY2VzO1xuICAgIGlmICh0aGlzLm1hdHJpeCA9IHRoaXMubW9kZWwuZ2V0TWF0cml4KCksIG4uaHRtbChcIlwiKSwgeSh0aGlzLmdldE9wdGlvbnMoKSwgXCJkYXRhXCIsIFwibG9hZGluZ1wiKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gci5nZXRNYWluWFNjYWxlKCksIHMgPSByLmdldE1haW5ZU2NhbGUoKSwgYSA9IHIuZ2V0RG9tYWluSWRlbnRpZmllcigpLCBvID0gci5nZXRSYW5nZUlkZW50aWZpZXIoKSwgbCA9IHRoaXMubW9kZWwuZ2V0VW5pcXVlRG9tYWluKCksIGMgPSB0aGlzLm1vZGVsLmdldFVuaXF1ZVJhbmdlcygpLCB1ID0gdGhpcy5tb2RlbC5nZXRNYXRyaXhBc0FycmF5KCksIGQgPSBpLnJhbmdlKCksIGggPSBzLnJhbmdlKCk7XG4gICAgdGhpcy54QmFuZHdpZHRoID0gTWF0aC5hYnMoKGRbMV0gLSBkWzBdKSAvIGwubGVuZ3RoKSwgdGhpcy55QmFuZHdpZHRoID0gTWF0aC5hYnMoKGhbMV0gLSBoWzBdKSAvIGMubGVuZ3RoKTtcbiAgICBjb25zdCBwID0gdGhpcy5zZXJ2aWNlcy5kb21VdGlscy5nZW5lcmF0ZUVsZW1lbnRJRFN0cmluZyhcImhlYXRtYXAtcGF0dGVybi1zdHJpcGVzXCIpO1xuICAgIG4uYXBwZW5kKFwiZGVmc1wiKS5hcHBlbmQoXCJwYXR0ZXJuXCIpLmF0dHIoXCJpZFwiLCBwKS5hdHRyKFwid2lkdGhcIiwgMykuYXR0cihcImhlaWdodFwiLCAzKS5hdHRyKFwicGF0dGVyblVuaXRzXCIsIFwidXNlclNwYWNlT25Vc2VcIikuYXR0cihcInBhdHRlcm5UcmFuc2Zvcm1cIiwgXCJyb3RhdGUoNDUpXCIpLmFwcGVuZChcInJlY3RcIikuY2xhc3NlZChcInBhdHRlcm4tZmlsbFwiLCAhMCkuYXR0cihcIndpZHRoXCIsIDAuNSkuYXR0cihcImhlaWdodFwiLCA4KTtcbiAgICBjb25zdCBmID0gbi5zZWxlY3RBbGwoKS5kYXRhKHUpLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgKGcpID0+IGBoZWF0LSR7Zy5pbmRleH1gKS5jbGFzc2VkKFwiY2VsbFwiLCAhMCkuYXR0cihcbiAgICAgIFwidHJhbnNmb3JtXCIsXG4gICAgICAoZykgPT4gYHRyYW5zbGF0ZSgke2koZ1thXSl9LCAke3MoZ1tvXSl9KWBcbiAgICApLmFwcGVuZChcInJlY3RcIikuYXR0cihcbiAgICAgIFwiY2xhc3NcIixcbiAgICAgIChnKSA9PiB0aGlzLm1vZGVsLmdldENvbG9yQ2xhc3NOYW1lKHtcbiAgICAgICAgdmFsdWU6IGcudmFsdWUsXG4gICAgICAgIG9yaWdpbmFsQ2xhc3NOYW1lOiBgaGVhdC0ke2cuaW5kZXh9YFxuICAgICAgfSlcbiAgICApLmNsYXNzZWQoXCJoZWF0XCIsICEwKS5jbGFzc2VkKFwibnVsbC1zdGF0ZVwiLCAoZykgPT4gZy5pbmRleCA9PT0gLTEgfHwgZy52YWx1ZSA9PT0gbnVsbCkuYXR0cihcIndpZHRoXCIsIHRoaXMueEJhbmR3aWR0aCkuYXR0cihcImhlaWdodFwiLCB0aGlzLnlCYW5kd2lkdGgpLnN0eWxlKFwiZmlsbFwiLCAoZykgPT4ge1xuICAgICAgY29uc3QgbSA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpbklkZW50aWZpZXIoZyk7XG4gICAgICByZXR1cm4gZy5pbmRleCA9PT0gLTEgfHwgZy52YWx1ZSA9PT0gbnVsbCA/IGB1cmwoIyR7cH0pYCA6IHRoaXMubW9kZWwuZ2V0RmlsbENvbG9yKE51bWJlcihnLnZhbHVlKSwgZ1ttXSwgZyk7XG4gICAgfSkuYXR0cihcImFyaWEtbGFiZWxcIiwgKGcpID0+IGcudmFsdWUpO1xuICAgIHRoaXMuY3JlYXRlT3V0ZXJCb3goXCJnLmNlbGwtaGlnaGxpZ2h0XCIsIHRoaXMueEJhbmR3aWR0aCwgdGhpcy55QmFuZHdpZHRoKSwgdGhpcy5jcmVhdGVPdXRlckJveChcbiAgICAgIFwiZy5tdWx0aS1jZWxsLmNvbHVtbi1oaWdobGlnaHRcIixcbiAgICAgIHRoaXMueEJhbmR3aWR0aCxcbiAgICAgIE1hdGguYWJzKGhbMV0gLSBoWzBdKVxuICAgICksIHRoaXMuY3JlYXRlT3V0ZXJCb3goXG4gICAgICBcImcubXVsdGktY2VsbC5yb3ctaGlnaGxpZ2h0XCIsXG4gICAgICBNYXRoLmFicyhkWzFdIC0gZFswXSksXG4gICAgICB0aGlzLnlCYW5kd2lkdGhcbiAgICApLCB0aGlzLmRldGVybWluZURpdmlkZXJTdGF0dXMoKSAmJiAoZi5zdHlsZShcInN0cm9rZS13aWR0aFwiLCBcIjFweFwiKSwgdGhpcy5wYXJlbnQuc2VsZWN0KFwiZy5jZWxsLWhpZ2hsaWdodFwiKS5jbGFzc2VkKFwiY2VsbC0yXCIsICEwKSksIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBib3ggdXNpbmcgbGluZXMgdG8gY3JlYXRlIGEgaG92ZXIgZWZmZWN0XG4gICAqIFRoZSBsaW5lcyBoYXZlIGRyb3Agc2hhZG93IGluIHRoZWlyIHJlc3BlY3RpdmUgZGlyZWN0aW9uXG4gICAqIEBwYXJhbSBwYXJlbnRUYWcgLSB0YWcgbmFtZVxuICAgKiBAcGFyYW0geEJhbmR3aWR0aCAtIFggbGVuZ3RoXG4gICAqIEBwYXJhbSB5QmFuZHdpZHRoIC0geSBsZW5ndGhcbiAgICovXG4gIGNyZWF0ZU91dGVyQm94KHQsIG4sIHIpIHtcbiAgICBjb25zdCBpID0gTi5hcHBlbmRPclNlbGVjdCh0aGlzLnBhcmVudCwgdCkuY2xhc3NlZChcInNoYWRvd3NcIiwgITApLmNsYXNzZWQoXCJoaWdobGlnaHRlci1oaWRkZW5cIiwgITApO1xuICAgIE4uYXBwZW5kT3JTZWxlY3QoaSwgXCJsaW5lLnRvcFwiKS5hdHRyKFwieDFcIiwgLTEpLmF0dHIoXCJ4MlwiLCBuICsgMSksIE4uYXBwZW5kT3JTZWxlY3QoaSwgXCJsaW5lLmxlZnRcIikuYXR0cihcIngxXCIsIDApLmF0dHIoXCJ5MVwiLCAtMSkuYXR0cihcIngyXCIsIDApLmF0dHIoXCJ5MlwiLCByICsgMSksIE4uYXBwZW5kT3JTZWxlY3QoaSwgXCJsaW5lLmRvd25cIikuYXR0cihcIngxXCIsIC0xKS5hdHRyKFwieDJcIiwgbiArIDEpLmF0dHIoXCJ5MVwiLCByKS5hdHRyKFwieTJcIiwgciksIE4uYXBwZW5kT3JTZWxlY3QoaSwgXCJsaW5lLnJpZ2h0XCIpLmF0dHIoXCJ4MVwiLCBuKS5hdHRyKFwieDJcIiwgbikuYXR0cihcInkxXCIsIC0xKS5hdHRyKFwieTJcIiwgciArIDEpO1xuICB9XG4gIGRldGVybWluZURpdmlkZXJTdGF0dXMoKSB7XG4gICAgY29uc3QgdCA9IHkodGhpcy5nZXRPcHRpb25zKCksIFwiaGVhdG1hcFwiLCBcImRpdmlkZXJcIiwgXCJzdGF0ZVwiKTtcbiAgICByZXR1cm4gdCAhPT0gUGkuT0ZGICYmICh0ID09PSBQaS5BVVRPICYmIERoLm1pbkNlbGxEaXZpZGVyRGltZW5zaW9uIDw9IHRoaXMueEJhbmR3aWR0aCAmJiBEaC5taW5DZWxsRGl2aWRlckRpbWVuc2lvbiA8PSB0aGlzLnlCYW5kd2lkdGggfHwgdCA9PT0gUGkuT04pO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMsIHsgY2FydGVzaWFuU2NhbGVzOiBuIH0gPSB0aGlzLnNlcnZpY2VzLCByID0gdGhpcy5nZXRPcHRpb25zKCksIGkgPSBndChyLCBcImxvY2FsZS50cmFuc2xhdGlvbnMudG90YWxcIikgfHwgZ3QociwgXCJ0b29sdGlwLnRvdGFsTGFiZWxcIikgfHwgXCJUb3RhbFwiLCBzID0gbi5nZXREb21haW5JZGVudGlmaWVyKCksIGEgPSBuLmdldFJhbmdlSWRlbnRpZmllcigpLCBvID0gbi5nZXREb21haW5MYWJlbCgpLCBsID0gbi5nZXRSYW5nZUxhYmVsKCk7XG4gICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwiZy5jZWxsXCIpLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKGMsIHUpIHtcbiAgICAgIGNvbnN0IGQgPSBJKHRoaXMpLCBoID0gZC5zZWxlY3QoXCJyZWN0LmhlYXRcIik7XG4gICAgICBpZiAoIWguY2xhc3NlZChcIm51bGwtc3RhdGVcIikpIHtcbiAgICAgICAgY29uc3QgcCA9IE1pKGQuYXR0cihcInRyYW5zZm9ybVwiKSk7XG4gICAgICAgIHQucGFyZW50LnNlbGVjdChcImcuY2VsbC1oaWdobGlnaHRcIikuYXR0cihcbiAgICAgICAgICBcInRyYW5zZm9ybVwiLFxuICAgICAgICAgIGB0cmFuc2xhdGUoJHtwLnggKyB0LnRyYW5zbGF0aW9uVW5pdHMueH0sICR7cC55ICsgdC50cmFuc2xhdGlvblVuaXRzLnl9KWBcbiAgICAgICAgKS5jbGFzc2VkKFwiaGlnaGxpZ2h0ZXItaGlkZGVuXCIsICExKSwgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkhlYXRtYXAuSEVBVE1BUF9NT1VTRU9WRVIsIHtcbiAgICAgICAgICBldmVudDogYyxcbiAgICAgICAgICBlbGVtZW50OiBoLFxuICAgICAgICAgIGRhdHVtOiB1XG4gICAgICAgIH0pLCB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5TSE9XLCB7XG4gICAgICAgICAgZXZlbnQ6IGMsXG4gICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbGFiZWw6IG8sXG4gICAgICAgICAgICAgIHZhbHVlOiB1W3NdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBsYWJlbDogbCxcbiAgICAgICAgICAgICAgdmFsdWU6IHVbYV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxhYmVsOiBpLFxuICAgICAgICAgICAgICB2YWx1ZTogdS52YWx1ZSxcbiAgICAgICAgICAgICAgY29sb3I6IGguc3R5bGUoXCJmaWxsXCIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KS5vbihcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbihjLCB1KSB7XG4gICAgICB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuSGVhdG1hcC5IRUFUTUFQX01PVVNFTU9WRSwge1xuICAgICAgICBldmVudDogYyxcbiAgICAgICAgZWxlbWVudDogSSh0aGlzKSxcbiAgICAgICAgZGF0dW06IHVcbiAgICAgIH0pLCB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5NT1ZFLCB7XG4gICAgICAgIGV2ZW50OiBjXG4gICAgICB9KTtcbiAgICB9KS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGMsIHUpIHtcbiAgICAgIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5IZWF0bWFwLkhFQVRNQVBfQ0xJQ0ssIHtcbiAgICAgICAgZXZlbnQ6IGMsXG4gICAgICAgIGVsZW1lbnQ6IEkodGhpcyksXG4gICAgICAgIGRhdHVtOiB1XG4gICAgICB9KTtcbiAgICB9KS5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKGMsIHUpIHtcbiAgICAgIGNvbnN0IGQgPSBJKHRoaXMpLnNlbGVjdChcInJlY3QuaGVhdFwiKSwgaCA9IGQuY2xhc3NlZChcIm51bGwtc3RhdGVcIik7XG4gICAgICB0LnBhcmVudC5zZWxlY3QoXCJnLmNlbGwtaGlnaGxpZ2h0XCIpLmNsYXNzZWQoXCJoaWdobGlnaHRlci1oaWRkZW5cIiwgITApLCBoIHx8ICh0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuSGVhdG1hcC5IRUFUTUFQX01PVVNFT1VULCB7XG4gICAgICAgIGV2ZW50OiBjLFxuICAgICAgICBlbGVtZW50OiBkLFxuICAgICAgICBkYXR1bTogdVxuICAgICAgfSksIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLkhJREUsIHtcbiAgICAgICAgZXZlbnQ6IGMsXG4gICAgICAgIGhvdmVyZWRFbGVtZW50OiBkXG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cbiAgLy8gUmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcInJlY3QuaGVhdFwiKS5vbihcIm1vdXNlb3ZlclwiLCBudWxsKS5vbihcIm1vdXNlbW92ZVwiLCBudWxsKS5vbihcImNsaWNrXCIsIG51bGwpLm9uKFwibW91c2VvdXRcIiwgbnVsbCk7XG4gICAgY29uc3QgdCA9IHRoaXMuc2VydmljZXMuZXZlbnRzO1xuICAgIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX0hPVkVSLCB0aGlzLmhhbmRsZUF4aXNPbkhvdmVyKSwgdC5yZW1vdmVFdmVudExpc3RlbmVyKFQuTGVnZW5kLklURU1fTU9VU0VPVVQsIHRoaXMuaGFuZGxlQXhpc01vdXNlT3V0KTtcbiAgfVxufVxuY2xhc3MgQkQgZXh0ZW5kcyBtdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IFwiaGlzdG9ncmFtXCIsIHRoaXMucmVuZGVyVHlwZSA9IHJ0LlNWRywgdGhpcy5oYW5kbGVMZWdlbmRPbkhvdmVyID0gKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgaG92ZXJlZEVsZW1lbnQ6IG4gfSA9IHQuZGV0YWlsLCByID0gdGhpcy5nZXRPcHRpb25zKCksIHsgZ3JvdXBNYXBzVG86IGkgfSA9IHIuZGF0YTtcbiAgICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcInBhdGguYmFyXCIpLnRyYW5zaXRpb24oXCJsZWdlbmQtaG92ZXItYmFyXCIpLmNhbGwoXG4gICAgICAgIChzKSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgdHJhbnNpdGlvbjogcyxcbiAgICAgICAgICBuYW1lOiBcImxlZ2VuZC1ob3Zlci1iYXJcIlxuICAgICAgICB9KVxuICAgICAgKS5hdHRyKFwib3BhY2l0eVwiLCAocykgPT4gc1tpXSAhPT0gbi5kYXR1bSgpLm5hbWUgPyAwLjMgOiAxKTtcbiAgICB9LCB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlT3V0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwicGF0aC5iYXJcIikudHJhbnNpdGlvbihcImxlZ2VuZC1tb3VzZW91dC1iYXJcIikuY2FsbChcbiAgICAgICAgKHQpID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICB0cmFuc2l0aW9uOiB0LFxuICAgICAgICAgIG5hbWU6IFwibGVnZW5kLW1vdXNlb3V0LWJhclwiXG4gICAgICAgIH0pXG4gICAgICApLmF0dHIoXCJvcGFjaXR5XCIsIDEpO1xuICAgIH07XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5zZXJ2aWNlcy5ldmVudHM7XG4gICAgdC5hZGRFdmVudExpc3RlbmVyKFQuTGVnZW5kLklURU1fSE9WRVIsIHRoaXMuaGFuZGxlTGVnZW5kT25Ib3ZlciksIHQuYWRkRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX01PVVNFT1VULCB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlT3V0KTtcbiAgfVxuICByZW5kZXIodCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldENvbXBvbmVudENvbnRhaW5lcih7XG4gICAgICBhcmlhTGFiZWw6IFwiaGlzdG9ncmFtIGJhcnNcIlxuICAgIH0pLCByID0gdGhpcy5tb2RlbC5nZXRPcHRpb25zKCksIHsgZ3JvdXBJZGVudGlmaWVyOiBpIH0gPSByLCB7IGdyb3VwTWFwc1RvOiBzIH0gPSByLmRhdGEsIGEgPSB0aGlzLm1vZGVsLmdldEJpbm5lZFN0YWNrZWREYXRhKCksIG8gPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRNYWluWFNjYWxlKCksIGwgPSBuLnNlbGVjdEFsbChcImcuYmFyc1wiKS5kYXRhKGEsICh1KSA9PiBndCh1LCBgMC4ke3N9YCkpO1xuICAgIGwuZXhpdCgpLmF0dHIoXCJvcGFjaXR5XCIsIDApLnJlbW92ZSgpLCBsLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5jbGFzc2VkKFwiYmFyc1wiLCAhMCkuYXR0cihcInJvbGVcIiwgaHQuR1JPVVApO1xuICAgIGNvbnN0IGMgPSBuLnNlbGVjdEFsbChcImcuYmFyc1wiKS5zZWxlY3RBbGwoXCJwYXRoLmJhclwiKS5kYXRhKCh1KSA9PiB1KTtcbiAgICBjLmV4aXQoKS5yZW1vdmUoKSwgYy5lbnRlcigpLmFwcGVuZChcInBhdGhcIikubWVyZ2UoYykuY2xhc3NlZChcImJhclwiLCAhMCkuYXR0cihpLCAodSwgZCkgPT4gZCkudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAodSkgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICB0cmFuc2l0aW9uOiB1LFxuICAgICAgICBuYW1lOiBcImhpc3RvZ3JhbS1iYXItdXBkYXRlLWVudGVyXCIsXG4gICAgICAgIGFuaW1hdGU6IHRcbiAgICAgIH0pXG4gICAgKS5hdHRyKFxuICAgICAgXCJjbGFzc1wiLFxuICAgICAgKHUpID0+IHRoaXMubW9kZWwuZ2V0Q29sb3JDbGFzc05hbWUoe1xuICAgICAgICBjbGFzc05hbWVUeXBlczogW2l0LkZJTExdLFxuICAgICAgICBkYXRhR3JvdXBOYW1lOiB1W3NdLFxuICAgICAgICBvcmlnaW5hbENsYXNzTmFtZTogXCJiYXJcIlxuICAgICAgfSlcbiAgICApLnN0eWxlKFwiZmlsbFwiLCAodSkgPT4gdGhpcy5tb2RlbC5nZXRGaWxsQ29sb3IodVtzXSwgbnVsbCwgdSkpLmF0dHIoXCJkXCIsICh1KSA9PiB7XG4gICAgICBjb25zdCBkID0gZ3QodSwgXCJkYXRhXCIpO1xuICAgICAgaWYgKCFkKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBoID0gbyhkLngxKSAtIG8oZC54MCkgLSAxLCBwID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0RG9tYWluVmFsdWUoZC54MCksIGYgPSBwICsgaCwgZyA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlVmFsdWUodVswXSk7XG4gICAgICBsZXQgbSA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlVmFsdWUodVsxXSk7XG4gICAgICByZXR1cm4gTWF0aC5hYnMobSAtIGcpID4gMCAmJiBNYXRoLmFicyhtIC0gZykgPiByLmJhcnMuZGl2aWRlclNpemUgJiYgKHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldE9yaWVudGF0aW9uKCkgPT09IEZ0LlZFUlRJQ0FMID8gbSArPSAxIDogbSAtPSAxKSwgYWUoXG4gICAgICAgIHsgeDA6IHAsIHgxOiBmLCB5MDogZywgeTE6IG0gfSxcbiAgICAgICAgdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0T3JpZW50YXRpb24oKVxuICAgICAgKTtcbiAgICB9KS5hdHRyKFwib3BhY2l0eVwiLCAxKS5hdHRyKFwicm9sZVwiLCBodC5HUkFQSElDU19TWU1CT0wpLmF0dHIoXCJhcmlhLXJvbGVkZXNjcmlwdGlvblwiLCBcImJhclwiKS5hdHRyKFwiYXJpYS1sYWJlbFwiLCAodSkgPT4geSh1LCBcImRhdGFcIiwgdVtzXSkpLCB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLCB7IGdyb3VwTWFwc1RvOiBuIH0gPSB0LmRhdGEsIHsgY29kZTogciwgbnVtYmVyOiBpIH0gPSB5KHQsIFwibG9jYWxlXCIpLCBzID0gdGhpcztcbiAgICB0aGlzLnBhcmVudC5zZWxlY3RBbGwoXCJwYXRoLmJhclwiKS5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbihhLCBvKSB7XG4gICAgICBjb25zdCBsID0gSSh0aGlzKTtcbiAgICAgIGwuY2xhc3NlZChcImhvdmVyZWRcIiwgITApO1xuICAgICAgY29uc3QgYyA9IGkocGFyc2VGbG9hdChndChvLCBcImRhdGEueDBcIikpLCByKSwgdSA9IGkocGFyc2VGbG9hdChndChvLCBcImRhdGEueDFcIikpLCByKSwgZCA9IHMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlQXhpc1Bvc2l0aW9uKCksIGggPSBzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRTY2FsZUxhYmVsKGQpO1xuICAgICAgcy5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuU0hPVywge1xuICAgICAgICBldmVudDogYSxcbiAgICAgICAgaG92ZXJlZEVsZW1lbnQ6IGwsXG4gICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6IGd0KHQsIFwiYmlucy5yYW5nZUxhYmVsXCIpIHx8IFwiUmFuZ2VcIixcbiAgICAgICAgICAgIHZhbHVlOiBgJHtjfSDigJMgJHt1fWBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiB0LnRvb2x0aXAuZ3JvdXBMYWJlbCB8fCBcIkdyb3VwXCIsXG4gICAgICAgICAgICB2YWx1ZTogb1tuXSxcbiAgICAgICAgICAgIGNsYXNzOiBzLm1vZGVsLmdldENvbG9yQ2xhc3NOYW1lKHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lVHlwZXM6IFtpdC5UT09MVElQXSxcbiAgICAgICAgICAgICAgZGF0YUdyb3VwTmFtZTogb1tuXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiBoLFxuICAgICAgICAgICAgdmFsdWU6IGd0KG8sIGBkYXRhLiR7b1tuXX1gKVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgfSkub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24oYSkge1xuICAgICAgcy5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuTU9WRSwge1xuICAgICAgICBldmVudDogYVxuICAgICAgfSk7XG4gICAgfSkub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIEkodGhpcykuY2xhc3NlZChcImhvdmVyZWRcIiwgITEpLCBzLnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5ISURFKTtcbiAgICB9KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcInBhdGguYmFyXCIpLm9uKFwibW91c2VvdmVyXCIsIG51bGwpLm9uKFwibW91c2Vtb3ZlXCIsIG51bGwpLm9uKFwibW91c2VvdXRcIiwgbnVsbCk7XG4gICAgY29uc3QgdCA9IHRoaXMuc2VydmljZXMuZXZlbnRzO1xuICAgIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX0hPVkVSLCB0aGlzLmhhbmRsZUxlZ2VuZE9uSG92ZXIpLCB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoVC5MZWdlbmQuSVRFTV9NT1VTRU9VVCwgdGhpcy5oYW5kbGVMZWdlbmRNb3VzZU91dCk7XG4gIH1cbn1cbmNsYXNzIEhEIGV4dGVuZHMgbm4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnR5cGUgPSBcImxvbGxpcG9wXCIsIHRoaXMucmVuZGVyVHlwZSA9IHJ0LlNWRywgdGhpcy5oYW5kbGVTY2F0dGVyT25Ib3ZlciA9ICh0KSA9PiB7XG4gICAgICBjb25zdCBuID0gdC5kZXRhaWwsIHIgPSB0aGlzLmdldE9wdGlvbnMoKSwgeyBncm91cE1hcHNUbzogaSB9ID0gci5kYXRhO1xuICAgICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwibGluZS5saW5lXCIpLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgKHMpID0+IHNbaV0gIT09IG4uZGF0dW1baV0gPyB2bi53ZWlnaHQudW5zZWxlY3RlZCA6IHZuLndlaWdodC5zZWxlY3RlZCk7XG4gICAgfSwgdGhpcy5oYW5kbGVTY2F0dGVyT25Nb3VzZU91dCA9ICgpID0+IHtcbiAgICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcImxpbmUubGluZVwiKS5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIHZuLndlaWdodC51bnNlbGVjdGVkKTtcbiAgICB9LCB0aGlzLmhhbmRsZUxlZ2VuZE9uSG92ZXIgPSAodCkgPT4ge1xuICAgICAgY29uc3QgeyBob3ZlcmVkRWxlbWVudDogbiB9ID0gdC5kZXRhaWwsIHIgPSB0aGlzLmdldE9wdGlvbnMoKSwgeyBncm91cE1hcHNUbzogaSB9ID0gci5kYXRhO1xuICAgICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwibGluZS5saW5lXCIpLnRyYW5zaXRpb24oXCJsZWdlbmQtaG92ZXItbGluZVwiKS5jYWxsKFxuICAgICAgICAocykgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICAgIHRyYW5zaXRpb246IHMsXG4gICAgICAgICAgbmFtZTogXCJsZWdlbmQtaG92ZXItbGluZVwiXG4gICAgICAgIH0pXG4gICAgICApLmF0dHIoXCJvcGFjaXR5XCIsIChzKSA9PiBzW2ldICE9PSBuLmRhdHVtKCkubmFtZSA/IHZuLm9wYWNpdHkudW5zZWxlY3RlZCA6IHZuLm9wYWNpdHkuc2VsZWN0ZWQpO1xuICAgIH0sIHRoaXMuaGFuZGxlTGVnZW5kTW91c2VPdXQgPSAoKSA9PiB7XG4gICAgICB0aGlzLnBhcmVudC5zZWxlY3RBbGwoXCJsaW5lLmxpbmVcIikudHJhbnNpdGlvbihcImxlZ2VuZC1tb3VzZW91dC1saW5lXCIpLmNhbGwoXG4gICAgICAgICh0KSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgdHJhbnNpdGlvbjogdCxcbiAgICAgICAgICBuYW1lOiBcImxlZ2VuZC1tb3VzZW91dC1saW5lXCJcbiAgICAgICAgfSlcbiAgICAgICkuYXR0cihcIm9wYWNpdHlcIiwgdm4ub3BhY2l0eS5zZWxlY3RlZCk7XG4gICAgfTtcbiAgfVxuICBpbml0KCkge1xuICAgIGNvbnN0IHsgZXZlbnRzOiB0IH0gPSB0aGlzLnNlcnZpY2VzO1xuICAgIHQuYWRkRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX0hPVkVSLCB0aGlzLmhhbmRsZUxlZ2VuZE9uSG92ZXIpLCB0LmFkZEV2ZW50TGlzdGVuZXIoVC5MZWdlbmQuSVRFTV9NT1VTRU9VVCwgdGhpcy5oYW5kbGVMZWdlbmRNb3VzZU91dCk7XG4gIH1cbiAgcmVuZGVyKHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoeyBhcmlhTGFiZWw6IFwibGluZXNcIiwgd2l0aGluQ2hhcnRDbGlwOiAhMCB9KSwgciA9IHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLCB7IGdyb3VwTWFwc1RvOiBpIH0gPSByLmRhdGEsIHsgY2FydGVzaWFuU2NhbGVzOiBzIH0gPSB0aGlzLnNlcnZpY2VzLCBhID0gcy5nZXRNYWluWFNjYWxlKCksIG8gPSBzLmdldE1haW5ZU2NhbGUoKSwgbCA9IHMuZ2V0RG9tYWluSWRlbnRpZmllcigpLCBjID0gKG0pID0+IHMuZ2V0RG9tYWluVmFsdWUobSksIHUgPSAobSkgPT4gcy5nZXRSYW5nZVZhbHVlKG0pLCBkID0gcy5nZXRPcmllbnRhdGlvbigpLCBbaCwgcF0gPSBFbihcbiAgICAgIGMsXG4gICAgICB1LFxuICAgICAgZFxuICAgICksIGYgPSBuLnNlbGVjdEFsbChcImxpbmUubGluZVwiKS5kYXRhKFxuICAgICAgdGhpcy5nZXRTY2F0dGVyRGF0YSgpLFxuICAgICAgKG0pID0+IGAke21baV19LSR7bVtsXX1gXG4gICAgKTtcbiAgICBmLmV4aXQoKS5hdHRyKFwib3BhY2l0eVwiLCAwKS5yZW1vdmUoKTtcbiAgICBjb25zdCBnID0gZi5lbnRlcigpLmFwcGVuZChcImxpbmVcIikuYXR0cihcIm9wYWNpdHlcIiwgMCkubWVyZ2UoZikuY2xhc3NlZChcImxpbmVcIiwgITApLmF0dHIoXG4gICAgICBcImNsYXNzXCIsXG4gICAgICAobSkgPT4gdGhpcy5tb2RlbC5nZXRDb2xvckNsYXNzTmFtZSh7XG4gICAgICAgIGNsYXNzTmFtZVR5cGVzOiBbaXQuU1RST0tFXSxcbiAgICAgICAgZGF0YUdyb3VwTmFtZTogbVtpXSxcbiAgICAgICAgb3JpZ2luYWxDbGFzc05hbWU6IFwibGluZVwiXG4gICAgICB9KVxuICAgICkudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAobSkgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICB0cmFuc2l0aW9uOiBtLFxuICAgICAgICBuYW1lOiBcImxvbGxpcG9wLWxpbmUtdXBkYXRlLWVudGVyXCIsXG4gICAgICAgIGFuaW1hdGU6IHRcbiAgICAgIH0pXG4gICAgKS5zdHlsZShcInN0cm9rZVwiLCAobSkgPT4gdGhpcy5tb2RlbC5nZXRGaWxsQ29sb3IobVtpXSwgbVtsXSwgbSkpLmF0dHIoXCJvcGFjaXR5XCIsIDEpO1xuICAgIGQgPT09IEZ0LkhPUklaT05UQUwgPyBnLmF0dHIoXCJ5MVwiLCBwKS5hdHRyKFwieTJcIiwgcCkuYXR0cihcIngxXCIsIGEucmFuZ2UoKVswXSkuYXR0cihcIngyXCIsIChtKSA9PiBoKG0pIC0gci5wb2ludHMucmFkaXVzKSA6IGcuYXR0cihcIngxXCIsIGgpLmF0dHIoXCJ4MlwiLCBoKS5hdHRyKFwieTFcIiwgby5yYW5nZSgpWzBdKS5hdHRyKFwieTJcIiwgKG0pID0+IHAobSkgKyByLnBvaW50cy5yYWRpdXMpLCB0aGlzLmFkZFNjYXR0ZXJQb2ludEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgLy8gbGlzdGVuIGZvciB3aGVuIGluZGl2aWR1YWwgZGF0YXBvaW50cyBhcmUgaG92ZXJlZFxuICBhZGRTY2F0dGVyUG9pbnRFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLnNlcnZpY2VzLmV2ZW50cy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgVC5TY2F0dGVyLlNDQVRURVJfTU9VU0VPVkVSLFxuICAgICAgdGhpcy5oYW5kbGVTY2F0dGVyT25Ib3ZlclxuICAgICksIHRoaXMuc2VydmljZXMuZXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBULlNjYXR0ZXIuU0NBVFRFUl9NT1VTRU9VVCxcbiAgICAgIHRoaXMuaGFuZGxlU2NhdHRlck9uTW91c2VPdXRcbiAgICApO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuc2VydmljZXMuZXZlbnRzO1xuICAgIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX0hPVkVSLCB0aGlzLmhhbmRsZUxlZ2VuZE9uSG92ZXIpLCB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoVC5MZWdlbmQuSVRFTV9NT1VTRU9VVCwgdGhpcy5oYW5kbGVMZWdlbmRNb3VzZU91dCksIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihULlNjYXR0ZXIuU0NBVFRFUl9NT1VTRU9WRVIsIHRoaXMuaGFuZGxlU2NhdHRlck9uSG92ZXIpLCB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBULlNjYXR0ZXIuU0NBVFRFUl9NT1VTRU9VVCxcbiAgICAgIHRoaXMuaGFuZGxlU2NhdHRlck9uTW91c2VPdXRcbiAgICApO1xuICB9XG59XG5jbGFzcyBWRCBleHRlbmRzIG10IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy50eXBlID0gXCJtZXRlclwiLCB0aGlzLnJlbmRlclR5cGUgPSBydC5TVkc7XG4gIH1cbiAgZ2V0U3RhY2tlZEJvdW5kcyh0LCBuKSB7XG4gICAgbGV0IHIgPSAwO1xuICAgIHJldHVybiB0Lm1hcCgoaSwgcykgPT4gcyAhPT0gMCA/IChyICs9IG4oaS52YWx1ZSksIHtcbiAgICAgIC4uLmksXG4gICAgICB3aWR0aDogTWF0aC5hYnMobihpLnZhbHVlKSAtIFp0LmRpdmlkZXJXaWR0aCksXG4gICAgICB4OiByIC0gbihpLnZhbHVlKVxuICAgIH0pIDogKHIgPSBuKGkudmFsdWUpLCB7XG4gICAgICAuLi5pLFxuICAgICAgd2lkdGg6IE1hdGguYWJzKG4oaS52YWx1ZSkgLSBadC5kaXZpZGVyV2lkdGgpLFxuICAgICAgeDogMFxuICAgIH0pKTtcbiAgfVxuICByZW5kZXIodCA9ICEwKSB7XG4gICAgY29uc3QgbiA9IHRoaXMsIHIgPSB0aGlzLmdldENvbXBvbmVudENvbnRhaW5lcih7XG4gICAgICBhcmlhTGFiZWw6IFwibWV0ZXIgbGluZXNcIlxuICAgIH0pLCBpID0gdGhpcy5nZXRPcHRpb25zKCksIHMgPSB5KGksIFwibWV0ZXJcIiwgXCJwcm9wb3J0aW9uYWxcIiksIGEgPSB0aGlzLm1vZGVsLmdldERpc3BsYXlEYXRhKCksIG8gPSB0aGlzLm1vZGVsLmdldFN0YXR1cygpLCB7IHdpZHRoOiBsIH0gPSBOLmdldFNWR0VsZW1lbnRTaXplKHIsIHtcbiAgICAgIHVzZUF0dHJzOiAhMFxuICAgIH0pLCB7IGdyb3VwTWFwc1RvOiBjIH0gPSBpLmRhdGE7XG4gICAgbGV0IHU7XG4gICAgeShpLCBcIm1ldGVyXCIsIFwicHJvcG9ydGlvbmFsXCIpID09PSBudWxsID8gdSA9IDEwMCA6IHUgPSB5KGksIFwibWV0ZXJcIiwgXCJwcm9wb3J0aW9uYWxcIiwgXCJ0b3RhbFwiKSB8fCB0aGlzLm1vZGVsLmdldE1heGltdW1Eb21haW4odGhpcy5tb2RlbC5nZXREaXNwbGF5RGF0YSgpKTtcbiAgICBjb25zdCBkID0gRmUoKS5kb21haW4oWzAsIHVdKS5yYW5nZShbMCwgbF0pLCBoID0gdGhpcy5nZXRTdGFja2VkQm91bmRzKGEsIGQpLCBwID0geShpLCBcIm1ldGVyXCIsIFwiaGVpZ2h0XCIpO1xuICAgIE4uYXBwZW5kT3JTZWxlY3QociwgXCJyZWN0LmNvbnRhaW5lclwiKS5hdHRyKFwieFwiLCAwKS5hdHRyKFwieVwiLCAwKS5hdHRyKFwid2lkdGhcIiwgbCkuYXR0cihcbiAgICAgIFwiaGVpZ2h0XCIsXG4gICAgICBwIHx8IChzID8gWnQuaGVpZ2h0LnByb3BvcnRpb25hbCA6IFp0LmhlaWdodC5kZWZhdWx0KVxuICAgICksIE4uYXBwZW5kT3JTZWxlY3QociwgXCJsaW5lLnJhbmdlSW5kaWNhdG9yXCIpLmF0dHIoXCJ4MVwiLCBsKS5hdHRyKFwieDJcIiwgbCkuYXR0cihcInkxXCIsIDApLmF0dHIoXG4gICAgICBcInkyXCIsXG4gICAgICBwIHx8IChzID8gWnQuaGVpZ2h0LnByb3BvcnRpb25hbCA6IFp0LmhlaWdodC5kZWZhdWx0KVxuICAgICk7XG4gICAgY29uc3QgZiA9IHIuc2VsZWN0QWxsKFwicmVjdC52YWx1ZVwiKS5kYXRhKGgpLCBnID0gbyAhPSBudWxsICYmICFuLm1vZGVsLmlzVXNlclByb3ZpZGVkQ29sb3JTY2FsZVZhbGlkKCkgJiYgIXMgPyBgdmFsdWUgc3RhdHVzLS0ke299YCA6IFwidmFsdWVcIjtcbiAgICBmLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKS5jbGFzc2VkKFwidmFsdWVcIiwgITApLm1lcmdlKGYpLmF0dHIoXCJ4XCIsIChfKSA9PiBfLngpLmF0dHIoXCJ5XCIsIDApLmF0dHIoXCJoZWlnaHRcIiwgKCkgPT4gcCB8fCAocyA/IFp0LmhlaWdodC5wcm9wb3J0aW9uYWwgOiBadC5oZWlnaHQuZGVmYXVsdCkpLmF0dHIoXG4gICAgICBcImNsYXNzXCIsXG4gICAgICAoXykgPT4gdGhpcy5tb2RlbC5nZXRDb2xvckNsYXNzTmFtZSh7XG4gICAgICAgIGNsYXNzTmFtZVR5cGVzOiBbaXQuRklMTF0sXG4gICAgICAgIGRhdGFHcm91cE5hbWU6IF9bY10sXG4gICAgICAgIG9yaWdpbmFsQ2xhc3NOYW1lOiBnXG4gICAgICB9KVxuICAgICkudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAoXykgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICB0cmFuc2l0aW9uOiBfLFxuICAgICAgICBuYW1lOiBcIm1ldGVyLWJhci11cGRhdGVcIixcbiAgICAgICAgYW5pbWF0ZTogdFxuICAgICAgfSlcbiAgICApLmF0dHIoXCJ3aWR0aFwiLCAoXykgPT4gXy52YWx1ZSA+IHUgPyBkKHUpIDogTWF0aC5tYXgoXy53aWR0aCwgMikpLnN0eWxlKFwiZmlsbFwiLCAoXykgPT4gbi5tb2RlbC5nZXRGaWxsQ29sb3IoX1tjXSwgbnVsbCwgXykpLmF0dHIoXCJyb2xlXCIsIGh0LkdSQVBISUNTX1NZTUJPTCkuYXR0cihcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCIsIFwidmFsdWVcIikuYXR0cihcImFyaWEtbGFiZWxcIiwgKF8pID0+IF8udmFsdWUpLCBmLmV4aXQoKS5yZW1vdmUoKTtcbiAgICBjb25zdCBtID0geShpLCBcIm1ldGVyXCIsIFwicGVha1wiKTtcbiAgICBsZXQgdiA9IG07XG4gICAgbSAhPT0gbnVsbCAmJiAobSA+IHUgPyB2ID0gdSA6IG0gPCAwICYmICh2ID0gMCkpO1xuICAgIGNvbnN0IHggPSByLnNlbGVjdEFsbChcImxpbmUucGVha1wiKS5kYXRhKHYgPT0gbnVsbCA/IFtdIDogW3ZdKTtcbiAgICB4LmVudGVyKCkuYXBwZW5kKFwibGluZVwiKS5jbGFzc2VkKFwicGVha1wiLCAhMCkubWVyZ2UoeCkuYXR0cihcInkxXCIsIDApLmF0dHIoXCJ5MlwiLCAoKSA9PiBwIHx8IChzID8gWnQuaGVpZ2h0LnByb3BvcnRpb25hbCA6IFp0LmhlaWdodC5kZWZhdWx0KSkudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAoXykgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICB0cmFuc2l0aW9uOiBfLFxuICAgICAgICBuYW1lOiBcInBlYWstbGluZS11cGRhdGVcIixcbiAgICAgICAgYW5pbWF0ZTogdFxuICAgICAgfSlcbiAgICApLmF0dHIoXCJ4MVwiLCAoXykgPT4gZChfKSkuYXR0cihcIngyXCIsIChfKSA9PiBkKF8pKS5hdHRyKFwicm9sZVwiLCBodC5HUkFQSElDU19TWU1CT0wpLmF0dHIoXCJhcmlhLXJvbGVkZXNjcmlwdGlvblwiLCBcInBlYWtcIikuYXR0cihcImFyaWEtbGFiZWxcIiwgKF8pID0+IF8pLCB4LmV4aXQoKS5yZW1vdmUoKSwgdGhpcy5zZXJ2aWNlcy5kb21VdGlscy5zZXRTVkdNYXhIZWlnaHQoKSwgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICB9XG4gIC8vIGFkZCBldmVudCBsaXN0ZW5lcnMgZm9yIHRvb2x0aXBzIG9uIHByb3BvcnRpb25hbCBtZXRlciBiYXJzXG4gIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldE9wdGlvbnMoKSwgeyBncm91cE1hcHNUbzogbiB9ID0gdC5kYXRhLCByID0gdGhpcywgaSA9IHkodCwgXCJtZXRlclwiLCBcInByb3BvcnRpb25hbFwiKTtcbiAgICB0aGlzLnBhcmVudC5zZWxlY3RBbGwoXCJyZWN0LnZhbHVlXCIpLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKHMsIGEpIHtcbiAgICAgIGNvbnN0IG8gPSBJKHRoaXMpO1xuICAgICAgci5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULk1ldGVyLk1FVEVSX01PVVNFT1ZFUiwge1xuICAgICAgICBldmVudDogcyxcbiAgICAgICAgZWxlbWVudDogbyxcbiAgICAgICAgZGF0dW06IGFcbiAgICAgIH0pLCBpICYmIChvLmNsYXNzZWQoXCJob3ZlcmVkXCIsICEwKSwgci5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuU0hPVywge1xuICAgICAgICBldmVudDogcyxcbiAgICAgICAgaG92ZXJlZEVsZW1lbnQ6IG8sXG4gICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6IGFbbl0sXG4gICAgICAgICAgICB2YWx1ZTogYS52YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSkpO1xuICAgIH0pLm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKHMsIGEpIHtcbiAgICAgIGNvbnN0IG8gPSBJKHRoaXMpO1xuICAgICAgci5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULk1ldGVyLk1FVEVSX01PVVNFTU9WRSwge1xuICAgICAgICBldmVudDogcyxcbiAgICAgICAgZWxlbWVudDogbyxcbiAgICAgICAgZGF0dW06IGFcbiAgICAgIH0pLCBpICYmIHIuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLk1PVkUsIHtcbiAgICAgICAgZXZlbnQ6IHNcbiAgICAgIH0pO1xuICAgIH0pLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24ocywgYSkge1xuICAgICAgci5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULk1ldGVyLk1FVEVSX0NMSUNLLCB7XG4gICAgICAgIGV2ZW50OiBzLFxuICAgICAgICBlbGVtZW50OiBJKHRoaXMpLFxuICAgICAgICBkYXR1bTogYVxuICAgICAgfSk7XG4gICAgfSkub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihzLCBhKSB7XG4gICAgICBjb25zdCBvID0gSSh0aGlzKTtcbiAgICAgIHIuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5NZXRlci5NRVRFUl9NT1VTRU9VVCwge1xuICAgICAgICBldmVudDogcyxcbiAgICAgICAgZWxlbWVudDogbyxcbiAgICAgICAgZGF0dW06IGFcbiAgICAgIH0pLCBpICYmIChvLmNsYXNzZWQoXCJob3ZlcmVkXCIsICExKSwgci5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuSElERSwge1xuICAgICAgICBob3ZlcmVkRWxlbWVudDogb1xuICAgICAgfSkpO1xuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwicmVjdC52YWx1ZVwiKS5vbihcIm1vdXNlb3ZlclwiLCBudWxsKS5vbihcIm1vdXNlbW92ZVwiLCBudWxsKS5vbihcIm1vdXNlb3V0XCIsIG51bGwpLm9uKFwiY2xpY2tcIiwgbnVsbCk7XG4gIH1cbn1cbmNsYXNzIEdEIGV4dGVuZHMgbXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnR5cGUgPSBcInJhZGFyXCIsIHRoaXMucmVuZGVyVHlwZSA9IHJ0LlNWRywgdGhpcy5nZXRMYWJlbERpbWVuc2lvbnMgPSAodCkgPT4ge1xuICAgICAgY29uc3QgbiA9IE4uYXBwZW5kT3JTZWxlY3QodGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoKSwgXCJnLnRtcC10aWNrXCIpLCByID0gTi5hcHBlbmRPclNlbGVjdChuLCBcInRleHRcIikudGV4dCh0KSwgeyB3aWR0aDogaSwgaGVpZ2h0OiBzIH0gPSBOLmdldFNWR0VsZW1lbnRTaXplKHIubm9kZSgpLCB7IHVzZUJCb3g6ICEwIH0pO1xuICAgICAgcmV0dXJuIG4ucmVtb3ZlKCksIHsgd2lkdGg6IGksIGhlaWdodDogcyB9O1xuICAgIH0sIHRoaXMubm9ybWFsaXplRmxhdERhdGEgPSAodCkgPT4ge1xuICAgICAgY29uc3QgbiA9IHRoaXMuZ2V0T3B0aW9ucygpLCB7IGFuZ2xlOiByLCB2YWx1ZTogaSB9ID0geShuLCBcInJhZGFyXCIsIFwiYXhlc1wiKSwgcyA9IHkobiwgXCJkYXRhXCIsIFwiZ3JvdXBNYXBzVG9cIiksIGEgPSBSQyhcbiAgICAgICAgdGhpcy51bmlxdWVLZXlzLm1hcCgobykgPT4gdGhpcy51bmlxdWVHcm91cHMubWFwKChsKSA9PiAoe1xuICAgICAgICAgIFtyXTogbyxcbiAgICAgICAgICBbc106IGwsXG4gICAgICAgICAgW2ldOiBudWxsXG4gICAgICAgIH0pKSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gYXQoYSwgdCk7XG4gICAgfSwgdGhpcy5ub3JtYWxpemVHcm91cGVkRGF0YSA9ICh0KSA9PiB7XG4gICAgICBjb25zdCBuID0gdGhpcy5nZXRPcHRpb25zKCksIHsgYW5nbGU6IHIsIHZhbHVlOiBpIH0gPSB5KG4sIFwicmFkYXJcIiwgXCJheGVzXCIpLCBzID0geShuLCBcImRhdGFcIiwgXCJncm91cE1hcHNUb1wiKTtcbiAgICAgIHJldHVybiB0Lm1hcCgoeyBuYW1lOiBhLCBkYXRhOiBvIH0pID0+IHtcbiAgICAgICAgY29uc3QgbCA9IHRoaXMudW5pcXVlS2V5cy5tYXAoKGMpID0+ICh7XG4gICAgICAgICAgW3NdOiBhLFxuICAgICAgICAgIFtyXTogYyxcbiAgICAgICAgICBbaV06IG51bGxcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4geyBuYW1lOiBhLCBkYXRhOiBhdChsLCBvKSB9O1xuICAgICAgfSk7XG4gICAgfSwgdGhpcy5oYW5kbGVMZWdlbmRPbkhvdmVyID0gKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgaG92ZXJlZEVsZW1lbnQ6IG4gfSA9IHQuZGV0YWlsO1xuICAgICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwiZy5ibG9icyBwYXRoXCIpLnRyYW5zaXRpb24oXCJsZWdlbmQtaG92ZXItYmxvYlwiKS5jYWxsKFxuICAgICAgICAocikgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICAgIHRyYW5zaXRpb246IHIsXG4gICAgICAgICAgbmFtZTogXCJsZWdlbmQtaG92ZXItYmxvYlwiXG4gICAgICAgIH0pXG4gICAgICApLnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIChyKSA9PiByLm5hbWUgIT09IG4uZGF0dW0oKS5uYW1lID8gV24ub3BhY2l0eS51bnNlbGVjdGVkIDogV24ub3BhY2l0eS5zZWxlY3RlZCkuc3R5bGUoXCJzdHJva2Utb3BhY2l0eVwiLCAocikgPT4gci5uYW1lICE9PSBuLmRhdHVtKCkubmFtZSA/IFduLm9wYWNpdHkudW5zZWxlY3RlZCA6IDEpO1xuICAgIH0sIHRoaXMuaGFuZGxlTGVnZW5kTW91c2VPdXQgPSAoKSA9PiB7XG4gICAgICB0aGlzLnBhcmVudC5zZWxlY3RBbGwoXCJnLmJsb2JzIHBhdGhcIikudHJhbnNpdGlvbihcImxlZ2VuZC1tb3VzZW91dC1ibG9iXCIpLmNhbGwoXG4gICAgICAgICh0KSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgdHJhbnNpdGlvbjogdCxcbiAgICAgICAgICBuYW1lOiBcImxlZ2VuZC1tb3VzZW91dC1ibG9iXCJcbiAgICAgICAgfSlcbiAgICAgICkuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgV24ub3BhY2l0eS5zZWxlY3RlZCkuc3R5bGUoXCJzdHJva2Utb3BhY2l0eVwiLCAxKTtcbiAgICB9O1xuICB9XG4gIGluaXQoKSB7XG4gICAgY29uc3QgeyBldmVudHM6IHQgfSA9IHRoaXMuc2VydmljZXM7XG4gICAgdC5hZGRFdmVudExpc3RlbmVyKFQuTGVnZW5kLklURU1fSE9WRVIsIHRoaXMuaGFuZGxlTGVnZW5kT25Ib3ZlciksIHQuYWRkRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX01PVVNFT1VULCB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlT3V0KTtcbiAgfVxuICByZW5kZXIodCA9ICEwKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0Q29tcG9uZW50Q29udGFpbmVyKHtcbiAgICAgIGFyaWFMYWJlbDogXCJyYWRhciBncmFwaFwiXG4gICAgfSksIHsgd2lkdGg6IHIsIGhlaWdodDogaSB9ID0gTi5nZXRTVkdFbGVtZW50U2l6ZShuLCB7XG4gICAgICB1c2VBdHRyczogITBcbiAgICB9KSwgcyA9IHRoaXMubW9kZWwuZ2V0RGF0YSgpLCBhID0gdGhpcy5tb2RlbC5nZXRHcm91cGVkRGF0YSgpLCBvID0gdGhpcy5nZXRPcHRpb25zKCksIGwgPSB5KG8sIFwiZGF0YVwiLCBcImdyb3VwTWFwc1RvXCIpLCBjID0geShvLCBcInJhZGFyXCIsIFwiYXhlc1wiLCBcInZhbHVlXCIpLCB7IGFuZ2xlOiB1LCB2YWx1ZTogZCB9ID0geShvLCBcInJhZGFyXCIsIFwiYXhlc1wiKSwgeyB4TGFiZWxQYWRkaW5nOiBoLCB5TGFiZWxQYWRkaW5nOiBwLCB5VGlja3NOdW1iZXI6IGYsIG1pblJhbmdlOiBnLCB4QXhpc1JlY3RIZWlnaHQ6IG0gfSA9IFduO1xuICAgIHRoaXMudW5pcXVlS2V5cyA9IEFycmF5LmZyb20obmV3IFNldChzLm1hcCgoTykgPT4gT1t1XSkpKSwgdGhpcy51bmlxdWVHcm91cHMgPSBBcnJheS5mcm9tKG5ldyBTZXQocy5tYXAoKE8pID0+IE9bbF0pKSksIHRoaXMuZnVsbERhdGFOb3JtYWxpemVkID0gdGhpcy5ub3JtYWxpemVGbGF0RGF0YShzKSwgdGhpcy5ncm91cGVkRGF0YU5vcm1hbGl6ZWQgPSB0aGlzLm5vcm1hbGl6ZUdyb3VwZWREYXRhKGEpO1xuICAgIGNvbnN0IHYgPSAyICogKHRoaXMuZ2V0TGFiZWxEaW1lbnNpb25zKHRoaXMudW5pcXVlS2V5c1swXSkuaGVpZ2h0ICsgcCksIHggPSAoTWF0aC5taW4ociwgaSkgLSB2KSAvIDI7XG4gICAgaWYgKHggPD0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBfID0gZ3MoKS5kb21haW4odGhpcy5mdWxsRGF0YU5vcm1hbGl6ZWQubWFwKChPKSA9PiBPW3VdKSkucmFuZ2UoWzAsIDIgKiBNYXRoLlBJXS5tYXAoKE8pID0+IE8gLSBNYXRoLlBJIC8gMikpLCBFID0gQm4odGhpcy5mdWxsRGF0YU5vcm1hbGl6ZWQubWFwKChPKSA9PiBPW2RdKSksIGIgPSBGZSgpLmRvbWFpbihbXG4gICAgICBFID49IDAgPyAwIDogRSxcbiAgICAgIG5yKHRoaXMuZnVsbERhdGFOb3JtYWxpemVkLm1hcCgoTykgPT4gT1tkXSkpXG4gICAgXSkucmFuZ2UoW2csIHhdKS5uaWNlKGYpLCBTID0gYi50aWNrcyhmKSwgTSA9IChPLCB3LCBMKSA9PiB0aGlzLm1vZGVsLmdldEZpbGxDb2xvcihPLCB3LCBMKSwgRCA9IGRrKCkuYW5nbGUoKE8pID0+IF8oT1t1XSkgKyBNYXRoLlBJIC8gMikucmFkaXVzKChPKSA9PiBiKE9bZF0pKS5jdXJ2ZShpZyksIEEgPSB0aGlzLnVuaXF1ZUtleXMubWFwKChPKSA9PiB7XG4gICAgICBjb25zdCB3ID0gdGhpcy5nZXRMYWJlbERpbWVuc2lvbnMoTykud2lkdGgsIEwgPSBVMihcbiAgICAgICAgXyhPKSxcbiAgICAgICAgeFxuICAgICAgKTtcbiAgICAgIHJldHVybiB3ICsgTDtcbiAgICB9KSwgUiA9IHtcbiAgICAgIHg6IG5yKEEpICsgaCxcbiAgICAgIHk6IGkgLyAyXG4gICAgfSwgJCA9IE4uYXBwZW5kT3JTZWxlY3QobiwgXCJnLnktYXhlc1wiKS5hdHRyKFwicm9sZVwiLCBodC5HUk9VUCkuc2VsZWN0QWxsKFwicGF0aFwiKS5kYXRhKFMsIChPKSA9PiBPKSwgSCA9IChPKSA9PiB0aGlzLnVuaXF1ZUtleXMubWFwKCh3KSA9PiAoeyBbdV06IHcsIFtkXTogTyB9KSk7XG4gICAgJC5qb2luKFxuICAgICAgKE8pID0+IE8uYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwib3BhY2l0eVwiLCAwKS5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHtSLnh9LCAke1IueX0pYCkuYXR0cihcImZpbGxcIiwgXCJub25lXCIpLmNhbGwoXG4gICAgICAgICh3KSA9PiB3LnRyYW5zaXRpb24oKS5jYWxsKFxuICAgICAgICAgIChMKSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBMLFxuICAgICAgICAgICAgbmFtZTogXCJyYWRhcl95X2F4ZXNfZW50ZXJcIixcbiAgICAgICAgICAgIGFuaW1hdGU6IHRcbiAgICAgICAgICB9KVxuICAgICAgICApLmF0dHIoXCJvcGFjaXR5XCIsIDEpLmF0dHIoXCJkXCIsIChMKSA9PiBEKEgoTCkpKVxuICAgICAgKSxcbiAgICAgIChPKSA9PiBPLmNhbGwoXG4gICAgICAgICh3KSA9PiB3LnRyYW5zaXRpb24oKS5jYWxsKFxuICAgICAgICAgIChMKSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBMLFxuICAgICAgICAgICAgbmFtZTogXCJyYWRhcl95X2F4ZXNfdXBkYXRlXCIsXG4gICAgICAgICAgICBhbmltYXRlOiB0XG4gICAgICAgICAgfSlcbiAgICAgICAgKS5hdHRyKFwib3BhY2l0eVwiLCAxKS5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHtSLnh9LCAke1IueX0pYCkuYXR0cihcImRcIiwgKEwpID0+IEQoSChMKSkpXG4gICAgICApLFxuICAgICAgKE8pID0+IE8uY2FsbChcbiAgICAgICAgKHcpID0+IHcudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAgICAgKEwpID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IEwsXG4gICAgICAgICAgICBuYW1lOiBcInJhZGFyX3lfYXhlc19leGl0XCIsXG4gICAgICAgICAgICBhbmltYXRlOiB0XG4gICAgICAgICAgfSlcbiAgICAgICAgKS5hdHRyKFwiZFwiLCAoTCkgPT4gRChIKEwpKSkuYXR0cihcIm9wYWNpdHlcIiwgMCkucmVtb3ZlKClcbiAgICAgIClcbiAgICApLCBOLmFwcGVuZE9yU2VsZWN0KG4sIFwiZy54LWF4ZXNcIikuYXR0cihcInJvbGVcIiwgaHQuR1JPVVApLnNlbGVjdEFsbChcImxpbmVcIikuZGF0YSh0aGlzLnVuaXF1ZUtleXMsIChPKSA9PiBPKS5qb2luKFxuICAgICAgKE8pID0+IE8uYXBwZW5kKFwibGluZVwiKS5hdHRyKFwib3BhY2l0eVwiLCAwKS5hdHRyKFwiY2xhc3NcIiwgKHcpID0+IGB4LWF4aXMtJHtUcih3KX1gKS5hdHRyKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcIjBcIikuYXR0cihcIngxXCIsICh3KSA9PiBVdChfKHcpLCAwLCBSKS54KS5hdHRyKFwieTFcIiwgKHcpID0+IFV0KF8odyksIDAsIFIpLnkpLmF0dHIoXCJ4MlwiLCAodykgPT4gVXQoXyh3KSwgMCwgUikueCkuYXR0cihcInkyXCIsICh3KSA9PiBVdChfKHcpLCAwLCBSKS55KS5jYWxsKFxuICAgICAgICAodykgPT4gdy50cmFuc2l0aW9uKCkuY2FsbChcbiAgICAgICAgICAoTCkgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICAgICAgdHJhbnNpdGlvbjogTCxcbiAgICAgICAgICAgIG5hbWU6IFwicmFkYXJfeF9heGVzX2VudGVyXCIsXG4gICAgICAgICAgICBhbmltYXRlOiB0XG4gICAgICAgICAgfSlcbiAgICAgICAgKS5hdHRyKFwib3BhY2l0eVwiLCAxKS5hdHRyKFwieDFcIiwgKEwpID0+IFV0KF8oTCksIGIucmFuZ2UoKVswXSwgUikueCkuYXR0cihcInkxXCIsIChMKSA9PiBVdChfKEwpLCBiLnJhbmdlKClbMF0sIFIpLnkpLmF0dHIoXCJ4MlwiLCAoTCkgPT4gVXQoXyhMKSwgYi5yYW5nZSgpWzFdLCBSKS54KS5hdHRyKFwieTJcIiwgKEwpID0+IFV0KF8oTCksIGIucmFuZ2UoKVsxXSwgUikueSlcbiAgICAgICksXG4gICAgICAoTykgPT4gTy5jYWxsKFxuICAgICAgICAodykgPT4gdy50cmFuc2l0aW9uKCkuY2FsbChcbiAgICAgICAgICAoTCkgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICAgICAgdHJhbnNpdGlvbjogTCxcbiAgICAgICAgICAgIG5hbWU6IFwicmFkYXJfeF9heGVzX3VwZGF0ZVwiLFxuICAgICAgICAgICAgYW5pbWF0ZTogdFxuICAgICAgICAgIH0pXG4gICAgICAgICkuYXR0cihcIm9wYWNpdHlcIiwgMSkuYXR0cihcIngxXCIsIChMKSA9PiBVdChfKEwpLCBiLnJhbmdlKClbMF0sIFIpLngpLmF0dHIoXCJ5MVwiLCAoTCkgPT4gVXQoXyhMKSwgYi5yYW5nZSgpWzBdLCBSKS55KS5hdHRyKFwieDJcIiwgKEwpID0+IFV0KF8oTCksIGIucmFuZ2UoKVsxXSwgUikueCkuYXR0cihcInkyXCIsIChMKSA9PiBVdChfKEwpLCBiLnJhbmdlKClbMV0sIFIpLnkpXG4gICAgICApLFxuICAgICAgKE8pID0+IE8uY2FsbChcbiAgICAgICAgKHcpID0+IHcudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAgICAgKEwpID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IEwsXG4gICAgICAgICAgICBuYW1lOiBcInJhZGFyX3hfYXhlc19leGl0XCIsXG4gICAgICAgICAgICBhbmltYXRlOiB0XG4gICAgICAgICAgfSlcbiAgICAgICAgKS5hdHRyKFwib3BhY2l0eVwiLCAwKS5yZW1vdmUoKVxuICAgICAgKVxuICAgICksIE4uYXBwZW5kT3JTZWxlY3QobiwgXCJnLngtbGFiZWxzXCIpLmF0dHIoXCJyb2xlXCIsIGh0LkdST1VQKS5zZWxlY3RBbGwoXCJ0ZXh0XCIpLmRhdGEodGhpcy51bmlxdWVLZXlzKS5qb2luKFxuICAgICAgKE8pID0+IE8uYXBwZW5kKFwidGV4dFwiKS50ZXh0KCh3KSA9PiB3KS5hdHRyKFwib3BhY2l0eVwiLCAwKS5hdHRyKFxuICAgICAgICBcInhcIixcbiAgICAgICAgKHcpID0+IFV0KF8odyksIGIucmFuZ2UoKVsxXSArIGgsIFIpLnhcbiAgICAgICkuYXR0cihcbiAgICAgICAgXCJ5XCIsXG4gICAgICAgICh3KSA9PiBVdChfKHcpLCBiLnJhbmdlKClbMV0gKyBoLCBSKS55XG4gICAgICApLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgKHcpID0+IHBkKF8odykpLnRleHRBbmNob3IpLnN0eWxlKFxuICAgICAgICBcImRvbWluYW50LWJhc2VsaW5lXCIsXG4gICAgICAgICh3KSA9PiBwZChfKHcpKS5kb21pbmFudEJhc2VsaW5lXG4gICAgICApLmNhbGwoXG4gICAgICAgICh3KSA9PiB3LnRyYW5zaXRpb24oKS5jYWxsKFxuICAgICAgICAgIChMKSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBMLFxuICAgICAgICAgICAgbmFtZTogXCJyYWRhcl94X2xhYmVsc19lbnRlclwiLFxuICAgICAgICAgICAgYW5pbWF0ZTogdFxuICAgICAgICAgIH0pXG4gICAgICAgICkuYXR0cihcIm9wYWNpdHlcIiwgMSlcbiAgICAgICksXG4gICAgICAoTykgPT4gTy5jYWxsKFxuICAgICAgICAodykgPT4gdy50cmFuc2l0aW9uKCkuY2FsbChcbiAgICAgICAgICAoTCkgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICAgICAgdHJhbnNpdGlvbjogTCxcbiAgICAgICAgICAgIG5hbWU6IFwicmFkYXJfeF9sYWJlbHNfdXBkYXRlXCIsXG4gICAgICAgICAgICBhbmltYXRlOiB0XG4gICAgICAgICAgfSlcbiAgICAgICAgKS5hdHRyKFwib3BhY2l0eVwiLCAxKS5hdHRyKFxuICAgICAgICAgIFwieFwiLFxuICAgICAgICAgIChMKSA9PiBVdChfKEwpLCBiLnJhbmdlKClbMV0gKyBoLCBSKS54XG4gICAgICAgICkuYXR0cihcbiAgICAgICAgICBcInlcIixcbiAgICAgICAgICAoTCkgPT4gVXQoXyhMKSwgYi5yYW5nZSgpWzFdICsgaCwgUikueVxuICAgICAgICApLmVuZCgpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IEwgPSB5KG8sIFwicmFkYXJcIiwgXCJhbGlnbm1lbnRcIiksIGsgPSB0aGlzLmdldEFsaWdubWVudFhPZmZzZXQoTCwgbiwgdGhpcy5nZXRQYXJlbnQoKSk7XG4gICAgICAgICAgbi5hdHRyKFwieFwiLCBrKTtcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICAoTykgPT4gTy5jYWxsKFxuICAgICAgICAodykgPT4gdy50cmFuc2l0aW9uKCkuY2FsbChcbiAgICAgICAgICAoTCkgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICAgICAgdHJhbnNpdGlvbjogTCxcbiAgICAgICAgICAgIG5hbWU6IFwicmFkYXJfeF9sYWJlbHNfZXhpdFwiLFxuICAgICAgICAgICAgYW5pbWF0ZTogdFxuICAgICAgICAgIH0pXG4gICAgICAgICkuYXR0cihcIm9wYWNpdHlcIiwgMCkucmVtb3ZlKClcbiAgICAgIClcbiAgICApLCBOLmFwcGVuZE9yU2VsZWN0KG4sIFwiZy5ibG9ic1wiKS5hdHRyKFwicm9sZVwiLCBodC5HUk9VUCkuc2VsZWN0QWxsKFwicGF0aFwiKS5kYXRhKHRoaXMuZ3JvdXBlZERhdGFOb3JtYWxpemVkLCAoTykgPT4gTy5uYW1lKS5qb2luKFxuICAgICAgKE8pID0+IE8uYXBwZW5kKFwicGF0aFwiKS5hdHRyKFxuICAgICAgICBcImNsYXNzXCIsXG4gICAgICAgICh3KSA9PiB0aGlzLm1vZGVsLmdldENvbG9yQ2xhc3NOYW1lKHtcbiAgICAgICAgICBjbGFzc05hbWVUeXBlczogW2l0LkZJTEwsIGl0LlNUUk9LRV0sXG4gICAgICAgICAgZGF0YUdyb3VwTmFtZTogdy5uYW1lLFxuICAgICAgICAgIG9yaWdpbmFsQ2xhc3NOYW1lOiBcImJsb2JcIlxuICAgICAgICB9KVxuICAgICAgKS5hdHRyKFwicm9sZVwiLCBodC5HUkFQSElDU19TWU1CT0wpLmF0dHIoXCJhcmlhLWxhYmVsXCIsICh3KSA9PiB3Lm5hbWUpLmF0dHIoXCJvcGFjaXR5XCIsIDApLmF0dHIoXG4gICAgICAgIFwidHJhbnNmb3JtXCIsXG4gICAgICAgIHQgPyAoKSA9PiBgdHJhbnNsYXRlKCR7Ui54fSwgJHtSLnl9KSBzY2FsZSgkezEgKyBNYXRoLnJhbmRvbSgpICogMC4zNX0pYCA6IGB0cmFuc2xhdGUoJHtSLnh9LCAke1IueX0pYFxuICAgICAgKS5zdHlsZShcImZpbGxcIiwgKHcpID0+IE0ody5uYW1lLCBudWxsLCB3LmRhdGEpKS5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBXbi5vcGFjaXR5LnNlbGVjdGVkKS5zdHlsZShcInN0cm9rZVwiLCAodykgPT4gTSh3Lm5hbWUsIG51bGwsIHcuZGF0YSkpLmNhbGwoKHcpID0+IHtcbiAgICAgICAgY29uc3QgTCA9IHcudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAgICAgKGspID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IGssXG4gICAgICAgICAgICBuYW1lOiBcInJhZGFyX2Jsb2JzX2VudGVyXCIsXG4gICAgICAgICAgICBhbmltYXRlOiB0XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgdCAmJiBMLmRlbGF5KCgpID0+IE1hdGgucmFuZG9tKCkgKiAzMCkuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7Ui54fSwgJHtSLnl9KWApLCBMLmF0dHIoXCJvcGFjaXR5XCIsIDEpLmF0dHIoXCJkXCIsIChrKSA9PiBEKGsuZGF0YSkpO1xuICAgICAgfSksXG4gICAgICAoTykgPT4gKE8uYXR0cihcbiAgICAgICAgXCJjbGFzc1wiLFxuICAgICAgICAodykgPT4gdGhpcy5tb2RlbC5nZXRDb2xvckNsYXNzTmFtZSh7XG4gICAgICAgICAgY2xhc3NOYW1lVHlwZXM6IFtpdC5GSUxMLCBpdC5TVFJPS0VdLFxuICAgICAgICAgIGRhdGFHcm91cE5hbWU6IHcubmFtZSxcbiAgICAgICAgICBvcmlnaW5hbENsYXNzTmFtZTogXCJibG9iXCJcbiAgICAgICAgfSlcbiAgICAgICkuc3R5bGUoXCJmaWxsXCIsICh3KSA9PiBNKHcubmFtZSwgbnVsbCwgdy5kYXRhKSkuc3R5bGUoXCJzdHJva2VcIiwgKHcpID0+IE0ody5uYW1lLCBudWxsLCB3LmRhdGEpKSwgTy5jYWxsKFxuICAgICAgICAodykgPT4gdy50cmFuc2l0aW9uKCkuY2FsbChcbiAgICAgICAgICAoTCkgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICAgICAgdHJhbnNpdGlvbjogTCxcbiAgICAgICAgICAgIG5hbWU6IFwicmFkYXJfYmxvYnNfdXBkYXRlXCIsXG4gICAgICAgICAgICBhbmltYXRlOiB0XG4gICAgICAgICAgfSlcbiAgICAgICAgKS5hdHRyKFwib3BhY2l0eVwiLCAxKS5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHtSLnh9LCAke1IueX0pYCkuYXR0cihcImRcIiwgKEwpID0+IEQoTC5kYXRhKSlcbiAgICAgICksIE8pLFxuICAgICAgKE8pID0+IE8uY2FsbCgodykgPT4ge1xuICAgICAgICBjb25zdCBMID0gdy50cmFuc2l0aW9uKCkuY2FsbChcbiAgICAgICAgICAoaykgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICAgICAgdHJhbnNpdGlvbjogayxcbiAgICAgICAgICAgIG5hbWU6IFwicmFkYXJfYmxvYnNfZXhpdFwiLFxuICAgICAgICAgICAgYW5pbWF0ZTogdFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHQgJiYgTC5kZWxheSgoKSA9PiBNYXRoLnJhbmRvbSgpICogMzApLmF0dHIoXG4gICAgICAgICAgXCJ0cmFuc2Zvcm1cIixcbiAgICAgICAgICAoKSA9PiBgdHJhbnNsYXRlKCR7Ui54fSwgJHtSLnl9KSBzY2FsZSgkezEgKyBNYXRoLnJhbmRvbSgpICogMC4zNX0pYFxuICAgICAgICApLCBMLmF0dHIoXCJvcGFjaXR5XCIsIDApLnJlbW92ZSgpO1xuICAgICAgfSlcbiAgICApLCBOLmFwcGVuZE9yU2VsZWN0KG4sIFwiZy5kb3RzXCIpLmF0dHIoXCJyb2xlXCIsIGh0LkdST1VQKS5zZWxlY3RBbGwoXCJjaXJjbGVcIikuZGF0YSh0aGlzLmZ1bGxEYXRhTm9ybWFsaXplZC5maWx0ZXIoKE8pID0+IHkoTywgZCkgIT09IG51bGwpKS5qb2luKFxuICAgICAgKE8pID0+IE8uYXBwZW5kKFwiY2lyY2xlXCIpLmF0dHIoXCJyb2xlXCIsIGh0LkdSQVBISUNTX1NZTUJPTCkuYXR0cihcImFyaWEtbGFiZWxcIiwgKHcpID0+IHdbY10pLFxuICAgICAgKE8pID0+IE8sXG4gICAgICAoTykgPT4gTy5yZW1vdmUoKVxuICAgICkuYXR0cihcbiAgICAgIFwiY2xhc3NcIixcbiAgICAgIChPKSA9PiB0aGlzLm1vZGVsLmdldENvbG9yQ2xhc3NOYW1lKHtcbiAgICAgICAgY2xhc3NOYW1lVHlwZXM6IFtpdC5GSUxMXSxcbiAgICAgICAgZGF0YUdyb3VwTmFtZTogT1tsXSxcbiAgICAgICAgb3JpZ2luYWxDbGFzc05hbWU6IFRyKE9bdV0pXG4gICAgICB9KVxuICAgICkuYXR0cihcImN4XCIsIChPKSA9PiBVdChfKE9bdV0pLCBiKE9bZF0pLCBSKS54KS5hdHRyKFwiY3lcIiwgKE8pID0+IFV0KF8oT1t1XSksIGIoT1tkXSksIFIpLnkpLmF0dHIoXCJyXCIsIDApLmF0dHIoXCJvcGFjaXR5XCIsIDApLnN0eWxlKFwiZmlsbFwiLCAoTykgPT4gTShPW2xdKSksIE4uYXBwZW5kT3JTZWxlY3QobiwgXCJnLngtYXhlcy1yZWN0XCIpLmF0dHIoXCJyb2xlXCIsIGh0LkdST1VQKS5zZWxlY3RBbGwoXCJyZWN0XCIpLmRhdGEodGhpcy51bmlxdWVLZXlzKS5qb2luKFxuICAgICAgKE8pID0+IE8uYXBwZW5kKFwicmVjdFwiKSxcbiAgICAgIChPKSA9PiBPLFxuICAgICAgKE8pID0+IE8ucmVtb3ZlKClcbiAgICApLmF0dHIoXCJ4XCIsIFIueCkuYXR0cihcInlcIiwgUi55IC0gbSAvIDIpLmF0dHIoXCJ3aWR0aFwiLCBiLnJhbmdlKClbMV0pLmF0dHIoXCJoZWlnaHRcIiwgbSkuc3R5bGUoXCJmaWxsXCIsIFwicmVkXCIpLnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIDApLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgKE8pID0+IGByb3RhdGUoJHtwZyhfKE8pKX0sICR7Ui54fSwgJHtSLnl9KWApO1xuICAgIGNvbnN0IHsgY29kZTogUCwgbnVtYmVyOiBCIH0gPSB5KG8sIFwibG9jYWxlXCIpO1xuICAgIE4uYXBwZW5kT3JTZWxlY3QobiwgXCJnLnktbGFiZWxzXCIpLmF0dHIoXCJyb2xlXCIsIGh0LkdST1VQKS5zZWxlY3RBbGwoXCJ0ZXh0XCIpLmRhdGEoemUoUykpLmpvaW4oXG4gICAgICAoTykgPT4gTy5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoXCJvcGFjaXR5XCIsIDApLnRleHQoKHcpID0+IEIodywgUCkpLmF0dHIoXG4gICAgICAgIFwieFwiLFxuICAgICAgICAodykgPT4gVXQoLU1hdGguUEkgLyAyLCBiKHcpLCBSKS54ICsgcFxuICAgICAgKS5hdHRyKFwieVwiLCAodykgPT4gVXQoLU1hdGguUEkgLyAyLCBiKHcpLCBSKS55KS5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwic3RhcnRcIikuc3R5bGUoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcIm1pZGRsZVwiKS5jYWxsKFxuICAgICAgICAodykgPT4gdy50cmFuc2l0aW9uKCkuY2FsbChcbiAgICAgICAgICAoTCkgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICAgICAgdHJhbnNpdGlvbjogTCxcbiAgICAgICAgICAgIG5hbWU6IFwicmFkYXJfeV9sYWJlbHNfZW50ZXJcIixcbiAgICAgICAgICAgIGFuaW1hdGU6IHRcbiAgICAgICAgICB9KVxuICAgICAgICApLmF0dHIoXCJvcGFjaXR5XCIsIDEpXG4gICAgICApLFxuICAgICAgKE8pID0+IE8uY2FsbChcbiAgICAgICAgKHcpID0+IHcudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAgICAgKEwpID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IEwsXG4gICAgICAgICAgICBuYW1lOiBcInJhZGFyX3lfbGFiZWxzX3VwZGF0ZVwiLFxuICAgICAgICAgICAgYW5pbWF0ZTogdFxuICAgICAgICAgIH0pXG4gICAgICAgICkudGV4dCgoTCkgPT4gTCkuYXR0cihcIm9wYWNpdHlcIiwgMSkuYXR0cihcbiAgICAgICAgICBcInhcIixcbiAgICAgICAgICAoTCkgPT4gVXQoLU1hdGguUEkgLyAyLCBiKEwpLCBSKS54ICsgcFxuICAgICAgICApLmF0dHIoXCJ5XCIsIChMKSA9PiBVdCgtTWF0aC5QSSAvIDIsIGIoTCksIFIpLnkpXG4gICAgICApLFxuICAgICAgKE8pID0+IE8uY2FsbChcbiAgICAgICAgKHcpID0+IHcudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAgICAgKEwpID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IEwsXG4gICAgICAgICAgICBuYW1lOiBcInJhZGFyX3lfbGFiZWxzX2V4aXRcIixcbiAgICAgICAgICAgIGFuaW1hdGU6IHRcbiAgICAgICAgICB9KVxuICAgICAgICApLmF0dHIoXCJvcGFjaXR5XCIsIDApLnJlbW92ZSgpXG4gICAgICApXG4gICAgKSwgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICB9XG4gIGdldEFsaWdubWVudFhPZmZzZXQodCwgbiwgcikge1xuICAgIGNvbnN0IGkgPSBOLmdldFNWR0VsZW1lbnRTaXplKG4sIHtcbiAgICAgIHVzZUJCb3g6ICEwXG4gICAgfSksIHsgd2lkdGg6IHMgfSA9IE4uZ2V0U1ZHRWxlbWVudFNpemUociwge1xuICAgICAgdXNlQXR0cnM6ICEwXG4gICAgfSk7XG4gICAgbGV0IGEgPSAwO1xuICAgIHJldHVybiB0ID09PSBqdC5DRU5URVIgPyBhID0gTWF0aC5mbG9vcigocyAtIGkud2lkdGgpIC8gMikgOiB0ID09PSBqdC5SSUdIVCAmJiAoYSA9IHMgLSBpLndpZHRoKSwgYTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcIi54LWF4ZXMtcmVjdCA+IHJlY3RcIikub24oXCJtb3VzZW92ZXJcIiwgbnVsbCkub24oXCJtb3VzZW1vdmVcIiwgbnVsbCkub24oXCJtb3VzZW91dFwiLCBudWxsKTtcbiAgICBjb25zdCB0ID0gdGhpcy5zZXJ2aWNlcy5ldmVudHM7XG4gICAgdC5yZW1vdmVFdmVudExpc3RlbmVyKFQuTGVnZW5kLklURU1fSE9WRVIsIHRoaXMuaGFuZGxlTGVnZW5kT25Ib3ZlciksIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX01PVVNFT1VULCB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlT3V0KTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICBjb25zdCB0ID0gdGhpcywge1xuICAgICAgYXhlczogeyBhbmdsZTogbiB9XG4gICAgfSA9IHkodGhpcy5nZXRPcHRpb25zKCksIFwicmFkYXJcIik7XG4gICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwiLngtYXhlcy1yZWN0ID4gcmVjdFwiKS5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbihyLCBpKSB7XG4gICAgICBjb25zdCBzID0gSSh0aGlzKTtcbiAgICAgIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5SYWRhci5YX0FYSVNfTU9VU0VPVkVSLCB7XG4gICAgICAgIGV2ZW50OiByLFxuICAgICAgICBlbGVtZW50OiBzLFxuICAgICAgICBkYXR1bTogaVxuICAgICAgfSk7XG4gICAgICBjb25zdCBhID0gdC5wYXJlbnQuc2VsZWN0KGAueC1heGVzIC54LWF4aXMtJHtUcihpKX1gKSwgbyA9IHQucGFyZW50LnNlbGVjdEFsbChgLmRvdHMgY2lyY2xlLiR7VHIoaSl9YCksIGwgPSB0Lm1vZGVsLmdldEFjdGl2ZURhdGFHcm91cE5hbWVzKCksIGMgPSB0LmdldE9wdGlvbnMoKSwgeyBncm91cE1hcHNUbzogdSB9ID0gYy5kYXRhLCBkID0geShjLCBcInJhZGFyXCIsIFwiYXhlc1wiLCBcInZhbHVlXCIpO1xuICAgICAgYS5jbGFzc2VkKFwiaG92ZXJlZFwiLCAhMCkuYXR0cihcInN0cm9rZS1kYXNoYXJyYXlcIiwgXCI0IDRcIiksIG8uY2xhc3NlZChcImhvdmVyZWRcIiwgITApLmF0dHIoXG4gICAgICAgIFwib3BhY2l0eVwiLFxuICAgICAgICAocCkgPT4gbC5pbmRleE9mKHBbdV0pICE9PSAtMSA/IDEgOiAwXG4gICAgICApLmF0dHIoXCJyXCIsIFduLmRvdHNSYWRpdXMpO1xuICAgICAgY29uc3QgaCA9IHQuZnVsbERhdGFOb3JtYWxpemVkLmZpbHRlcihcbiAgICAgICAgKHApID0+IHBbbl0gPT09IGkgJiYgbC5pbmRleE9mKHBbdV0pICE9PSAtMVxuICAgICAgKTtcbiAgICAgIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLlNIT1csIHtcbiAgICAgICAgZXZlbnQ6IHIsXG4gICAgICAgIGhvdmVyZWRFbGVtZW50OiBzLFxuICAgICAgICBpdGVtczogaC5maWx0ZXIoKHApID0+IHR5cGVvZiBwW2RdID09IFwibnVtYmVyXCIpLm1hcCgocCkgPT4gKHtcbiAgICAgICAgICBsYWJlbDogcFt1XSxcbiAgICAgICAgICB2YWx1ZTogcFtkXSxcbiAgICAgICAgICBjb2xvcjogdC5tb2RlbC5nZXRGaWxsQ29sb3IocFt1XSwgbnVsbCwgcCksXG4gICAgICAgICAgY2xhc3M6IHQubW9kZWwuZ2V0Q29sb3JDbGFzc05hbWUoe1xuICAgICAgICAgICAgY2xhc3NOYW1lVHlwZXM6IFtpdC5UT09MVElQXSxcbiAgICAgICAgICAgIGRhdGFHcm91cE5hbWU6IHBbdV1cbiAgICAgICAgICB9KVxuICAgICAgICB9KSlcbiAgICAgIH0pO1xuICAgIH0pLm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKHIsIGkpIHtcbiAgICAgIGNvbnN0IHMgPSBJKHRoaXMpO1xuICAgICAgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlJhZGFyLlhfQVhJU19NT1VTRU1PVkUsIHtcbiAgICAgICAgZXZlbnQ6IHIsXG4gICAgICAgIGVsZW1lbnQ6IHMsXG4gICAgICAgIGRhdHVtOiBpXG4gICAgICB9KSwgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuTU9WRSwge1xuICAgICAgICBldmVudDogclxuICAgICAgfSk7XG4gICAgfSkub24oXCJjbGlja1wiLCBmdW5jdGlvbihyLCBpKSB7XG4gICAgICB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuUmFkYXIuWF9BWElTX0NMSUNLLCB7XG4gICAgICAgIGV2ZW50OiByLFxuICAgICAgICBlbGVtZW50OiBJKHRoaXMpLFxuICAgICAgICBkYXR1bTogaVxuICAgICAgfSk7XG4gICAgfSkub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihyLCBpKSB7XG4gICAgICBjb25zdCBzID0gSSh0aGlzKSwgYSA9IHQucGFyZW50LnNlbGVjdChgLngtYXhlcyAueC1heGlzLSR7VHIoaSl9YCksIG8gPSB0LnBhcmVudC5zZWxlY3RBbGwoYC5kb3RzIGNpcmNsZS4ke1RyKGkpfWApO1xuICAgICAgYS5jbGFzc2VkKFwiaG92ZXJlZFwiLCAhMSkuYXR0cihcInN0cm9rZS1kYXNoYXJyYXlcIiwgXCIwXCIpLCBvLmNsYXNzZWQoXCJob3ZlcmVkXCIsICExKS5hdHRyKFwib3BhY2l0eVwiLCAwKS5hdHRyKFwiclwiLCAwKSwgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlJhZGFyLlhfQVhJU19NT1VTRU9VVCwge1xuICAgICAgICBldmVudDogcixcbiAgICAgICAgZWxlbWVudDogcyxcbiAgICAgICAgZGF0dW06IGlcbiAgICAgIH0pLCB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5ISURFKTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgJHYgZXh0ZW5kcyBodSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IFwic2ltcGxlLWJhclwiLCB0aGlzLnJlbmRlclR5cGUgPSBydC5TVkcsIHRoaXMuaGFuZGxlTGVnZW5kT25Ib3ZlciA9ICh0KSA9PiB7XG4gICAgICBjb25zdCB7IGhvdmVyZWRFbGVtZW50OiBuIH0gPSB0LmRldGFpbCwgeyBncm91cE1hcHNUbzogciB9ID0gdGhpcy5nZXRPcHRpb25zKCkuZGF0YTtcbiAgICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcInBhdGguYmFyXCIpLnRyYW5zaXRpb24oXCJsZWdlbmQtaG92ZXItc2ltcGxlLWJhclwiKS5jYWxsKFxuICAgICAgICAoaSkgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICAgIHRyYW5zaXRpb246IGksXG4gICAgICAgICAgbmFtZTogXCJsZWdlbmQtaG92ZXItc2ltcGxlLWJhclwiXG4gICAgICAgIH0pXG4gICAgICApLmF0dHIoXCJvcGFjaXR5XCIsIChpKSA9PiBpW3JdICE9PSBuLmRhdHVtKCkubmFtZSA/IDAuMyA6IDEpO1xuICAgIH0sIHRoaXMuaGFuZGxlTGVnZW5kTW91c2VPdXQgPSAoKSA9PiB7XG4gICAgICB0aGlzLnBhcmVudC5zZWxlY3RBbGwoXCJwYXRoLmJhclwiKS50cmFuc2l0aW9uKFwibGVnZW5kLW1vdXNlb3V0LXNpbXBsZS1iYXJcIikuY2FsbChcbiAgICAgICAgKHQpID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICB0cmFuc2l0aW9uOiB0LFxuICAgICAgICAgIG5hbWU6IFwibGVnZW5kLW1vdXNlb3V0LXNpbXBsZS1iYXJcIlxuICAgICAgICB9KVxuICAgICAgKS5hdHRyKFwib3BhY2l0eVwiLCAxKTtcbiAgICB9O1xuICB9XG4gIGluaXQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuc2VydmljZXMuZXZlbnRzO1xuICAgIHQuYWRkRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX0hPVkVSLCB0aGlzLmhhbmRsZUxlZ2VuZE9uSG92ZXIpLCB0LmFkZEV2ZW50TGlzdGVuZXIoVC5MZWdlbmQuSVRFTV9NT1VTRU9VVCwgdGhpcy5oYW5kbGVMZWdlbmRNb3VzZU91dCk7XG4gIH1cbiAgcmVuZGVyKHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRPcHRpb25zKCksIHsgZ3JvdXBNYXBzVG86IHIgfSA9IG4uZGF0YSwgaSA9IHRoaXMuZ2V0Q29tcG9uZW50Q29udGFpbmVyKHtcbiAgICAgIGFyaWFMYWJlbDogXCJiYXIgZ3JhcGhzXCIsXG4gICAgICB3aXRoaW5DaGFydENsaXA6ICEwXG4gICAgfSksIHMgPSB0aGlzLm1vZGVsLmdldERpc3BsYXlEYXRhKHRoaXMuY29uZmlncy5ncm91cHMpLCBhID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0T3JpZW50YXRpb24oKSwgbyA9IGkuc2VsZWN0QWxsKFwicGF0aC5iYXJcIikuZGF0YShzLCAobCkgPT4gbFtyXSk7XG4gICAgby5leGl0KCkuYXR0cihcIm9wYWNpdHlcIiwgMCkucmVtb3ZlKCksIG8uZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpLmF0dHIoXCJvcGFjaXR5XCIsIDApLm1lcmdlKG8pLmNsYXNzZWQoXCJiYXJcIiwgITApLmF0dHIoXCJ3aWR0aFwiLCB0aGlzLmdldEJhcldpZHRoLmJpbmQodGhpcykpLnRyYW5zaXRpb24oKS5jYWxsKFxuICAgICAgKGwpID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgdHJhbnNpdGlvbjogbCxcbiAgICAgICAgbmFtZTogXCJiYXItdXBkYXRlLWVudGVyXCIsXG4gICAgICAgIGFuaW1hdGU6IHRcbiAgICAgIH0pXG4gICAgKS5hdHRyKFxuICAgICAgXCJjbGFzc1wiLFxuICAgICAgKGwpID0+IHRoaXMubW9kZWwuZ2V0Q29sb3JDbGFzc05hbWUoe1xuICAgICAgICBjbGFzc05hbWVUeXBlczogW2l0LkZJTExdLFxuICAgICAgICBkYXRhR3JvdXBOYW1lOiBsW3JdLFxuICAgICAgICBvcmlnaW5hbENsYXNzTmFtZTogXCJiYXJcIlxuICAgICAgfSlcbiAgICApLnN0eWxlKFwiZmlsbFwiLCAobCkgPT4ge1xuICAgICAgY29uc3QgYyA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpbklkZW50aWZpZXIobCk7XG4gICAgICByZXR1cm4gdGhpcy5tb2RlbC5nZXRGaWxsQ29sb3IobFtyXSwgbFtjXSwgbCk7XG4gICAgfSkuYXR0cihcImRcIiwgKGwpID0+IHtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRSYW5nZUlkZW50aWZpZXIoKSwgdSA9IHRoaXMuZ2V0QmFyV2lkdGgoKSwgZCA9IGxbY10sIGggPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXREb21haW5WYWx1ZShsKSAtIHUgLyAyLCBwID0gaCArIHU7XG4gICAgICBsZXQgZiwgZztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGQpICYmIGQubGVuZ3RoID09PSAyKVxuICAgICAgICBmID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0UmFuZ2VWYWx1ZShkWzBdKSwgZyA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlVmFsdWUoZFsxXSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlU2NhbGUoKS5kb21haW4oKVswXTtcbiAgICAgICAgZiA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlVmFsdWUoTWF0aC5tYXgoMCwgdikpLCBnID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0UmFuZ2VWYWx1ZShsKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG0gPSBNYXRoLmFicyhnIC0gZik7XG4gICAgICBpZiAobSAhPT0gMCAmJiBtIDwgMiAmJiAoZCA+IDAgJiYgYSA9PT0gRnQuVkVSVElDQUwgfHwgZCA8IDAgJiYgYSA9PT0gRnQuSE9SSVpPTlRBTCA/IGcgPSBmIC0gMiA6IGcgPSBmICsgMiksICF0aGlzLmlzT3V0c2lkZVpvb21lZERvbWFpbihoLCBwKSlcbiAgICAgICAgcmV0dXJuIGFlKHsgeDA6IGgsIHgxOiBwLCB5MDogZiwgeTE6IGcgfSwgYSk7XG4gICAgfSkuYXR0cihcIm9wYWNpdHlcIiwgMSkuYXR0cihcInJvbGVcIiwgaHQuR1JBUEhJQ1NfU1lNQk9MKS5hdHRyKFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIiwgXCJiYXJcIikuYXR0cihcImFyaWEtbGFiZWxcIiwgKGwpID0+IGwudmFsdWUpLCB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXM7XG4gICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwicGF0aC5iYXJcIikub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24obiwgcikge1xuICAgICAgY29uc3QgaSA9IEkodGhpcyk7XG4gICAgICBpLmNsYXNzZWQoXCJob3ZlcmVkXCIsICEwKSwgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkJhci5CQVJfTU9VU0VPVkVSLCB7XG4gICAgICAgIGV2ZW50OiBuLFxuICAgICAgICBlbGVtZW50OiBpLFxuICAgICAgICBkYXR1bTogclxuICAgICAgfSksIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLlNIT1csIHtcbiAgICAgICAgZXZlbnQ6IG4sXG4gICAgICAgIGhvdmVyZWRFbGVtZW50OiBpLFxuICAgICAgICBkYXRhOiBbcl1cbiAgICAgIH0pO1xuICAgIH0pLm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKG4sIHIpIHtcbiAgICAgIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5CYXIuQkFSX01PVVNFTU9WRSwge1xuICAgICAgICBldmVudDogbixcbiAgICAgICAgZWxlbWVudDogSSh0aGlzKSxcbiAgICAgICAgZGF0dW06IHJcbiAgICAgIH0pLCB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5NT1ZFLCB7XG4gICAgICAgIGV2ZW50OiBuXG4gICAgICB9KTtcbiAgICB9KS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKG4sIHIpIHtcbiAgICAgIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5CYXIuQkFSX0NMSUNLLCB7XG4gICAgICAgIGV2ZW50OiBuLFxuICAgICAgICBlbGVtZW50OiBJKHRoaXMpLFxuICAgICAgICBkYXR1bTogclxuICAgICAgfSk7XG4gICAgfSkub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihuLCByKSB7XG4gICAgICBjb25zdCBpID0gSSh0aGlzKTtcbiAgICAgIGkuY2xhc3NlZChcImhvdmVyZWRcIiwgITEpLCB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuQmFyLkJBUl9NT1VTRU9VVCwge1xuICAgICAgICBldmVudDogbixcbiAgICAgICAgZWxlbWVudDogaSxcbiAgICAgICAgZGF0dW06IHJcbiAgICAgIH0pLCB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5ISURFLCB7XG4gICAgICAgIGhvdmVyZWRFbGVtZW50OiBpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcInBhdGguYmFyXCIpLm9uKFwibW91c2VvdmVyXCIsIG51bGwpLm9uKFwibW91c2Vtb3ZlXCIsIG51bGwpLm9uKFwibW91c2VvdXRcIiwgbnVsbCk7XG4gICAgY29uc3QgdCA9IHRoaXMuc2VydmljZXMuZXZlbnRzO1xuICAgIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX0hPVkVSLCB0aGlzLmhhbmRsZUxlZ2VuZE9uSG92ZXIpLCB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoVC5MZWdlbmQuSVRFTV9NT1VTRU9VVCwgdGhpcy5oYW5kbGVMZWdlbmRNb3VzZU91dCk7XG4gIH1cbn1cbmNsYXNzIHpEIGV4dGVuZHMgY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnR5cGUgPSBcInNrZWxldG9uLWxpbmVzXCI7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcmVuZGVyKHQgPSAhMCkge1xuICAgIGNvbnN0IG4gPSB5KHRoaXMuZ2V0T3B0aW9ucygpLCBcImRhdGFcIiwgXCJsb2FkaW5nXCIpLCByID0gIXkodGhpcy5nZXRPcHRpb25zKCksIFwiZ3JpZFwiLCBcInhcIiwgXCJlbmFibGVkXCIpICYmICF5KHRoaXMuZ2V0T3B0aW9ucygpLCBcImdyaWRcIiwgXCJ5XCIsIFwiZW5hYmxlZFwiKSAmJiAheSh0aGlzLmdldE9wdGlvbnMoKSwgXCJheGVzXCIsIFwiYm90dG9tXCIsIFwidmlzaWJsZVwiKSAmJiAheSh0aGlzLmdldE9wdGlvbnMoKSwgXCJheGVzXCIsIFwibGVmdFwiLCBcInZpc2libGVcIik7XG4gICAgbiAmJiAhciA/IHN1cGVyLnJlbmRlckdyaWRTa2VsZXRvbihuKSA6IG4gJiYgciA/IHRoaXMucmVuZGVyU3BhcmtsaW5lU2tlbGV0b24obikgOiB0aGlzLnJlbW92ZVNrZWxldG9uKCk7XG4gIH1cbiAgcmVuZGVyU3BhcmtsaW5lU2tlbGV0b24odCkge1xuICAgIHRoaXMuc2V0U2NhbGVzKCksIHRoaXMuZHJhd0JhY2tkcm9wKHQpLCB0aGlzLmRyYXdTcGFya2xpbmUodCksIHRoaXMudXBkYXRlQmFja2Ryb3BTdHlsZSgpLCB0ICYmIHRoaXMuc2V0U2hpbW1lckVmZmVjdChcInNoaW1tZXItbGluZXNcIik7XG4gIH1cbiAgZHJhd1NwYXJrbGluZSh0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMuYmFja2Ryb3AuYXR0cihcIndpZHRoXCIpLCByID0gWzEwMF0sIGkgPSBOLmFwcGVuZE9yU2VsZWN0KHRoaXMuYmFja2Ryb3AsIFwiZy55LnNrZWxldG9uXCIpLCBzID0gaS5zZWxlY3RBbGwoXCJsaW5lXCIpLmRhdGEocik7XG4gICAgcy5lbnRlcigpLmFwcGVuZChcImxpbmVcIikubWVyZ2UocykuYXR0cihcIngxXCIsIDApLmF0dHIoXCJ4MlwiLCBuKS5hdHRyKFwieTFcIiwgKGEpID0+IGEpLmF0dHIoXCJ5MlwiLCAoYSkgPT4gYSksIGkuc2VsZWN0QWxsKFwibGluZVwiKS5jbGFzc2VkKFwic2hpbW1lci1lZmZlY3QtbGluZXNcIiwgdCkuY2xhc3NlZChcImVtcHR5LXN0YXRlLWxpbmVzXCIsICF0KS5zdHlsZShcbiAgICAgIFwic3Ryb2tlXCIsXG4gICAgICB0ID8gYHVybCgjJHt0aGlzLnNlcnZpY2VzLmRvbVV0aWxzLmdlbmVyYXRlRWxlbWVudElEU3RyaW5nKFwic2hpbW1lci1saW5lc1wiKX0pYCA6IG51bGxcbiAgICApO1xuICB9XG4gIHVwZGF0ZUJhY2tkcm9wU3R5bGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMucGFyZW50O1xuICAgIHRoaXMuYmFja2Ryb3AgPSBOLmFwcGVuZE9yU2VsZWN0KHQsIFwic3ZnLmNoYXJ0LXNrZWxldG9uLkRBSUlcIikuYXR0cihcbiAgICAgIFwicm9sZVwiLFxuICAgICAgXCJwcmVzZW50YXRpb25cIlxuICAgICksIE4uYXBwZW5kT3JTZWxlY3QodGhpcy5iYWNrZHJvcCwgXCJyZWN0LmNoYXJ0LXNrZWxldG9uLWJhY2tkcm9wXCIpLmNsYXNzZWQoXCJzaGltbWVyLWVmZmVjdC1saW5lc1wiLCAhMSkuY2xhc3NlZChcInNoaW1tZXItZWZmZWN0LXNwYXJrbGluZVwiLCAhMCkuc3R5bGUoXCJzdHJva2VcIiwgbnVsbCk7XG4gIH1cbn1cbmNsYXNzIE12IGV4dGVuZHMgbXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnR5cGUgPSBcImFyZWEtc3RhY2tlZFwiLCB0aGlzLnJlbmRlclR5cGUgPSBydC5TVkcsIHRoaXMuaGFuZGxlTGVnZW5kT25Ib3ZlciA9ICh0KSA9PiB7XG4gICAgICBjb25zdCB7IGhvdmVyZWRFbGVtZW50OiBuIH0gPSB0LmRldGFpbCwgciA9IHRoaXMuZ2V0T3B0aW9ucygpLCB7IGdyb3VwTWFwc1RvOiBpIH0gPSByLmRhdGE7XG4gICAgICB0aGlzLnBhcmVudC5zZWxlY3RBbGwoXCJwYXRoLmFyZWFcIikudHJhbnNpdGlvbihcImxlZ2VuZC1ob3Zlci1hcmVhXCIpLmNhbGwoXG4gICAgICAgIChzKSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgdHJhbnNpdGlvbjogcyxcbiAgICAgICAgICBuYW1lOiBcImxlZ2VuZC1ob3Zlci1hcmVhXCJcbiAgICAgICAgfSlcbiAgICAgICkuYXR0cihcIm9wYWNpdHlcIiwgKHMpID0+IHkocywgMCwgaSkgIT09IG4uZGF0dW0oKS5uYW1lID8geW4ub3BhY2l0eS51bnNlbGVjdGVkIDogeW4ub3BhY2l0eS5zZWxlY3RlZCk7XG4gICAgfSwgdGhpcy5oYW5kbGVMZWdlbmRNb3VzZU91dCA9ICgpID0+IHtcbiAgICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcInBhdGguYXJlYVwiKS50cmFuc2l0aW9uKFwibGVnZW5kLW1vdXNlb3V0LWFyZWFcIikuY2FsbChcbiAgICAgICAgKHQpID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICB0cmFuc2l0aW9uOiB0LFxuICAgICAgICAgIG5hbWU6IFwibGVnZW5kLW1vdXNlb3V0LWFyZWFcIlxuICAgICAgICB9KVxuICAgICAgKS5hdHRyKFwib3BhY2l0eVwiLCB5bi5vcGFjaXR5LnNlbGVjdGVkKTtcbiAgICB9O1xuICB9XG4gIGluaXQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuc2VydmljZXMuZXZlbnRzO1xuICAgIHQuYWRkRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX0hPVkVSLCB0aGlzLmhhbmRsZUxlZ2VuZE9uSG92ZXIpLCB0LmFkZEV2ZW50TGlzdGVuZXIoVC5MZWdlbmQuSVRFTV9NT1VTRU9VVCwgdGhpcy5oYW5kbGVMZWdlbmRNb3VzZU91dCk7XG4gIH1cbiAgcmVuZGVyKHQgPSAhMCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldENvbXBvbmVudENvbnRhaW5lcih7XG4gICAgICBhcmlhTGFiZWw6IFwic3RhY2tlZCBhcmVhIGdyYXBoc1wiLFxuICAgICAgd2l0aGluQ2hhcnRDbGlwOiAhMFxuICAgIH0pLCByID0gdGhpcywgaSA9IHRoaXMuZ2V0T3B0aW9ucygpLCB7IGdyb3VwTWFwc1RvOiBzIH0gPSBpLmRhdGEsIGEgPSBPYmplY3Qua2V5cyhpLmF4ZXMpLnNvbWUoKHApID0+IGkuYXhlc1twXS5wZXJjZW50YWdlKSwgbyA9IHRoaXMubW9kZWwuZ2V0U3RhY2tlZERhdGEoe1xuICAgICAgcGVyY2VudGFnZTogYSxcbiAgICAgIGdyb3VwczogdGhpcy5jb25maWdzLmdyb3Vwc1xuICAgIH0pLCBsID0geShvLCAwLCAwKSwgYyA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpbkF4aXNQb3NpdGlvbih7IGRhdHVtOiBsIH0pLCB1ID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0UmFuZ2VBeGlzUG9zaXRpb24oeyBkYXR1bTogbCB9KSwgZCA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFNjYWxlQnlQb3NpdGlvbih1KSwgaCA9IG4uc2VsZWN0QWxsKFwicGF0aC5hcmVhXCIpLmRhdGEobywgKHApID0+IHkocCwgMCwgcykpO1xuICAgIHRoaXMuYXJlYUdlbmVyYXRvciA9IGF1KCkueChcbiAgICAgIChwKSA9PiB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRWYWx1ZVRocm91Z2hBeGlzUG9zaXRpb24oXG4gICAgICAgIGMsXG4gICAgICAgIHAuZGF0YS5zaGFyZWRTdGFja0tleVxuICAgICAgKVxuICAgICkueTAoKHApID0+IGQocFswXSkpLnkxKChwKSA9PiBkKHBbMV0pKS5jdXJ2ZSh0aGlzLnNlcnZpY2VzLmN1cnZlcy5nZXREM0N1cnZlKCkpLCBoLmV4aXQoKS5hdHRyKFwib3BhY2l0eVwiLCAwKS5yZW1vdmUoKSwgaC5lbnRlcigpLmFwcGVuZChcInBhdGhcIikuYXR0cihcIm9wYWNpdHlcIiwgMCkubWVyZ2UoaCkuZGF0YShvLCAocCkgPT4geShwLCAwLCBzKSkuYXR0cihcImNsYXNzXCIsIFwiYXJlYVwiKS5hdHRyKFxuICAgICAgXCJjbGFzc1wiLFxuICAgICAgKHApID0+IHRoaXMubW9kZWwuZ2V0Q29sb3JDbGFzc05hbWUoe1xuICAgICAgICBjbGFzc05hbWVUeXBlczogW2l0LkZJTExdLFxuICAgICAgICBkYXRhR3JvdXBOYW1lOiB5KHAsIDAsIHMpLFxuICAgICAgICBvcmlnaW5hbENsYXNzTmFtZTogXCJhcmVhXCJcbiAgICAgIH0pXG4gICAgKS5zdHlsZShcImZpbGxcIiwgKHApID0+IHIubW9kZWwuZ2V0RmlsbENvbG9yKHkocCwgMCwgcyksIG51bGwsIHApKS5hdHRyKFwicm9sZVwiLCBodC5HUkFQSElDU19TWU1CT0wpLmF0dHIoXCJhcmlhLXJvbGVkZXNjcmlwdGlvblwiLCBcImFyZWFcIikuYXR0cihcImFyaWEtbGFiZWxcIiwgKHApID0+IHkocCwgMCwgcykpLnRyYW5zaXRpb24oKS5jYWxsKFxuICAgICAgKHApID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgdHJhbnNpdGlvbjogcCxcbiAgICAgICAgbmFtZTogXCJhcmVhLXVwZGF0ZS1lbnRlclwiLFxuICAgICAgICBhbmltYXRlOiB0XG4gICAgICB9KVxuICAgICkuYXR0cihcIm9wYWNpdHlcIiwgeW4ub3BhY2l0eS5zZWxlY3RlZCkuYXR0cihcImRcIiwgdGhpcy5hcmVhR2VuZXJhdG9yKTtcbiAgfVxufVxuY2xhc3MgQ3YgZXh0ZW5kcyBodSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IFwic3RhY2tlZC1iYXJcIiwgdGhpcy5yZW5kZXJUeXBlID0gcnQuU1ZHLCB0aGlzLmhhbmRsZUxlZ2VuZE9uSG92ZXIgPSAodCkgPT4ge1xuICAgICAgY29uc3QgeyBob3ZlcmVkRWxlbWVudDogbiB9ID0gdC5kZXRhaWwsIHsgZ3JvdXBNYXBzVG86IHIgfSA9IHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLmRhdGE7XG4gICAgICB0aGlzLnBhcmVudC5zZWxlY3RBbGwoXCJwYXRoLmJhclwiKS50cmFuc2l0aW9uKFwibGVnZW5kLWhvdmVyLWJhclwiKS5jYWxsKFxuICAgICAgICAoaSkgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICAgIHRyYW5zaXRpb246IGksXG4gICAgICAgICAgbmFtZTogXCJsZWdlbmQtaG92ZXItYmFyXCJcbiAgICAgICAgfSlcbiAgICAgICkuYXR0cihcIm9wYWNpdHlcIiwgKGkpID0+IGlbcl0gIT09IG4uZGF0dW0oKS5uYW1lID8gMC4zIDogMSk7XG4gICAgfSwgdGhpcy5oYW5kbGVMZWdlbmRNb3VzZU91dCA9ICgpID0+IHtcbiAgICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcInBhdGguYmFyXCIpLnRyYW5zaXRpb24oXCJsZWdlbmQtbW91c2VvdXQtYmFyXCIpLmNhbGwoXG4gICAgICAgICh0KSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgdHJhbnNpdGlvbjogdCxcbiAgICAgICAgICBuYW1lOiBcImxlZ2VuZC1tb3VzZW91dC1iYXJcIlxuICAgICAgICB9KVxuICAgICAgKS5hdHRyKFwib3BhY2l0eVwiLCAxKTtcbiAgICB9O1xuICB9XG4gIGluaXQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuc2VydmljZXMuZXZlbnRzO1xuICAgIHQuYWRkRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX0hPVkVSLCB0aGlzLmhhbmRsZUxlZ2VuZE9uSG92ZXIpLCB0LmFkZEV2ZW50TGlzdGVuZXIoVC5MZWdlbmQuSVRFTV9NT1VTRU9VVCwgdGhpcy5oYW5kbGVMZWdlbmRNb3VzZU91dCk7XG4gIH1cbiAgcmVuZGVyKHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoeyBhcmlhTGFiZWw6IFwic3RhY2tlZCBiYXIgZ3JhcGhzXCIsIHdpdGhpbkNoYXJ0Q2xpcDogITAgfSksIHIgPSB0aGlzLmdldE9wdGlvbnMoKSwgeyBncm91cE1hcHNUbzogaSB9ID0gci5kYXRhLCBzID0gdGhpcy5tb2RlbC5nZXRTdGFja2VkRGF0YSh7XG4gICAgICBncm91cHM6IHRoaXMuY29uZmlncy5ncm91cHMsXG4gICAgICBkaXZlcmdlbnQ6ICEwXG4gICAgfSksIGEgPSB0aGlzLm1vZGVsLmdldEFjdGl2ZURhdGFHcm91cE5hbWVzKCksIG8gPSBuLnNlbGVjdEFsbChcImcuYmFyc1wiKS5kYXRhKHMsIChjKSA9PiB5KGMsIDAsIGkpKTtcbiAgICBvLmV4aXQoKS5hdHRyKFwib3BhY2l0eVwiLCAwKS5yZW1vdmUoKSwgby5lbnRlcigpLmFwcGVuZChcImdcIikuY2xhc3NlZChcImJhcnNcIiwgITApLmF0dHIoXCJyb2xlXCIsIGh0LkdST1VQKS5hdHRyKFwiZGF0YS1uYW1lXCIsIFwiYmFyc1wiKTtcbiAgICBjb25zdCBsID0gbi5zZWxlY3RBbGwoXCJnLmJhcnNcIikuc2VsZWN0QWxsKFwicGF0aC5iYXJcIikuZGF0YShcbiAgICAgIChjKSA9PiBjLFxuICAgICAgKGMpID0+IGMuZGF0YS5zaGFyZWRTdGFja0tleVxuICAgICk7XG4gICAgbC5leGl0KCkucmVtb3ZlKCksIGwuZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpLm1lcmdlKGwpLmNsYXNzZWQoXCJiYXJcIiwgITApLnRyYW5zaXRpb24oKS5jYWxsKFxuICAgICAgKGMpID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgdHJhbnNpdGlvbjogYyxcbiAgICAgICAgbmFtZTogXCJiYXItdXBkYXRlLWVudGVyXCIsXG4gICAgICAgIGFuaW1hdGU6IHRcbiAgICAgIH0pXG4gICAgKS5hdHRyKFxuICAgICAgXCJjbGFzc1wiLFxuICAgICAgKGMpID0+IHRoaXMubW9kZWwuZ2V0Q29sb3JDbGFzc05hbWUoe1xuICAgICAgICBjbGFzc05hbWVUeXBlczogW2l0LkZJTExdLFxuICAgICAgICBkYXRhR3JvdXBOYW1lOiBjW2ldLFxuICAgICAgICBvcmlnaW5hbENsYXNzTmFtZTogXCJiYXJcIlxuICAgICAgfSlcbiAgICApLnN0eWxlKFxuICAgICAgXCJmaWxsXCIsXG4gICAgICAoYykgPT4gdGhpcy5tb2RlbC5nZXRGaWxsQ29sb3IoY1tpXSwgYy5kYXRhLnNoYXJlZFN0YWNrS2V5LCBjLmRhdGEpXG4gICAgKS5hdHRyKFwiZFwiLCAoYykgPT4ge1xuICAgICAgY29uc3QgdSA9IGMuZGF0YS5zaGFyZWRTdGFja0tleSwgZCA9IHRoaXMuZ2V0QmFyV2lkdGgoKSwgaCA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpblZhbHVlKHUpIC0gZCAvIDIsIHAgPSBoICsgZCwgZiA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlVmFsdWUoY1swXSk7XG4gICAgICBsZXQgZyA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlVmFsdWUoY1sxXSk7XG4gICAgICBpZiAoIXRoaXMuaXNPdXRzaWRlWm9vbWVkRG9tYWluKGgsIHApKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhnIC0gZikgPiAwICYmIE1hdGguYWJzKGcgLSBmKSA+IHIuYmFycy5kaXZpZGVyU2l6ZSkge1xuICAgICAgICAgIGNvbnN0IG0gPSBjWzBdIDwgMCAmJiBjWzFdIDw9IDA7XG4gICAgICAgICAgbSAmJiBhLmxlbmd0aCA+IDEgPyB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRPcmllbnRhdGlvbigpID09PSBGdC5WRVJUSUNBTCA/IGcgKz0gY1sxXSA9PT0gMCA/IDIgOiAxIDogZyAtPSAxIDogbSB8fCAodGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0T3JpZW50YXRpb24oKSA9PT0gRnQuVkVSVElDQUwgPyBnICs9IDEgOiBnIC09IDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZShcbiAgICAgICAgICB7IHgwOiBoLCB4MTogcCwgeTA6IGYsIHkxOiBnIH0sXG4gICAgICAgICAgdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0T3JpZW50YXRpb24oKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pLmF0dHIoXCJvcGFjaXR5XCIsIDEpLmF0dHIoXCJyb2xlXCIsIGh0LkdSQVBISUNTX1NZTUJPTCkuYXR0cihcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCIsIFwiYmFyXCIpLmF0dHIoXCJhcmlhLWxhYmVsXCIsIChjKSA9PiBjWzFdIC0gY1swXSksIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRPcHRpb25zKCksIHsgZ3JvdXBNYXBzVG86IG4gfSA9IHQuZGF0YSwgciA9IHRoaXM7XG4gICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwicGF0aC5iYXJcIikub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oaSwgcykge1xuICAgICAgY29uc3QgYSA9IEkodGhpcyk7XG4gICAgICBhLmNsYXNzZWQoXCJob3ZlcmVkXCIsICEwKSwgci5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkJhci5CQVJfTU9VU0VPVkVSLCB7XG4gICAgICAgIGV2ZW50OiBpLFxuICAgICAgICBlbGVtZW50OiBhLFxuICAgICAgICBkYXR1bTogc1xuICAgICAgfSk7XG4gICAgICBsZXQgbyA9IHIubW9kZWwuZ2V0RGlzcGxheURhdGEoci5jb25maWdzLmdyb3VwcykuZmluZCgobCkgPT4ge1xuICAgICAgICBjb25zdCBjID0gci5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0RG9tYWluSWRlbnRpZmllcihsKSwgdSA9IHIuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlSWRlbnRpZmllcihsKTtcbiAgICAgICAgcmV0dXJuIGxbdV0gPT09IHMuZGF0YVtzW25dXSAmJiBsW2NdLnRvU3RyaW5nKCkgPT09IHMuZGF0YS5zaGFyZWRTdGFja0tleSAmJiBsW25dID09PSBzW25dO1xuICAgICAgfSk7XG4gICAgICBpZiAobyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IGwgPSByLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXREb21haW5JZGVudGlmaWVyKCksIGMgPSByLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRSYW5nZUlkZW50aWZpZXIoKTtcbiAgICAgICAgbyA9IHtcbiAgICAgICAgICBbbF06IHMuZGF0YS5zaGFyZWRTdGFja0tleSxcbiAgICAgICAgICBbY106IHMuZGF0YVtzW25dXSxcbiAgICAgICAgICBbbl06IHNbbl1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHIuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLlNIT1csIHtcbiAgICAgICAgZXZlbnQ6IGksXG4gICAgICAgIGhvdmVyZWRFbGVtZW50OiBhLFxuICAgICAgICBkYXRhOiBbb11cbiAgICAgIH0pO1xuICAgIH0pLm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKGksIHMpIHtcbiAgICAgIGNvbnN0IGEgPSBJKHRoaXMpO1xuICAgICAgci5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkJhci5CQVJfTU9VU0VNT1ZFLCB7XG4gICAgICAgIGV2ZW50OiBpLFxuICAgICAgICBlbGVtZW50OiBhLFxuICAgICAgICBkYXR1bTogc1xuICAgICAgfSksIHIuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLk1PVkUsIHtcbiAgICAgICAgZXZlbnQ6IGlcbiAgICAgIH0pO1xuICAgIH0pLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oaSwgcykge1xuICAgICAgci5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkJhci5CQVJfQ0xJQ0ssIHtcbiAgICAgICAgZXZlbnQ6IGksXG4gICAgICAgIGVsZW1lbnQ6IEkodGhpcyksXG4gICAgICAgIGRhdHVtOiBzXG4gICAgICB9KTtcbiAgICB9KS5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKGksIHMpIHtcbiAgICAgIGNvbnN0IGEgPSBJKHRoaXMpO1xuICAgICAgYS5jbGFzc2VkKFwiaG92ZXJlZFwiLCAhMSksIHIuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5CYXIuQkFSX01PVVNFT1VULCB7XG4gICAgICAgIGV2ZW50OiBpLFxuICAgICAgICBlbGVtZW50OiBhLFxuICAgICAgICBkYXR1bTogc1xuICAgICAgfSksIHIuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLkhJREUsIHtcbiAgICAgICAgaG92ZXJlZEVsZW1lbnQ6IGFcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGdldEJhcldpZHRoKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICBpZiAoeSh0LCBcImJhcnNcIiwgXCJ3aWR0aFwiKSlcbiAgICAgIHJldHVybiB0LmJhcnMud2lkdGg7XG4gICAgY29uc3QgbiA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldE1haW5YU2NhbGUoKSwgciA9IE4uZ2V0U1ZHRWxlbWVudFNpemUodGhpcy5wYXJlbnQsIHtcbiAgICAgIHVzZUF0dHJzOiAhMFxuICAgIH0pLndpZHRoLCBpID0gdGhpcy5tb2RlbC5nZXRTdGFja0tleXMoKS5sZW5ndGgsIHMgPSB5KHQsIFwiYmFyc1wiLCBcInNwYWNpbmdGYWN0b3JcIik7XG4gICAgcmV0dXJuIG4uc3RlcCA/IE1hdGgubWluKHQuYmFycy5tYXhXaWR0aCwgbi5zdGVwKCkgLyAyKSA6IE1hdGgubWluKHQuYmFycy5tYXhXaWR0aCwgciAqIHMgLyBpKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcInBhdGguYmFyXCIpLm9uKFwibW91c2VvdmVyXCIsIG51bGwpLm9uKFwibW91c2Vtb3ZlXCIsIG51bGwpLm9uKFwibW91c2VvdXRcIiwgbnVsbCk7XG4gICAgY29uc3QgdCA9IHRoaXMuc2VydmljZXMuZXZlbnRzO1xuICAgIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX0hPVkVSLCB0aGlzLmhhbmRsZUxlZ2VuZE9uSG92ZXIpLCB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoVC5MZWdlbmQuSVRFTV9NT1VTRU9VVCwgdGhpcy5oYW5kbGVMZWdlbmRNb3VzZU91dCk7XG4gIH1cbn1cbmNsYXNzIEF2IGV4dGVuZHMgbm4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnR5cGUgPSBcInNjYXR0ZXItc3RhY2tlZFwiLCB0aGlzLnJlbmRlclR5cGUgPSBydC5TVkc7XG4gIH1cbiAgcmVuZGVyKHQpIHtcbiAgICBpZiAoIXkodGhpcy5nZXRPcHRpb25zKCksIFwicG9pbnRzXCIsIFwiZW5hYmxlZFwiKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoeyBhcmlhTGFiZWw6IFwic2NhdHRlciBwb2ludHNcIiwgd2l0aGluQ2hhcnRDbGlwOiAhMCB9KSwgciA9IHRoaXMuZ2V0T3B0aW9ucygpLCB7IGdyb3VwTWFwc1RvOiBpIH0gPSByLmRhdGEsIHMgPSBPYmplY3Qua2V5cyhyLmF4ZXMpLnNvbWUoKHUpID0+IHIuYXhlc1t1XS5wZXJjZW50YWdlKSwgYSA9IHRoaXMubW9kZWwuZ2V0U3RhY2tlZERhdGEoe1xuICAgICAgZ3JvdXBzOiB0aGlzLmNvbmZpZ3MuZ3JvdXBzLFxuICAgICAgcGVyY2VudGFnZTogc1xuICAgIH0pLCBvID0gbi5zZWxlY3RBbGwoXCJnLmRvdHNcIikuZGF0YShhLCAodSkgPT4geSh1LCAwLCBpKSk7XG4gICAgby5leGl0KCkuYXR0cihcIm9wYWNpdHlcIiwgMCkucmVtb3ZlKCk7XG4gICAgY29uc3QgbCA9IG8uZW50ZXIoKS5hcHBlbmQoXCJnXCIpLmNsYXNzZWQoXCJkb3RzXCIsICEwKS5hdHRyKFwicm9sZVwiLCBodC5HUk9VUCkubWVyZ2Uobykuc2VsZWN0QWxsKFwiY2lyY2xlLmRvdFwiKS5kYXRhKCh1KSA9PiB1KTtcbiAgICBsLmV4aXQoKS5hdHRyKFwib3BhY2l0eVwiLCAwKS5yZW1vdmUoKTtcbiAgICBjb25zdCBjID0gbC5lbnRlcigpLmFwcGVuZChcImNpcmNsZVwiKS5jbGFzc2VkKFwiZG90XCIsICEwKS5hdHRyKFwib3BhY2l0eVwiLCAwKS5tZXJnZShsKS5kYXR1bSgodSkgPT4ge1xuICAgICAgY29uc3QgZCA9IHVbaV0sIGggPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXREb21haW5JZGVudGlmaWVyKHUpLCBwID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0UmFuZ2VJZGVudGlmaWVyKHUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW2ldOiBkLFxuICAgICAgICBbaF06IHUuZGF0YS5zaGFyZWRTdGFja0tleSxcbiAgICAgICAgW3BdOiB1WzFdXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHRoaXMuc3R5bGVDaXJjbGVzKGMsIHQpLCB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgZ2V0VG9vbHRpcERhdGEodCwgbikge1xuICAgIGNvbnN0IHIgPSB0aGlzLmdldE9wdGlvbnMoKSwgeyBncm91cE1hcHNUbzogaSB9ID0gci5kYXRhLCBzID0gT2JqZWN0LmtleXMoci5heGVzKS5zb21lKChsKSA9PiByLmF4ZXNbbF0ucGVyY2VudGFnZSksIGEgPSB0aGlzLm1vZGVsLmdldFN0YWNrZWREYXRhKHtcbiAgICAgIGdyb3VwczogdGhpcy5jb25maWdzLmdyb3VwcyxcbiAgICAgIHBlcmNlbnRhZ2U6IHNcbiAgICB9KSwgbyA9IFtdO1xuICAgIHJldHVybiBhLmZvckVhY2goKGwsIGMpID0+IHtcbiAgICAgIGwuZm9yRWFjaCgodSwgZCkgPT4ge1xuICAgICAgICBjb25zdCBoID0gdVtpXSwgcCA9IHUuZGF0YS5zaGFyZWRTdGFja0tleTtcbiAgICAgICAgbGV0IGYgPSB1LmRhdGFbaF07XG4gICAgICAgIGNvbnN0IGcgPSB1WzFdLCBtID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0RG9tYWluSWRlbnRpZmllcih1KSwgdiA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlSWRlbnRpZmllcih1KTtcbiAgICAgICAgZiAhPSBudWxsICYmIHQgPT09IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldERvbWFpblZhbHVlKHApICYmIG4gPT09IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldFJhbmdlVmFsdWUoZykgJiYgKHMgJiYgKGYgPSB0aGlzLm1vZGVsLmdldFN0YWNrZWREYXRhKHtcbiAgICAgICAgICBncm91cHM6IHRoaXMuY29uZmlncy5ncm91cHNcbiAgICAgICAgfSlbY11bZF0uZGF0YVtoXSksIGYgIT09IG51bGwgJiYgby5wdXNoKHtcbiAgICAgICAgICBbaV06IGgsXG4gICAgICAgICAgW21dOiBwLFxuICAgICAgICAgIFt2XTogZlxuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9KSwgdGhpcy5tb2RlbC5nZXREaXNwbGF5RGF0YSh0aGlzLmNvbmZpZ3MuZ3JvdXBzKS5maWx0ZXIoKGwpID0+IHtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXREb21haW5JZGVudGlmaWVyKGwpLCB1ID0gdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZ2V0UmFuZ2VJZGVudGlmaWVyKGwpO1xuICAgICAgcmV0dXJuIG8uZmluZCgoZCkgPT4gZFtpXSA9PSBsW2ldICYmIGRbY10gPT0gbFtjXSAmJiBkW3VdID09IGxbdV0pICE9PSB2b2lkIDA7XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IFNpID0gNjtcbmNsYXNzIEZEIGV4dGVuZHMgbXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnR5cGUgPSBcInRyZWVcIiwgdGhpcy5yZW5kZXJUeXBlID0gcnQuU1ZHO1xuICB9XG4gIGdldExvbmdlc3RMYWJlbCh0KSB7XG4gICAgbGV0IG4gPSBcIlwiO1xuICAgIHJldHVybiB0LmZvckVhY2goKHIpID0+IHtcbiAgICAgIGNvbnN0IGkgPSByLmNoaWxkcmVuID8gdGhpcy5nZXRMb25nZXN0TGFiZWwoci5jaGlsZHJlbikgOiBcIlwiO1xuICAgICAgKGkubGVuZ3RoID4gbi5sZW5ndGggfHwgci5uYW1lLmxlbmd0aCA+IG4ubGVuZ3RoKSAmJiAobiA9IGkubGVuZ3RoID4gci5uYW1lLmxlbmd0aCA/IGkgOiByLm5hbWUpO1xuICAgIH0pLCBuO1xuICB9XG4gIGdldE1vY2tMYWJlbFdpZHRoKHQsIG4pIHtcbiAgICBjb25zdCByID0gdC5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoXCJkeVwiLCBcIjAuMzFlbVwiKS5hdHRyKFwieFwiLCAwKS5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIikudGV4dChuKSwgeyB3aWR0aDogaSB9ID0gTi5nZXRTVkdFbGVtZW50U2l6ZShyLm5vZGUoKSwge1xuICAgICAgdXNlQkJveDogITBcbiAgICB9KTtcbiAgICByZXR1cm4gci5yZW1vdmUoKSwgaTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gIC8vIEB0cy1pZ25vcmVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICByZW5kZXIodCA9ICEwKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0Q29tcG9uZW50Q29udGFpbmVyKHtcbiAgICAgIGFyaWFMYWJlbDogXCJ0cmVlIGRpYWdyYW1cIlxuICAgIH0pO1xuICAgIG4uaHRtbChcIlwiKTtcbiAgICBjb25zdCB7IHdpZHRoOiByLCBoZWlnaHQ6IGkgfSA9IE4uZ2V0U1ZHRWxlbWVudFNpemUodGhpcy5wYXJlbnQsIHtcbiAgICAgIHVzZUF0dHJzOiAhMFxuICAgIH0pO1xuICAgIGlmIChyIDwgMSB8fCBpIDwgMSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBzID0gdGhpcy5tb2RlbC5nZXRPcHRpb25zKCksIGEgPSB0aGlzLm1vZGVsLmdldERpc3BsYXlEYXRhKCksIG8gPSB5KHMsIFwidHJlZVwiLCBcInJvb3RUaXRsZVwiKSB8fCBcIlRyZWVcIiwgbCA9IHRoaXMuZ2V0TW9ja0xhYmVsV2lkdGgobiwgbyksIGMgPSB0aGlzLmdldExvbmdlc3RMYWJlbChhKSwgdSA9IHRoaXMuZ2V0TW9ja0xhYmVsV2lkdGgobiwgYyksIGQgPSB7XG4gICAgICBsZWZ0OiBsID4gMCA/IGwgKyBTaSA6IDMwIC0gU2lcbiAgICB9LCBoID0geXMoe1xuICAgICAgbmFtZTogbyxcbiAgICAgIGNoaWxkcmVuOiBhXG4gICAgfSksIHAgPSAxMCwgZiA9IHIgLyA2LCBnID0gKFMpID0+IHtcbiAgICAgIGNvbnN0IE0gPSBoLmRlc2NlbmRhbnRzKCkucmV2ZXJzZSgpLCBEID0gaC5saW5rcygpO1xuICAgICAgbGV0IEEgPSBoLCBSID0gaDtcbiAgICAgIGguZWFjaEJlZm9yZSgoaykgPT4ge1xuICAgICAgICBrLnggPCBBLnggJiYgKEEgPSBrKSwgay54ID4gUi54ICYmIChSID0gayk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0ICQgPSBSLnggLSBBLngsIEggPSBuLnRyYW5zaXRpb24oKS5jYWxsKFxuICAgICAgICAoaykgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICAgIHRyYW5zaXRpb246IGssXG4gICAgICAgICAgbmFtZTogXCJ0cmVlLXVwZGF0ZS12aWV3Ym94XCIsXG4gICAgICAgICAgYW5pbWF0ZTogITBcbiAgICAgICAgfSlcbiAgICAgICkuYXR0cihcInZpZXdCb3hcIiwgWy1kLmxlZnQsIEEueCwgciwgJF0uam9pbihcIiBcIikpLCBQID0gYi5zZWxlY3RBbGwoXCJnXCIpLmRhdGEoTSwgKGspID0+IGsuaWQpLCBCID0gdGhpcywgTyA9IFAuZW50ZXIoKS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgKCkgPT4gYHRyYW5zbGF0ZSgke1MueTB9LCR7Uy54MH0pYCkuYXR0cihcbiAgICAgICAgXCJjbGFzc1wiLFxuICAgICAgICAoaykgPT4gay5kZXB0aCAhPT0gMCAmJiBrLmNoaWxkcmVuICYmIGsuY2hpbGRyZW4ubGVuZ3RoID4gMCA/IFwiY2xpY2thYmxlXCIgOiBudWxsXG4gICAgICApLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKGssIFUpIHtcbiAgICAgICAgQi5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRyZWUuTk9ERV9NT1VTRU9WRVIsIHtcbiAgICAgICAgICBldmVudDogayxcbiAgICAgICAgICBlbGVtZW50OiBJKHRoaXMpLFxuICAgICAgICAgIGRhdHVtOiBVXG4gICAgICAgIH0pO1xuICAgICAgfSkub24oXCJjbGlja1wiLCBmdW5jdGlvbihrLCBVKSB7XG4gICAgICAgIFUuZGVwdGggIT09IDAgJiYgKFUuY2hpbGRyZW4gPSBVLmNoaWxkcmVuID8gbnVsbCA6IFUuX2NoaWxkcmVuLCBnKFUpKSwgQi5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRyZWUuTk9ERV9DTElDSywge1xuICAgICAgICAgIGV2ZW50OiBrLFxuICAgICAgICAgIGVsZW1lbnQ6IEkodGhpcyksXG4gICAgICAgICAgZGF0dW06IFVcbiAgICAgICAgfSk7XG4gICAgICB9KS5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKGssIFUpIHtcbiAgICAgICAgQi5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRyZWUuTk9ERV9NT1VTRU9VVCwge1xuICAgICAgICAgIGV2ZW50OiBrLFxuICAgICAgICAgIGVsZW1lbnQ6IEkodGhpcyksXG4gICAgICAgICAgZGF0dW06IFVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIE8uYXBwZW5kKFwiY2lyY2xlXCIpLmF0dHIoXCJyXCIsIDIuNSkuYXR0cihcImNsYXNzXCIsIChrKSA9PiBrLl9jaGlsZHJlbiA/IFwicGFyZW50XCIgOiBcImNoaWxkXCIpLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMTApLCBPLmFwcGVuZChcInRleHRcIikuYXR0cihcImR5XCIsIFwiMC4zMWVtXCIpLmF0dHIoXCJ4XCIsIChrKSA9PiBrLl9jaGlsZHJlbiA/IC02IDogU2kpLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCAoaykgPT4gay5fY2hpbGRyZW4gPyBcImVuZFwiIDogXCJzdGFydFwiKS50ZXh0KChrKSA9PiBrLmRhdGEubmFtZSkuY2xvbmUoITApLmF0dHIoXCJjbGFzc1wiLCBcInRleHQtc3Ryb2tlXCIpLmxvd2VyKCksIFAubWVyZ2UoTykudHJhbnNpdGlvbihIKS5hdHRyKFwidHJhbnNmb3JtXCIsIChrKSA9PiBgdHJhbnNsYXRlKCR7ay55fSwke2sueH0pYCkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAxKS5hdHRyKFwic3Ryb2tlLW9wYWNpdHlcIiwgMSksIFAuZXhpdCgpLnRyYW5zaXRpb24oSCkucmVtb3ZlKCkuYXR0cihcInRyYW5zZm9ybVwiLCAoKSA9PiBgdHJhbnNsYXRlKCR7Uy55fSwke1MueH0pYCkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKS5hdHRyKFwic3Ryb2tlLW9wYWNpdHlcIiwgMCk7XG4gICAgICBjb25zdCB3ID0gRS5zZWxlY3RBbGwoXCJwYXRoXCIpLmRhdGEoRCwgKGspID0+IGsudGFyZ2V0LmlkKSwgTCA9IHcuZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpLmF0dHIoXCJkXCIsICgpID0+IHtcbiAgICAgICAgY29uc3QgayA9IHsgeDogUy54MCwgeTogUy55MCB9O1xuICAgICAgICByZXR1cm4gXyh7IHNvdXJjZTogaywgdGFyZ2V0OiBrIH0pO1xuICAgICAgfSk7XG4gICAgICB3Lm1lcmdlKEwpLnRyYW5zaXRpb24oSCkuYXR0cihcImRcIiwgXyksIHcuZXhpdCgpLnRyYW5zaXRpb24oSCkucmVtb3ZlKCkuYXR0cihcImRcIiwgKCkgPT4ge1xuICAgICAgICBjb25zdCBrID0geyB4OiBTLngsIHk6IFMueSB9O1xuICAgICAgICByZXR1cm4gXyh7IHNvdXJjZTogaywgdGFyZ2V0OiBrIH0pO1xuICAgICAgfSksIGguZWFjaEJlZm9yZSgoaykgPT4ge1xuICAgICAgICBrLngwID0gay54LCBrLnkwID0gay55O1xuICAgICAgfSk7XG4gICAgfSwgbSA9IGguZGVzY2VuZGFudHMoKSwgdiA9IG1bbS5sZW5ndGggLSAxXS5kZXB0aCwgeCA9IHkocywgXCJ0cmVlXCIsIFwidHlwZVwiKSA9PT0gcGMuREVORFJPR1JBTSA/IGxMKCkuc2l6ZShbXG4gICAgICBpLFxuICAgICAgciAtIHUgLSB2ICogU2kgLSBsXG4gICAgXSkgOiBYTCgpLm5vZGVTaXplKFtwLCBmXSkuc2l6ZShbXG4gICAgICBpLFxuICAgICAgciAtIHUgLSB2ICogU2kgLSBsXG4gICAgXSksIF8gPSB5aygpLngoKFMpID0+IFMueSkueSgoUykgPT4gUy54KTtcbiAgICBoLngwID0gZiAvIDIsIGgueTAgPSAwLCBoLmRlc2NlbmRhbnRzKCkuZm9yRWFjaCgoUywgTSkgPT4ge1xuICAgICAgUy5pZCA9IE0sIFMuX2NoaWxkcmVuID0gUy5jaGlsZHJlbjtcbiAgICB9KSwgeChoKSwgbi5hdHRyKFwidmlld0JveFwiLCBbLWQubGVmdCwgLTAsIHIsIHBdKS5zdHlsZShcInVzZXItc2VsZWN0XCIsIFwibm9uZVwiKTtcbiAgICBjb25zdCBFID0gbi5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcImxpbmtzXCIpLCBiID0gbi5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcIm5vZGVzXCIpO1xuICAgIGcoaCk7XG4gIH1cbn1cbnZhciBqRCA9IFwiIzAwMDAwMFwiLCBXRCA9IFwiI2ZmZmZmZlwiLCBxRCA9IFwiI2ZjZjRkNlwiLCBZRCA9IFwiI2ZkZGM2OVwiLCBYRCA9IFwiI2YxYzIxYlwiLCBaRCA9IFwiI2QyYTEwNlwiLCBLRCA9IFwiI2IyODYwMFwiLCBRRCA9IFwiIzhlNmEwMFwiLCBKRCA9IFwiIzY4NGUwMFwiLCB0UiA9IFwiIzQ4MzcwMFwiLCBlUiA9IFwiIzMwMjQwMFwiLCBuUiA9IFwiIzFjMTUwMFwiLCByUiA9IHtcbiAgMTA6IHFELFxuICAyMDogWUQsXG4gIDMwOiBYRCxcbiAgNDA6IFpELFxuICA1MDogS0QsXG4gIDYwOiBRRCxcbiAgNzA6IEpELFxuICA4MDogdFIsXG4gIDkwOiBlUixcbiAgMTAwOiBuUlxufSwgaVIgPSBcIiNmZmYyZThcIiwgc1IgPSBcIiNmZmQ5YmVcIiwgYVIgPSBcIiNmZmI3ODRcIiwgb1IgPSBcIiNmZjgzMmJcIiwgbFIgPSBcIiNlYjYyMDBcIiwgY1IgPSBcIiNiYTRlMDBcIiwgdVIgPSBcIiM4YTM4MDBcIiwgaFIgPSBcIiM1ZTI5MDBcIiwgZFIgPSBcIiMzZTFhMDBcIiwgcFIgPSBcIiMyMzEwMDBcIiwgZlIgPSB7XG4gIDEwOiBpUixcbiAgMjA6IHNSLFxuICAzMDogYVIsXG4gIDQwOiBvUixcbiAgNTA6IGxSLFxuICA2MDogY1IsXG4gIDcwOiB1UixcbiAgODA6IGhSLFxuICA5MDogZFIsXG4gIDEwMDogcFJcbn0sIG1SID0gXCIjZmZmMWYxXCIsIGdSID0gXCIjZmZkN2Q5XCIsIHZSID0gXCIjZmZiM2I4XCIsIHlSID0gXCIjZmY4Mzg5XCIsIHhSID0gXCIjZmE0ZDU2XCIsIGJSID0gXCIjZGExZTI4XCIsIF9SID0gXCIjYTIxOTFmXCIsIEVSID0gXCIjNzUwZTEzXCIsIE9SID0gXCIjNTIwNDA4XCIsIFNSID0gXCIjMmQwNzA5XCIsIFRSID0ge1xuICAxMDogbVIsXG4gIDIwOiBnUixcbiAgMzA6IHZSLFxuICA0MDogeVIsXG4gIDUwOiB4UixcbiAgNjA6IGJSLFxuICA3MDogX1IsXG4gIDgwOiBFUixcbiAgOTA6IE9SLFxuICAxMDA6IFNSXG59LCB3UiA9IFwiI2ZmZjBmN1wiLCAkUiA9IFwiI2ZmZDZlOFwiLCBNUiA9IFwiI2ZmYWZkMlwiLCBDUiA9IFwiI2ZmN2ViNlwiLCBBUiA9IFwiI2VlNTM5NlwiLCBMUiA9IFwiI2QwMjY3MFwiLCBrUiA9IFwiIzlmMTg1M1wiLCBEUiA9IFwiIzc0MDkzN1wiLCBSUiA9IFwiIzUxMDIyNFwiLCBJUiA9IFwiIzJhMGExOFwiLCBOUiA9IHtcbiAgMTA6IHdSLFxuICAyMDogJFIsXG4gIDMwOiBNUixcbiAgNDA6IENSLFxuICA1MDogQVIsXG4gIDYwOiBMUixcbiAgNzA6IGtSLFxuICA4MDogRFIsXG4gIDkwOiBSUixcbiAgMTAwOiBJUlxufSwgUFIgPSBcIiNmNmYyZmZcIiwgVVIgPSBcIiNlOGRhZmZcIiwgQlIgPSBcIiNkNGJiZmZcIiwgSFIgPSBcIiNiZTk1ZmZcIiwgVlIgPSBcIiNhNTZlZmZcIiwgR1IgPSBcIiM4YTNmZmNcIiwgelIgPSBcIiM2OTI5YzRcIiwgRlIgPSBcIiM0OTFkOGJcIiwgalIgPSBcIiMzMTEzNWVcIiwgV1IgPSBcIiMxYzBmMzBcIiwgcVIgPSB7XG4gIDEwOiBQUixcbiAgMjA6IFVSLFxuICAzMDogQlIsXG4gIDQwOiBIUixcbiAgNTA6IFZSLFxuICA2MDogR1IsXG4gIDcwOiB6UixcbiAgODA6IEZSLFxuICA5MDogalIsXG4gIDEwMDogV1Jcbn0sIFlSID0gXCIjZWRmNWZmXCIsIFhSID0gXCIjZDBlMmZmXCIsIFpSID0gXCIjYTZjOGZmXCIsIEtSID0gXCIjNzhhOWZmXCIsIFFSID0gXCIjNDU4OWZmXCIsIEpSID0gXCIjMGY2MmZlXCIsIHRJID0gXCIjMDA0M2NlXCIsIGVJID0gXCIjMDAyZDljXCIsIG5JID0gXCIjMDAxZDZjXCIsIHJJID0gXCIjMDAxMTQxXCIsIGlJID0ge1xuICAxMDogWVIsXG4gIDIwOiBYUixcbiAgMzA6IFpSLFxuICA0MDogS1IsXG4gIDUwOiBRUixcbiAgNjA6IEpSLFxuICA3MDogdEksXG4gIDgwOiBlSSxcbiAgOTA6IG5JLFxuICAxMDA6IHJJXG59LCBzSSA9IFwiI2U1ZjZmZlwiLCBhSSA9IFwiI2JhZTZmZlwiLCBvSSA9IFwiIzgyY2ZmZlwiLCBsSSA9IFwiIzMzYjFmZlwiLCBjSSA9IFwiIzExOTJlOFwiLCB1SSA9IFwiIzAwNzJjM1wiLCBoSSA9IFwiIzAwNTM5YVwiLCBkSSA9IFwiIzAwM2E2ZFwiLCBwSSA9IFwiIzAxMjc0OVwiLCBmSSA9IFwiIzA2MTcyN1wiLCBtSSA9IHtcbiAgMTA6IHNJLFxuICAyMDogYUksXG4gIDMwOiBvSSxcbiAgNDA6IGxJLFxuICA1MDogY0ksXG4gIDYwOiB1SSxcbiAgNzA6IGhJLFxuICA4MDogZEksXG4gIDkwOiBwSSxcbiAgMTAwOiBmSVxufSwgZ0kgPSBcIiNkOWZiZmJcIiwgdkkgPSBcIiM5ZWYwZjBcIiwgeUkgPSBcIiMzZGRiZDlcIiwgeEkgPSBcIiMwOGJkYmFcIiwgYkkgPSBcIiMwMDlkOWFcIiwgX0kgPSBcIiMwMDdkNzlcIiwgRUkgPSBcIiMwMDVkNWRcIiwgT0kgPSBcIiMwMDQxNDRcIiwgU0kgPSBcIiMwMjJiMzBcIiwgVEkgPSBcIiMwODFhMWNcIiwgd0kgPSB7XG4gIDEwOiBnSSxcbiAgMjA6IHZJLFxuICAzMDogeUksXG4gIDQwOiB4SSxcbiAgNTA6IGJJLFxuICA2MDogX0ksXG4gIDcwOiBFSSxcbiAgODA6IE9JLFxuICA5MDogU0ksXG4gIDEwMDogVElcbn0sICRJID0gXCIjZGVmYmU2XCIsIE1JID0gXCIjYTdmMGJhXCIsIENJID0gXCIjNmZkYzhjXCIsIEFJID0gXCIjNDJiZTY1XCIsIExJID0gXCIjMjRhMTQ4XCIsIGtJID0gXCIjMTk4MDM4XCIsIERJID0gXCIjMGU2MDI3XCIsIFJJID0gXCIjMDQ0MzE3XCIsIElJID0gXCIjMDIyZDBkXCIsIE5JID0gXCIjMDcxOTA4XCIsIFBJID0ge1xuICAxMDogJEksXG4gIDIwOiBNSSxcbiAgMzA6IENJLFxuICA0MDogQUksXG4gIDUwOiBMSSxcbiAgNjA6IGtJLFxuICA3MDogREksXG4gIDgwOiBSSSxcbiAgOTA6IElJLFxuICAxMDA6IE5JXG59LCBVSSA9IFwiI2YyZjRmOFwiLCBCSSA9IFwiI2RkZTFlNlwiLCBISSA9IFwiI2MxYzdjZFwiLCBWSSA9IFwiI2EyYTliMFwiLCBHSSA9IFwiIzg3OGQ5NlwiLCB6SSA9IFwiIzY5NzA3N1wiLCBGSSA9IFwiIzRkNTM1OFwiLCBqSSA9IFwiIzM0M2EzZlwiLCBXSSA9IFwiIzIxMjcyYVwiLCBxSSA9IFwiIzEyMTYxOVwiLCBZSSA9IHtcbiAgMTA6IFVJLFxuICAyMDogQkksXG4gIDMwOiBISSxcbiAgNDA6IFZJLFxuICA1MDogR0ksXG4gIDYwOiB6SSxcbiAgNzA6IEZJLFxuICA4MDogakksXG4gIDkwOiBXSSxcbiAgMTAwOiBxSVxufSwgWEkgPSBcIiNmNGY0ZjRcIiwgWkkgPSBcIiNlMGUwZTBcIiwgS0kgPSBcIiNjNmM2YzZcIiwgUUkgPSBcIiNhOGE4YThcIiwgSkkgPSBcIiM4ZDhkOGRcIiwgdE4gPSBcIiM2ZjZmNmZcIiwgZU4gPSBcIiM1MjUyNTJcIiwgbk4gPSBcIiMzOTM5MzlcIiwgck4gPSBcIiMyNjI2MjZcIiwgaU4gPSBcIiMxNjE2MTZcIiwgc04gPSB7XG4gIDEwOiBYSSxcbiAgMjA6IFpJLFxuICAzMDogS0ksXG4gIDQwOiBRSSxcbiAgNTA6IEpJLFxuICA2MDogdE4sXG4gIDcwOiBlTixcbiAgODA6IG5OLFxuICA5MDogck4sXG4gIDEwMDogaU5cbn0sIGFOID0gXCIjZjdmM2YyXCIsIG9OID0gXCIjZTVlMGRmXCIsIGxOID0gXCIjY2FjNWM0XCIsIGNOID0gXCIjYWRhOGE4XCIsIHVOID0gXCIjOGY4YjhiXCIsIGhOID0gXCIjNzI2ZTZlXCIsIGROID0gXCIjNTY1MTUxXCIsIHBOID0gXCIjM2MzODM4XCIsIGZOID0gXCIjMjcyNTI1XCIsIG1OID0gXCIjMTcxNDE0XCIsIGdOID0ge1xuICAxMDogYU4sXG4gIDIwOiBvTixcbiAgMzA6IGxOLFxuICA0MDogY04sXG4gIDUwOiB1TixcbiAgNjA6IGhOLFxuICA3MDogZE4sXG4gIDgwOiBwTixcbiAgOTA6IGZOLFxuICAxMDA6IG1OXG59LCB2cCA9IHtcbiAgYmxhY2s6IHtcbiAgICAxMDA6IGpEXG4gIH0sXG4gIGJsdWU6IGlJLFxuICBjb29sR3JheTogWUksXG4gIGN5YW46IG1JLFxuICBncmF5OiBzTixcbiAgZ3JlZW46IFBJLFxuICBtYWdlbnRhOiBOUixcbiAgb3JhbmdlOiBmUixcbiAgcHVycGxlOiBxUixcbiAgcmVkOiBUUixcbiAgdGVhbDogd0ksXG4gIHdhcm1HcmF5OiBnTixcbiAgd2hpdGU6IHtcbiAgICAwOiBXRFxuICB9LFxuICB5ZWxsb3c6IHJSXG59O1xuY29uc3Qgdk4gPSAoZSkgPT4ge1xuICBpZiAoIWUpXG4gICAgcmV0dXJuIG51bGw7XG4gIGZvciAoY29uc3QgdCBvZiBPYmplY3Qua2V5cyh2cCkpIHtcbiAgICBjb25zdCBuID0gdnBbdF07XG4gICAgZm9yIChjb25zdCByIG9mIE9iamVjdC5rZXlzKG4pKVxuICAgICAgaWYgKG5bK3JdID09PSBlKVxuICAgICAgICByZXR1cm4gcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn0sIHlwID0gZnVuY3Rpb24oZSkge1xuICBjb25zdCB0ID0gSSh0aGlzLnBhcmVudE5vZGUpLnNlbGVjdChcInJlY3QubGVhZlwiKSwgbiA9IGUuYmFja2dyb3VuZENvbG9yID8/IGdldENvbXB1dGVkU3R5bGUodC5ub2RlKCksIG51bGwpLmdldFByb3BlcnR5VmFsdWUoXCJmaWxsXCIpLCByID0gVG4obik7XG4gIGxldCBpO1xuICBpZiAociAmJiAoaSA9IHZOKHIgPyByLmhleCgpIDogbnVsbCkpLCBpID09IG51bGwpIHtcbiAgICBjb25zdCBzID0gbG0ocikubDtcbiAgICBpID0gTWF0aC5hYnMocyAqIDEwMCAtIDEwMCk7XG4gIH1cbiAgcmV0dXJuIGkgPiA1MCA/IFwid2hpdGVcIiA6IFwiYmxhY2tcIjtcbn07XG5sZXQgeU4gPSAwO1xuY2xhc3MgeE4gZXh0ZW5kcyBtdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IFwidHJlZW1hcFwiLCB0aGlzLnJlbmRlclR5cGUgPSBydC5TVkcsIHRoaXMuaGFuZGxlTGVnZW5kT25Ib3ZlciA9ICh0KSA9PiB7XG4gICAgICBjb25zdCB7IGhvdmVyZWRFbGVtZW50OiBuIH0gPSB0LmRldGFpbDtcbiAgICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcImdbZGF0YS1uYW1lPSdsZWFmJ11cIikudHJhbnNpdGlvbihcImxlZ2VuZC1ob3Zlci10cmVlbWFwXCIpLmNhbGwoXG4gICAgICAgIChyKSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgdHJhbnNpdGlvbjogcixcbiAgICAgICAgICBuYW1lOiBcImxlZ2VuZC1ob3Zlci10cmVlbWFwXCJcbiAgICAgICAgfSlcbiAgICAgICkuYXR0cihcbiAgICAgICAgXCJvcGFjaXR5XCIsXG4gICAgICAgIChyKSA9PiByLnBhcmVudC5kYXRhLm5hbWUgPT09IG4uZGF0dW0oKS5uYW1lID8gMSA6IDAuM1xuICAgICAgKTtcbiAgICB9LCB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlT3V0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwiZ1tkYXRhLW5hbWU9J2xlYWYnXVwiKS50cmFuc2l0aW9uKFwibGVnZW5kLW1vdXNlb3V0LXRyZWVtYXBcIikuY2FsbChcbiAgICAgICAgKHQpID0+IHRoaXMuc2VydmljZXMudHJhbnNpdGlvbnMuc2V0dXBUcmFuc2l0aW9uKHtcbiAgICAgICAgICB0cmFuc2l0aW9uOiB0LFxuICAgICAgICAgIG5hbWU6IFwibGVnZW5kLW1vdXNlb3V0LXRyZWVtYXBcIlxuICAgICAgICB9KVxuICAgICAgKS5hdHRyKFwib3BhY2l0eVwiLCAxKTtcbiAgICB9O1xuICB9XG4gIGluaXQoKSB7XG4gICAgY29uc3QgeyBldmVudHM6IHQgfSA9IHRoaXMuc2VydmljZXM7XG4gICAgdC5hZGRFdmVudExpc3RlbmVyKFQuTGVnZW5kLklURU1fSE9WRVIsIHRoaXMuaGFuZGxlTGVnZW5kT25Ib3ZlciksIHQuYWRkRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX01PVVNFT1VULCB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlT3V0KTtcbiAgfVxuICByZW5kZXIodCA9ICEwKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0Q29tcG9uZW50Q29udGFpbmVyKHtcbiAgICAgIGFyaWFMYWJlbDogXCJ0cmVlbWFwXCJcbiAgICB9KTtcbiAgICB0aGlzLm1vZGVsLmdldERhdGEoKTtcbiAgICBjb25zdCByID0gdGhpcy5tb2RlbC5nZXREaXNwbGF5RGF0YSgpLCBpID0gdGhpcy5tb2RlbC5nZXRPcHRpb25zKCksIHMgPSB5KHdpbmRvdywgXCJsb2NhdGlvblwiKSwgeyB3aWR0aDogYSwgaGVpZ2h0OiBvIH0gPSBOLmdldFNWR0VsZW1lbnRTaXplKG4sIHtcbiAgICAgIHVzZUF0dHJzOiAhMFxuICAgIH0pLCBsID0geXMoe1xuICAgICAgbmFtZTogaS50aXRsZSB8fCBcIlRyZWVtYXBcIixcbiAgICAgIGNoaWxkcmVuOiByXG4gICAgfSkuc3VtKChwKSA9PiBwLnZhbHVlKS5zb3J0KChwLCBmKSA9PiBmLnZhbHVlIC0gcC52YWx1ZSksIGMgPSB0aygpLnNpemUoW2EsIG9dKS5wYWRkaW5nSW5uZXIoMSkucGFkZGluZ091dGVyKDApLnJvdW5kKCEwKShcbiAgICAgIGxcbiAgICApLCB1ID0gbi5zZWxlY3RBbGwoXCJnW2RhdGEtbmFtZT0nbGVhZiddXCIpLmRhdGEoYy5sZWF2ZXMoKSwgKHApID0+IHAuZGF0YS5uYW1lKTtcbiAgICB1LmV4aXQoKS5hdHRyKFwib3BhY2l0eVwiLCAwKS5yZW1vdmUoKTtcbiAgICBjb25zdCBkID0gdS5lbnRlcigpLmFwcGVuZChcImdcIikuYXR0cihcImRhdGEtbmFtZVwiLCBcImxlYWZcIikuYXR0cihcImRhdGEtdWlkXCIsICgpID0+IHlOKyspLm1lcmdlKHUpO1xuICAgIGQuYXR0cihcImRhdGEtbmFtZVwiLCBcImxlYWZcIikudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAocCkgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICB0cmFuc2l0aW9uOiBwLFxuICAgICAgICBuYW1lOiBcInRyZWVtYXAtZ3JvdXAtdXBkYXRlXCIsXG4gICAgICAgIGFuaW1hdGU6IHRcbiAgICAgIH0pXG4gICAgKS5hdHRyKFwidHJhbnNmb3JtXCIsIChwKSA9PiBgdHJhbnNsYXRlKCR7cC54MH0sJHtwLnkwfSlgKTtcbiAgICBjb25zdCBoID0gZC5zZWxlY3RBbGwoXCJyZWN0LmxlYWZcIikuZGF0YSgocCkgPT4gW3BdKTtcbiAgICBoLmV4aXQoKS5hdHRyKFwid2lkdGhcIiwgMCkuYXR0cihcImhlaWdodFwiLCAwKS5yZW1vdmUoKSwgaC5lbnRlcigpLmFwcGVuZChcInJlY3RcIikuY2xhc3NlZChcImxlYWZcIiwgITApLm1lcmdlKGgpLmF0dHIoXCJ3aWR0aFwiLCAwKS5hdHRyKFwiaGVpZ2h0XCIsIDApLmF0dHIoXCJpZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHAgPSBJKHRoaXMucGFyZW50Tm9kZSkuYXR0cihcImRhdGEtdWlkXCIpO1xuICAgICAgcmV0dXJuIGAke2kuc3R5bGUucHJlZml4fS1sZWFmLSR7cH1gO1xuICAgIH0pLmF0dHIoXCJjbGFzc1wiLCAocCkgPT4ge1xuICAgICAgZm9yICg7IHAuZGVwdGggPiAxOyApIHAgPSBwLnBhcmVudDtcbiAgICAgIHJldHVybiB0aGlzLm1vZGVsLmdldENvbG9yQ2xhc3NOYW1lKHtcbiAgICAgICAgY2xhc3NOYW1lVHlwZXM6IFtpdC5GSUxMXSxcbiAgICAgICAgZGF0YUdyb3VwTmFtZTogcC5kYXRhLm5hbWUsXG4gICAgICAgIG9yaWdpbmFsQ2xhc3NOYW1lOiBcImxlYWZcIlxuICAgICAgfSk7XG4gICAgfSkudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAocCkgPT4gdGhpcy5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICB0cmFuc2l0aW9uOiBwLFxuICAgICAgICBuYW1lOiBcInRyZWVtYXAtbGVhZi11cGRhdGUtZW50ZXJcIixcbiAgICAgICAgYW5pbWF0ZTogdFxuICAgICAgfSlcbiAgICApLmF0dHIoXCJ3aWR0aFwiLCAocCkgPT4gcC54MSAtIHAueDApLmF0dHIoXCJoZWlnaHRcIiwgKHApID0+IHAueTEgLSBwLnkwKS5zdHlsZShcImZpbGxcIiwgKHApID0+IHtcbiAgICAgIGZvciAoOyBwLmRlcHRoID4gMTsgKSBwID0gcC5wYXJlbnQ7XG4gICAgICByZXR1cm4gdGhpcy5tb2RlbC5nZXRGaWxsQ29sb3IocC5kYXRhLm5hbWUsIG51bGwsIHAuZGF0YSk7XG4gICAgfSksIGQuc2VsZWN0QWxsKFwiY2xpcFBhdGhcIikuZGF0YShcbiAgICAgIChwKSA9PiBwLmRhdGEuc2hvd0xhYmVsICE9PSAhMCA/IFtdIDogWzFdLFxuICAgICAgKHApID0+IHBcbiAgICApLmpvaW4oXG4gICAgICAocCkgPT4gcC5hcHBlbmQoXCJjbGlwUGF0aFwiKS5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGYgPSBJKHRoaXMucGFyZW50Tm9kZSkuYXR0cihcImRhdGEtdWlkXCIpO1xuICAgICAgICByZXR1cm4gYCR7aS5zdHlsZS5wcmVmaXh9LWNsaXAtJHtmfWA7XG4gICAgICB9KS5hcHBlbmQoXCJ1c2VcIikuYXR0cihcInhsaW5rOmhyZWZcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGYgPSBJKHRoaXMucGFyZW50Tm9kZS5wYXJlbnROb2RlKS5hdHRyKFwiZGF0YS11aWRcIiksIGcgPSBgJHtpLnN0eWxlLnByZWZpeH0tbGVhZi0ke2Z9YDtcbiAgICAgICAgcmV0dXJuIG5ldyBVUkwoYCMke2d9YCwgcykgKyBcIlwiO1xuICAgICAgfSksXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAocCkgPT4gbnVsbCxcbiAgICAgIChwKSA9PiBwLnJlbW92ZSgpXG4gICAgKSwgZC5zZWxlY3RBbGwoXCJ0ZXh0XCIpLmRhdGEoXG4gICAgICAocCkgPT4ge1xuICAgICAgICBpZiAocC5kYXRhLnNob3dMYWJlbCAhPT0gITApXG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgZiA9IHA7XG4gICAgICAgIGZvciAoOyBmLmRlcHRoID4gMTsgKSBmID0gZi5wYXJlbnQ7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGV4dDogcC5kYXRhLm5hbWUsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMubW9kZWwuZ2V0RmlsbENvbG9yKGYuZGF0YS5uYW1lKVxuICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICAgIH0sXG4gICAgICAocCkgPT4gcFxuICAgICkuam9pbihcbiAgICAgIChwKSA9PiB7XG4gICAgICAgIGNvbnN0IGYgPSBwLmFwcGVuZChcInRleHRcIikudGV4dCgoZykgPT4gZy50ZXh0KS5zdHlsZShcImZpbGxcIiwgeXApLmF0dHIoXCJ4XCIsIDcpLmF0dHIoXCJ5XCIsIDE4KTtcbiAgICAgICAgcmV0dXJuIHMgJiYgZi5hdHRyKFwiY2xpcC1wYXRoXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNvbnN0IGcgPSBJKHRoaXMucGFyZW50Tm9kZSkuYXR0cihcImRhdGEtdWlkXCIpLCBtID0gYCR7aS5zdHlsZS5wcmVmaXh9LWNsaXAtJHtnfWA7XG4gICAgICAgICAgcmV0dXJuIGB1cmwoJHtuZXcgVVJMKGAjJHttfWAsIHMpICsgXCJcIn0pYDtcbiAgICAgICAgfSksIGY7XG4gICAgICB9LFxuICAgICAgKHApID0+IHAudGV4dCgoZikgPT4gZi50ZXh0KS5zdHlsZShcImZpbGxcIiwgeXApLFxuICAgICAgKHApID0+IHAucmVtb3ZlKClcbiAgICApLCB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXM7XG4gICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwicmVjdC5sZWFmXCIpLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKG4sIHIpIHtcbiAgICAgIGNvbnN0IGkgPSBJKHRoaXMpO1xuICAgICAgbGV0IHMgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMsIG51bGwpLmdldFByb3BlcnR5VmFsdWUoXCJmaWxsXCIpLCBhID0gcjtcbiAgICAgIGZvciAoOyBhLmRlcHRoID4gMTsgKSBhID0gYS5wYXJlbnQ7XG4gICAgICBpLnRyYW5zaXRpb24oXCJncmFwaF9lbGVtZW50X21vdXNlb3Zlcl9maWxsX3VwZGF0ZVwiKS5jYWxsKFxuICAgICAgICAobykgPT4gdC5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICAgIHRyYW5zaXRpb246IG8sXG4gICAgICAgICAgbmFtZTogXCJncmFwaF9lbGVtZW50X21vdXNlb3Zlcl9maWxsX3VwZGF0ZVwiXG4gICAgICAgIH0pXG4gICAgICApLnN0eWxlKFwiZmlsbFwiLCAobykgPT4ge1xuICAgICAgICBjb25zdCBsID0gdC5tb2RlbC5nZXRGaWxsQ29sb3Ioby5wYXJlbnQuZGF0YS5uYW1lLCBudWxsLCBvLmRhdGEpO1xuICAgICAgICByZXR1cm4gbCAmJiAocyA9IGwpLCBUbihzKS5kYXJrZXIoMC43KS50b1N0cmluZygpO1xuICAgICAgfSksIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLlNIT1csIHtcbiAgICAgICAgZXZlbnQ6IG4sXG4gICAgICAgIGhvdmVyZWRFbGVtZW50OiBpLFxuICAgICAgICBpdGVtczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbG9yOiBzLFxuICAgICAgICAgICAgbGFiZWw6IGEuZGF0YS5uYW1lLFxuICAgICAgICAgICAgYm9sZDogITBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiByLmRhdGEubmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiByLmRhdGEudmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0pLCB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVHJlZW1hcC5MRUFGX01PVVNFT1ZFUiwge1xuICAgICAgICBldmVudDogbixcbiAgICAgICAgZWxlbWVudDogaSxcbiAgICAgICAgZGF0dW06IHJcbiAgICAgIH0pO1xuICAgIH0pLm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKG4sIHIpIHtcbiAgICAgIGNvbnN0IGkgPSBJKHRoaXMpO1xuICAgICAgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRyZWVtYXAuTEVBRl9NT1VTRU1PVkUsIHtcbiAgICAgICAgZXZlbnQ6IG4sXG4gICAgICAgIGVsZW1lbnQ6IGksXG4gICAgICAgIGRhdHVtOiByXG4gICAgICB9KSwgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuTU9WRSwge1xuICAgICAgICBldmVudDogblxuICAgICAgfSk7XG4gICAgfSkub24oXCJjbGlja1wiLCBmdW5jdGlvbihuLCByKSB7XG4gICAgICB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVHJlZW1hcC5MRUFGX0NMSUNLLCB7XG4gICAgICAgIGV2ZW50OiBuLFxuICAgICAgICBlbGVtZW50OiBJKHRoaXMpLFxuICAgICAgICBkYXR1bTogclxuICAgICAgfSk7XG4gICAgfSkub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihuLCByKSB7XG4gICAgICBjb25zdCBpID0gSSh0aGlzKTtcbiAgICAgIGkuY2xhc3NlZChcImhvdmVyZWRcIiwgITEpO1xuICAgICAgbGV0IHMgPSByO1xuICAgICAgZm9yICg7IHMuZGVwdGggPiAxOyApIHMgPSBzLnBhcmVudDtcbiAgICAgIGkudHJhbnNpdGlvbigpLmNhbGwoXG4gICAgICAgIChhKSA9PiB0LnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgdHJhbnNpdGlvbjogYSxcbiAgICAgICAgICBuYW1lOiBcImdyYXBoX2VsZW1lbnRfbW91c2VvdXRfZmlsbF91cGRhdGVcIlxuICAgICAgICB9KVxuICAgICAgKS5zdHlsZShcImZpbGxcIiwgKGEpID0+IHQubW9kZWwuZ2V0RmlsbENvbG9yKGEucGFyZW50LmRhdGEubmFtZSwgbnVsbCwgYS5kYXRhKSksIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5UcmVlbWFwLkxFQUZfTU9VU0VPVVQsIHtcbiAgICAgICAgZXZlbnQ6IG4sXG4gICAgICAgIGVsZW1lbnQ6IGksXG4gICAgICAgIGRhdHVtOiByXG4gICAgICB9KSwgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuSElERSwge1xuICAgICAgICBob3ZlcmVkRWxlbWVudDogaVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJOKGUpIHtcbiAgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCBcImRlZmF1bHRcIikgPyBlLmRlZmF1bHQgOiBlO1xufVxuZnVuY3Rpb24gX04oZSkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIFwiX19lc01vZHVsZVwiKSkgcmV0dXJuIGU7XG4gIHZhciB0ID0gZS5kZWZhdWx0O1xuICBpZiAodHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIG4gPSBmdW5jdGlvbiByKCkge1xuICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiByID8gUmVmbGVjdC5jb25zdHJ1Y3QodCwgYXJndW1lbnRzLCB0aGlzLmNvbnN0cnVjdG9yKSA6IHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIG4ucHJvdG90eXBlID0gdC5wcm90b3R5cGU7XG4gIH0gZWxzZSBuID0ge307XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICB2YXIgaSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcik7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHIsIGkuZ2V0ID8gaSA6IHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGVbcl07XG4gICAgICB9XG4gICAgfSk7XG4gIH0pLCBuO1xufVxudmFyIEVOID0geyB2YWx1ZTogZnVuY3Rpb24oKSB7XG59IH07XG5mdW5jdGlvbiBMdigpIHtcbiAgZm9yICh2YXIgZSA9IDAsIHQgPSBhcmd1bWVudHMubGVuZ3RoLCBuID0ge30sIHI7IGUgPCB0OyArK2UpIHtcbiAgICBpZiAoIShyID0gYXJndW1lbnRzW2VdICsgXCJcIikgfHwgciBpbiBuIHx8IC9bXFxzLl0vLnRlc3QocikpIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgdHlwZTogXCIgKyByKTtcbiAgICBuW3JdID0gW107XG4gIH1cbiAgcmV0dXJuIG5ldyBzYShuKTtcbn1cbmZ1bmN0aW9uIHNhKGUpIHtcbiAgdGhpcy5fID0gZTtcbn1cbmZ1bmN0aW9uIE9OKGUsIHQpIHtcbiAgcmV0dXJuIGUudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24obikge1xuICAgIHZhciByID0gXCJcIiwgaSA9IG4uaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCAmJiAociA9IG4uc2xpY2UoaSArIDEpLCBuID0gbi5zbGljZSgwLCBpKSksIG4gJiYgIXQuaGFzT3duUHJvcGVydHkobikpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyBuKTtcbiAgICByZXR1cm4geyB0eXBlOiBuLCBuYW1lOiByIH07XG4gIH0pO1xufVxuc2EucHJvdG90eXBlID0gTHYucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3Rvcjogc2EsXG4gIG9uOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgdmFyIG4gPSB0aGlzLl8sIHIgPSBPTihlICsgXCJcIiwgbiksIGksIHMgPSAtMSwgYSA9IHIubGVuZ3RoO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgZm9yICg7ICsrcyA8IGE7ICkgaWYgKChpID0gKGUgPSByW3NdKS50eXBlKSAmJiAoaSA9IFNOKG5baV0sIGUubmFtZSkpKSByZXR1cm4gaTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHQgIT0gbnVsbCAmJiB0eXBlb2YgdCAhPSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2FsbGJhY2s6IFwiICsgdCk7XG4gICAgZm9yICg7ICsrcyA8IGE7IClcbiAgICAgIGlmIChpID0gKGUgPSByW3NdKS50eXBlKSBuW2ldID0geHAobltpXSwgZS5uYW1lLCB0KTtcbiAgICAgIGVsc2UgaWYgKHQgPT0gbnVsbCkgZm9yIChpIGluIG4pIG5baV0gPSB4cChuW2ldLCBlLm5hbWUsIG51bGwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZSA9IHt9LCB0ID0gdGhpcy5fO1xuICAgIGZvciAodmFyIG4gaW4gdCkgZVtuXSA9IHRbbl0uc2xpY2UoKTtcbiAgICByZXR1cm4gbmV3IHNhKGUpO1xuICB9LFxuICBjYWxsOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgaWYgKChpID0gYXJndW1lbnRzLmxlbmd0aCAtIDIpID4gMCkgZm9yICh2YXIgbiA9IG5ldyBBcnJheShpKSwgciA9IDAsIGksIHM7IHIgPCBpOyArK3IpIG5bcl0gPSBhcmd1bWVudHNbciArIDJdO1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgZSk7XG4gICAgZm9yIChzID0gdGhpcy5fW2VdLCByID0gMCwgaSA9IHMubGVuZ3RoOyByIDwgaTsgKytyKSBzW3JdLnZhbHVlLmFwcGx5KHQsIG4pO1xuICB9LFxuICBhcHBseTogZnVuY3Rpb24oZSwgdCwgbikge1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgZSk7XG4gICAgZm9yICh2YXIgciA9IHRoaXMuX1tlXSwgaSA9IDAsIHMgPSByLmxlbmd0aDsgaSA8IHM7ICsraSkgcltpXS52YWx1ZS5hcHBseSh0LCBuKTtcbiAgfVxufTtcbmZ1bmN0aW9uIFNOKGUsIHQpIHtcbiAgZm9yICh2YXIgbiA9IDAsIHIgPSBlLmxlbmd0aCwgaTsgbiA8IHI7ICsrbilcbiAgICBpZiAoKGkgPSBlW25dKS5uYW1lID09PSB0KVxuICAgICAgcmV0dXJuIGkudmFsdWU7XG59XG5mdW5jdGlvbiB4cChlLCB0LCBuKSB7XG4gIGZvciAodmFyIHIgPSAwLCBpID0gZS5sZW5ndGg7IHIgPCBpOyArK3IpXG4gICAgaWYgKGVbcl0ubmFtZSA9PT0gdCkge1xuICAgICAgZVtyXSA9IEVOLCBlID0gZS5zbGljZSgwLCByKS5jb25jYXQoZS5zbGljZShyICsgMSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gbiAhPSBudWxsICYmIGUucHVzaCh7IG5hbWU6IHQsIHZhbHVlOiBuIH0pLCBlO1xufVxuY29uc3QgVE4gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBkaXNwYXRjaDogTHZcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIHdOID0gLyogQF9fUFVSRV9fICovIF9OKFROKTtcbnZhciB1bCwgYnA7XG5mdW5jdGlvbiAkTigpIHtcbiAgaWYgKGJwKSByZXR1cm4gdWw7XG4gIGJwID0gMTtcbiAgY29uc3QgZSA9IHdOLmRpc3BhdGNoLCB0ID0gTWF0aC5QSSAvIDE4MCwgbiA9IHtcbiAgICBhcmNoaW1lZGVhbjogZyxcbiAgICByZWN0YW5ndWxhcjogbVxuICB9LCByID0gNjQsIGkgPSAyMDQ4O1xuICB1bCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBFID0gWzI1NiwgMjU2XSwgYiA9IHMsIFMgPSBhLCBNID0gbCwgRCA9IG8sIEEgPSBvLCBSID0gYywgJCA9IHUsIEggPSBnLCBQID0gW10sIEIgPSAxIC8gMCwgTyA9IGUoXCJ3b3JkXCIsIFwiZW5kXCIpLCB3ID0gbnVsbCwgTCA9IE1hdGgucmFuZG9tLCBrID0ge30sIFUgPSB4O1xuICAgIGsuY2FudmFzID0gZnVuY3Rpb24oRikge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoVSA9IF8oRiksIGspIDogVTtcbiAgICB9LCBrLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgRiA9IFooVSgpKSwgWSA9IHYoKEVbMF0gPj4gNSkgKiBFWzFdKSwgb3QgPSBudWxsLCBRID0gUC5sZW5ndGgsIHEgPSAtMSwgdHQgPSBbXSwgbHQgPSBQLm1hcChmdW5jdGlvbihXLCBYKSB7XG4gICAgICAgIHJldHVybiBXLnRleHQgPSBiLmNhbGwodGhpcywgVywgWCksIFcuZm9udCA9IFMuY2FsbCh0aGlzLCBXLCBYKSwgVy5zdHlsZSA9IEQuY2FsbCh0aGlzLCBXLCBYKSwgVy53ZWlnaHQgPSBBLmNhbGwodGhpcywgVywgWCksIFcucm90YXRlID0gUi5jYWxsKHRoaXMsIFcsIFgpLCBXLnNpemUgPSB+fk0uY2FsbCh0aGlzLCBXLCBYKSwgVy5wYWRkaW5nID0gJC5jYWxsKHRoaXMsIFcsIFgpLCBXO1xuICAgICAgfSkuc29ydChmdW5jdGlvbihXLCBYKSB7XG4gICAgICAgIHJldHVybiBYLnNpemUgLSBXLnNpemU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB3ICYmIGNsZWFySW50ZXJ2YWwodyksIHcgPSBzZXRJbnRlcnZhbCh6LCAwKSwgeigpLCBrO1xuICAgICAgZnVuY3Rpb24geigpIHtcbiAgICAgICAgZm9yICh2YXIgVyA9IERhdGUubm93KCk7IERhdGUubm93KCkgLSBXIDwgQiAmJiArK3EgPCBRICYmIHc7ICkge1xuICAgICAgICAgIHZhciBYID0gbHRbcV07XG4gICAgICAgICAgWC54ID0gRVswXSAqIChMKCkgKyAwLjUpID4+IDEsIFgueSA9IEVbMV0gKiAoTCgpICsgMC41KSA+PiAxLCBkKEYsIFgsIGx0LCBxKSwgWC5oYXNUZXh0ICYmIGooWSwgWCwgb3QpICYmICh0dC5wdXNoKFgpLCBPLmNhbGwoXCJ3b3JkXCIsIGssIFgpLCBvdCA/IHAob3QsIFgpIDogb3QgPSBbeyB4OiBYLnggKyBYLngwLCB5OiBYLnkgKyBYLnkwIH0sIHsgeDogWC54ICsgWC54MSwgeTogWC55ICsgWC55MSB9XSwgWC54IC09IEVbMF0gPj4gMSwgWC55IC09IEVbMV0gPj4gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcSA+PSBRICYmIChrLnN0b3AoKSwgTy5jYWxsKFwiZW5kXCIsIGssIHR0LCBvdCkpO1xuICAgICAgfVxuICAgIH0sIGsuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdyAmJiAoY2xlYXJJbnRlcnZhbCh3KSwgdyA9IG51bGwpO1xuICAgICAgZm9yIChjb25zdCBGIG9mIFApXG4gICAgICAgIGRlbGV0ZSBGLnNwcml0ZTtcbiAgICAgIHJldHVybiBrO1xuICAgIH07XG4gICAgZnVuY3Rpb24gWihGKSB7XG4gICAgICBjb25zdCBZID0gRi5nZXRDb250ZXh0KFwiMmRcIiwgeyB3aWxsUmVhZEZyZXF1ZW50bHk6ICEwIH0pO1xuICAgICAgRi53aWR0aCA9IEYuaGVpZ2h0ID0gMTtcbiAgICAgIGNvbnN0IG90ID0gTWF0aC5zcXJ0KFkuZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGEubGVuZ3RoID4+IDIpO1xuICAgICAgcmV0dXJuIEYud2lkdGggPSAociA8PCA1KSAvIG90LCBGLmhlaWdodCA9IGkgLyBvdCwgWS5maWxsU3R5bGUgPSBZLnN0cm9rZVN0eWxlID0gXCJyZWRcIiwgeyBjb250ZXh0OiBZLCByYXRpbzogb3QgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaihGLCBZLCBvdCkge1xuICAgICAgRVswXSwgRVsxXTtcbiAgICAgIGZvciAodmFyIFEgPSBZLngsIHEgPSBZLnksIHR0ID0gTWF0aC5zcXJ0KEVbMF0gKiBFWzBdICsgRVsxXSAqIEVbMV0pLCBsdCA9IEgoRSksIHogPSBMKCkgPCAwLjUgPyAxIDogLTEsIFcgPSAteiwgWCwgViwgdXQ7IChYID0gbHQoVyArPSB6KSkgJiYgKFYgPSB+flhbMF0sIHV0ID0gfn5YWzFdLCAhKE1hdGgubWluKE1hdGguYWJzKFYpLCBNYXRoLmFicyh1dCkpID49IHR0KSk7IClcbiAgICAgICAgaWYgKFkueCA9IFEgKyBWLCBZLnkgPSBxICsgdXQsICEoWS54ICsgWS54MCA8IDAgfHwgWS55ICsgWS55MCA8IDAgfHwgWS54ICsgWS54MSA+IEVbMF0gfHwgWS55ICsgWS55MSA+IEVbMV0pICYmICghb3QgfHwgZihZLCBvdCkpICYmICFoKFksIEYsIEVbMF0pKSB7XG4gICAgICAgICAgZm9yICh2YXIgc3QgPSBZLnNwcml0ZSwgRHQgPSBZLndpZHRoID4+IDUsIE50ID0gRVswXSA+PiA1LCBudCA9IFkueCAtIChEdCA8PCA0KSwgeXQgPSBudCAmIDEyNywgU2UgPSAzMiAtIHl0LCBnZSA9IFkueTEgLSBZLnkwLCBvaSA9IChZLnkgKyBZLnkwKSAqIE50ICsgKG50ID4+IDUpLCBsaSwgRm4gPSAwOyBGbiA8IGdlOyBGbisrKSB7XG4gICAgICAgICAgICBsaSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBJZSA9IDA7IEllIDw9IER0OyBJZSsrKVxuICAgICAgICAgICAgICBGW29pICsgSWVdIHw9IGxpIDw8IFNlIHwgKEllIDwgRHQgPyAobGkgPSBzdFtGbiAqIER0ICsgSWVdKSA+Pj4geXQgOiAwKTtcbiAgICAgICAgICAgIG9pICs9IE50O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgcmV0dXJuIGsudGltZUludGVydmFsID0gZnVuY3Rpb24oRikge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoQiA9IEYgPz8gMSAvIDAsIGspIDogQjtcbiAgICB9LCBrLndvcmRzID0gZnVuY3Rpb24oRikge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoUCA9IEYsIGspIDogUDtcbiAgICB9LCBrLnNpemUgPSBmdW5jdGlvbihGKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChFID0gWytGWzBdLCArRlsxXV0sIGspIDogRTtcbiAgICB9LCBrLmZvbnQgPSBmdW5jdGlvbihGKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChTID0gXyhGKSwgaykgOiBTO1xuICAgIH0sIGsuZm9udFN0eWxlID0gZnVuY3Rpb24oRikge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoRCA9IF8oRiksIGspIDogRDtcbiAgICB9LCBrLmZvbnRXZWlnaHQgPSBmdW5jdGlvbihGKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChBID0gXyhGKSwgaykgOiBBO1xuICAgIH0sIGsucm90YXRlID0gZnVuY3Rpb24oRikge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoUiA9IF8oRiksIGspIDogUjtcbiAgICB9LCBrLnRleHQgPSBmdW5jdGlvbihGKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChiID0gXyhGKSwgaykgOiBiO1xuICAgIH0sIGsuc3BpcmFsID0gZnVuY3Rpb24oRikge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoSCA9IG5bRl0gfHwgRiwgaykgOiBIO1xuICAgIH0sIGsuZm9udFNpemUgPSBmdW5jdGlvbihGKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChNID0gXyhGKSwgaykgOiBNO1xuICAgIH0sIGsucGFkZGluZyA9IGZ1bmN0aW9uKEYpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKCQgPSBfKEYpLCBrKSA6ICQ7XG4gICAgfSwgay5yYW5kb20gPSBmdW5jdGlvbihGKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChMID0gRiwgaykgOiBMO1xuICAgIH0sIGsub24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBGID0gTy5vbi5hcHBseShPLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIEYgPT09IE8gPyBrIDogRjtcbiAgICB9LCBrO1xuICB9O1xuICBmdW5jdGlvbiBzKEUpIHtcbiAgICByZXR1cm4gRS50ZXh0O1xuICB9XG4gIGZ1bmN0aW9uIGEoKSB7XG4gICAgcmV0dXJuIFwic2VyaWZcIjtcbiAgfVxuICBmdW5jdGlvbiBvKCkge1xuICAgIHJldHVybiBcIm5vcm1hbFwiO1xuICB9XG4gIGZ1bmN0aW9uIGwoRSkge1xuICAgIHJldHVybiBNYXRoLnNxcnQoRS52YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gYygpIHtcbiAgICByZXR1cm4gKH5+KHJhbmRvbSgpICogNikgLSAzKSAqIDMwO1xuICB9XG4gIGZ1bmN0aW9uIHUoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgZnVuY3Rpb24gZChFLCBiLCBTLCBNKSB7XG4gICAgaWYgKCFiLnNwcml0ZSkge1xuICAgICAgdmFyIEQgPSBFLmNvbnRleHQsIEEgPSBFLnJhdGlvO1xuICAgICAgRC5jbGVhclJlY3QoMCwgMCwgKHIgPDwgNSkgLyBBLCBpIC8gQSk7XG4gICAgICB2YXIgUiA9IDAsICQgPSAwLCBIID0gMCwgUCA9IFMubGVuZ3RoO1xuICAgICAgZm9yICgtLU07ICsrTSA8IFA7ICkge1xuICAgICAgICBiID0gU1tNXSwgRC5zYXZlKCksIEQuZm9udCA9IGIuc3R5bGUgKyBcIiBcIiArIGIud2VpZ2h0ICsgXCIgXCIgKyB+figoYi5zaXplICsgMSkgLyBBKSArIFwicHggXCIgKyBiLmZvbnQ7XG4gICAgICAgIGNvbnN0IFggPSBELm1lYXN1cmVUZXh0KGIudGV4dCksIFYgPSAtTWF0aC5mbG9vcihYLndpZHRoIC8gMik7XG4gICAgICAgIGxldCB1dCA9IChYLndpZHRoICsgMSkgKiBBLCBzdCA9IGIuc2l6ZSA8PCAxO1xuICAgICAgICBpZiAoYi5yb3RhdGUpIHtcbiAgICAgICAgICB2YXIgQiA9IE1hdGguc2luKGIucm90YXRlICogdCksIE8gPSBNYXRoLmNvcyhiLnJvdGF0ZSAqIHQpLCB3ID0gdXQgKiBPLCBMID0gdXQgKiBCLCBrID0gc3QgKiBPLCBVID0gc3QgKiBCO1xuICAgICAgICAgIHV0ID0gTWF0aC5tYXgoTWF0aC5hYnModyArIFUpLCBNYXRoLmFicyh3IC0gVSkpICsgMzEgPj4gNSA8PCA1LCBzdCA9IH5+TWF0aC5tYXgoTWF0aC5hYnMoTCArIGspLCBNYXRoLmFicyhMIC0gaykpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICB1dCA9IHV0ICsgMzEgPj4gNSA8PCA1O1xuICAgICAgICBpZiAoc3QgPiBIICYmIChIID0gc3QpLCBSICsgdXQgPj0gciA8PCA1ICYmIChSID0gMCwgJCArPSBILCBIID0gMCksICQgKyBzdCA+PSBpKSBicmVhaztcbiAgICAgICAgRC50cmFuc2xhdGUoKFIgKyAodXQgPj4gMSkpIC8gQSwgKCQgKyAoc3QgPj4gMSkpIC8gQSksIGIucm90YXRlICYmIEQucm90YXRlKGIucm90YXRlICogdCksIEQuZmlsbFRleHQoYi50ZXh0LCBWLCAwKSwgYi5wYWRkaW5nICYmIChELmxpbmVXaWR0aCA9IDIgKiBiLnBhZGRpbmcsIEQuc3Ryb2tlVGV4dChiLnRleHQsIFYsIDApKSwgRC5yZXN0b3JlKCksIGIud2lkdGggPSB1dCwgYi5oZWlnaHQgPSBzdCwgYi54b2ZmID0gUiwgYi55b2ZmID0gJCwgYi54MSA9IHV0ID4+IDEsIGIueTEgPSBzdCA+PiAxLCBiLngwID0gLWIueDEsIGIueTAgPSAtYi55MSwgYi5oYXNUZXh0ID0gITAsIFIgKz0gdXQ7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBaID0gRC5nZXRJbWFnZURhdGEoMCwgMCwgKHIgPDwgNSkgLyBBLCBpIC8gQSkuZGF0YSwgaiA9IFtdOyAtLU0gPj0gMDsgKVxuICAgICAgICBpZiAoYiA9IFNbTV0sICEhYi5oYXNUZXh0KSB7XG4gICAgICAgICAgZm9yICh2YXIgRiA9IGIud2lkdGgsIFkgPSBGID4+IDUsIG90ID0gYi55MSAtIGIueTAsIFEgPSAwOyBRIDwgb3QgKiBZOyBRKyspIGpbUV0gPSAwO1xuICAgICAgICAgIGlmIChSID0gYi54b2ZmLCBSID09IG51bGwpIHJldHVybjtcbiAgICAgICAgICAkID0gYi55b2ZmO1xuICAgICAgICAgIGZvciAodmFyIHEgPSAwLCB0dCA9IC0xLCBsdCA9IDA7IGx0IDwgb3Q7IGx0KyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIFEgPSAwOyBRIDwgRjsgUSsrKSB7XG4gICAgICAgICAgICAgIHZhciB6ID0gWSAqIGx0ICsgKFEgPj4gNSksIFcgPSBaWygkICsgbHQpICogKHIgPDwgNSkgKyAoUiArIFEpIDw8IDJdID8gMSA8PCAzMSAtIFEgJSAzMiA6IDA7XG4gICAgICAgICAgICAgIGpbel0gfD0gVywgcSB8PSBXO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcSA/IHR0ID0gbHQgOiAoYi55MCsrLCBvdC0tLCBsdC0tLCAkKyspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiLnkxID0gYi55MCArIHR0LCBiLnNwcml0ZSA9IGouc2xpY2UoMCwgKGIueTEgLSBiLnkwKSAqIFkpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGgoRSwgYiwgUykge1xuICAgIFMgPj49IDU7XG4gICAgZm9yICh2YXIgTSA9IEUuc3ByaXRlLCBEID0gRS53aWR0aCA+PiA1LCBBID0gRS54IC0gKEQgPDwgNCksIFIgPSBBICYgMTI3LCAkID0gMzIgLSBSLCBIID0gRS55MSAtIEUueTAsIFAgPSAoRS55ICsgRS55MCkgKiBTICsgKEEgPj4gNSksIEIsIE8gPSAwOyBPIDwgSDsgTysrKSB7XG4gICAgICBCID0gMDtcbiAgICAgIGZvciAodmFyIHcgPSAwOyB3IDw9IEQ7IHcrKylcbiAgICAgICAgaWYgKChCIDw8ICQgfCAodyA8IEQgPyAoQiA9IE1bTyAqIEQgKyB3XSkgPj4+IFIgOiAwKSkgJiBiW1AgKyB3XSkgcmV0dXJuICEwO1xuICAgICAgUCArPSBTO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH1cbiAgZnVuY3Rpb24gcChFLCBiKSB7XG4gICAgdmFyIFMgPSBFWzBdLCBNID0gRVsxXTtcbiAgICBiLnggKyBiLngwIDwgUy54ICYmIChTLnggPSBiLnggKyBiLngwKSwgYi55ICsgYi55MCA8IFMueSAmJiAoUy55ID0gYi55ICsgYi55MCksIGIueCArIGIueDEgPiBNLnggJiYgKE0ueCA9IGIueCArIGIueDEpLCBiLnkgKyBiLnkxID4gTS55ICYmIChNLnkgPSBiLnkgKyBiLnkxKTtcbiAgfVxuICBmdW5jdGlvbiBmKEUsIGIpIHtcbiAgICByZXR1cm4gRS54ICsgRS54MSA+IGJbMF0ueCAmJiBFLnggKyBFLngwIDwgYlsxXS54ICYmIEUueSArIEUueTEgPiBiWzBdLnkgJiYgRS55ICsgRS55MCA8IGJbMV0ueTtcbiAgfVxuICBmdW5jdGlvbiBnKEUpIHtcbiAgICB2YXIgYiA9IEVbMF0gLyBFWzFdO1xuICAgIHJldHVybiBmdW5jdGlvbihTKSB7XG4gICAgICByZXR1cm4gW2IgKiAoUyAqPSAwLjEpICogTWF0aC5jb3MoUyksIFMgKiBNYXRoLnNpbihTKV07XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBtKEUpIHtcbiAgICB2YXIgYiA9IDQsIFMgPSBiICogRVswXSAvIEVbMV0sIE0gPSAwLCBEID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24oQSkge1xuICAgICAgdmFyIFIgPSBBIDwgMCA/IC0xIDogMTtcbiAgICAgIHN3aXRjaCAoTWF0aC5zcXJ0KDEgKyA0ICogUiAqIEEpIC0gUiAmIDMpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIE0gKz0gUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIEQgKz0gYjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIE0gLT0gUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBEIC09IGI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gW00sIERdO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gdihFKSB7XG4gICAgZm9yICh2YXIgYiA9IFtdLCBTID0gLTE7ICsrUyA8IEU7ICkgYltTXSA9IDA7XG4gICAgcmV0dXJuIGI7XG4gIH1cbiAgZnVuY3Rpb24geCgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgfVxuICBmdW5jdGlvbiBfKEUpIHtcbiAgICByZXR1cm4gdHlwZW9mIEUgPT0gXCJmdW5jdGlvblwiID8gRSA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEU7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gdWw7XG59XG52YXIgTU4gPSAkTigpO1xuY29uc3QgQ04gPSAvKiBAX19QVVJFX18gKi8gYk4oTU4pO1xuY2xhc3MgQU4gZXh0ZW5kcyBtdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IFwid29yZGNsb3VkXCIsIHRoaXMucmVuZGVyVHlwZSA9IHJ0LlNWRywgdGhpcy5oYW5kbGVMZWdlbmRPbkhvdmVyID0gKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgaG92ZXJlZEVsZW1lbnQ6IG4gfSA9IHQuZGV0YWlsLCB7IGdyb3VwTWFwc1RvOiByIH0gPSB0aGlzLmdldE9wdGlvbnMoKS5kYXRhO1xuICAgICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwidGV4dC53b3JkXCIpLnRyYW5zaXRpb24oXCJsZWdlbmQtaG92ZXItd29yZGNsb3VkXCIpLmNhbGwoXG4gICAgICAgIChpKSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgdHJhbnNpdGlvbjogaSxcbiAgICAgICAgICBuYW1lOiBcImxlZ2VuZC1ob3Zlci13b3JkY2xvdWRcIlxuICAgICAgICB9KVxuICAgICAgKS5hdHRyKFwib3BhY2l0eVwiLCAoaSkgPT4gaVtyXSAhPT0gbi5kYXR1bSgpLm5hbWUgPyAwLjMgOiAxKTtcbiAgICB9LCB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlT3V0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5wYXJlbnQuc2VsZWN0QWxsKFwidGV4dC53b3JkXCIpLnRyYW5zaXRpb24oXCJsZWdlbmQtbW91c2VvdXQtd29yZGNsb3VkXCIpLmNhbGwoXG4gICAgICAgICh0KSA9PiB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgdHJhbnNpdGlvbjogdCxcbiAgICAgICAgICBuYW1lOiBcImxlZ2VuZC1tb3VzZW91dC13b3JkY2xvdWRcIlxuICAgICAgICB9KVxuICAgICAgKS5hdHRyKFwib3BhY2l0eVwiLCAxKTtcbiAgICB9O1xuICB9XG4gIGluaXQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuc2VydmljZXMuZXZlbnRzO1xuICAgIHQuYWRkRXZlbnRMaXN0ZW5lcihULkxlZ2VuZC5JVEVNX0hPVkVSLCB0aGlzLmhhbmRsZUxlZ2VuZE9uSG92ZXIpLCB0LmFkZEV2ZW50TGlzdGVuZXIoVC5MZWdlbmQuSVRFTV9NT1VTRU9VVCwgdGhpcy5oYW5kbGVMZWdlbmRNb3VzZU91dCk7XG4gIH1cbiAgcmVuZGVyKHQgPSAhMCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLCByID0gdGhpcy5nZXRDb21wb25lbnRDb250YWluZXIoe1xuICAgICAgYXJpYUxhYmVsOiBcIndvcmQgY2xvdWRcIlxuICAgIH0pLmF0dHIoXCJ3aWR0aFwiLCBcIjEwMCVcIikuYXR0cihcImhlaWdodFwiLCBcIjEwMCVcIiksIGkgPSB0aGlzLm1vZGVsLmdldERpc3BsYXlEYXRhKCksIHMgPSB0aGlzLmdldEZvbnRTaXplU2NhbGUoaSksIGEgPSB0aGlzLmdldE9wdGlvbnMoKSwgeyBmb250U2l6ZU1hcHNUbzogbywgd29yZE1hcHNUbzogbCB9ID0gYS53b3JkQ2xvdWQsIHsgZ3JvdXBNYXBzVG86IGMgfSA9IGEuZGF0YSwgeyB3aWR0aDogdSwgaGVpZ2h0OiBkIH0gPSBOLmdldFNWR0VsZW1lbnRTaXplKHIsIHtcbiAgICAgIHVzZUF0dHJzOiAhMFxuICAgIH0pO1xuICAgIGlmICh1ID09PSAwIHx8IGQgPT09IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaCA9IENOKCkuc2l6ZShbdSwgZF0pLndvcmRzKFxuICAgICAgaS5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgICBjb25zdCBnID0gZltvXTtcbiAgICAgICAgaWYgKHR5cGVvZiBmW29dICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkJhZGx5IGZvcm1hdHRlZCBXb3JkQ2xvdWQgZGF0YS4gYHZhbHVlYCBzaG91bGQgb25seSBiZSBhbiBpbnRlZ2VyIG9yIGZsb2F0XCJcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIFtjXTogZltjXSxcbiAgICAgICAgICB0ZXh0OiBmW2xdLFxuICAgICAgICAgIHNpemU6IGcsXG4gICAgICAgICAgdmFsdWU6IGdcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgKS5wYWRkaW5nKDUpLnJvdGF0ZSgwKS5mb250U2l6ZSgoZikgPT4gcyhmLnNpemUpKS5vbihcImVuZFwiLCBwKTtcbiAgICBoLnN0YXJ0KCk7XG4gICAgZnVuY3Rpb24gcChmKSB7XG4gICAgICBjb25zdCBnID0gTi5hcHBlbmRPclNlbGVjdChyLCBcImcud29yZHNcIik7XG4gICAgICBnLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke2guc2l6ZSgpWzBdIC8gMn0sICR7aC5zaXplKClbMV0gLyAyfSlgKTtcbiAgICAgIGNvbnN0IG0gPSBnLnNlbGVjdEFsbChcInRleHRcIikuZGF0YShmLCAodikgPT4gYCR7dltjXX0tJHt2LnRleHR9YCk7XG4gICAgICBtLmV4aXQoKS5hdHRyKFwib3BhY2l0eVwiLCAwKS5yZW1vdmUoKSwgbS5lbnRlcigpLmFwcGVuZChcInRleHRcIikuYXR0cihcIm9wYWNpdHlcIiwgMCkubWVyZ2UobSkuc3R5bGUoXCJmb250LXNpemVcIiwgKHYpID0+IGAke3Yuc2l6ZX1weGApLnRleHQoZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdi50ZXh0O1xuICAgICAgfSkuYXR0cihcbiAgICAgICAgXCJjbGFzc1wiLFxuICAgICAgICAodikgPT4gbi5tb2RlbC5nZXRDb2xvckNsYXNzTmFtZSh7XG4gICAgICAgICAgY2xhc3NOYW1lVHlwZXM6IFtpdC5GSUxMXSxcbiAgICAgICAgICBkYXRhR3JvdXBOYW1lOiB2W2NdLFxuICAgICAgICAgIG9yaWdpbmFsQ2xhc3NOYW1lOiBgd29yZCAke3Yuc2l6ZSA+IDMyID8gXCJsaWdodFwiIDogXCJcIn1gXG4gICAgICAgIH0pXG4gICAgICApLnN0eWxlKFwiZmlsbFwiLCAodikgPT4gbi5tb2RlbC5nZXRGaWxsQ29sb3IodltjXSwgdi50ZXh0LCB2KSkuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpLnRyYW5zaXRpb24oKS5jYWxsKFxuICAgICAgICAodikgPT4gbi5zZXJ2aWNlcy50cmFuc2l0aW9ucy5zZXR1cFRyYW5zaXRpb24oe1xuICAgICAgICAgIHRyYW5zaXRpb246IHYsXG4gICAgICAgICAgbmFtZTogXCJ3b3JkY2xvdWQtdGV4dC11cGRhdGUtZW50ZXJcIixcbiAgICAgICAgICBhbmltYXRlOiB0XG4gICAgICAgIH0pXG4gICAgICApLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgKHYpID0+IGB0cmFuc2xhdGUoJHt2Lnh9LCAke3YueX0pYCkuYXR0cihcIm9wYWNpdHlcIiwgMSk7XG4gICAgfVxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICBnZXRGb250U2l6ZVNjYWxlKHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRPcHRpb25zKCksIHsgZm9udFNpemVNYXBzVG86IHIgfSA9IG4ud29yZENsb3VkLCBpID0gdC5tYXAoKGwpID0+IGxbcl0pLmZpbHRlcigobCkgPT4gbCksIHMgPSBOLmdldEhUTUxFbGVtZW50U2l6ZSh0aGlzLnNlcnZpY2VzLmRvbVV0aWxzLmdldE1haW5Db250YWluZXIoKSksIGEgPSBpLmxlbmd0aCA+IDAsIG8gPSBhID8gemUoaSkgOiBbMSwgMV07XG4gICAgcmV0dXJuIEZlKCkuZG9tYWluKG8pLnJhbmdlKGEgPyBuLndvcmRDbG91ZC5mb250U2l6ZVJhbmdlKHMsIHQpIDogWzQsIDRdKTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRPcHRpb25zKCksIHsgZ3JvdXBNYXBzVG86IG4gfSA9IHQuZGF0YSwgciA9IHRoaXMsIGkgPSBiYSgocykgPT4ge1xuICAgICAgY29uc3QgYSA9IHIucGFyZW50LnNlbGVjdEFsbChcInRleHQud29yZFwiKS50cmFuc2l0aW9uKFwid29yZGNsb3VkLXdvcmQtbW91c2UtaGlnaGxpZ2h0XCIpLmNhbGwoXG4gICAgICAgIChvKSA9PiByLnNlcnZpY2VzLnRyYW5zaXRpb25zLnNldHVwVHJhbnNpdGlvbih7XG4gICAgICAgICAgdHJhbnNpdGlvbjogbyxcbiAgICAgICAgICBuYW1lOiBcIndvcmRjbG91ZC13b3JkLW1vdXNlLWhpZ2hsaWdodFwiXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcyA9PT0gbnVsbCA/IGEuYXR0cihcIm9wYWNpdHlcIiwgMSkgOiBhLmF0dHIoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcyA9PT0gdGhpcyA/IDEgOiAwLjM7XG4gICAgICB9KTtcbiAgICB9LCA2KTtcbiAgICB0aGlzLnBhcmVudC5zZWxlY3RBbGwoXCJ0ZXh0LndvcmRcIikub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24ocywgYSkge1xuICAgICAgY29uc3QgbyA9IHRoaXM7XG4gICAgICBpKG8pLCByLnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuV29yZENsb3VkLldPUkRfTU9VU0VPVkVSLCB7XG4gICAgICAgIGV2ZW50OiBzLFxuICAgICAgICBlbGVtZW50OiBJKHRoaXMpLFxuICAgICAgICBkYXR1bTogYVxuICAgICAgfSksIHIuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Ub29sdGlwLlNIT1csIHtcbiAgICAgICAgZXZlbnQ6IHMsXG4gICAgICAgIGhvdmVyZWRFbGVtZW50OiBvLFxuICAgICAgICBpdGVtczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiB0LnRvb2x0aXAud29yZExhYmVsLFxuICAgICAgICAgICAgdmFsdWU6IGEudGV4dFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6IHQudG9vbHRpcC52YWx1ZUxhYmVsLFxuICAgICAgICAgICAgdmFsdWU6IGEudmFsdWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiBndCh0LCBcImxvY2FsZS50cmFuc2xhdGlvbnMuZ3JvdXBcIikgfHwgZ3QodCwgXCJ0b29sdGlwLmdyb3VwTGFiZWxcIikgfHwgXCJHcm91cFwiLFxuICAgICAgICAgICAgdmFsdWU6IGFbbl0sXG4gICAgICAgICAgICBjbGFzczogci5tb2RlbC5nZXRDb2xvckNsYXNzTmFtZSh7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZVR5cGVzOiBbaXQuVE9PTFRJUF0sXG4gICAgICAgICAgICAgIGRhdGFHcm91cE5hbWU6IGFbbl1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9KTtcbiAgICB9KS5vbihcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbihzLCBhKSB7XG4gICAgICBjb25zdCBvID0gSSh0aGlzKTtcbiAgICAgIHIuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Xb3JkQ2xvdWQuV09SRF9NT1VTRU1PVkUsIHtcbiAgICAgICAgZWxlbWVudDogbyxcbiAgICAgICAgZGF0dW06IGFcbiAgICAgIH0pLCByLnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuVG9vbHRpcC5NT1ZFLCB7XG4gICAgICAgIGV2ZW50OiBzXG4gICAgICB9KTtcbiAgICB9KS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKHMsIGEpIHtcbiAgICAgIHIuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5Xb3JkQ2xvdWQuV09SRF9DTElDSywge1xuICAgICAgICBldmVudDogcyxcbiAgICAgICAgZWxlbWVudDogSSh0aGlzKSxcbiAgICAgICAgZGF0dW06IGFcbiAgICAgIH0pO1xuICAgIH0pLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24ocywgYSkge1xuICAgICAgY29uc3QgbyA9IEkodGhpcyk7XG4gICAgICBpKG51bGwpLCByLnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KFQuV29yZENsb3VkLldPUkRfTU9VU0VPVVQsIHtcbiAgICAgICAgZXZlbnQ6IHMsXG4gICAgICAgIGVsZW1lbnQ6IG8sXG4gICAgICAgIGRhdHVtOiBhXG4gICAgICB9KSwgci5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULlRvb2x0aXAuSElERSwge1xuICAgICAgICBob3ZlcmVkRWxlbWVudDogb1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIExOIGV4dGVuZHMgbXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnR5cGUgPSBcImdlb1wiLCB0aGlzLnJlbmRlclR5cGUgPSBydC5TVkc7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldENvbXBvbmVudENvbnRhaW5lcih7IHdpdGhpbkNoYXJ0Q2xpcDogITAgfSksIHsgd2lkdGg6IG4sIGhlaWdodDogciB9ID0gTi5nZXRTVkdFbGVtZW50U2l6ZSh0LCB7XG4gICAgICB1c2VBdHRyczogITBcbiAgICB9KTtcbiAgICBpZiAobiA8IDEgfHwgciA8IDEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0UHJvamVjdGlvbigpLCBzID0geSh0aGlzLmdldE9wdGlvbnMoKSwgXCJnZW9EYXRhXCIpLCBhID0gdGhpcy5tb2RlbC5nZXRDb21iaW5lZERhdGEoKSwgbyA9IHt9LCBsID0ge307XG4gICAgT2JqZWN0LmtleXMoYSkuZm9yRWFjaCgobSkgPT4ge1xuICAgICAgdHlwZW9mIGFbbV0udmFsdWUgPT0gXCJudW1iZXJcIiA/IG9bbV0gPSBhW21dIDogbFttXSA9IGFbbV07XG4gICAgfSk7XG4gICAgY29uc3QgYyA9IE9EKHMsIE9iamVjdC52YWx1ZXMobCkpLCB1ID0gYkQocywge1xuICAgICAgLy8gV2UgbmVlZCB0byBzcGVjaWZ5IHRoYXQgd2UgYXJlIGNvbnZlcnRpbmcgZ2VvbWV0cnkgY29sbGVjdGlvbnNcbiAgICAgIHR5cGU6IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXG4gICAgICBnZW9tZXRyaWVzOiBPYmplY3QudmFsdWVzKG8pXG4gICAgfSksIGQgPSBpLmZpdFNpemUoW24sIHJdLCB1KSwgaCA9IFJBKCkucHJvamVjdGlvbihkKTtcbiAgICBOLmFwcGVuZE9yU2VsZWN0KHQsIFwiZy5nZW9cIikuc2VsZWN0QWxsKFwicGF0aFwiKS5kYXRhKHUuZmVhdHVyZXMpLmpvaW4oXCJwYXRoXCIpLmF0dHIoXCJkXCIsIGgpO1xuICAgIGNvbnN0IHAgPSB0aGlzLnNlcnZpY2VzLmRvbVV0aWxzLmdlbmVyYXRlRWxlbWVudElEU3RyaW5nKFwiZ2VvLXBhdHRlcm4tc3RyaXBlc1wiKSwgZiA9IE4uYXBwZW5kT3JTZWxlY3QodCwgXCJkZWZzXCIpO1xuICAgIE4uYXBwZW5kT3JTZWxlY3QoZiwgXCJwYXR0ZXJuXCIpLmF0dHIoXCJpZFwiLCBwKS5hdHRyKFwid2lkdGhcIiwgNSkuYXR0cihcImhlaWdodFwiLCAxMCkuYXR0cihcInBhdHRlcm5Vbml0c1wiLCBcInVzZXJTcGFjZU9uVXNlXCIpLmF0dHIoXCJwYXR0ZXJuVHJhbnNmb3JtXCIsIFwicm90YXRlKDQ1KVwiKS5hcHBlbmQoXCJwYXRoXCIpLmNsYXNzZWQoXCJwYXR0ZXJuLWZpbGxcIiwgITApLmF0dHIoXG4gICAgICBcImRcIixcbiAgICAgIHhzKCkoW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFswLCAxMF1cbiAgICAgIF0pXG4gICAgKTtcbiAgICBjb25zdCBnID0gTi5hcHBlbmRPclNlbGVjdCh0LCBcImcubWlzc2luZy1kYXRhXCIpO1xuICAgIE4uYXBwZW5kT3JTZWxlY3QoZywgXCJwYXRoXCIpLmRhdHVtKGMpLmF0dHIoXCJkXCIsIGgpLnN0eWxlKFwiZmlsbFwiLCBgdXJsKCMke3B9KWApO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIEQzIGdlb2dyYXBoaWMgcHJvamVjdGlvbiBiYXNlZCBvbiB0aGUgb3B0aW9ucyBwcm92aWRlZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgc2VsZWN0cyBhIGdlb2dyYXBoaWMgcHJvamVjdGlvbiBmcm9tIHRoZSBhdmFpbGFibGUgRDMgcHJvamVjdGlvbnNcbiAgICogYmFzZWQgb24gdGhlIGBwcm9qZWN0aW9uYCBwcm9wZXJ0eSBpbiB0aGUgYHRoZW1hdGljYCBvcHRpb25zLiBJZiB0aGUgcHJvamVjdGlvblxuICAgKiBpcyBub3Qgc3VwcG9ydGVkIG9yIGlzIG1pc3NpbmcsIGFuIGVycm9yIGlzIHRocm93bi5cbiAgICpcbiAgICogQHJldHVybnMge2QzLkdlb1Byb2plY3Rpb259IC0gVGhlIEQzIGdlb2dyYXBoaWMgcHJvamVjdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBzZWxlY3RlZCBvcHRpb24uXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcHJvamVjdGlvbiBpcyBub3Qgc3VwcG9ydGVkIG9yIGlzIG1pc3NpbmcuXG4gICAqL1xuICBnZXRQcm9qZWN0aW9uKCkge1xuICAgIGxldCB0ID0gbnVsbDtcbiAgICBzd2l0Y2ggKHkodGhpcy5nZXRPcHRpb25zKCksIFwidGhlbWF0aWNcIiwgXCJwcm9qZWN0aW9uXCIpKSB7XG4gICAgICAvLyBBemltdXRoYWwgUHJvamVjdGlvbnNcbiAgICAgIGNhc2UgZ24uZ2VvRXF1YWxFYXJ0aDpcbiAgICAgICAgdCA9IEpBKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gQ29uaWMgUHJvamVjdGlvbnNcbiAgICAgIGNhc2UgZ24uZ2VvQWxiZXJzOlxuICAgICAgICB0ID0gV0EoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGduLmdlb0NvbmljRXF1YWxBcmVhOlxuICAgICAgICB0ID0gdHYoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGduLmdlb0NvbmljRXF1aWRpc3RhbnQ6XG4gICAgICAgIHQgPSBLQSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIEN5bmRyaWNhbCBwcm9qZWN0aW9uc1xuICAgICAgY2FzZSBnbi5nZW9FcXVpcmVjdGFuZ3VsYXI6XG4gICAgICAgIHQgPSBYQSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZ24uZ2VvTWVyY2F0b3I6XG4gICAgICAgIHQgPSBxQSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZ24uZ2VvTmF0dXJhbEVhcnRoMTpcbiAgICAgICAgdCA9IHRMKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvamVjdGlvbiBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbn1cbmNsYXNzIGtOIGV4dGVuZHMgTE4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnR5cGUgPSBcImNob3JvcGxldGhcIjtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gIC8vIEB0cy1pZ25vcmVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICByZW5kZXIodCA9ICEwKSB7XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgY29uc3QgbiA9IHRoaXMubW9kZWwuZ2V0Q29tYmluZWREYXRhKCksIHIgPSB0aGlzLmdldENvbXBvbmVudENvbnRhaW5lcih7IGFyaWFMYWJlbDogXCJtYXBcIiwgd2l0aGluQ2hhcnRDbGlwOiAhMCB9KSwgaSA9IHkodGhpcy5nZXRPcHRpb25zKCksIFwiY29sb3JcIiksIHMgPSB5KGksIFwiZ3JhZGllbnRcIiwgXCJjb2xvcnNcIik7XG4gICAgci5zZWxlY3QoXCJnLmdlb1wiKS5zZWxlY3RBbGwoXCJwYXRoXCIpLmNsYXNzZWQoXCJib3JkZXJcIiwgITApLmF0dHIoXCJjbGFzc1wiLCAoYSkgPT4gdGhpcy5tb2RlbC5nZXRDb2xvckNsYXNzTmFtZSh7XG4gICAgICB2YWx1ZTogblthLnByb3BlcnRpZXMuTkFNRV0udmFsdWUsXG4gICAgICBvcmlnaW5hbENsYXNzTmFtZTogXCJib3JkZXJcIlxuICAgIH0pKS5hdHRyKFwic3R5bGVcIiwgKGEpID0+IHMgPyBgZmlsbDogJHt0aGlzLm1vZGVsLmdldENvbG9yQ2xhc3NOYW1lKHtcbiAgICAgIHZhbHVlOiBuW2EucHJvcGVydGllcy5OQU1FXS52YWx1ZVxuICAgIH0pfWAgOiBudWxsKSwgdGhpcy5hZGRDb3VudHJ5QXJlYUV2ZW50TGlzdGVuZXIoKTtcbiAgfVxuICBhZGRDb3VudHJ5QXJlYUV2ZW50TGlzdGVuZXIoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMsIG4gPSB0aGlzLm1vZGVsLmdldENvbWJpbmVkRGF0YSgpO1xuICAgIHRoaXMucGFyZW50LnNlbGVjdEFsbChcInBhdGguYm9yZGVyXCIpLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKHIsIGkpIHtcbiAgICAgIGNvbnN0IHMgPSBJKHRoaXMpO1xuICAgICAgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChEci5DSE9ST1BMRVRIX01PVVNFT1ZFUiwge1xuICAgICAgICBldmVudDogcixcbiAgICAgICAgZWxlbWVudDogcyxcbiAgICAgICAgZGF0dW06IG5baS5wcm9wZXJ0aWVzLk5BTUVdXG4gICAgICB9KSwgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChJaS5TSE9XLCB7XG4gICAgICAgIGV2ZW50OiByLFxuICAgICAgICBob3ZlcmVkRWxlbWVudDogcyxcbiAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogaS5wcm9wZXJ0aWVzLk5BTUUsXG4gICAgICAgICAgICB2YWx1ZTogbltpLnByb3BlcnRpZXMuTkFNRV0udmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0pO1xuICAgIH0pLm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKHIsIGkpIHtcbiAgICAgIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoRHIuQ0hPUk9QTEVUSF9NT1VTRU1PVkUsIHtcbiAgICAgICAgZXZlbnQ6IHIsXG4gICAgICAgIGVsZW1lbnQ6IEkodGhpcyksXG4gICAgICAgIGRhdHVtOiBuW2kucHJvcGVydGllcy5OQU1FXVxuICAgICAgfSksIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoSWkuTU9WRSwge1xuICAgICAgICBldmVudDogclxuICAgICAgfSk7XG4gICAgfSkub24oXCJjbGlja1wiLCBmdW5jdGlvbihyLCBpKSB7XG4gICAgICB0LnNlcnZpY2VzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KERyLkNIT1JPUExFVEhfQ0xJQ0ssIHtcbiAgICAgICAgZXZlbnQ6IHIsXG4gICAgICAgIGVsZW1lbnQ6IEkodGhpcyksXG4gICAgICAgIGRhdHVtOiBuW2kucHJvcGVydGllcy5OQU1FXVxuICAgICAgfSk7XG4gICAgfSkub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihyLCBpKSB7XG4gICAgICBjb25zdCBzID0gSSh0aGlzKTtcbiAgICAgIHQuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoRHIuQ0hPUk9QTEVUSF9NT1VTRU9VVCwge1xuICAgICAgICBldmVudDogcixcbiAgICAgICAgZWxlbWVudDogcyxcbiAgICAgICAgZGF0dW06IG5baS5wcm9wZXJ0aWVzLk5BTUVdXG4gICAgICB9KSwgdC5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChJaS5ISURFLCB7XG4gICAgICAgIGV2ZW50OiByLFxuICAgICAgICBob3ZlcmVkRWxlbWVudDogc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGR1KGUpIHtcbiAgdmFyIHQgPSBlID09IG51bGwgPyAwIDogZS5sZW5ndGg7XG4gIHJldHVybiB0ID8gS2EoZSwgMSkgOiBbXTtcbn1cbmZ1bmN0aW9uIEROKGUpIHtcbiAgcmV0dXJuIHZmKHhmKGUsIHZvaWQgMCwgZHUpLCBlICsgXCJcIik7XG59XG5mdW5jdGlvbiBrdihlLCB0LCBuKSB7XG4gIHZhciByID0gLTEsIGkgPSBlLmxlbmd0aDtcbiAgdCA8IDAgJiYgKHQgPSAtdCA+IGkgPyAwIDogaSArIHQpLCBuID0gbiA+IGkgPyBpIDogbiwgbiA8IDAgJiYgKG4gKz0gaSksIGkgPSB0ID4gbiA/IDAgOiBuIC0gdCA+Pj4gMCwgdCA+Pj49IDA7XG4gIGZvciAodmFyIHMgPSBBcnJheShpKTsgKytyIDwgaTsgKVxuICAgIHNbcl0gPSBlW3IgKyB0XTtcbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBSTihlLCB0KSB7XG4gIHJldHVybiB0Lmxlbmd0aCA8IDIgPyBlIDogT2MoZSwga3YodCwgMCwgLTEpKTtcbn1cbmZ1bmN0aW9uIElOKGUsIHQpIHtcbiAgcmV0dXJuIHQgPSBaYSh0LCBlKSwgZSA9IFJOKGUsIHQpLCBlID09IG51bGwgfHwgZGVsZXRlIGVbaHMoV2YodCkpXTtcbn1cbmZ1bmN0aW9uIE5OKGUpIHtcbiAgcmV0dXJuICRmKGUpID8gdm9pZCAwIDogZTtcbn1cbnZhciBQTiA9IDEsIFVOID0gMiwgQk4gPSA0LCBITiA9IEROKGZ1bmN0aW9uKGUsIHQpIHtcbiAgdmFyIG4gPSB7fTtcbiAgaWYgKGUgPT0gbnVsbClcbiAgICByZXR1cm4gbjtcbiAgdmFyIHIgPSAhMTtcbiAgdCA9IGZjKHQsIGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gcyA9IFphKHMsIGUpLCByIHx8IChyID0gcy5sZW5ndGggPiAxKSwgcztcbiAgfSksIHJpKGUsIERmKGUpLCBuKSwgciAmJiAobiA9IEJpKG4sIFBOIHwgVU4gfCBCTiwgTk4pKTtcbiAgZm9yICh2YXIgaSA9IHQubGVuZ3RoOyBpLS07IClcbiAgICBJTihuLCB0W2ldKTtcbiAgcmV0dXJuIG47XG59KTtcbmZ1bmN0aW9uIF9wKGUpIHtcbiAgcmV0dXJuIE1hdGgubG9nKGUpO1xufVxuZnVuY3Rpb24gRXAoZSkge1xuICByZXR1cm4gTWF0aC5leHAoZSk7XG59XG5mdW5jdGlvbiBWTihlKSB7XG4gIHJldHVybiAtTWF0aC5sb2coLWUpO1xufVxuZnVuY3Rpb24gR04oZSkge1xuICByZXR1cm4gLU1hdGguZXhwKC1lKTtcbn1cbmZ1bmN0aW9uIHpOKGUpIHtcbiAgcmV0dXJuIGlzRmluaXRlKGUpID8gKyhcIjFlXCIgKyBlKSA6IGUgPCAwID8gMCA6IGU7XG59XG5mdW5jdGlvbiBGTihlKSB7XG4gIHJldHVybiBlID09PSAxMCA/IHpOIDogZSA9PT0gTWF0aC5FID8gTWF0aC5leHAgOiAodCkgPT4gTWF0aC5wb3coZSwgdCk7XG59XG5mdW5jdGlvbiBqTihlKSB7XG4gIHJldHVybiBlID09PSBNYXRoLkUgPyBNYXRoLmxvZyA6IGUgPT09IDEwICYmIE1hdGgubG9nMTAgfHwgZSA9PT0gMiAmJiBNYXRoLmxvZzIgfHwgKGUgPSBNYXRoLmxvZyhlKSwgKHQpID0+IE1hdGgubG9nKHQpIC8gZSk7XG59XG5mdW5jdGlvbiBPcChlKSB7XG4gIHJldHVybiAodCwgbikgPT4gLWUoLXQsIG4pO1xufVxuZnVuY3Rpb24gV04oZSkge1xuICBjb25zdCB0ID0gZShfcCwgRXApLCBuID0gdC5kb21haW47XG4gIGxldCByID0gMTAsIGksIHM7XG4gIGZ1bmN0aW9uIGEoKSB7XG4gICAgcmV0dXJuIGkgPSBqTihyKSwgcyA9IEZOKHIpLCBuKClbMF0gPCAwID8gKGkgPSBPcChpKSwgcyA9IE9wKHMpLCBlKFZOLCBHTikpIDogZShfcCwgRXApLCB0O1xuICB9XG4gIHJldHVybiB0LmJhc2UgPSBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAociA9ICtvLCBhKCkpIDogcjtcbiAgfSwgdC5kb21haW4gPSBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobihvKSwgYSgpKSA6IG4oKTtcbiAgfSwgdC50aWNrcyA9IChvKSA9PiB7XG4gICAgY29uc3QgbCA9IG4oKTtcbiAgICBsZXQgYyA9IGxbMF0sIHUgPSBsW2wubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgZCA9IHUgPCBjO1xuICAgIGQgJiYgKFtjLCB1XSA9IFt1LCBjXSk7XG4gICAgbGV0IGggPSBpKGMpLCBwID0gaSh1KSwgZiwgZztcbiAgICBjb25zdCBtID0gbyA9PSBudWxsID8gMTAgOiArbztcbiAgICBsZXQgdiA9IFtdO1xuICAgIGlmICghKHIgJSAxKSAmJiBwIC0gaCA8IG0pIHtcbiAgICAgIGlmIChoID0gTWF0aC5mbG9vcihoKSwgcCA9IE1hdGguY2VpbChwKSwgYyA+IDApIHtcbiAgICAgICAgZm9yICg7IGggPD0gcDsgKytoKVxuICAgICAgICAgIGZvciAoZiA9IDE7IGYgPCByOyArK2YpXG4gICAgICAgICAgICBpZiAoZyA9IGggPCAwID8gZiAvIHMoLWgpIDogZiAqIHMoaCksICEoZyA8IGMpKSB7XG4gICAgICAgICAgICAgIGlmIChnID4gdSkgYnJlYWs7XG4gICAgICAgICAgICAgIHYucHVzaChnKTtcbiAgICAgICAgICAgIH1cbiAgICAgIH0gZWxzZSBmb3IgKDsgaCA8PSBwOyArK2gpXG4gICAgICAgIGZvciAoZiA9IHIgLSAxOyBmID49IDE7IC0tZilcbiAgICAgICAgICBpZiAoZyA9IGggPiAwID8gZiAvIHMoLWgpIDogZiAqIHMoaCksICEoZyA8IGMpKSB7XG4gICAgICAgICAgICBpZiAoZyA+IHUpIGJyZWFrO1xuICAgICAgICAgICAgdi5wdXNoKGcpO1xuICAgICAgICAgIH1cbiAgICAgIHYubGVuZ3RoICogMiA8IG0gJiYgKHYgPSBjYShjLCB1LCBtKSk7XG4gICAgfSBlbHNlXG4gICAgICB2ID0gY2EoaCwgcCwgTWF0aC5taW4ocCAtIGgsIG0pKS5tYXAocyk7XG4gICAgcmV0dXJuIGQgPyB2LnJldmVyc2UoKSA6IHY7XG4gIH0sIHQudGlja0Zvcm1hdCA9IChvLCBsKSA9PiB7XG4gICAgaWYgKG8gPT0gbnVsbCAmJiAobyA9IDEwKSwgbCA9PSBudWxsICYmIChsID0gciA9PT0gMTAgPyBcInNcIiA6IFwiLFwiKSwgdHlwZW9mIGwgIT0gXCJmdW5jdGlvblwiICYmICghKHIgJSAxKSAmJiAobCA9IHRzKGwpKS5wcmVjaXNpb24gPT0gbnVsbCAmJiAobC50cmltID0gITApLCBsID0gSGMobCkpLCBvID09PSAxIC8gMCkgcmV0dXJuIGw7XG4gICAgY29uc3QgYyA9IE1hdGgubWF4KDEsIHIgKiBvIC8gdC50aWNrcygpLmxlbmd0aCk7XG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICBsZXQgZCA9IHUgLyBzKE1hdGgucm91bmQoaSh1KSkpO1xuICAgICAgcmV0dXJuIGQgKiByIDwgciAtIDAuNSAmJiAoZCAqPSByKSwgZCA8PSBjID8gbCh1KSA6IFwiXCI7XG4gICAgfTtcbiAgfSwgdC5uaWNlID0gKCkgPT4gbihxbShuKCksIHtcbiAgICBmbG9vcjogKG8pID0+IHMoTWF0aC5mbG9vcihpKG8pKSksXG4gICAgY2VpbDogKG8pID0+IHMoTWF0aC5jZWlsKGkobykpKVxuICB9KSksIHQ7XG59XG5mdW5jdGlvbiBEdigpIHtcbiAgY29uc3QgZSA9IFdOKFRtKCkpLmRvbWFpbihbMSwgMTBdKTtcbiAgcmV0dXJuIGUuY29weSA9ICgpID0+IFZjKGUsIER2KCkpLmJhc2UoZS5iYXNlKCkpLCBpaS5hcHBseShlLCBhcmd1bWVudHMpLCBlO1xufVxuZnVuY3Rpb24gQmEoZSwgdCwgbikge1xuICBlLl9jb250ZXh0LmJlemllckN1cnZlVG8oXG4gICAgKDIgKiBlLl94MCArIGUuX3gxKSAvIDMsXG4gICAgKDIgKiBlLl95MCArIGUuX3kxKSAvIDMsXG4gICAgKGUuX3gwICsgMiAqIGUuX3gxKSAvIDMsXG4gICAgKGUuX3kwICsgMiAqIGUuX3kxKSAvIDMsXG4gICAgKGUuX3gwICsgNCAqIGUuX3gxICsgdCkgLyA2LFxuICAgIChlLl95MCArIDQgKiBlLl95MSArIG4pIC8gNlxuICApO1xufVxuZnVuY3Rpb24gZ28oZSkge1xuICB0aGlzLl9jb250ZXh0ID0gZTtcbn1cbmdvLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feTAgPSB0aGlzLl95MSA9IE5hTiwgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIEJhKHRoaXMsIHRoaXMuX3gxLCB0aGlzLl95MSk7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gxLCB0aGlzLl95MSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAodGhpcy5fbGluZSB8fCB0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSAmJiB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpLCB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgc3dpdGNoIChlID0gK2UsIHQgPSArdCwgdGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAxLCB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oZSwgdCkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyhlLCB0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMywgdGhpcy5fY29udGV4dC5saW5lVG8oKDUgKiB0aGlzLl94MCArIHRoaXMuX3gxKSAvIDYsICg1ICogdGhpcy5feTAgKyB0aGlzLl95MSkgLyA2KTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIEJhKHRoaXMsIGUsIHQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSBlLCB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHQ7XG4gIH1cbn07XG5mdW5jdGlvbiBxTihlKSB7XG4gIHJldHVybiBuZXcgZ28oZSk7XG59XG5mdW5jdGlvbiBSdihlKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBlO1xufVxuUnYucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IEhuLFxuICBhcmVhRW5kOiBIbixcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID0gdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gdGhpcy5feTMgPSB0aGlzLl95NCA9IE5hTiwgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKSwgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDI6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oKHRoaXMuX3gyICsgMiAqIHRoaXMuX3gzKSAvIDMsICh0aGlzLl95MiArIDIgKiB0aGlzLl95MykgLyAzKSwgdGhpcy5fY29udGV4dC5saW5lVG8oKHRoaXMuX3gzICsgMiAqIHRoaXMuX3gyKSAvIDMsICh0aGlzLl95MyArIDIgKiB0aGlzLl95MikgLyAzKSwgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDM6IHtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MiwgdGhpcy5feTIpLCB0aGlzLnBvaW50KHRoaXMuX3gzLCB0aGlzLl95MyksIHRoaXMucG9pbnQodGhpcy5feDQsIHRoaXMuX3k0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2ludDogZnVuY3Rpb24oZSwgdCkge1xuICAgIHN3aXRjaCAoZSA9ICtlLCB0ID0gK3QsIHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMSwgdGhpcy5feDIgPSBlLCB0aGlzLl95MiA9IHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB0aGlzLl9wb2ludCA9IDIsIHRoaXMuX3gzID0gZSwgdGhpcy5feTMgPSB0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAzLCB0aGlzLl94NCA9IGUsIHRoaXMuX3k0ID0gdCwgdGhpcy5fY29udGV4dC5tb3ZlVG8oKHRoaXMuX3gwICsgNCAqIHRoaXMuX3gxICsgZSkgLyA2LCAodGhpcy5feTAgKyA0ICogdGhpcy5feTEgKyB0KSAvIDYpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIEJhKHRoaXMsIGUsIHQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSBlLCB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHQ7XG4gIH1cbn07XG5mdW5jdGlvbiBZTihlKSB7XG4gIHJldHVybiBuZXcgUnYoZSk7XG59XG5mdW5jdGlvbiBJdihlKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBlO1xufVxuSXYucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl95MCA9IHRoaXMuX3kxID0gTmFOLCB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICh0aGlzLl9saW5lIHx8IHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDMpICYmIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCksIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBzd2l0Y2ggKGUgPSArZSwgdCA9ICt0LCB0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB0aGlzLl9wb2ludCA9IDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICB0aGlzLl9wb2ludCA9IDM7XG4gICAgICAgIHZhciBuID0gKHRoaXMuX3gwICsgNCAqIHRoaXMuX3gxICsgZSkgLyA2LCByID0gKHRoaXMuX3kwICsgNCAqIHRoaXMuX3kxICsgdCkgLyA2O1xuICAgICAgICB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8obiwgcikgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyhuLCByKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHRoaXMuX3BvaW50ID0gNDtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIEJhKHRoaXMsIGUsIHQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSBlLCB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHQ7XG4gIH1cbn07XG5mdW5jdGlvbiBYTihlKSB7XG4gIHJldHVybiBuZXcgSXYoZSk7XG59XG5mdW5jdGlvbiBOdihlLCB0KSB7XG4gIHRoaXMuX2Jhc2lzID0gbmV3IGdvKGUpLCB0aGlzLl9iZXRhID0gdDtcbn1cbk52LnByb3RvdHlwZSA9IHtcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94ID0gW10sIHRoaXMuX3kgPSBbXSwgdGhpcy5fYmFzaXMubGluZVN0YXJ0KCk7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlID0gdGhpcy5feCwgdCA9IHRoaXMuX3ksIG4gPSBlLmxlbmd0aCAtIDE7XG4gICAgaWYgKG4gPiAwKVxuICAgICAgZm9yICh2YXIgciA9IGVbMF0sIGkgPSB0WzBdLCBzID0gZVtuXSAtIHIsIGEgPSB0W25dIC0gaSwgbyA9IC0xLCBsOyArK28gPD0gbjsgKVxuICAgICAgICBsID0gbyAvIG4sIHRoaXMuX2Jhc2lzLnBvaW50KFxuICAgICAgICAgIHRoaXMuX2JldGEgKiBlW29dICsgKDEgLSB0aGlzLl9iZXRhKSAqIChyICsgbCAqIHMpLFxuICAgICAgICAgIHRoaXMuX2JldGEgKiB0W29dICsgKDEgLSB0aGlzLl9iZXRhKSAqIChpICsgbCAqIGEpXG4gICAgICAgICk7XG4gICAgdGhpcy5feCA9IHRoaXMuX3kgPSBudWxsLCB0aGlzLl9iYXNpcy5saW5lRW5kKCk7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgdGhpcy5feC5wdXNoKCtlKSwgdGhpcy5feS5wdXNoKCt0KTtcbiAgfVxufTtcbmNvbnN0IFpOID0gZnVuY3Rpb24gZSh0KSB7XG4gIGZ1bmN0aW9uIG4ocikge1xuICAgIHJldHVybiB0ID09PSAxID8gbmV3IGdvKHIpIDogbmV3IE52KHIsIHQpO1xuICB9XG4gIHJldHVybiBuLmJldGEgPSBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIGUoK3IpO1xuICB9LCBuO1xufSgwLjg1KTtcbmZ1bmN0aW9uIEhhKGUsIHQsIG4pIHtcbiAgZS5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKFxuICAgIGUuX3gxICsgZS5fayAqIChlLl94MiAtIGUuX3gwKSxcbiAgICBlLl95MSArIGUuX2sgKiAoZS5feTIgLSBlLl95MCksXG4gICAgZS5feDIgKyBlLl9rICogKGUuX3gxIC0gdCksXG4gICAgZS5feTIgKyBlLl9rICogKGUuX3kxIC0gbiksXG4gICAgZS5feDIsXG4gICAgZS5feTJcbiAgKTtcbn1cbmZ1bmN0aW9uIHB1KGUsIHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGUsIHRoaXMuX2sgPSAoMSAtIHQpIC8gNjtcbn1cbnB1LnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU4sIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgSGEodGhpcywgdGhpcy5feDEsIHRoaXMuX3kxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgICh0aGlzLl9saW5lIHx8IHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpICYmIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCksIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBzd2l0Y2ggKGUgPSArZSwgdCA9ICt0LCB0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB0aGlzLl9wb2ludCA9IDEsIHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyhlLCB0KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKGUsIHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAyLCB0aGlzLl94MSA9IGUsIHRoaXMuX3kxID0gdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMztcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIEhhKHRoaXMsIGUsIHQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSBlLCB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHQ7XG4gIH1cbn07XG5jb25zdCBLTiA9IGZ1bmN0aW9uIGUodCkge1xuICBmdW5jdGlvbiBuKHIpIHtcbiAgICByZXR1cm4gbmV3IHB1KHIsIHQpO1xuICB9XG4gIHJldHVybiBuLnRlbnNpb24gPSBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIGUoK3IpO1xuICB9LCBuO1xufSgwKTtcbmZ1bmN0aW9uIGZ1KGUsIHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGUsIHRoaXMuX2sgPSAoMSAtIHQpIC8gNjtcbn1cbmZ1LnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBIbixcbiAgYXJlYUVuZDogSG4sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feDMgPSB0aGlzLl94NCA9IHRoaXMuX3g1ID0gdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gdGhpcy5feTMgPSB0aGlzLl95NCA9IHRoaXMuX3k1ID0gTmFOLCB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMToge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MywgdGhpcy5feTMpLCB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMjoge1xuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MywgdGhpcy5feTMpLCB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMzoge1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gzLCB0aGlzLl95MyksIHRoaXMucG9pbnQodGhpcy5feDQsIHRoaXMuX3k0KSwgdGhpcy5wb2ludCh0aGlzLl94NSwgdGhpcy5feTUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgc3dpdGNoIChlID0gK2UsIHQgPSArdCwgdGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAxLCB0aGlzLl94MyA9IGUsIHRoaXMuX3kzID0gdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMiwgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDQgPSBlLCB0aGlzLl95NCA9IHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAzLCB0aGlzLl94NSA9IGUsIHRoaXMuX3k1ID0gdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBIYSh0aGlzLCBlLCB0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0gZSwgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB0O1xuICB9XG59O1xuY29uc3QgUU4gPSBmdW5jdGlvbiBlKHQpIHtcbiAgZnVuY3Rpb24gbihyKSB7XG4gICAgcmV0dXJuIG5ldyBmdShyLCB0KTtcbiAgfVxuICByZXR1cm4gbi50ZW5zaW9uID0gZnVuY3Rpb24ocikge1xuICAgIHJldHVybiBlKCtyKTtcbiAgfSwgbjtcbn0oMCk7XG5mdW5jdGlvbiBtdShlLCB0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBlLCB0aGlzLl9rID0gKDEgLSB0KSAvIDY7XG59XG5tdS5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOLCB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICh0aGlzLl9saW5lIHx8IHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDMpICYmIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCksIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBzd2l0Y2ggKGUgPSArZSwgdCA9ICt0LCB0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB0aGlzLl9wb2ludCA9IDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICB0aGlzLl9wb2ludCA9IDMsIHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHRoaXMuX3BvaW50ID0gNDtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIEhhKHRoaXMsIGUsIHQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSBlLCB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHQ7XG4gIH1cbn07XG5jb25zdCBKTiA9IGZ1bmN0aW9uIGUodCkge1xuICBmdW5jdGlvbiBuKHIpIHtcbiAgICByZXR1cm4gbmV3IG11KHIsIHQpO1xuICB9XG4gIHJldHVybiBuLnRlbnNpb24gPSBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIGUoK3IpO1xuICB9LCBuO1xufSgwKTtcbmZ1bmN0aW9uIGd1KGUsIHQsIG4pIHtcbiAgdmFyIHIgPSBlLl94MSwgaSA9IGUuX3kxLCBzID0gZS5feDIsIGEgPSBlLl95MjtcbiAgaWYgKGUuX2wwMV9hID4gbmUpIHtcbiAgICB2YXIgbyA9IDIgKiBlLl9sMDFfMmEgKyAzICogZS5fbDAxX2EgKiBlLl9sMTJfYSArIGUuX2wxMl8yYSwgbCA9IDMgKiBlLl9sMDFfYSAqIChlLl9sMDFfYSArIGUuX2wxMl9hKTtcbiAgICByID0gKHIgKiBvIC0gZS5feDAgKiBlLl9sMTJfMmEgKyBlLl94MiAqIGUuX2wwMV8yYSkgLyBsLCBpID0gKGkgKiBvIC0gZS5feTAgKiBlLl9sMTJfMmEgKyBlLl95MiAqIGUuX2wwMV8yYSkgLyBsO1xuICB9XG4gIGlmIChlLl9sMjNfYSA+IG5lKSB7XG4gICAgdmFyIGMgPSAyICogZS5fbDIzXzJhICsgMyAqIGUuX2wyM19hICogZS5fbDEyX2EgKyBlLl9sMTJfMmEsIHUgPSAzICogZS5fbDIzX2EgKiAoZS5fbDIzX2EgKyBlLl9sMTJfYSk7XG4gICAgcyA9IChzICogYyArIGUuX3gxICogZS5fbDIzXzJhIC0gdCAqIGUuX2wxMl8yYSkgLyB1LCBhID0gKGEgKiBjICsgZS5feTEgKiBlLl9sMjNfMmEgLSBuICogZS5fbDEyXzJhKSAvIHU7XG4gIH1cbiAgZS5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHIsIGksIHMsIGEsIGUuX3gyLCBlLl95Mik7XG59XG5mdW5jdGlvbiBQdihlLCB0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBlLCB0aGlzLl9hbHBoYSA9IHQ7XG59XG5Qdi5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOLCB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2EgPSB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEgPSB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDIsIHRoaXMuX3kyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgICh0aGlzLl9saW5lIHx8IHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpICYmIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCksIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBpZiAoZSA9ICtlLCB0ID0gK3QsIHRoaXMuX3BvaW50KSB7XG4gICAgICB2YXIgbiA9IHRoaXMuX3gyIC0gZSwgciA9IHRoaXMuX3kyIC0gdDtcbiAgICAgIHRoaXMuX2wyM19hID0gTWF0aC5zcXJ0KHRoaXMuX2wyM18yYSA9IE1hdGgucG93KG4gKiBuICsgciAqIHIsIHRoaXMuX2FscGhhKSk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAxLCB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oZSwgdCkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyhlLCB0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMztcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGd1KHRoaXMsIGUsIHQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSwgdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSwgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEsIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0gZSwgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB0O1xuICB9XG59O1xuY29uc3QgdFAgPSBmdW5jdGlvbiBlKHQpIHtcbiAgZnVuY3Rpb24gbihyKSB7XG4gICAgcmV0dXJuIHQgPyBuZXcgUHYociwgdCkgOiBuZXcgcHUociwgMCk7XG4gIH1cbiAgcmV0dXJuIG4uYWxwaGEgPSBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIGUoK3IpO1xuICB9LCBuO1xufSgwLjUpO1xuZnVuY3Rpb24gVXYoZSwgdCkge1xuICB0aGlzLl9jb250ZXh0ID0gZSwgdGhpcy5fYWxwaGEgPSB0O1xufVxuVXYucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IEhuLFxuICBhcmVhRW5kOiBIbixcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID0gdGhpcy5feDUgPSB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSB0aGlzLl95MyA9IHRoaXMuX3k0ID0gdGhpcy5feTUgPSBOYU4sIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSA9IHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYSA9IHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gzLCB0aGlzLl95MyksIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAyOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gzLCB0aGlzLl95MyksIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAzOiB7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDMsIHRoaXMuX3kzKSwgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpLCB0aGlzLnBvaW50KHRoaXMuX3g1LCB0aGlzLl95NSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBpZiAoZSA9ICtlLCB0ID0gK3QsIHRoaXMuX3BvaW50KSB7XG4gICAgICB2YXIgbiA9IHRoaXMuX3gyIC0gZSwgciA9IHRoaXMuX3kyIC0gdDtcbiAgICAgIHRoaXMuX2wyM19hID0gTWF0aC5zcXJ0KHRoaXMuX2wyM18yYSA9IE1hdGgucG93KG4gKiBuICsgciAqIHIsIHRoaXMuX2FscGhhKSk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAxLCB0aGlzLl94MyA9IGUsIHRoaXMuX3kzID0gdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMiwgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDQgPSBlLCB0aGlzLl95NCA9IHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAzLCB0aGlzLl94NSA9IGUsIHRoaXMuX3k1ID0gdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBndSh0aGlzLCBlLCB0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2EsIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSwgdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhLCB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IGUsIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0gdDtcbiAgfVxufTtcbmNvbnN0IGVQID0gZnVuY3Rpb24gZSh0KSB7XG4gIGZ1bmN0aW9uIG4ocikge1xuICAgIHJldHVybiB0ID8gbmV3IFV2KHIsIHQpIDogbmV3IGZ1KHIsIDApO1xuICB9XG4gIHJldHVybiBuLmFscGhhID0gZnVuY3Rpb24ocikge1xuICAgIHJldHVybiBlKCtyKTtcbiAgfSwgbjtcbn0oMC41KTtcbmZ1bmN0aW9uIEJ2KGUsIHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGUsIHRoaXMuX2FscGhhID0gdDtcbn1cbkJ2LnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU4sIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSA9IHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYSA9IHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgKHRoaXMuX2xpbmUgfHwgdGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMykgJiYgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKSwgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oZSwgdCkge1xuICAgIGlmIChlID0gK2UsIHQgPSArdCwgdGhpcy5fcG9pbnQpIHtcbiAgICAgIHZhciBuID0gdGhpcy5feDIgLSBlLCByID0gdGhpcy5feTIgLSB0O1xuICAgICAgdGhpcy5fbDIzX2EgPSBNYXRoLnNxcnQodGhpcy5fbDIzXzJhID0gTWF0aC5wb3cobiAqIG4gKyByICogciwgdGhpcy5fYWxwaGEpKTtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB0aGlzLl9wb2ludCA9IDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICB0aGlzLl9wb2ludCA9IDMsIHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHRoaXMuX3BvaW50ID0gNDtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGd1KHRoaXMsIGUsIHQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSwgdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSwgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEsIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0gZSwgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB0O1xuICB9XG59O1xuY29uc3QgblAgPSBmdW5jdGlvbiBlKHQpIHtcbiAgZnVuY3Rpb24gbihyKSB7XG4gICAgcmV0dXJuIHQgPyBuZXcgQnYociwgdCkgOiBuZXcgbXUociwgMCk7XG4gIH1cbiAgcmV0dXJuIG4uYWxwaGEgPSBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIGUoK3IpO1xuICB9LCBuO1xufSgwLjUpO1xuZnVuY3Rpb24gU3AoZSkge1xuICByZXR1cm4gZSA8IDAgPyAtMSA6IDE7XG59XG5mdW5jdGlvbiBUcChlLCB0LCBuKSB7XG4gIHZhciByID0gZS5feDEgLSBlLl94MCwgaSA9IHQgLSBlLl94MSwgcyA9IChlLl95MSAtIGUuX3kwKSAvIChyIHx8IGkgPCAwICYmIC0wKSwgYSA9IChuIC0gZS5feTEpIC8gKGkgfHwgciA8IDAgJiYgLTApLCBvID0gKHMgKiBpICsgYSAqIHIpIC8gKHIgKyBpKTtcbiAgcmV0dXJuIChTcChzKSArIFNwKGEpKSAqIE1hdGgubWluKE1hdGguYWJzKHMpLCBNYXRoLmFicyhhKSwgMC41ICogTWF0aC5hYnMobykpIHx8IDA7XG59XG5mdW5jdGlvbiB3cChlLCB0KSB7XG4gIHZhciBuID0gZS5feDEgLSBlLl94MDtcbiAgcmV0dXJuIG4gPyAoMyAqIChlLl95MSAtIGUuX3kwKSAvIG4gLSB0KSAvIDIgOiB0O1xufVxuZnVuY3Rpb24gaGwoZSwgdCwgbikge1xuICB2YXIgciA9IGUuX3gwLCBpID0gZS5feTAsIHMgPSBlLl94MSwgYSA9IGUuX3kxLCBvID0gKHMgLSByKSAvIDM7XG4gIGUuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhyICsgbywgaSArIG8gKiB0LCBzIC0gbywgYSAtIG8gKiBuLCBzLCBhKTtcbn1cbmZ1bmN0aW9uIFZhKGUpIHtcbiAgdGhpcy5fY29udGV4dCA9IGU7XG59XG5WYS5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl90MCA9IE5hTiwgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gxLCB0aGlzLl95MSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBobCh0aGlzLCB0aGlzLl90MCwgd3AodGhpcywgdGhpcy5fdDApKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgICh0aGlzLl9saW5lIHx8IHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpICYmIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCksIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICB2YXIgbiA9IE5hTjtcbiAgICBpZiAoZSA9ICtlLCB0ID0gK3QsICEoZSA9PT0gdGhpcy5feDEgJiYgdCA9PT0gdGhpcy5feTEpKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICB0aGlzLl9wb2ludCA9IDEsIHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyhlLCB0KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKGUsIHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhpcy5fcG9pbnQgPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhpcy5fcG9pbnQgPSAzLCBobCh0aGlzLCB3cCh0aGlzLCBuID0gVHAodGhpcywgZSwgdCkpLCBuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBobCh0aGlzLCB0aGlzLl90MCwgbiA9IFRwKHRoaXMsIGUsIHQpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gZSwgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0LCB0aGlzLl90MCA9IG47XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gSHYoZSkge1xuICB0aGlzLl9jb250ZXh0ID0gbmV3IFZ2KGUpO1xufVxuKEh2LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVmEucHJvdG90eXBlKSkucG9pbnQgPSBmdW5jdGlvbihlLCB0KSB7XG4gIFZhLnByb3RvdHlwZS5wb2ludC5jYWxsKHRoaXMsIHQsIGUpO1xufTtcbmZ1bmN0aW9uIFZ2KGUpIHtcbiAgdGhpcy5fY29udGV4dCA9IGU7XG59XG5Wdi5wcm90b3R5cGUgPSB7XG4gIG1vdmVUbzogZnVuY3Rpb24oZSwgdCkge1xuICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHQsIGUpO1xuICB9LFxuICBjbG9zZVBhdGg6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH0sXG4gIGxpbmVUbzogZnVuY3Rpb24oZSwgdCkge1xuICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHQsIGUpO1xuICB9LFxuICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbihlLCB0LCBuLCByLCBpLCBzKSB7XG4gICAgdGhpcy5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHQsIGUsIHIsIG4sIHMsIGkpO1xuICB9XG59O1xuZnVuY3Rpb24gclAoZSkge1xuICByZXR1cm4gbmV3IFZhKGUpO1xufVxuZnVuY3Rpb24gaVAoZSkge1xuICByZXR1cm4gbmV3IEh2KGUpO1xufVxuZnVuY3Rpb24gR3YoZSkge1xuICB0aGlzLl9jb250ZXh0ID0gZTtcbn1cbkd2LnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94ID0gW10sIHRoaXMuX3kgPSBbXTtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGUgPSB0aGlzLl94LCB0ID0gdGhpcy5feSwgbiA9IGUubGVuZ3RoO1xuICAgIGlmIChuKVxuICAgICAgaWYgKHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyhlWzBdLCB0WzBdKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKGVbMF0sIHRbMF0pLCBuID09PSAyKVxuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyhlWzFdLCB0WzFdKTtcbiAgICAgIGVsc2VcbiAgICAgICAgZm9yICh2YXIgciA9ICRwKGUpLCBpID0gJHAodCksIHMgPSAwLCBhID0gMTsgYSA8IG47ICsrcywgKythKVxuICAgICAgICAgIHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhyWzBdW3NdLCBpWzBdW3NdLCByWzFdW3NdLCBpWzFdW3NdLCBlW2FdLCB0W2FdKTtcbiAgICAodGhpcy5fbGluZSB8fCB0aGlzLl9saW5lICE9PSAwICYmIG4gPT09IDEpICYmIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCksIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZSwgdGhpcy5feCA9IHRoaXMuX3kgPSBudWxsO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oZSwgdCkge1xuICAgIHRoaXMuX3gucHVzaCgrZSksIHRoaXMuX3kucHVzaCgrdCk7XG4gIH1cbn07XG5mdW5jdGlvbiAkcChlKSB7XG4gIHZhciB0LCBuID0gZS5sZW5ndGggLSAxLCByLCBpID0gbmV3IEFycmF5KG4pLCBzID0gbmV3IEFycmF5KG4pLCBhID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKGlbMF0gPSAwLCBzWzBdID0gMiwgYVswXSA9IGVbMF0gKyAyICogZVsxXSwgdCA9IDE7IHQgPCBuIC0gMTsgKyt0KSBpW3RdID0gMSwgc1t0XSA9IDQsIGFbdF0gPSA0ICogZVt0XSArIDIgKiBlW3QgKyAxXTtcbiAgZm9yIChpW24gLSAxXSA9IDIsIHNbbiAtIDFdID0gNywgYVtuIC0gMV0gPSA4ICogZVtuIC0gMV0gKyBlW25dLCB0ID0gMTsgdCA8IG47ICsrdCkgciA9IGlbdF0gLyBzW3QgLSAxXSwgc1t0XSAtPSByLCBhW3RdIC09IHIgKiBhW3QgLSAxXTtcbiAgZm9yIChpW24gLSAxXSA9IGFbbiAtIDFdIC8gc1tuIC0gMV0sIHQgPSBuIC0gMjsgdCA+PSAwOyAtLXQpIGlbdF0gPSAoYVt0XSAtIGlbdCArIDFdKSAvIHNbdF07XG4gIGZvciAoc1tuIC0gMV0gPSAoZVtuXSArIGlbbiAtIDFdKSAvIDIsIHQgPSAwOyB0IDwgbiAtIDE7ICsrdCkgc1t0XSA9IDIgKiBlW3QgKyAxXSAtIGlbdCArIDFdO1xuICByZXR1cm4gW2ksIHNdO1xufVxuZnVuY3Rpb24gc1AoZSkge1xuICByZXR1cm4gbmV3IEd2KGUpO1xufVxuZnVuY3Rpb24gdm8oZSwgdCkge1xuICB0aGlzLl9jb250ZXh0ID0gZSwgdGhpcy5fdCA9IHQ7XG59XG52by5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feCA9IHRoaXMuX3kgPSBOYU4sIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgMCA8IHRoaXMuX3QgJiYgdGhpcy5fdCA8IDEgJiYgdGhpcy5fcG9pbnQgPT09IDIgJiYgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feCwgdGhpcy5feSksICh0aGlzLl9saW5lIHx8IHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpICYmIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCksIHRoaXMuX2xpbmUgPj0gMCAmJiAodGhpcy5fdCA9IDEgLSB0aGlzLl90LCB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmUpO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oZSwgdCkge1xuICAgIHN3aXRjaCAoZSA9ICtlLCB0ID0gK3QsIHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMSwgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKGUsIHQpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oZSwgdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB0aGlzLl9wb2ludCA9IDI7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGlmICh0aGlzLl90IDw9IDApXG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feCwgdCksIHRoaXMuX2NvbnRleHQubGluZVRvKGUsIHQpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgbiA9IHRoaXMuX3ggKiAoMSAtIHRoaXMuX3QpICsgZSAqIHRoaXMuX3Q7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8obiwgdGhpcy5feSksIHRoaXMuX2NvbnRleHQubGluZVRvKG4sIHQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl94ID0gZSwgdGhpcy5feSA9IHQ7XG4gIH1cbn07XG5mdW5jdGlvbiBhUChlKSB7XG4gIHJldHVybiBuZXcgdm8oZSwgMC41KTtcbn1cbmZ1bmN0aW9uIG9QKGUpIHtcbiAgcmV0dXJuIG5ldyB2byhlLCAwKTtcbn1cbmZ1bmN0aW9uIGxQKGUpIHtcbiAgcmV0dXJuIG5ldyB2byhlLCAxKTtcbn1cbmNsYXNzIGNQIGV4dGVuZHMgRG4ge1xuICAvKipcbiAgICogZm9jYWw6ICBvYmplY3QgdG8gem9vbSBpbnRvXG4gICAqIGNhbnZhc0VsZW1lbnRzOiBhbGwgdGhlIGVsZW1lbnRzIHRvIHRyYW5zbGF0ZSBhbmQgem9vbSBvbiB0aGUgY2hhcnQgYXJlYVxuICAgKiB6b29tU2V0dGluZ3M6IG9iamVjdCBjb250YWluaW5nIGR1cmF0aW9uLCBlYXNpbmcgYW5kIHpvb21sZXZlbCBmb3IgdGhlIHpvb20gYmVoYXZpb3Vyc1xuICAgKiAgKi9cbiAgem9vbUluKHQsIG4sIHIpIHtcbiAgICBsZXQgaSwgcywgYTtcbiAgICBjb25zdCBvID0gciB8fCBOcjtcbiAgICB0ICYmIChpID0gdC54LCBzID0gdC55LCBhID0gMik7XG4gICAgY29uc3QgeyB3aWR0aDogbCwgaGVpZ2h0OiBjIH0gPSBOLmdldFNWR0VsZW1lbnRTaXplKHRoaXMuc2VydmljZXMuZG9tVXRpbHMuZ2V0SG9sZGVyKCksIHtcbiAgICAgIHVzZUNsaWVudERpbWVuc2lvbnM6ICEwXG4gICAgfSk7XG4gICAgbi50cmFuc2l0aW9uKCkuZHVyYXRpb24oby5kdXJhdGlvbikuZWFzZShvLmVhc2UpLmF0dHIoXG4gICAgICBcInRyYW5zZm9ybVwiLFxuICAgICAgYHRyYW5zbGF0ZSgke2wgLyAyfSwgJHtjIC8gMn0pIHNjYWxlKCR7YX0pIHRyYW5zbGF0ZSgkey1pfSwkey1zfSlgXG4gICAgKSwgdGhpcy5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkNhbnZhc1pvb20uQ0FOVkFTX1pPT01fSU4sIHtcbiAgICAgIGVsZW1lbnQ6IEkodClcbiAgICB9KTtcbiAgfVxuICB6b29tT3V0KHQsIG4pIHtcbiAgICBjb25zdCByID0gbiB8fCBOcjtcbiAgICB0LnRyYW5zaXRpb24oKS5kdXJhdGlvbihyLmR1cmF0aW9uKS5lYXNlKHIuZWFzZSkuYXR0cihcInRyYW5zZm9ybVwiLCBcIlwiKSwgdGhpcy5zZXJ2aWNlcy5ldmVudHMuZGlzcGF0Y2hFdmVudChULkNhbnZhc1pvb20uQ0FOVkFTX1pPT01fT1VUKTtcbiAgfVxufVxuY2xhc3MgdVAgZXh0ZW5kcyBEbiB7XG4gIGluaXQoKSB7XG4gICAgdGhpcy5kb2N1bWVudEZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIodCwgbikge1xuICAgIHRoaXMuZG9jdW1lbnRGcmFnbWVudC5hZGRFdmVudExpc3RlbmVyKHQsIG4pO1xuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodCwgbikge1xuICAgIHRoaXMuZG9jdW1lbnRGcmFnbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHQsIG4pO1xuICB9XG4gIGRpc3BhdGNoRXZlbnQodCwgbikge1xuICAgIGxldCByO1xuICAgIG4gPyByID0gbmV3IEN1c3RvbUV2ZW50KHQsIHtcbiAgICAgIGRldGFpbDogblxuICAgIH0pIDogKHIgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpLCByLmluaXRFdmVudCh0LCAhMSwgITApKSwgdGhpcy5kb2N1bWVudEZyYWdtZW50LmRpc3BhdGNoRXZlbnQocik7XG4gIH1cbn1cbmNsYXNzIGhQIGV4dGVuZHMgRG4ge1xuICBjb25zdHJ1Y3Rvcih0LCBuKSB7XG4gICAgc3VwZXIodCwgbik7XG4gIH1cbiAgZG93bmxvYWRDU1YodCwgbikge1xuICAgIGNvbnN0IHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKSwgaSA9IFwidGV4dC9jc3Y7ZW5jb2Rpbmc6dXRmLThcIjtcbiAgICBpZiAobmF2aWdhdG9yLm1zU2F2ZUJsb2IpXG4gICAgICBuYXZpZ2F0b3IubXNTYXZlQmxvYihcbiAgICAgICAgbmV3IEJsb2IoW3RdLCB7XG4gICAgICAgICAgdHlwZTogaVxuICAgICAgICB9KSxcbiAgICAgICAgblxuICAgICAgKTtcbiAgICBlbHNlIGlmIChVUkwgJiYgXCJkb3dubG9hZFwiIGluIHIpIHtcbiAgICAgIGNvbnN0IHMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKFxuICAgICAgICBuZXcgQmxvYihbdF0sIHtcbiAgICAgICAgICB0eXBlOiBpXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgci5ocmVmID0gcywgci5zZXRBdHRyaWJ1dGUoXCJkb3dubG9hZFwiLCBuKSwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyKSwgci5jbGljaygpLCBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHIpLCBVUkwucmV2b2tlT2JqZWN0VVJMKHMpO1xuICAgIH0gZWxzZVxuICAgICAgbG9jYXRpb24uaHJlZiA9IGBkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSwke2VuY29kZVVSSUNvbXBvbmVudCh0KX1gO1xuICB9XG4gIGRvd25sb2FkSW1hZ2UodCwgbikge1xuICAgIGNvbnN0IHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICByLmRvd25sb2FkID0gbiwgci5ocmVmID0gdCwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyKSwgci5jbGljaygpLCBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHIpO1xuICB9XG59XG5jbGFzcyBkUCBleHRlbmRzIERuIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5wZW5kaW5nVHJhbnNpdGlvbnMgPSB7fTtcbiAgfVxuICBpbml0KCkge1xuICAgIHZhciB0O1xuICAgICh0ID0gdGhpcy5zZXJ2aWNlcy5ldmVudHMpID09IG51bGwgfHwgdC5hZGRFdmVudExpc3RlbmVyKFQuTW9kZWwuVVBEQVRFLCAoKSA9PiB7XG4gICAgICB0aGlzLnBlbmRpbmdUcmFuc2l0aW9ucyA9IHt9O1xuICAgIH0pO1xuICB9XG4gIHNldHVwVHJhbnNpdGlvbih7IHRyYW5zaXRpb246IHQsIG5hbWU6IG4sIGFuaW1hdGU6IHIgfSkge1xuICAgIHJldHVybiB0aGlzLnBlbmRpbmdUcmFuc2l0aW9uc1t0Ll9pZF0gPSB0LCB0Lm9uKFwiZW5kIGludGVycnVwdCBjYW5jZWxcIiwgKCkgPT4ge1xuICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYW5zaXRpb25zW3QuX2lkXTtcbiAgICB9KSwgdGhpcy5tb2RlbC5nZXRPcHRpb25zKCkuYW5pbWF0aW9ucyA9PT0gITEgfHwgciA9PT0gITEgPyB0LmR1cmF0aW9uKDApIDogdC5kdXJhdGlvbihcbiAgICAgIHkoTmgsIG4sIFwiZHVyYXRpb25cIikgfHwgTmguZGVmYXVsdC5kdXJhdGlvblxuICAgICk7XG4gIH1cbiAgZ2V0UGVuZGluZ1RyYW5zaXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLnBlbmRpbmdUcmFuc2l0aW9ucztcbiAgfVxufVxuZnVuY3Rpb24gRmkoZSwgdCkge1xuICBjb25zdCBuID0gK0h0KGUpIC0gK0h0KHQpO1xuICByZXR1cm4gbiA8IDAgPyAtMSA6IG4gPiAwID8gMSA6IG47XG59XG5mdW5jdGlvbiBwUChlLCB0LCBuKSB7XG4gIGNvbnN0IFtyLCBpXSA9IHVyKFxuICAgIHZvaWQgMCxcbiAgICBlLFxuICAgIHRcbiAgKTtcbiAgcmV0dXJuIHIuZ2V0RnVsbFllYXIoKSAtIGkuZ2V0RnVsbFllYXIoKTtcbn1cbmZ1bmN0aW9uIGZQKGUsIHQsIG4pIHtcbiAgY29uc3QgW3IsIGldID0gdXIoXG4gICAgdm9pZCAwLFxuICAgIGUsXG4gICAgdFxuICApLCBzID0gRmkociwgaSksIGEgPSBNYXRoLmFicyhwUChyLCBpKSk7XG4gIHIuc2V0RnVsbFllYXIoMTU4NCksIGkuc2V0RnVsbFllYXIoMTU4NCk7XG4gIGNvbnN0IG8gPSBGaShyLCBpKSA9PT0gLXMsIGwgPSBzICogKGEgLSArbyk7XG4gIHJldHVybiBsID09PSAwID8gMCA6IGw7XG59XG5mdW5jdGlvbiB2dShlLCB0LCBuKSB7XG4gIGNvbnN0IHIgPSBIdChlLCB2b2lkIDApO1xuICBpZiAoaXNOYU4odCkpIHJldHVybiBMZShlLCBOYU4pO1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIHI7XG4gIGNvbnN0IGkgPSByLmdldERhdGUoKSwgcyA9IExlKGUsIHIuZ2V0VGltZSgpKTtcbiAgcy5zZXRNb250aChyLmdldE1vbnRoKCkgKyB0ICsgMSwgMCk7XG4gIGNvbnN0IGEgPSBzLmdldERhdGUoKTtcbiAgcmV0dXJuIGkgPj0gYSA/IHMgOiAoci5zZXRGdWxsWWVhcihcbiAgICBzLmdldEZ1bGxZZWFyKCksXG4gICAgcy5nZXRNb250aCgpLFxuICAgIGlcbiAgKSwgcik7XG59XG5mdW5jdGlvbiB6dihlLCB0LCBuKSB7XG4gIHJldHVybiB2dShlLCB0ICogMTIpO1xufVxuZnVuY3Rpb24gbVAoZSwgdCwgbikge1xuICByZXR1cm4genYoZSwgLXQpO1xufVxuZnVuY3Rpb24gZ1AoZSwgdCwgbikge1xuICBjb25zdCBbciwgaV0gPSB1cihcbiAgICB2b2lkIDAsXG4gICAgZSxcbiAgICB0XG4gICksIHMgPSByLmdldEZ1bGxZZWFyKCkgLSBpLmdldEZ1bGxZZWFyKCksIGEgPSByLmdldE1vbnRoKCkgLSBpLmdldE1vbnRoKCk7XG4gIHJldHVybiBzICogMTIgKyBhO1xufVxuZnVuY3Rpb24gdlAoZSwgdCkge1xuICBjb25zdCBuID0gSHQoZSwgdm9pZCAwKTtcbiAgcmV0dXJuIG4uc2V0SG91cnMoMjMsIDU5LCA1OSwgOTk5KSwgbjtcbn1cbmZ1bmN0aW9uIHlQKGUsIHQpIHtcbiAgY29uc3QgbiA9IEh0KGUsIHZvaWQgMCksIHIgPSBuLmdldE1vbnRoKCk7XG4gIHJldHVybiBuLnNldEZ1bGxZZWFyKG4uZ2V0RnVsbFllYXIoKSwgciArIDEsIDApLCBuLnNldEhvdXJzKDIzLCA1OSwgNTksIDk5OSksIG47XG59XG5mdW5jdGlvbiB4UChlLCB0KSB7XG4gIGNvbnN0IG4gPSBIdChlLCB2b2lkIDApO1xuICByZXR1cm4gK3ZQKG4pID09ICt5UChuKTtcbn1cbmZ1bmN0aW9uIGJQKGUsIHQsIG4pIHtcbiAgY29uc3QgW3IsIGksIHNdID0gdXIoXG4gICAgdm9pZCAwLFxuICAgIGUsXG4gICAgZSxcbiAgICB0XG4gICksIGEgPSBGaShpLCBzKSwgbyA9IE1hdGguYWJzKFxuICAgIGdQKGksIHMpXG4gICk7XG4gIGlmIChvIDwgMSkgcmV0dXJuIDA7XG4gIGkuZ2V0TW9udGgoKSA9PT0gMSAmJiBpLmdldERhdGUoKSA+IDI3ICYmIGkuc2V0RGF0ZSgzMCksIGkuc2V0TW9udGgoaS5nZXRNb250aCgpIC0gYSAqIG8pO1xuICBsZXQgbCA9IEZpKGksIHMpID09PSAtYTtcbiAgeFAocikgJiYgbyA9PT0gMSAmJiBGaShyLCBzKSA9PT0gMSAmJiAobCA9ICExKTtcbiAgY29uc3QgYyA9IGEgKiAobyAtICtsKTtcbiAgcmV0dXJuIGMgPT09IDAgPyAwIDogYztcbn1cbmZ1bmN0aW9uIF9QKGUsIHQsIG4pIHtcbiAgcmV0dXJuIHZ1KGUsIC10KTtcbn1cbmZ1bmN0aW9uIEVQKGUsIHQsIG4pIHtcbiAgY29uc3QgW3IsIGldID0gdXIoXG4gICAgdm9pZCAwLFxuICAgIGUsXG4gICAgdFxuICApLCBzID0gTXAociwgaSksIGEgPSBNYXRoLmFicyhcbiAgICBVbShyLCBpKVxuICApO1xuICByLnNldERhdGUoci5nZXREYXRlKCkgLSBzICogYSk7XG4gIGNvbnN0IG8gPSArKE1wKHIsIGkpID09PSAtcyksIGwgPSBzICogKGEgLSBvKTtcbiAgcmV0dXJuIGwgPT09IDAgPyAwIDogbDtcbn1cbmZ1bmN0aW9uIE1wKGUsIHQpIHtcbiAgY29uc3QgbiA9IGUuZ2V0RnVsbFllYXIoKSAtIHQuZ2V0RnVsbFllYXIoKSB8fCBlLmdldE1vbnRoKCkgLSB0LmdldE1vbnRoKCkgfHwgZS5nZXREYXRlKCkgLSB0LmdldERhdGUoKSB8fCBlLmdldEhvdXJzKCkgLSB0LmdldEhvdXJzKCkgfHwgZS5nZXRNaW51dGVzKCkgLSB0LmdldE1pbnV0ZXMoKSB8fCBlLmdldFNlY29uZHMoKSAtIHQuZ2V0U2Vjb25kcygpIHx8IGUuZ2V0TWlsbGlzZWNvbmRzKCkgLSB0LmdldE1pbGxpc2Vjb25kcygpO1xuICByZXR1cm4gbiA8IDAgPyAtMSA6IG4gPiAwID8gMSA6IG47XG59XG5mdW5jdGlvbiBGdihlLCB0LCBuKSB7XG4gIGNvbnN0IHIgPSBIdChlLCB2b2lkIDApO1xuICByZXR1cm4gaXNOYU4odCkgPyBMZShlLCBOYU4pIDogKHQgJiYgci5zZXREYXRlKHIuZ2V0RGF0ZSgpICsgdCksIHIpO1xufVxuZnVuY3Rpb24gT1AoZSwgdCwgbikge1xuICByZXR1cm4gRnYoZSwgLXQpO1xufVxuZnVuY3Rpb24geXUoZSkge1xuICByZXR1cm4gKHQpID0+IHtcbiAgICBjb25zdCBuID0gKDAsIE1hdGgudHJ1bmMpKHQpO1xuICAgIHJldHVybiBuID09PSAwID8gMCA6IG47XG4gIH07XG59XG5mdW5jdGlvbiBTUChlLCB0LCBuKSB7XG4gIGNvbnN0IFtyLCBpXSA9IHVyKFxuICAgIHZvaWQgMCxcbiAgICBlLFxuICAgIHRcbiAgKSwgcyA9ICgrciAtICtpKSAvIGhmO1xuICByZXR1cm4geXUoKShzKTtcbn1cbmZ1bmN0aW9uIGp2KGUsIHQsIG4pIHtcbiAgcmV0dXJuIExlKGUsICtIdChlKSArIHQpO1xufVxuZnVuY3Rpb24gV3YoZSwgdCwgbikge1xuICByZXR1cm4ganYoZSwgdCAqIGhmKTtcbn1cbmZ1bmN0aW9uIFRQKGUsIHQsIG4pIHtcbiAgcmV0dXJuIFd2KGUsIC10KTtcbn1cbmZ1bmN0aW9uIHF2KGUsIHQpIHtcbiAgcmV0dXJuICtIdChlKSAtICtIdCh0KTtcbn1cbmZ1bmN0aW9uIENwKGUsIHQsIG4pIHtcbiAgY29uc3QgciA9IHF2KGUsIHQpIC8gdWY7XG4gIHJldHVybiB5dSgpKHIpO1xufVxuZnVuY3Rpb24gY2MoZSwgdCwgbikge1xuICBjb25zdCByID0gSHQoZSwgdm9pZCAwKTtcbiAgcmV0dXJuIHIuc2V0VGltZShyLmdldFRpbWUoKSArIHQgKiB1ZiksIHI7XG59XG5mdW5jdGlvbiBBcChlLCB0LCBuKSB7XG4gIHJldHVybiBjYyhlLCAtdCk7XG59XG5mdW5jdGlvbiBMcChlLCB0LCBuKSB7XG4gIGNvbnN0IHIgPSBxdihlLCB0KSAvIDFlMztcbiAgcmV0dXJuIHl1KCkocik7XG59XG5mdW5jdGlvbiB1YyhlLCB0LCBuKSB7XG4gIHJldHVybiBqdihlLCB0ICogMWUzKTtcbn1cbmZ1bmN0aW9uIGtwKGUsIHQsIG4pIHtcbiAgcmV0dXJuIHVjKGUsIC10KTtcbn1cbmNsYXNzIHdQIGV4dGVuZHMgRG4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnNjYWxlVHlwZXMgPSB7XG4gICAgICB0b3A6IG51bGwsXG4gICAgICByaWdodDogbnVsbCxcbiAgICAgIGJvdHRvbTogbnVsbCxcbiAgICAgIGxlZnQ6IG51bGxcbiAgICB9LCB0aGlzLnNjYWxlcyA9IHtcbiAgICAgIC8vIG51bGwgb3IgZnVuY3Rpb25cbiAgICAgIHRvcDogbnVsbCxcbiAgICAgIHJpZ2h0OiBudWxsLFxuICAgICAgYm90dG9tOiBudWxsLFxuICAgICAgbGVmdDogbnVsbFxuICAgIH07XG4gIH1cbiAgZ2V0RG9tYWluQXhpc1Bvc2l0aW9uKHsgZGF0dW06IHQgPSBudWxsIH0gPSB7fSkge1xuICAgIGlmICh0aGlzLmR1YWxBeGVzICYmIHQpIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLm1vZGVsLmdldE9wdGlvbnMoKSwgeyBncm91cE1hcHNUbzogciB9ID0gbi5kYXRhLCBpID0geShuLCBcImF4ZXNcIiwgdGhpcy5zZWNvbmRhcnlEb21haW5BeGlzUG9zaXRpb24pLCBzID0gdFtyXTtcbiAgICAgIGlmIChpICE9IG51bGwgJiYgaS5jb3JyZXNwb25kaW5nRGF0YXNldHMgJiYgaS5jb3JyZXNwb25kaW5nRGF0YXNldHMuaW5jbHVkZXMocykpXG4gICAgICAgIHJldHVybiB0aGlzLnNlY29uZGFyeURvbWFpbkF4aXNQb3NpdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZG9tYWluQXhpc1Bvc2l0aW9uO1xuICB9XG4gIGdldFJhbmdlQXhpc1Bvc2l0aW9uKHsgZGF0dW06IHQgPSBudWxsLCBncm91cHM6IG4gPSBudWxsIH0gPSB7fSkge1xuICAgIGlmICh0aGlzLmR1YWxBeGVzKSB7XG4gICAgICBjb25zdCByID0gdGhpcy5tb2RlbC5nZXRPcHRpb25zKCksIHsgZ3JvdXBNYXBzVG86IGkgfSA9IHIuZGF0YSwgcyA9IHkociwgXCJheGVzXCIsIHRoaXMuc2Vjb25kYXJ5UmFuZ2VBeGlzUG9zaXRpb24pO1xuICAgICAgbGV0IGE7XG4gICAgICBpZiAodCAhPT0gbnVsbCA/IGEgPSB0W2ldIDogbiAmJiBuLmxlbmd0aCA+IDAgJiYgKGEgPSBuWzBdKSwgcyAhPSBudWxsICYmIHMuY29ycmVzcG9uZGluZ0RhdGFzZXRzICYmIHMuY29ycmVzcG9uZGluZ0RhdGFzZXRzLmluY2x1ZGVzKGEpKVxuICAgICAgICByZXR1cm4gdGhpcy5zZWNvbmRhcnlSYW5nZUF4aXNQb3NpdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmFuZ2VBeGlzUG9zaXRpb247XG4gIH1cbiAgZ2V0QXhpc09wdGlvbnModCkge1xuICAgIHJldHVybiB5KHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLCBcImF4ZXNcIiwgdCk7XG4gIH1cbiAgZ2V0RG9tYWluQXhpc09wdGlvbnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0RG9tYWluQXhpc1Bvc2l0aW9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXhpc09wdGlvbnModCk7XG4gIH1cbiAgZ2V0UmFuZ2VBeGlzT3B0aW9ucygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRSYW5nZUF4aXNQb3NpdGlvbigpO1xuICAgIHJldHVybiB0aGlzLmdldEF4aXNPcHRpb25zKHQpO1xuICB9XG4gIGdldFNjYWxlTGFiZWwodCkge1xuICAgIHJldHVybiB0aGlzLmdldEF4aXNPcHRpb25zKHQpLnRpdGxlIHx8ICh0ID09PSBHLkJPVFRPTSB8fCB0ID09PSBHLlRPUCA/IFwieC12YWx1ZVwiIDogXCJ5LXZhbHVlXCIpO1xuICB9XG4gIGdldERvbWFpbkxhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLmdldFNjYWxlTGFiZWwodGhpcy5nZXREb21haW5BeGlzUG9zaXRpb24oKSk7XG4gIH1cbiAgZ2V0UmFuZ2VMYWJlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTY2FsZUxhYmVsKHRoaXMuZ2V0UmFuZ2VBeGlzUG9zaXRpb24oKSk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuZGV0ZXJtaW5lQXhpc0R1YWxpdHkoKSwgdGhpcy5maW5kRG9tYWluQW5kUmFuZ2VBeGVzKCksIHRoaXMuZGV0ZXJtaW5lT3JpZW50YXRpb24oKSwgT2JqZWN0LmtleXMoRykubWFwKFxuICAgICAgKHQpID0+IEdbdF1cbiAgICApLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHRoaXMuc2NhbGVzW3RdID0gdGhpcy5jcmVhdGVTY2FsZSh0KTtcbiAgICB9KTtcbiAgfVxuICBmaW5kRG9tYWluQW5kUmFuZ2VBeGVzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmZpbmRWZXJ0aWNhbEF4ZXNQb3NpdGlvbnMoKSwgbiA9IHRoaXMuZmluZEhvcml6b250YWxBeGVzUG9zaXRpb25zKCksIHIgPSB0aGlzLmZpbmREb21haW5BbmRSYW5nZUF4ZXNQb3NpdGlvbnMoXG4gICAgICB0LFxuICAgICAgblxuICAgICk7XG4gICAgdGhpcy5kb21haW5BeGlzUG9zaXRpb24gPSByLnByaW1hcnlEb21haW5BeGlzUG9zaXRpb24sIHRoaXMucmFuZ2VBeGlzUG9zaXRpb24gPSByLnByaW1hcnlSYW5nZUF4aXNQb3NpdGlvbiwgdGhpcy5pc0R1YWxBeGVzKCkgJiYgKHRoaXMuc2Vjb25kYXJ5RG9tYWluQXhpc1Bvc2l0aW9uID0gci5zZWNvbmRhcnlEb21haW5BeGlzUG9zaXRpb24sIHRoaXMuc2Vjb25kYXJ5UmFuZ2VBeGlzUG9zaXRpb24gPSByLnNlY29uZGFyeVJhbmdlQXhpc1Bvc2l0aW9uKTtcbiAgfVxuICBkZXRlcm1pbmVPcmllbnRhdGlvbigpIHtcbiAgICAodGhpcy5yYW5nZUF4aXNQb3NpdGlvbiA9PT0gRy5MRUZUIHx8IHRoaXMucmFuZ2VBeGlzUG9zaXRpb24gPT09IEcuUklHSFQpICYmICh0aGlzLmRvbWFpbkF4aXNQb3NpdGlvbiA9PT0gRy5CT1RUT00gfHwgdGhpcy5kb21haW5BeGlzUG9zaXRpb24gPT09IEcuVE9QKSA/IHRoaXMub3JpZW50YXRpb24gPSBGdC5WRVJUSUNBTCA6IHRoaXMub3JpZW50YXRpb24gPSBGdC5IT1JJWk9OVEFMO1xuICB9XG4gIGlzRHVhbEF4ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHVhbEF4ZXM7XG4gIH1cbiAgLy8gaWYgYW55IG9mIHRoZSBheGVzIG9iamVjdHMgaGF2ZSBjb3JyZXNwb25kaW5nRGF0YXNldHMgW10gYXNzZXJ0ZWQgd2UgZmxhZyB0aGUgY2hhcnQgYXMgZHVhbCBheGVzXG4gIC8vIGl0IGRvZXMgbm90IGNvdW50IGFzIGR1YWwgYXhlcyBpZiBpdCBqdXN0IGhhcyBhbm90aGVyIGF4aXMgdHVybmVkIG9uIGJ1dCBpcyBub3QgYWN0dWFsbHkgdXNpbmcgaXQgdG8gbWFwIGEgZGF0YXNldFxuICBkZXRlcm1pbmVBeGlzRHVhbGl0eSgpIHtcbiAgICB2YXIgdCwgbiwgciwgaTtcbiAgICBjb25zdCBzID0gdGhpcy5tb2RlbC5nZXRPcHRpb25zKCksIGEgPSB5KHMsIFwiYXhlc1wiKTtcbiAgICAoKHQgPSBhW0cuTEVGVF0pICE9IG51bGwgJiYgdC5jb3JyZXNwb25kaW5nRGF0YXNldHMgJiYgYVtHLlJJR0hUXSB8fCAobiA9IGFbRy5SSUdIVF0pICE9IG51bGwgJiYgbi5jb3JyZXNwb25kaW5nRGF0YXNldHMgJiYgYVtHLkxFRlRdIHx8IChyID0gYVtHLlRPUF0pICE9IG51bGwgJiYgci5jb3JyZXNwb25kaW5nRGF0YXNldHMgJiYgYVtHLkJPVFRPTV0gfHwgKGkgPSBhW0cuQk9UVE9NXSkgIT0gbnVsbCAmJiBpLmNvcnJlc3BvbmRpbmdEYXRhc2V0cyAmJiBhW0cuVE9QXSkgJiYgKHRoaXMuZHVhbEF4ZXMgPSAhMCk7XG4gIH1cbiAgZ2V0Q3VzdG9tRG9tYWluVmFsdWVzQnlwb3NpdGlvbih0KSB7XG4gICAgY29uc3QgbiA9IHkodGhpcy5tb2RlbC5nZXRPcHRpb25zKCksIFwiYXhlc1wiLCB0LCBcImRvbWFpblwiKTtcbiAgICBpZiAobiAmJiAhQXJyYXkuaXNBcnJheShuKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRG9tYWluIGluICR7dH0gYXhpcyBpcyBub3QgYSB2YWxpZCBhcnJheWApO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG4pICYmICh0aGlzLnNjYWxlVHlwZXNbdF0gPT09IGV0LkxJTkVBUiB8fCB0aGlzLnNjYWxlVHlwZXNbdF0gPT09IGV0LlRJTUUpICYmIG4ubGVuZ3RoICE9PSAyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlcmUgY2FuIG9ubHkgYmUgMiBlbGVtZW50cyBpbiBkb21haW4gZm9yIHNjYWxlIHR5cGU6ICR7dGhpcy5zY2FsZVR5cGVzW3RdfWBcbiAgICAgICk7XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgZ2V0T3JpZW50YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZW50YXRpb247XG4gIH1cbiAgZ2V0U2NhbGVCeVBvc2l0aW9uKHQpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZXNbdF07XG4gIH1cbiAgZ2V0U2NhbGVUeXBlQnlQb3NpdGlvbih0KSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGVUeXBlc1t0XTtcbiAgfVxuICBnZXREb21haW5BeGlzU2NhbGVUeXBlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldERvbWFpbkF4aXNQb3NpdGlvbigpO1xuICAgIHJldHVybiB0aGlzLmdldFNjYWxlVHlwZUJ5UG9zaXRpb24odCk7XG4gIH1cbiAgZ2V0UmFuZ2VBeGlzU2NhbGVUeXBlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldFJhbmdlQXhpc1Bvc2l0aW9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2NhbGVUeXBlQnlQb3NpdGlvbih0KTtcbiAgfVxuICBnZXREb21haW5TY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZXNbdGhpcy5kb21haW5BeGlzUG9zaXRpb25dO1xuICB9XG4gIGdldFJhbmdlU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGVzW3RoaXMucmFuZ2VBeGlzUG9zaXRpb25dO1xuICB9XG4gIC8vIEZpbmQgdGhlIG1haW4geC1heGlzIG91dCBvZiB0aGUgMiB4LWF4aXMgb24gdGhlIGNoYXJ0ICh3aGVuIDJEIGF4aXMgaXMgdXNlZClcbiAgZ2V0TWFpblhBeGlzUG9zaXRpb24oKSB7XG4gICAgY29uc3QgdCA9IFtHLkJPVFRPTSwgRy5UT1BdO1xuICAgIHJldHVybiBbdGhpcy5kb21haW5BeGlzUG9zaXRpb24sIHRoaXMucmFuZ2VBeGlzUG9zaXRpb25dLmZpbmQoXG4gICAgICAobikgPT4gdC5pbmRleE9mKG4pID4gLTFcbiAgICApO1xuICB9XG4gIC8vIEZpbmQgdGhlIG1haW4geS1heGlzIG91dCBvZiB0aGUgMiB5LWF4aXMgb24gdGhlIGNoYXJ0ICh3aGVuIDJEIGF4aXMgaXMgdXNlZClcbiAgZ2V0TWFpbllBeGlzUG9zaXRpb24oKSB7XG4gICAgY29uc3QgdCA9IFtHLkxFRlQsIEcuUklHSFRdO1xuICAgIHJldHVybiBbdGhpcy5kb21haW5BeGlzUG9zaXRpb24sIHRoaXMucmFuZ2VBeGlzUG9zaXRpb25dLmZpbmQoXG4gICAgICAobikgPT4gdC5pbmRleE9mKG4pID4gLTFcbiAgICApO1xuICB9XG4gIGdldE1haW5YU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGVzW3RoaXMuZ2V0TWFpblhBeGlzUG9zaXRpb24oKV07XG4gIH1cbiAgZ2V0TWFpbllTY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZXNbdGhpcy5nZXRNYWluWUF4aXNQb3NpdGlvbigpXTtcbiAgfVxuICBnZXRWYWx1ZUZyb21TY2FsZSh0LCBuLCByLCBpKSB7XG4gICAgY29uc3QgcyA9IHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLCBhID0geShzLCBcImF4ZXNcIilbcl0sIHsgbWFwc1RvOiBvIH0gPSBhLCBsID0geShpLCBvKSAhPT0gbnVsbCA/IGlbb10gOiBpO1xuICAgIGxldCBjO1xuICAgIHN3aXRjaCAobikge1xuICAgICAgY2FzZSBldC5MQUJFTFM6XG4gICAgICAgIGMgPSB0KGwpICsgdC5zdGVwKCkgLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZXQuVElNRTpcbiAgICAgICAgYyA9IHQobmV3IERhdGUobCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGMgPSB0KGwpO1xuICAgIH1cbiAgICByZXR1cm4gYztcbiAgfVxuICBnZXRCb3VuZGVkU2NhbGVkVmFsdWVzKHQpIHtcbiAgICBjb25zdCB7IGJvdW5kczogbiB9ID0gdGhpcy5tb2RlbC5nZXRPcHRpb25zKCksIHIgPSB0aGlzLmdldFJhbmdlQXhpc1Bvc2l0aW9uKHsgZGF0dW06IHQgfSksIGkgPSB0aGlzLnNjYWxlc1tyXSwgcyA9IHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLCBhID0geShzLCBcImF4ZXNcIilbcl0sIHsgbWFwc1RvOiBvIH0gPSBhLCBsID0gdFtvXSAhPT0gdm9pZCAwID8gdFtvXSA6IHQ7XG4gICAgcmV0dXJuIFtcbiAgICAgIGkoXG4gICAgICAgIHkodCwgbi51cHBlckJvdW5kTWFwc1RvKSAhPT0gbnVsbCA/IHRbbi51cHBlckJvdW5kTWFwc1RvXSA6IGxcbiAgICAgICksXG4gICAgICBpKFxuICAgICAgICB5KHQsIG4ubG93ZXJCb3VuZE1hcHNUbykgIT09IG51bGwgPyB0W24ubG93ZXJCb3VuZE1hcHNUb10gOiBsXG4gICAgICApXG4gICAgXTtcbiAgfVxuICBnZXRWYWx1ZVRocm91Z2hBeGlzUG9zaXRpb24odCwgbikge1xuICAgIGNvbnN0IHIgPSB0aGlzLnNjYWxlVHlwZXNbdF0sIGkgPSB0aGlzLnNjYWxlc1t0XTtcbiAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZUZyb21TY2FsZShpLCByLCB0LCBuKTtcbiAgfVxuICBnZXREb21haW5WYWx1ZSh0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0RG9tYWluQXhpc1Bvc2l0aW9uKHsgZGF0dW06IHQgfSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVUaHJvdWdoQXhpc1Bvc2l0aW9uKG4sIHQpO1xuICB9XG4gIGdldFJhbmdlVmFsdWUodCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldFJhbmdlQXhpc1Bvc2l0aW9uKHsgZGF0dW06IHQgfSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVUaHJvdWdoQXhpc1Bvc2l0aW9uKG4sIHQpO1xuICB9XG4gIGdldE1haW5YU2NhbGVUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmdldFNjYWxlVHlwZUJ5UG9zaXRpb24odGhpcy5nZXRNYWluWEF4aXNQb3NpdGlvbigpKTtcbiAgfVxuICBnZXRNYWluWVNjYWxlVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTY2FsZVR5cGVCeVBvc2l0aW9uKHRoaXMuZ2V0TWFpbllBeGlzUG9zaXRpb24oKSk7XG4gIH1cbiAgZ2V0RG9tYWluSWRlbnRpZmllcih0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpO1xuICAgIHJldHVybiB5KG4sIFwiYXhlc1wiLCB0aGlzLmdldERvbWFpbkF4aXNQb3NpdGlvbih7IGRhdHVtOiB0IH0pLCBcIm1hcHNUb1wiKTtcbiAgfVxuICBnZXRSYW5nZUlkZW50aWZpZXIodCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLm1vZGVsLmdldE9wdGlvbnMoKTtcbiAgICByZXR1cm4geShuLCBcImF4ZXNcIiwgdGhpcy5nZXRSYW5nZUF4aXNQb3NpdGlvbih7IGRhdHVtOiB0IH0pLCBcIm1hcHNUb1wiKTtcbiAgfVxuICBleHRlbmRzRG9tYWluKHQsIG4pIHtcbiAgICBjb25zdCByID0gdGhpcy5tb2RlbC5nZXRPcHRpb25zKCksIGkgPSB5KHIsIFwiYXhlc1wiLCB0KTtcbiAgICBpZiAoaS5zY2FsZVR5cGUgPT09IGV0LlRJTUUpIHtcbiAgICAgIGNvbnN0IHMgPSB5KHIsIFwidGltZVNjYWxlXCIsIFwiYWRkU3BhY2VPbkVkZ2VzXCIpO1xuICAgICAgcmV0dXJuICRQKG4sIHMpO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIE1QKG4sIFBuLnBhZGRpbmdSYXRpbywgaS5zY2FsZVR5cGUpO1xuICB9XG4gIGZpbmRWZXJ0aWNhbEF4ZXNQb3NpdGlvbnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLCBuID0geSh0LCBcImF4ZXNcIiksIHIgPSB0aGlzLmlzRHVhbEF4ZXMoKTtcbiAgICByZXR1cm4geShuLCBHLkxFRlQpID09PSBudWxsICYmIHkobiwgRy5SSUdIVCkgIT09IG51bGwgfHwgeShuLCBHLlJJR0hULCBcIm1haW5cIikgPT09ICEwIHx8IHIgJiYgeShuLCBHLkxFRlQsIFwiY29ycmVzcG9uZGluZ0RhdGFzZXRzXCIpID8ge1xuICAgICAgcHJpbWFyeTogRy5SSUdIVCxcbiAgICAgIHNlY29uZGFyeTogRy5MRUZUXG4gICAgfSA6IHsgcHJpbWFyeTogRy5MRUZULCBzZWNvbmRhcnk6IEcuUklHSFQgfTtcbiAgfVxuICBmaW5kSG9yaXpvbnRhbEF4ZXNQb3NpdGlvbnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLCBuID0geSh0LCBcImF4ZXNcIiksIHIgPSB0aGlzLmlzRHVhbEF4ZXMoKTtcbiAgICByZXR1cm4geShuLCBHLkJPVFRPTSkgPT09IG51bGwgJiYgeShuLCBHLlRPUCkgIT09IG51bGwgfHwgeShuLCBHLlRPUCwgXCJtYWluXCIpID09PSAhMCB8fCByICYmIHkobiwgRy5CT1RUT00sIFwiY29ycmVzcG9uZGluZ0RhdGFzZXRzXCIpID8ge1xuICAgICAgcHJpbWFyeTogRy5UT1AsXG4gICAgICBzZWNvbmRhcnk6IEcuQk9UVE9NXG4gICAgfSA6IHsgcHJpbWFyeTogRy5CT1RUT00sIHNlY29uZGFyeTogRy5UT1AgfTtcbiAgfVxuICBmaW5kRG9tYWluQW5kUmFuZ2VBeGVzUG9zaXRpb25zKHQsIG4pIHtcbiAgICBjb25zdCByID0gdGhpcy5tb2RlbC5nZXRPcHRpb25zKCksIGkgPSB5KHIsIFwiYXhlc1wiLCB0LnByaW1hcnkpLCBzID0geShyLCBcImF4ZXNcIiwgbi5wcmltYXJ5KSwgYSA9IGkuc2NhbGVUeXBlIHx8IGV0LkxJTkVBUiwgbyA9IHMuc2NhbGVUeXBlIHx8IGV0LkxJTkVBUiwgbCA9IHtcbiAgICAgIHByaW1hcnlEb21haW5BeGlzUG9zaXRpb246IG51bGwsXG4gICAgICBzZWNvbmRhcnlEb21haW5BeGlzUG9zaXRpb246IG51bGwsXG4gICAgICBwcmltYXJ5UmFuZ2VBeGlzUG9zaXRpb246IG51bGwsXG4gICAgICBzZWNvbmRhcnlSYW5nZUF4aXNQb3NpdGlvbjogbnVsbFxuICAgIH07XG4gICAgcmV0dXJuIGwucHJpbWFyeURvbWFpbkF4aXNQb3NpdGlvbiA9IG4ucHJpbWFyeSwgbC5wcmltYXJ5UmFuZ2VBeGlzUG9zaXRpb24gPSB0LnByaW1hcnksIGwuc2Vjb25kYXJ5RG9tYWluQXhpc1Bvc2l0aW9uID0gbi5zZWNvbmRhcnksIGwuc2Vjb25kYXJ5UmFuZ2VBeGlzUG9zaXRpb24gPSB0LnNlY29uZGFyeSwgKCEobyA9PT0gZXQuTEFCRUxTIHx8IG8gPT09IGV0LlRJTUUpICYmIGEgPT09IGV0LkxBQkVMUyB8fCBhID09PSBldC5USU1FKSAmJiAobC5wcmltYXJ5RG9tYWluQXhpc1Bvc2l0aW9uID0gdC5wcmltYXJ5LCBsLnByaW1hcnlSYW5nZUF4aXNQb3NpdGlvbiA9IG4ucHJpbWFyeSwgbC5zZWNvbmRhcnlEb21haW5BeGlzUG9zaXRpb24gPSB0LnNlY29uZGFyeSwgbC5zZWNvbmRhcnlSYW5nZUF4aXNQb3NpdGlvbiA9IG4uc2Vjb25kYXJ5KSwgbDtcbiAgfVxuICBnZXRTY2FsZURvbWFpbih0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLCByID0geShuLCBcImF4ZXNcIiwgdCksIGkgPSB5KG4sIFwiYm91bmRzXCIpLCB7IGluY2x1ZGVaZXJvOiBzIH0gPSByLCBhID0geShyLCBcInNjYWxlVHlwZVwiKSB8fCBldC5MSU5FQVI7XG4gICAgaWYgKHRoaXMubW9kZWwuaXNEYXRhRW1wdHkoKSlcbiAgICAgIHJldHVybiBbXTtcbiAgICBpZiAoci5iaW5uZWQpIHtcbiAgICAgIGNvbnN0IHsgYmluczogdiB9ID0gdGhpcy5tb2RlbC5nZXRCaW5Db25maWd1cmF0aW9ucygpO1xuICAgICAgcmV0dXJuIFswLCBucih2LCAoeCkgPT4geC5sZW5ndGgpXTtcbiAgICB9IGVsc2UgaWYgKHIubGltaXREb21haW5Ub0JpbnMpIHtcbiAgICAgIGNvbnN0IHsgYmluczogdiB9ID0gdGhpcy5tb2RlbC5nZXRCaW5Db25maWd1cmF0aW9ucygpLCB4ID0gdGhpcy5tb2RlbC5nZXRTdGFja0tleXMoeyBiaW5zOiB2IH0pO1xuICAgICAgcmV0dXJuIFt4WzBdLnNwbGl0KFwiOlwiKVswXSwgeFt4Lmxlbmd0aCAtIDFdLnNwbGl0KFwiOlwiKVsxXV07XG4gICAgfVxuICAgIGNvbnN0IG8gPSB0aGlzLm1vZGVsLmdldERpc3BsYXlEYXRhKCksIHsgZXh0ZW5kTGluZWFyRG9tYWluQnk6IGwsIG1hcHNUbzogYywgcGVyY2VudGFnZTogdSwgdGhyZXNob2xkczogZCB9ID0gciwgeyByZWZlcmVuY2U6IGgsIGNvbXBhcmVUbzogcCB9ID0gUG4ucmF0aW87XG4gICAgaWYgKHIuZG9tYWluKVxuICAgICAgcmV0dXJuIGEgPT09IGV0LkxBQkVMUyA/IHIuZG9tYWluIDogKGEgPT09IGV0LlRJTUUgJiYgKHIuZG9tYWluID0gci5kb21haW4ubWFwKFxuICAgICAgICAodikgPT4gdi5nZXRUaW1lID09PSB2b2lkIDAgPyBuZXcgRGF0ZSh2KSA6IHZcbiAgICAgICkpLCB0aGlzLmV4dGVuZHNEb21haW4odCwgci5kb21haW4pKTtcbiAgICBpZiAodSlcbiAgICAgIHJldHVybiBbMCwgMTAwXTtcbiAgICBpZiAociAmJiBhID09PSBldC5MQUJFTFMpXG4gICAgICByZXR1cm4gWmkoby5tYXAoKHYpID0+IHZbY10pKTtcbiAgICBsZXQgZiwgZztcbiAgICBjb25zdCBtID0gdGhpcy5tb2RlbC5nZXREYXRhR3JvdXBOYW1lcygpO1xuICAgIGlmIChhID09PSBldC5MQUJFTFNfUkFUSU8pXG4gICAgICByZXR1cm4gby5tYXAoKHYpID0+IGAke3ZbaF19LyR7dltwXX1gKTtcbiAgICBpZiAoYSA9PT0gZXQuVElNRSlcbiAgICAgIGcgPSBvLm1hcCgodikgPT4gK25ldyBEYXRlKHZbY10pKTtcbiAgICBlbHNlIGlmIChpICYmIG4uYXhlcylcbiAgICAgIGcgPSBbXSwgby5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgIGcucHVzaCh2W2NdKSwgdltpLnVwcGVyQm91bmRNYXBzVG9dICYmIGcucHVzaCh2W2kudXBwZXJCb3VuZE1hcHNUb10pLCB2W2kubG93ZXJCb3VuZE1hcHNUb10gJiYgZy5wdXNoKHZbaS5sb3dlckJvdW5kTWFwc1RvXSk7XG4gICAgICB9KTtcbiAgICBlbHNlIGlmIChyLnN0YWNrZWQgPT09ICEwICYmIG0gJiYgdCA9PT0gdGhpcy5nZXRSYW5nZUF4aXNQb3NpdGlvbigpKSB7XG4gICAgICBjb25zdCB7IGdyb3VwTWFwc1RvOiB2IH0gPSBuLmRhdGEsIHggPSB0aGlzLm1vZGVsLmdldERhdGFWYWx1ZXNHcm91cGVkQnlLZXlzKHtcbiAgICAgICAgZ3JvdXBzOiBtXG4gICAgICB9KSwgXyA9IG8uZmlsdGVyKFxuICAgICAgICAoYikgPT4gIW0uaW5jbHVkZXMoYlt2XSlcbiAgICAgICksIEUgPSBbXTtcbiAgICAgIHguZm9yRWFjaCgoYikgPT4ge1xuICAgICAgICBjb25zdCB7IC4uLlMgfSA9IGI7XG4gICAgICAgIGxldCBNID0gMCwgRCA9IDA7XG4gICAgICAgIE9iamVjdC52YWx1ZXMoSE4oUywgXCJzaGFyZWRTdGFja0tleVwiKSkuZm9yRWFjaCgoQSkgPT4ge1xuICAgICAgICAgIGlzTmFOKEEpIHx8IChBIDwgMCA/IEQgKz0gQSA6IE0gKz0gQSk7XG4gICAgICAgIH0pLCBFLnB1c2goW0QsIE1dKTtcbiAgICAgIH0pLCBnID0gW1xuICAgICAgICAuLi5kdShFKSxcbiAgICAgICAgLi4uXy5tYXAoKGIpID0+IGJbY10pXG4gICAgICBdO1xuICAgIH0gZWxzZVxuICAgICAgZyA9IFtdLCBvLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgY29uc3QgeCA9IHZbY107XG4gICAgICAgIEFycmF5LmlzQXJyYXkoeCkgJiYgeC5sZW5ndGggPT09IDIgPyAoZy5wdXNoKHhbMF0pLCBnLnB1c2goeFsxXSkpIDogKGwgJiYgZy5wdXNoKE1hdGgubWF4KHZbY10sIHZbbF0pKSwgZy5wdXNoKHgpKTtcbiAgICAgIH0pO1xuICAgIHJldHVybiBhICE9PSBldC5USU1FICYmIGEgIT09IGV0LkxPRyAmJiBzICYmIGcucHVzaCgwKSwgZCAmJiBkLmxlbmd0aCA+IDAgJiYgZC5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICBjb25zdCB4ID0geSh2LCBcInZhbHVlXCIpO1xuICAgICAgeCAhPT0gbnVsbCAmJiBnLnB1c2goeCk7XG4gICAgfSksIGYgPSB6ZShnKSwgZiA9IHRoaXMuZXh0ZW5kc0RvbWFpbih0LCBmKSwgZjtcbiAgfVxuICBjcmVhdGVTY2FsZSh0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLCByID0geShuLCBcImF4ZXNcIiwgdCk7XG4gICAgaWYgKCFyKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgaSA9IHkociwgXCJzY2FsZVR5cGVcIikgfHwgZXQuTElORUFSO1xuICAgIHRoaXMuc2NhbGVUeXBlc1t0XSA9IGk7XG4gICAgbGV0IHM7XG4gICAgcmV0dXJuIGkgPT09IGV0LlRJTUUgPyBzID0gZWcoKSA6IGkgPT09IGV0LkxPRyA/IHMgPSBEdigpLmJhc2Uoci5iYXNlIHx8IDEwKSA6IGkgPT09IGV0LkxBQkVMUyB8fCBpID09PSBldC5MQUJFTFNfUkFUSU8gPyBzID0gZ3MoKSA6IHMgPSBGZSgpLCBzLmRvbWFpbih0aGlzLmdldFNjYWxlRG9tYWluKHQpKSwgcztcbiAgfVxuICBnZXREb21haW5Mb3dlckJvdW5kKHQpIHtcbiAgICBsZXQgbiwgciA9IDA7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T3JpZW50YXRpb24oKSA9PT0gRnQuVkVSVElDQUwgPyBuID0gdGhpcy5nZXRNYWluWVNjYWxlKCkuZG9tYWluKCkgOiBuID0gdGhpcy5nZXRNYWluWFNjYWxlKCkuZG9tYWluKCksIHkodGhpcy5tb2RlbC5nZXRPcHRpb25zKCksIFwiYXhlc1wiLCB0LCBcImluY2x1ZGVaZXJvXCIpID09PSAhMSAmJiBuWzBdID4gMCAmJiBuWzFdID4gMCAmJiAociA9IG5bMF0pLCByO1xuICB9XG4gIGdldEhpZ2hlc3REb21haW5UaHJlc2hvbGQoKSB7XG4gICAgY29uc3QgdCA9IHkodGhpcy5tb2RlbC5nZXRPcHRpb25zKCksIFwiYXhlc1wiKSwgbiA9IHRoaXMuZ2V0RG9tYWluQXhpc1Bvc2l0aW9uKCksIHsgdGhyZXNob2xkczogciB9ID0gdFtuXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocikgfHwgQXJyYXkuaXNBcnJheShyKSAmJiAhci5sZW5ndGgpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBpID0gdGhpcy5nZXREb21haW5TY2FsZSgpLCBzID0gci5zb3J0KChhLCBvKSA9PiBvLnZhbHVlIC0gYS52YWx1ZSlbMF07XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2NhbGVUeXBlQnlQb3NpdGlvbihuKSA9PT0gZXQuVElNRSAmJiAodHlwZW9mIHMudmFsdWUgPT0gXCJzdHJpbmdcIiB8fCBzLnZhbHVlLmdldFRpbWUgPT09IHZvaWQgMCkgJiYgKHMudmFsdWUgPSBuZXcgRGF0ZShzLnZhbHVlKSksIHtcbiAgICAgIHRocmVzaG9sZDogcyxcbiAgICAgIHNjYWxlVmFsdWU6IGkocy52YWx1ZSlcbiAgICB9O1xuICB9XG4gIGdldEhpZ2hlc3RSYW5nZVRocmVzaG9sZCgpIHtcbiAgICBjb25zdCB0ID0geSh0aGlzLm1vZGVsLmdldE9wdGlvbnMoKSwgXCJheGVzXCIpLCBuID0gdGhpcy5nZXRSYW5nZUF4aXNQb3NpdGlvbigpLCB7IHRocmVzaG9sZHM6IHIgfSA9IHRbbl07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHIpIHx8IEFycmF5LmlzQXJyYXkocikgJiYgIXIubGVuZ3RoKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0UmFuZ2VTY2FsZSgpLCBzID0gci5zb3J0KChhLCBvKSA9PiBvLnZhbHVlIC0gYS52YWx1ZSlbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHRocmVzaG9sZDogcyxcbiAgICAgIHNjYWxlVmFsdWU6IGkocy52YWx1ZSlcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiAkUChlLCB0KSB7XG4gIGNvbnN0IG4gPSBuZXcgRGF0ZShlWzBdKSwgciA9IG5ldyBEYXRlKGVbMV0pO1xuICByZXR1cm4gZlAociwgbikgPiAxID8gW21QKG4sIHQpLCB6dihyLCB0KV0gOiBiUChyLCBuKSA+IDEgPyBbX1AobiwgdCksIHZ1KHIsIHQpXSA6IEVQKHIsIG4pID4gMSA/IFtPUChuLCB0KSwgRnYociwgdCldIDogU1AociwgbikgPiAxID8gW1RQKG4sIHQpLCBXdihyLCB0KV0gOiBDcChyLCBuKSA+IDMwID8gW1xuICAgIEFwKG4sIHQgKiAzMCksXG4gICAgY2MociwgdCAqIDMwKVxuICBdIDogQ3AociwgbikgPiAxID8gW0FwKG4sIHQpLCBjYyhyLCB0KV0gOiBMcChyLCBuKSA+IDE1ID8gW1xuICAgIGtwKG4sIHQgKiAxNSksXG4gICAgdWMociwgdCAqIDE1KVxuICBdIDogTHAociwgbikgPiAxID8gW2twKG4sIHQpLCB1YyhyLCB0KV0gOiBbbiwgcl07XG59XG5mdW5jdGlvbiBNUChbZSwgdF0sIG4sIHIpIHtcbiAgY29uc3QgaSA9ICh0IC0gZSkgKiBuLCBzID0gdCA8PSAwICYmIHQgKyBpID4gMCA/IDAgOiB0ICsgaTtcbiAgbGV0IGEgPSBlID49IDAgJiYgZSAtIGkgPCAwID8gMCA6IGUgLSBpO1xuICBpZiAociA9PT0gZXQuTE9HICYmIGEgPD0gMCkge1xuICAgIGlmIChlIDw9IDApXG4gICAgICB0aHJvdyBFcnJvcihcIkRhdGEgbXVzdCBoYXZlIHZhbHVlcyBncmVhdGVyIHRoYW4gMCBpZiBsb2cgc2NhbGUgdHlwZSBpcyB1c2VkLlwiKTtcbiAgICBhID0gZTtcbiAgfVxuICByZXR1cm4gW2EsIHNdO1xufVxuY2xhc3MgQ1AgZXh0ZW5kcyBEbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuY3VydmVUeXBlcyA9IHtcbiAgICAgIGN1cnZlTGluZWFyOiBvbyxcbiAgICAgIGN1cnZlTGluZWFyQ2xvc2VkOiBpZyxcbiAgICAgIGN1cnZlQmFzaXM6IHFOLFxuICAgICAgY3VydmVCYXNpc0Nsb3NlZDogWU4sXG4gICAgICBjdXJ2ZUJhc2lzT3BlbjogWE4sXG4gICAgICBjdXJ2ZUJ1bmRsZTogWk4sXG4gICAgICBjdXJ2ZUNhcmRpbmFsOiBLTixcbiAgICAgIGN1cnZlQ2FyZGluYWxDbG9zZWQ6IFFOLFxuICAgICAgY3VydmVDYXJkaW5hbE9wZW46IEpOLFxuICAgICAgY3VydmVDYXRtdWxsUm9tOiB0UCxcbiAgICAgIGN1cnZlQ2F0bXVsbFJvbUNsb3NlZDogZVAsXG4gICAgICBjdXJ2ZUNhdG11bGxSb21PcGVuOiBuUCxcbiAgICAgIGN1cnZlTW9ub3RvbmVYOiByUCxcbiAgICAgIGN1cnZlTW9ub3RvbmVZOiBpUCxcbiAgICAgIGN1cnZlTmF0dXJhbDogc1AsXG4gICAgICBjdXJ2ZVN0ZXA6IGFQLFxuICAgICAgY3VydmVTdGVwQWZ0ZXI6IGxQLFxuICAgICAgY3VydmVTdGVwQmVmb3JlOiBvUFxuICAgIH07XG4gIH1cbiAgZ2V0RDNDdXJ2ZSgpIHtcbiAgICBsZXQgdCA9IFwiY3VydmVMaW5lYXJcIjtcbiAgICBjb25zdCBuID0gdGhpcy5tb2RlbC5nZXRPcHRpb25zKCkuY3VydmU7XG4gICAgaWYgKG4gJiYgKHR5cGVvZiBuID09IFwic3RyaW5nXCIgPyB0ID0gbiA6IHQgPSBuLm5hbWUpLCB0aGlzLmN1cnZlVHlwZXNbdF0pIHtcbiAgICAgIGxldCByID0gdGhpcy5jdXJ2ZVR5cGVzW3RdO1xuICAgICAgcmV0dXJuIG4gJiYgT2JqZWN0LmtleXMobikuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgICByW2ldICYmIChyID0gcltpXShuW2ldKSk7XG4gICAgICB9KSwgcjtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnNvbGUud2FybihgVGhlIGN1cnZlIHR5cGUgJyR7dH0nIGlzIGludmFsaWQsIHVzaW5nICdjdXJ2ZUxpbmVhcicgaW5zdGVhZGApLCB0aGlzLmN1cnZlVHlwZXMuY3VydmVMaW5lYXI7XG4gIH1cbn1cbmNsYXNzIEFQIGV4dGVuZHMgRG4ge1xuICBpc1pvb21CYXJFbmFibGVkKCkge1xuICAgIGlmICghdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMgfHwgIXkodGhpcy5tb2RlbC5nZXRPcHRpb25zKCksIFwiem9vbUJhclwiLCBcInRvcFwiLCBcImVuYWJsZWRcIikpXG4gICAgICByZXR1cm4gITE7XG4gICAgdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZmluZERvbWFpbkFuZFJhbmdlQXhlcygpO1xuICAgIGNvbnN0IHQgPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRNYWluWEF4aXNQb3NpdGlvbigpLCBuID0geShcbiAgICAgIHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLFxuICAgICAgXCJheGVzXCIsXG4gICAgICB0LFxuICAgICAgXCJzY2FsZVR5cGVcIlxuICAgICk7XG4gICAgcmV0dXJuIHQgPT09IEcuQk9UVE9NICYmIG4gPT09IGV0LlRJTUU7XG4gIH1cbiAgLy8gZ2V0IGRpc3BsYXkgZGF0YSBmb3Igem9vbSBiYXJcbiAgLy8gYmFzaWNhbGx5IGl0J3Mgc3VtIG9mIHZhbHVlIGdyb3VwZWQgYnkgdGltZVxuICBnZXRab29tQmFyRGF0YSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5tb2RlbC5nZXRab29tQmFyRGF0YSgpO1xuICAgIHJldHVybiB0ICYmIHQubGVuZ3RoID4gMSA/IHQgOiB0aGlzLm1vZGVsLmdldERpc3BsYXlEYXRhKCk7XG4gIH1cbiAgZ2V0RGVmYXVsdFpvb21CYXJEb21haW4odCkge1xuICAgIGlmICghdGhpcy5zZXJ2aWNlcy56b29tKSB0aHJvdyBuZXcgRXJyb3IoXCJTZXJ2aWNlcyB6b29tIG5vdCBkZWZpbmVkXCIpO1xuICAgIGNvbnN0IG4gPSB0IHx8IHRoaXMuc2VydmljZXMuem9vbS5nZXRab29tQmFyRGF0YSgpLCB7IGNhcnRlc2lhblNjYWxlczogciB9ID0gdGhpcy5zZXJ2aWNlcztcbiAgICBpZiAoIXIpIHRocm93IG5ldyBFcnJvcihcIlNlcnZpY2VzIGNhcnRlc2lhblNjYWxlcyB1bmRlZmluZWRcIik7XG4gICAgY29uc3QgaSA9IHIuZ2V0TWFpblhBeGlzUG9zaXRpb24oKSwgcyA9IHIuZ2V0RG9tYWluSWRlbnRpZmllcigpLCBhID0geSh0aGlzLm1vZGVsLmdldE9wdGlvbnMoKSwgXCJheGVzXCIsIGksIFwiZG9tYWluXCIpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpICYmIGEubGVuZ3RoID09PSAyKVxuICAgICAgcmV0dXJuIGE7XG4gICAgaWYgKCFpKSB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgZGVmaW5lZDogbWFpblhBeGlzUG9zaXRpb25cIik7XG4gICAgcmV0dXJuIHIuZXh0ZW5kc0RvbWFpbihcbiAgICAgIGksXG4gICAgICB6ZShuLCAobykgPT4gb1tzXSlcbiAgICApO1xuICB9XG4gIGhhbmRsZURvbWFpbkNoYW5nZSh0LCBuID0geyBkaXNwYXRjaEV2ZW50OiAhMCB9KSB7XG4gICAgdmFyIHI7XG4gICAgdGhpcy5tb2RlbC5zZXQoeyB6b29tRG9tYWluOiB0IH0sIHsgYW5pbWF0ZTogITEgfSksIG4uZGlzcGF0Y2hFdmVudCAmJiAoKHIgPSB0aGlzLnNlcnZpY2VzLmV2ZW50cykgPT0gbnVsbCB8fCByLmRpc3BhdGNoRXZlbnQoVC5ab29tRG9tYWluLkNIQU5HRSwge1xuICAgICAgbmV3RG9tYWluOiB0XG4gICAgfSkpO1xuICB9XG4gIGdldFpvb21SYXRpbygpIHtcbiAgICByZXR1cm4geSh0aGlzLm1vZGVsLmdldE9wdGlvbnMoKSwgXCJ6b29tQmFyXCIsIFwiem9vbVJhdGlvXCIpO1xuICB9XG4gIC8vIGZpbHRlciBvdXQgZGF0YSBub3QgaW5zaWRlIHpvb20gZG9tYWluXG4gIC8vIHRvIGdldCBiZXR0ZXIgcmFuZ2UgdmFsdWUgZm9yIGF4aXMgbGFiZWxcbiAgZmlsdGVyRGF0YUZvclJhbmdlQXhpcyh0LCBuKSB7XG4gICAgdmFyIHI7XG4gICAgY29uc3QgaSA9IHRoaXMubW9kZWwuZ2V0KFwiem9vbURvbWFpblwiKSwgcyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7IHN0YWNrZWQ6ICExIH0sXG4gICAgICAvLyBkZWZhdWx0IGNvbmZpZ3NcbiAgICAgIG5cbiAgICApLCBhID0geSh0aGlzLm1vZGVsLmdldE9wdGlvbnMoKSwgXCJ6b29tQmFyXCIsIFwidXBkYXRlUmFuZ2VBeGlzXCIpO1xuICAgIGlmICh0aGlzLmlzWm9vbUJhckVuYWJsZWQoKSAmJiBhICYmIGkpIHtcbiAgICAgIGNvbnN0IG8gPSBzLnN0YWNrZWQgPyBcInNoYXJlZFN0YWNrS2V5XCIgOiAociA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzKSA9PSBudWxsID8gdm9pZCAwIDogci5nZXREb21haW5JZGVudGlmaWVyKCksIGwgPSB0LmZpbHRlcihcbiAgICAgICAgKGMpID0+IG5ldyBEYXRlKGNbb10pID49IGlbMF0gJiYgbmV3IERhdGUoY1tvXSkgPD0gaVsxXVxuICAgICAgKTtcbiAgICAgIGlmIChsLmxlbmd0aCA+IDApXG4gICAgICAgIHJldHVybiBsO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuICB6b29tSW4odCA9IHRoaXMuZ2V0Wm9vbVJhdGlvKCkpIHtcbiAgICB2YXIgbjtcbiAgICBjb25zdCByID0gdGhpcy5tb2RlbC5nZXQoXCJ6b29tRG9tYWluXCIpLCBpID0geWUuaGFuZGxlV2lkdGgsIHMgPSAobiA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzKSA9PSBudWxsID8gdm9pZCAwIDogbi5nZXRNYWluWFNjYWxlKCkuY29weSgpO1xuICAgIHMuZG9tYWluKHRoaXMuZ2V0RGVmYXVsdFpvb21CYXJEb21haW4oKSk7XG4gICAgY29uc3QgYSA9IHMoclswXSksIG8gPSBzKHJbMV0pO1xuICAgIGlmIChvIC0gYSA8IGkgKyAxKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGwgPSBzLnJhbmdlKCksIGMgPSBvIC0gYSwgdSA9IE1hdGgubWluKChsWzFdIC0gbFswXSkgLyAyICogKHQgLyAyKSwgYyAvIDIpO1xuICAgIGxldCBkID0gYSArIHUsIGggPSBvIC0gdTtcbiAgICBkID49IGggJiYgKGQgPSBhICsgYyAvIDIgLSBpIC8gMiwgaCA9IG8gLSBjIC8gMiArIGkgLyAyKTtcbiAgICBjb25zdCBwID0gW3MuaW52ZXJ0KGQpLCBzLmludmVydChoKV07XG4gICAgKHJbMF0udmFsdWVPZigpICE9PSBwWzBdLnZhbHVlT2YoKSB8fCByWzFdLnZhbHVlT2YoKSAhPT0gcFsxXS52YWx1ZU9mKCkpICYmIHRoaXMuaGFuZGxlRG9tYWluQ2hhbmdlKHApO1xuICB9XG4gIHpvb21PdXQodCA9IHRoaXMuZ2V0Wm9vbVJhdGlvKCkpIHtcbiAgICBjb25zdCBuID0gdGhpcy5tb2RlbC5nZXQoXCJ6b29tRG9tYWluXCIpO1xuICAgIGlmICghdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMpIHRocm93IG5ldyBFcnJvcihcIlNlcnZpY2VzIGNhcnRlc2lhblNjYWxlcyB1bmRlZmluZWRcIik7XG4gICAgY29uc3QgciA9IHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmdldE1haW5YU2NhbGUoKS5jb3B5KCk7XG4gICAgci5kb21haW4odGhpcy5nZXREZWZhdWx0Wm9vbUJhckRvbWFpbigpKTtcbiAgICBjb25zdCBpID0gcihuWzBdKSwgcyA9IHIoblsxXSksIGEgPSByLnJhbmdlKCksIG8gPSAoYVsxXSAtIGFbMF0pIC8gMiAqICh0IC8gMiksIGwgPSBNYXRoLm1heChpIC0gbywgYVswXSksIGMgPSBNYXRoLm1pbihzICsgbywgYVsxXSksIHUgPSBbci5pbnZlcnQobCksIHIuaW52ZXJ0KGMpXTtcbiAgICAoblswXS52YWx1ZU9mKCkgIT09IHVbMF0udmFsdWVPZigpIHx8IG5bMV0udmFsdWVPZigpICE9PSB1WzFdLnZhbHVlT2YoKSkgJiYgdGhpcy5oYW5kbGVEb21haW5DaGFuZ2UodSk7XG4gIH1cbiAgcmVzZXRab29tRG9tYWluKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm1vZGVsLmdldChcInpvb21Eb21haW5cIiksIG4gPSB0aGlzLmdldERlZmF1bHRab29tQmFyRG9tYWluKCk7XG4gICAgKHRbMF0udmFsdWVPZigpICE9PSBuWzBdLnZhbHVlT2YoKSB8fCB0WzFdLnZhbHVlT2YoKSAhPT0gblsxXS52YWx1ZU9mKCkpICYmIHRoaXMuaGFuZGxlRG9tYWluQ2hhbmdlKG4pO1xuICB9XG4gIC8vIGNoZWNrIGlmIGN1cnJlbnQgem9vbSBkb21haW4gaXMgYWxyZWFkeSB0aGUgbWluIHpvb20gZG9tYWluXG4gIC8vIHdoZW4gdG9vbGJhciBpcyByZW5kZXJlZCwgd2UgZG9uJ3QgcmVuZGVyIGNoYXJ0IHlldFxuICAvLyBkb24ndCBkZXBlbmQgb24gc2NhbGUgcmFuZ2VcbiAgaXNNaW5ab29tRG9tYWluKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm1vZGVsLmdldChcInpvb21Eb21haW5cIiksIG4gPSB0aGlzLmdldERlZmF1bHRab29tQmFyRG9tYWluKCk7XG4gICAgaWYgKCF0IHx8ICFuKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHIgPSB0WzFdLnZhbHVlT2YoKSAtIHRbMF0udmFsdWVPZigpLCBpID0gblsxXS52YWx1ZU9mKCkgLSBuWzBdLnZhbHVlT2YoKSwgcyA9IHkodGhpcy5tb2RlbC5nZXRPcHRpb25zKCksIFwiem9vbUJhclwiLCBcIm1pblpvb21SYXRpb1wiKTtcbiAgICByZXR1cm4gciAvIGkgPCBzO1xuICB9XG4gIC8vIGNoZWNrIGlmIGN1cnJlbnQgem9vbSBkb21haW4gaXMgYWxyZWFkeSB0aGUgbWF4IHpvb20gZG9tYWluXG4gIGlzTWF4Wm9vbURvbWFpbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5tb2RlbC5nZXQoXCJ6b29tRG9tYWluXCIpLCBuID0gdGhpcy5nZXREZWZhdWx0Wm9vbUJhckRvbWFpbigpO1xuICAgIHJldHVybiAhISh0ICYmIG4gJiYgdFswXS52YWx1ZU9mKCkgPT09IG5bMF0udmFsdWVPZigpICYmIHRbMV0udmFsdWVPZigpID09PSBuWzFdLnZhbHVlT2YoKSk7XG4gIH1cbiAgaXNFbXB0eVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLmdldFpvb21CYXJEYXRhKCkubGVuZ3RoID09PSAwO1xuICB9XG4gIGlzWm9vbUJhckxvYWRpbmcodCkge1xuICAgIHJldHVybiB5KHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLCBcInpvb21CYXJcIiwgdCwgXCJsb2FkaW5nXCIpO1xuICB9XG4gIGlzWm9vbUJhckxvY2tlZCh0KSB7XG4gICAgcmV0dXJuIHkodGhpcy5tb2RlbC5nZXRPcHRpb25zKCksIFwiem9vbUJhclwiLCB0LCBcImxvY2tlZFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gTFAoZSwgdCwgbikge1xuICB2YXIgciA9IGUubGVuZ3RoO1xuICByZXR1cm4gbiA9IG4gPT09IHZvaWQgMCA/IHIgOiBuLCBrdihlLCB0LCBuKTtcbn1cbnZhciBrUCA9IFwiXFxcXHVkODAwLVxcXFx1ZGZmZlwiLCBEUCA9IFwiXFxcXHUwMzAwLVxcXFx1MDM2ZlwiLCBSUCA9IFwiXFxcXHVmZTIwLVxcXFx1ZmUyZlwiLCBJUCA9IFwiXFxcXHUyMGQwLVxcXFx1MjBmZlwiLCBOUCA9IERQICsgUlAgKyBJUCwgUFAgPSBcIlxcXFx1ZmUwZVxcXFx1ZmUwZlwiLCBVUCA9IFwiXFxcXHUyMDBkXCIsIEJQID0gUmVnRXhwKFwiW1wiICsgVVAgKyBrUCArIE5QICsgUFAgKyBcIl1cIik7XG5mdW5jdGlvbiBZdihlKSB7XG4gIHJldHVybiBCUC50ZXN0KGUpO1xufVxuZnVuY3Rpb24gSFAoZSkge1xuICByZXR1cm4gZS5zcGxpdChcIlwiKTtcbn1cbnZhciBYdiA9IFwiXFxcXHVkODAwLVxcXFx1ZGZmZlwiLCBWUCA9IFwiXFxcXHUwMzAwLVxcXFx1MDM2ZlwiLCBHUCA9IFwiXFxcXHVmZTIwLVxcXFx1ZmUyZlwiLCB6UCA9IFwiXFxcXHUyMGQwLVxcXFx1MjBmZlwiLCBGUCA9IFZQICsgR1AgKyB6UCwgalAgPSBcIlxcXFx1ZmUwZVxcXFx1ZmUwZlwiLCBXUCA9IFwiW1wiICsgWHYgKyBcIl1cIiwgaGMgPSBcIltcIiArIEZQICsgXCJdXCIsIGRjID0gXCJcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl1cIiwgcVAgPSBcIig/OlwiICsgaGMgKyBcInxcIiArIGRjICsgXCIpXCIsIFp2ID0gXCJbXlwiICsgWHYgKyBcIl1cIiwgS3YgPSBcIig/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn1cIiwgUXYgPSBcIltcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXVwiLCBZUCA9IFwiXFxcXHUyMDBkXCIsIEp2ID0gcVAgKyBcIj9cIiwgdDAgPSBcIltcIiArIGpQICsgXCJdP1wiLCBYUCA9IFwiKD86XCIgKyBZUCArIFwiKD86XCIgKyBbWnYsIEt2LCBRdl0uam9pbihcInxcIikgKyBcIilcIiArIHQwICsgSnYgKyBcIikqXCIsIFpQID0gdDAgKyBKdiArIFhQLCBLUCA9IFwiKD86XCIgKyBbWnYgKyBoYyArIFwiP1wiLCBoYywgS3YsIFF2LCBXUF0uam9pbihcInxcIikgKyBcIilcIiwgUVAgPSBSZWdFeHAoZGMgKyBcIig/PVwiICsgZGMgKyBcIil8XCIgKyBLUCArIFpQLCBcImdcIik7XG5mdW5jdGlvbiBKUChlKSB7XG4gIHJldHVybiBlLm1hdGNoKFFQKSB8fCBbXTtcbn1cbmZ1bmN0aW9uIHQzKGUpIHtcbiAgcmV0dXJuIFl2KGUpID8gSlAoZSkgOiBIUChlKTtcbn1cbmZ1bmN0aW9uIGUzKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0ID0gdXModCk7XG4gICAgdmFyIG4gPSBZdih0KSA/IHQzKHQpIDogdm9pZCAwLCByID0gbiA/IG5bMF0gOiB0LmNoYXJBdCgwKSwgaSA9IG4gPyBMUChuLCAxKS5qb2luKFwiXCIpIDogdC5zbGljZSgxKTtcbiAgICByZXR1cm4gcltlXSgpICsgaTtcbiAgfTtcbn1cbnZhciBuMyA9IGUzKFwidG9VcHBlckNhc2VcIik7XG5mdW5jdGlvbiByMyhlKSB7XG4gIHJldHVybiBuMyh1cyhlKS50b0xvd2VyQ2FzZSgpKTtcbn1cbnZhciBpMyA9ICRnKGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgPSB0LnRvTG93ZXJDYXNlKCksIGUgKyAobiA/IHIzKHQpIDogdCk7XG59KTtcbmNsYXNzIFllIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHRoaXMuY29tcG9uZW50cyA9IFtdLCB0aGlzLnNlcnZpY2VzID0ge1xuICAgICAgY2FudmFzWm9vbTogY1AsXG4gICAgICBkb21VdGlsczogTixcbiAgICAgIGV2ZW50czogdVAsXG4gICAgICBmaWxlczogaFAsXG4gICAgICBncmFkaWVudFV0aWxzOiBObCxcbiAgICAgIHRyYW5zaXRpb25zOiBkUFxuICAgIH0sIHRoaXMubW9kZWwgPSBuZXcgYW4odGhpcy5zZXJ2aWNlcyk7XG4gIH1cbiAgLy8gQ29udGFpbnMgdGhlIGNvZGUgdGhhdCB1c2VzIHByb3BlcnRpZXMgdGhhdCBhcmUgb3ZlcnJpZGFibGUgYnkgdGhlIHN1cGVyLWNsYXNzXG4gIGluaXQodCwgbikge1xuICAgIHRoaXMubW9kZWwuc2V0KHsgaG9sZGVyOiB0IH0sIHsgc2tpcFVwZGF0ZTogITAgfSksIE9iamVjdC5rZXlzKHRoaXMuc2VydmljZXMpLmZvckVhY2goKHIpID0+IHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLnNlcnZpY2VzW3JdO1xuICAgICAgdGhpcy5zZXJ2aWNlc1tyXSA9IG5ldyBpKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpO1xuICAgIH0pLCB0aGlzLnNlcnZpY2VzLmV2ZW50cy5hZGRFdmVudExpc3RlbmVyKFQuTW9kZWwuVVBEQVRFLCAocikgPT4ge1xuICAgICAgY29uc3QgaSA9ICEheShyLCBcImRldGFpbFwiLCBcImFuaW1hdGVcIik7XG4gICAgICB0aGlzLnVwZGF0ZShpKTtcbiAgICB9KSwgdGhpcy5tb2RlbC5zZXREYXRhKG4uZGF0YSksIHRoaXMuc2VydmljZXMuZXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIoVC5DaGFydC5SRVNJWkUsICgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlKCExKTtcbiAgICB9KSwgdGhpcy5jb21wb25lbnRzID0gdGhpcy5nZXRDb21wb25lbnRzKCksIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY29tcG9uZW50cyB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGdyYXBoIGZyYW1lLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcG9uZW50W119IEFuIGFycmF5IG9mIGNvbXBvbmVudHMgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBnZXRDb21wb25lbnRzKCkge1xuICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiZ2V0Q29tcG9uZW50cygpIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWRcIiksIFtdO1xuICB9XG4gIHVwZGF0ZSh0ID0gITApIHtcbiAgICBpZiAoIXRoaXMuY29tcG9uZW50cylcbiAgICAgIHJldHVybjtcbiAgICBPYmplY3Qua2V5cyh0aGlzLnNlcnZpY2VzKS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICB0aGlzLnNlcnZpY2VzW2ldLnVwZGF0ZSgpO1xuICAgIH0pLCB0aGlzLmNvbXBvbmVudHMuZm9yRWFjaCgoaSkgPT4gaS5yZW5kZXIodCkpO1xuICAgIGNvbnN0IG4gPSB0aGlzLnNlcnZpY2VzLnRyYW5zaXRpb25zLmdldFBlbmRpbmdUcmFuc2l0aW9ucygpLCByID0gT2JqZWN0LmtleXMobikubWFwKChpKSA9PiBuW2ldLmVuZCgpLmNhdGNoKChzKSA9PiBzKSk7XG4gICAgUHJvbWlzZS5hbGwocikudGhlbihcbiAgICAgICgpID0+IHRoaXMuc2VydmljZXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoVC5DaGFydC5SRU5ERVJfRklOSVNIRUQpXG4gICAgKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKCh0KSA9PiB0LmRlc3Ryb3koKSksIHRoaXMuc2VydmljZXMuZG9tVXRpbHMuZ2V0SG9sZGVyKCkucmVtb3ZlKCksIHRoaXMubW9kZWwuc2V0KHsgZGVzdHJveWVkOiAhMCB9LCB7IHNraXBVcGRhdGU6ICEwIH0pO1xuICB9XG4gIGdldENoYXJ0Q29tcG9uZW50cyh0LCBuKSB7XG4gICAgY29uc3QgciA9IHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLCBpID0geShyLCBcInRvb2xiYXJcIiwgXCJlbmFibGVkXCIpLCBzID0ge1xuICAgICAgaWQ6IFwibGVnZW5kXCIsXG4gICAgICBjb21wb25lbnRzOiBbbmV3IGx1KHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpXSxcbiAgICAgIGdyb3d0aDogY3QuUFJFRkVSUkVEXG4gICAgfSwgYSA9IHkociwgXCJjYW52YXNab29tXCIsIFwiZW5hYmxlZFwiKTtcbiAgICBhICYmIGEgPT09ICEwICYmIHQucHVzaChuZXcgVmsodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcykpO1xuICAgIGNvbnN0IG8gPSAhIXRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLnRpdGxlLCBsID0ge1xuICAgICAgaWQ6IFwidGl0bGVcIixcbiAgICAgIGNvbXBvbmVudHM6IFtuZXcgYnModGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyldLFxuICAgICAgZ3Jvd3RoOiBjdC5TVFJFVENIXG4gICAgfSwgYyA9IHtcbiAgICAgIGlkOiBcInRvb2xiYXJcIixcbiAgICAgIGNvbXBvbmVudHM6IFtuZXcgcG8odGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyldLFxuICAgICAgZ3Jvd3RoOiBjdC5QUkVGRVJSRURcbiAgICB9LCB1ID0ge1xuICAgICAgaWQ6IFwiaGVhZGVyXCIsXG4gICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgIG5ldyBiZShcbiAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgIHRoaXMuc2VydmljZXMsXG4gICAgICAgICAgW1xuICAgICAgICAgICAgLy8gYWx3YXlzIGFkZCB0aXRsZSB0byBrZWVwIGxheW91dCBjb3JyZWN0XG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgLi4uaSA/IFtjXSA6IFtdXG4gICAgICAgICAgXSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkaXJlY3Rpb246IEF0LlJPVyxcbiAgICAgICAgICAgIGFsaWduSXRlbXM6IG5pLkNFTlRFUlxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgXSxcbiAgICAgIGdyb3d0aDogY3QuUFJFRkVSUkVEXG4gICAgfSwgZCA9IHtcbiAgICAgIGlkOiBcImdyYXBoLWZyYW1lXCIsXG4gICAgICBjb21wb25lbnRzOiB0LFxuICAgICAgZ3Jvd3RoOiBjdC5TVFJFVENILFxuICAgICAgcmVuZGVyVHlwZTogeShuLCBcImdyYXBoRnJhbWVSZW5kZXJUeXBlXCIpIHx8IHJ0LlNWR1xuICAgIH0sIGggPSB5KG4sIFwiZXhjbHVkZUxlZ2VuZFwiKSAhPT0gITAgJiYgci5sZWdlbmQuZW5hYmxlZCAhPT0gITE7XG4gICAgbGV0IHAgPSBBdC5DT0xVTU47XG4gICAgaWYgKGgpIHtcbiAgICAgIGNvbnN0IHYgPSB5KHIsIFwibGVnZW5kXCIsIFwicG9zaXRpb25cIik7XG4gICAgICB2ID09PSBcImxlZnRcIiA/IChwID0gQXQuUk9XLCByLmxlZ2VuZC5vcmllbnRhdGlvbiB8fCAoci5sZWdlbmQub3JpZW50YXRpb24gPSBqaS5WRVJUSUNBTCkpIDogdiA9PT0gXCJyaWdodFwiID8gKHAgPSBBdC5ST1dfUkVWRVJTRSwgci5sZWdlbmQub3JpZW50YXRpb24gfHwgKHIubGVnZW5kLm9yaWVudGF0aW9uID0gamkuVkVSVElDQUwpKSA6IHYgPT09IFwiYm90dG9tXCIgJiYgKHAgPSBBdC5DT0xVTU5fUkVWRVJTRSk7XG4gICAgfVxuICAgIGNvbnN0IGYgPSB7XG4gICAgICBpZDogXCJzcGFjZXJcIixcbiAgICAgIGNvbXBvbmVudHM6IFtuZXcgQW4odGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyldLFxuICAgICAgZ3Jvd3RoOiBjdC5QUkVGRVJSRURcbiAgICB9LCBnID0ge1xuICAgICAgaWQ6IFwiZnVsbC1mcmFtZVwiLFxuICAgICAgY29tcG9uZW50czogW1xuICAgICAgICBuZXcgYmUoXG4gICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICB0aGlzLnNlcnZpY2VzLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIC4uLmggPyBbc10gOiBbXSxcbiAgICAgICAgICAgIC4uLmggPyBbZl0gOiBbXSxcbiAgICAgICAgICAgIGRcbiAgICAgICAgICBdLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbjogcFxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgXSxcbiAgICAgIGdyb3d0aDogY3QuU1RSRVRDSFxuICAgIH0sIG0gPSBbXTtcbiAgICBpZiAobyB8fCBpKSB7XG4gICAgICBtLnB1c2godSk7XG4gICAgICBjb25zdCB2ID0ge1xuICAgICAgICBpZDogXCJzcGFjZXJcIixcbiAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgIG5ldyBBbih0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzLCBpID8geyBzaXplOiAxNSB9IDogdm9pZCAwKVxuICAgICAgICBdLFxuICAgICAgICBncm93dGg6IGN0LlBSRUZFUlJFRFxuICAgICAgfTtcbiAgICAgIG0ucHVzaCh2KTtcbiAgICB9XG4gICAgcmV0dXJuIG0ucHVzaChnKSwgW1xuICAgICAgbmV3IGN1KHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpLFxuICAgICAgbmV3IGZvKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpLFxuICAgICAgbmV3IGJlKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMsIG0sIHtcbiAgICAgICAgZGlyZWN0aW9uOiBBdC5DT0xVTU5cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufVxuY2xhc3MgbWUgZXh0ZW5kcyBZZSB7XG4gIGNvbnN0cnVjdG9yKHQsIG4pIHtcbiAgICBzdXBlcih0LCBuKSwgdGhpcy5zZXJ2aWNlcyA9IE9iamVjdC5hc3NpZ24odGhpcy5zZXJ2aWNlcywge1xuICAgICAgY2FydGVzaWFuU2NhbGVzOiB3UCxcbiAgICAgIGN1cnZlczogQ1AsXG4gICAgICB6b29tOiBBUFxuICAgIH0pLCB0aGlzLm1vZGVsID0gbmV3IG1yKHRoaXMuc2VydmljZXMpO1xuICB9XG4gIGdldEF4aXNDaGFydENvbXBvbmVudHModCwgbikge1xuICAgIGNvbnN0IHIgPSB0aGlzLm1vZGVsLmdldE9wdGlvbnMoKSwgaSA9IHkociwgXCJ6b29tQmFyXCIsIEcuVE9QLCBcImVuYWJsZWRcIiksIHMgPSB5KHIsIFwidG9vbGJhclwiLCBcImVuYWJsZWRcIik7XG4gICAgdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZGV0ZXJtaW5lQXhpc0R1YWxpdHkoKSwgdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZmluZERvbWFpbkFuZFJhbmdlQXhlcygpLCB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5kZXRlcm1pbmVPcmllbnRhdGlvbigpO1xuICAgIGNvbnN0IGEgPSB0aGlzLnNlcnZpY2VzLmNhcnRlc2lhblNjYWxlcy5nZXRNYWluWEF4aXNQb3NpdGlvbigpLCBvID0geShyLCBcImF4ZXNcIiwgYSwgXCJzY2FsZVR5cGVcIiksIGwgPSBpICYmIGEgPT09IEcuQk9UVE9NICYmIG8gPT09IGV0LlRJTUUsIGMgPSB0aGlzLnNlcnZpY2VzLnpvb20uaXNab29tQmFyTG9ja2VkKEcuVE9QKSwgdSA9ICEhdGhpcy5tb2RlbC5nZXRPcHRpb25zKCkudGl0bGUsIGQgPSB7XG4gICAgICBpZDogXCJ0aXRsZVwiLFxuICAgICAgY29tcG9uZW50czogW25ldyBicyh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzKV0sXG4gICAgICBncm93dGg6IGN0LlNUUkVUQ0hcbiAgICB9LCBoID0ge1xuICAgICAgaWQ6IFwidG9vbGJhclwiLFxuICAgICAgY29tcG9uZW50czogW25ldyBwbyh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzKV0sXG4gICAgICBncm93dGg6IGN0LlBSRUZFUlJFRFxuICAgIH0sIHAgPSB7XG4gICAgICBpZDogXCJoZWFkZXJcIixcbiAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgbmV3IGJlKFxuICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgdGhpcy5zZXJ2aWNlcyxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAvLyBhbHdheXMgYWRkIHRpdGxlIHRvIGtlZXAgbGF5b3V0IGNvcnJlY3RcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICAuLi5zID8gW2hdIDogW11cbiAgICAgICAgICBdLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbjogQXQuUk9XLFxuICAgICAgICAgICAgYWxpZ25JdGVtczogbmkuQ0VOVEVSXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICBdLFxuICAgICAgZ3Jvd3RoOiBjdC5QUkVGRVJSRURcbiAgICB9LCBmID0ge1xuICAgICAgaWQ6IFwibGVnZW5kXCIsXG4gICAgICBjb21wb25lbnRzOiBbbmV3IGx1KHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpXSxcbiAgICAgIGdyb3d0aDogY3QuUFJFRkVSUkVEXG4gICAgfTtcbiAgICBsICYmICFjICYmIHQucHVzaChcbiAgICAgIG5ldyB2dih0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzKSxcbiAgICAgIG5ldyBHayh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzKVxuICAgICksIHQucHVzaChuZXcgRmsodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcykpLCB0LnB1c2gobmV3IGprKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpKTtcbiAgICBjb25zdCBnID0ge1xuICAgICAgaWQ6IFwiZ3JhcGgtZnJhbWVcIixcbiAgICAgIGNvbXBvbmVudHM6IHQsXG4gICAgICBncm93dGg6IGN0LlNUUkVUQ0gsXG4gICAgICByZW5kZXJUeXBlOiBydC5TVkdcbiAgICB9LCBtID0geShuLCBcImxlZ2VuZFwiLCBcImVuYWJsZWRcIikgIT09ICExICYmIHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLmxlZ2VuZC5lbmFibGVkICE9PSAhMTtcbiAgICBsZXQgdiA9IEF0LkNPTFVNTjtcbiAgICBpZiAobSkge1xuICAgICAgY29uc3QgUyA9IHkodGhpcy5tb2RlbC5nZXRPcHRpb25zKCksIFwibGVnZW5kXCIsIFwicG9zaXRpb25cIik7XG4gICAgICBTID09PSBOaS5MRUZUID8gKHYgPSBBdC5ST1csIHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLmxlZ2VuZC5vcmllbnRhdGlvbiB8fCAodGhpcy5tb2RlbC5nZXRPcHRpb25zKCkubGVnZW5kLm9yaWVudGF0aW9uID0gamkuVkVSVElDQUwpKSA6IFMgPT09IE5pLlJJR0hUID8gKHYgPSBBdC5ST1dfUkVWRVJTRSwgdGhpcy5tb2RlbC5nZXRPcHRpb25zKCkubGVnZW5kLm9yaWVudGF0aW9uIHx8ICh0aGlzLm1vZGVsLmdldE9wdGlvbnMoKS5sZWdlbmQub3JpZW50YXRpb24gPSBqaS5WRVJUSUNBTCkpIDogUyA9PT0gTmkuQk9UVE9NICYmICh2ID0gQXQuQ09MVU1OX1JFVkVSU0UpO1xuICAgIH1cbiAgICBjb25zdCB4ID0ge1xuICAgICAgaWQ6IFwic3BhY2VyXCIsXG4gICAgICBjb21wb25lbnRzOiBbbmV3IEFuKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpXSxcbiAgICAgIGdyb3d0aDogY3QuUFJFRkVSUkVEXG4gICAgfSwgXyA9IHtcbiAgICAgIGlkOiBcImZ1bGwtZnJhbWVcIixcbiAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgbmV3IGJlKFxuICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgdGhpcy5zZXJ2aWNlcyxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAuLi5tID8gW2ZdIDogW10sXG4gICAgICAgICAgICAuLi5tID8gW3hdIDogW10sXG4gICAgICAgICAgICBnXG4gICAgICAgICAgXSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkaXJlY3Rpb246IHZcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIF0sXG4gICAgICBncm93dGg6IGN0LlNUUkVUQ0hcbiAgICB9LCBFID0ge1xuICAgICAgaWQ6IFwiem9vbS1iYXJcIixcbiAgICAgIGNvbXBvbmVudHM6IFtuZXcgemsodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyldLFxuICAgICAgZ3Jvd3RoOiBjdC5QUkVGRVJSRUQsXG4gICAgICByZW5kZXJUeXBlOiBydC5TVkdcbiAgICB9LCBiID0gW107XG4gICAgaWYgKHUgfHwgcykge1xuICAgICAgYi5wdXNoKHApO1xuICAgICAgY29uc3QgUyA9IHtcbiAgICAgICAgaWQ6IFwic3BhY2VyXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICBuZXcgQW4odGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcywgcyA/IHsgc2l6ZTogMTUgfSA6IHZvaWQgMClcbiAgICAgICAgXSxcbiAgICAgICAgZ3Jvd3RoOiBjdC5QUkVGRVJSRURcbiAgICAgIH07XG4gICAgICBiLnB1c2goUyk7XG4gICAgfVxuICAgIHJldHVybiBsICYmIGIucHVzaChFKSwgYi5wdXNoKF8pLCBbXG4gICAgICBuZXcgeHYodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgZm8odGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgYmUodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcywgYiwge1xuICAgICAgICBkaXJlY3Rpb246IEF0LkNPTFVNTlxuICAgICAgfSlcbiAgICBdO1xuICB9XG59XG5jbGFzcyBzMyBleHRlbmRzIFllIHtcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHN1cGVyKHQsIG4pLCB0aGlzLm1vZGVsID0gbmV3IFF3KHRoaXMuc2VydmljZXMpLCB0aGlzLm1vZGVsLnNldE9wdGlvbnMoUnQod3QuYWxsdXZpYWxDaGFydCwgbi5vcHRpb25zKSksIHRoaXMuaW5pdCh0LCBuKTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBjb21wb25lbnRzIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgZ3JhcGggZnJhbWUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wb25lbnRbXX0gQW4gYXJyYXkgb2YgY29tcG9uZW50cyB0byBiZSByZW5kZXJlZC5cbiAgICovXG4gIGdldENvbXBvbmVudHMoKSB7XG4gICAgY29uc3QgdCA9IFtuZXcgaEQodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyldO1xuICAgIHJldHVybiB0aGlzLmdldENoYXJ0Q29tcG9uZW50cyh0LCB7XG4gICAgICBleGNsdWRlTGVnZW5kOiAhMFxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBhMyBleHRlbmRzIG1lIHtcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHN1cGVyKHQsIG4pLCB0aGlzLm1vZGVsLnNldE9wdGlvbnMoXG4gICAgICBSdChTbih3dC5hcmVhQ2hhcnQpLCBuLm9wdGlvbnMpXG4gICAgKSwgdGhpcy5pbml0KHQsIG4pO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGNvbXBvbmVudHMgdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBncmFwaCBmcmFtZS5cbiAgICpcbiAgICogQHJldHVybnMge0NvbXBvbmVudFtdfSBBbiBhcnJheSBvZiBjb21wb25lbnRzIHRvIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgZ2V0Q29tcG9uZW50cygpIHtcbiAgICBjb25zdCB0ID0gW1xuICAgICAgbmV3IGZlKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpLFxuICAgICAgbmV3IE9lKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpLFxuICAgICAgbmV3IFZuKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpLFxuICAgICAgbmV3IEZyKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpLFxuICAgICAgbmV3IEV2KHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpLFxuICAgICAgbmV3IG5uKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMsIHtcbiAgICAgICAgZmFkZUluT25DaGFydEhvbGRlck1vdXNlb3ZlcjogITAsXG4gICAgICAgIGhhbmRsZVRocmVzaG9sZHM6ICEwXG4gICAgICB9KSxcbiAgICAgIG5ldyBjZSh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzLCB7XG4gICAgICAgIHNrZWxldG9uOiB6dC5HUklEXG4gICAgICB9KVxuICAgIF07XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXhpc0NoYXJ0Q29tcG9uZW50cyh0KTtcbiAgfVxufVxuY2xhc3MgbzMgZXh0ZW5kcyBtZSB7XG4gIGNvbnN0cnVjdG9yKHQsIG4pIHtcbiAgICBzdXBlcih0LCBuKSwgdGhpcy5tb2RlbCA9IG5ldyBKdyh0aGlzLnNlcnZpY2VzKSwgdGhpcy5tb2RlbC5zZXRPcHRpb25zKFJ0KHd0LmJveHBsb3RDaGFydCwgbi5vcHRpb25zKSksIHRoaXMuaW5pdCh0LCBuKTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBjb21wb25lbnRzIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgZ3JhcGggZnJhbWUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wb25lbnRbXX0gQW4gYXJyYXkgb2YgY29tcG9uZW50cyB0byBiZSByZW5kZXJlZC5cbiAgICovXG4gIGdldENvbXBvbmVudHMoKSB7XG4gICAgY29uc3QgdCA9IFtcbiAgICAgIG5ldyBmZSh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzKSxcbiAgICAgIG5ldyBPZSh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzKSxcbiAgICAgIG5ldyBmRCh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzKSxcbiAgICAgIG5ldyBzaSh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzKSxcbiAgICAgIG5ldyBjZSh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzLCB7XG4gICAgICAgIHNrZWxldG9uOiB6dC5WRVJUX09SX0hPUklaXG4gICAgICB9KVxuICAgIF07XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXhpc0NoYXJ0Q29tcG9uZW50cyh0LCB7XG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZW5hYmxlZDogITFcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgbDMgZXh0ZW5kcyBtZSB7XG4gIGNvbnN0cnVjdG9yKHQsIG4pIHtcbiAgICBzdXBlcih0LCBuKSwgdGhpcy5tb2RlbC5zZXRPcHRpb25zKFJ0KHd0LmJ1YmJsZUNoYXJ0LCBuLm9wdGlvbnMpKSwgdGhpcy5pbml0KHQsIG4pO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGNvbXBvbmVudHMgdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBncmFwaCBmcmFtZS5cbiAgICpcbiAgICogQHJldHVybnMge0NvbXBvbmVudFtdfSBBbiBhcnJheSBvZiBjb21wb25lbnRzIHRvIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgZ2V0Q29tcG9uZW50cygpIHtcbiAgICBjb25zdCB0ID0gW1xuICAgICAgbmV3IGZlKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpLFxuICAgICAgbmV3IE9lKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpLFxuICAgICAgbmV3IFZuKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpLFxuICAgICAgbmV3IG1EKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpLFxuICAgICAgbmV3IGNlKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMsIHtcbiAgICAgICAgc2tlbGV0b246IHp0LkdSSURcbiAgICAgIH0pXG4gICAgXTtcbiAgICByZXR1cm4gdGhpcy5nZXRBeGlzQ2hhcnRDb21wb25lbnRzKHQpO1xuICB9XG59XG5jbGFzcyBjMyBleHRlbmRzIG1lIHtcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHN1cGVyKHQsIG4pLCB0aGlzLm1vZGVsID0gbmV3IHQkKHRoaXMuc2VydmljZXMpLCB0aGlzLm1vZGVsLnNldE9wdGlvbnMoUnQod3QuYnVsbGV0Q2hhcnQsIG4ub3B0aW9ucykpLCB0aGlzLmluaXQodCwgbik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY29tcG9uZW50cyB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGdyYXBoIGZyYW1lLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcG9uZW50W119IEFuIGFycmF5IG9mIGNvbXBvbmVudHMgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBnZXRDb21wb25lbnRzKCkge1xuICAgIGNvbnN0IHQgPSBbXG4gICAgICBuZXcgZmUodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgT2UodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgZ0QodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgY2UodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcywge1xuICAgICAgICBza2VsZXRvbjogenQuR1JJRFxuICAgICAgfSlcbiAgICBdO1xuICAgIHJldHVybiB0aGlzLmdldEF4aXNDaGFydENvbXBvbmVudHModCk7XG4gIH1cbn1cbmNsYXNzIHUzIGV4dGVuZHMgWWUge1xuICBjb25zdHJ1Y3Rvcih0LCBuKSB7XG4gICAgc3VwZXIodCwgbiksIHRoaXMubW9kZWwgPSBuZXcgZSQodGhpcy5zZXJ2aWNlcyksIHRoaXMubW9kZWwuc2V0T3B0aW9ucyhcbiAgICAgIFJ0KHd0LmNob3JvcGxldGhDaGFydCwgbi5vcHRpb25zKVxuICAgICksIHRoaXMuaW5pdCh0LCBuKTtcbiAgfVxuICAvLyBDdXN0b20gZ2V0Q2hhcnRDb21wb25lbnRzIC0gSW1wbGVtZW50cyBnZXRDaGFydENvbXBvbmVudHNcbiAgLy8gUmVtb3ZlcyB6b29tYmFyIHN1cHBvcnQgYW5kIGFkZGl0aW9uYWwgYGZlYXR1cmVzYCB0aGF0IGFyZSBub3Qgc3VwcG9ydGVkIGluIGhlYXRtYXBcbiAgZ2V0Q2hhcnRDb21wb25lbnRzKHQsIG4pIHtcbiAgICBjb25zdCByID0gdGhpcy5tb2RlbC5nZXRPcHRpb25zKCksIGkgPSB5KHIsIFwidG9vbGJhclwiLCBcImVuYWJsZWRcIiksIHMgPSAhIXRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLnRpdGxlLCBhID0ge1xuICAgICAgaWQ6IFwidGl0bGVcIixcbiAgICAgIGNvbXBvbmVudHM6IFtuZXcgYnModGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyldLFxuICAgICAgZ3Jvd3RoOiBjdC5TVFJFVENIXG4gICAgfSwgbyA9IHtcbiAgICAgIGlkOiBcInRvb2xiYXJcIixcbiAgICAgIGNvbXBvbmVudHM6IFtuZXcgcG8odGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyldLFxuICAgICAgZ3Jvd3RoOiBjdC5QUkVGRVJSRURcbiAgICB9LCBsID0ge1xuICAgICAgaWQ6IFwiaGVhZGVyXCIsXG4gICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgIG5ldyBiZShcbiAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgIHRoaXMuc2VydmljZXMsXG4gICAgICAgICAgW1xuICAgICAgICAgICAgLy8gYWx3YXlzIGFkZCB0aXRsZSB0byBrZWVwIGxheW91dCBjb3JyZWN0XG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgLi4uaSA/IFtvXSA6IFtdXG4gICAgICAgICAgXSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkaXJlY3Rpb246IEF0LlJPVyxcbiAgICAgICAgICAgIGFsaWduSXRlbXM6IG5pLkNFTlRFUlxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgXSxcbiAgICAgIGdyb3d0aDogY3QuUFJFRkVSUkVEXG4gICAgfSwgYyA9IHtcbiAgICAgIGlkOiBcImxlZ2VuZFwiLFxuICAgICAgY29tcG9uZW50czogW1xuICAgICAgICBuZXcgU3YodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcywge1xuICAgICAgICAgIGNoYXJ0VHlwZTogXCJjaG9yb3BsZXRoXCJcbiAgICAgICAgfSlcbiAgICAgIF0sXG4gICAgICBncm93dGg6IGN0LlBSRUZFUlJFRCxcbiAgICAgIHJlbmRlclR5cGU6IHJ0LlNWR1xuICAgIH0sIHUgPSB7XG4gICAgICBpZDogXCJncmFwaC1mcmFtZVwiLFxuICAgICAgY29tcG9uZW50czogdCxcbiAgICAgIGdyb3d0aDogY3QuU1RSRVRDSCxcbiAgICAgIHJlbmRlclR5cGU6IHJ0LlNWR1xuICAgIH0sIGQgPSB5KG4sIFwibGVnZW5kXCIsIFwiZW5hYmxlZFwiKSAhPT0gITEgJiYgdGhpcy5tb2RlbC5nZXRPcHRpb25zKCkubGVnZW5kLmVuYWJsZWQgIT09ICExICYmIHRoaXMubW9kZWwuZ2V0RGF0YSgpLmxlbmd0aCA+IDAsIGggPSBBdC5DT0xVTU5fUkVWRVJTRSwgcCA9IHtcbiAgICAgIGlkOiBcInNwYWNlclwiLFxuICAgICAgY29tcG9uZW50czogW25ldyBBbih0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzLCB7IHNpemU6IDE1IH0pXSxcbiAgICAgIGdyb3d0aDogY3QuUFJFRkVSUkVEXG4gICAgfSwgZiA9IHtcbiAgICAgIGlkOiBcImZ1bGwtZnJhbWVcIixcbiAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgbmV3IGJlKFxuICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgdGhpcy5zZXJ2aWNlcyxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAuLi5kID8gW2NdIDogW10sXG4gICAgICAgICAgICAuLi5kID8gW3BdIDogW10sXG4gICAgICAgICAgICB1XG4gICAgICAgICAgXSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkaXJlY3Rpb246IGhcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIF0sXG4gICAgICBncm93dGg6IGN0LlNUUkVUQ0hcbiAgICB9LCBnID0gW107XG4gICAgaWYgKHMgfHwgaSkge1xuICAgICAgZy5wdXNoKGwpO1xuICAgICAgY29uc3QgbSA9IHtcbiAgICAgICAgaWQ6IFwic3BhY2VyXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICBuZXcgQW4odGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcywgaSA/IHsgc2l6ZTogMTUgfSA6IHZvaWQgMClcbiAgICAgICAgXSxcbiAgICAgICAgZ3Jvd3RoOiBjdC5QUkVGRVJSRURcbiAgICAgIH07XG4gICAgICBnLnB1c2gobSk7XG4gICAgfVxuICAgIHJldHVybiBnLnB1c2goZiksIFtcbiAgICAgIG5ldyBjdSh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzKSxcbiAgICAgIG5ldyBmbyh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzKSxcbiAgICAgIG5ldyBiZSh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzLCBnLCB7XG4gICAgICAgIGRpcmVjdGlvbjogQXQuQ09MVU1OXG4gICAgICB9KVxuICAgIF07XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY29tcG9uZW50cyB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGdyYXBoIGZyYW1lLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcG9uZW50W119IEFuIGFycmF5IG9mIGNvbXBvbmVudHMgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBnZXRDb21wb25lbnRzKCkge1xuICAgIGNvbnN0IHQgPSBbbmV3IGtOKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpXTtcbiAgICByZXR1cm4gdGhpcy5nZXRDaGFydENvbXBvbmVudHModCk7XG4gIH1cbn1cbmNsYXNzIGgzIGV4dGVuZHMgWWUge1xuICBjb25zdHJ1Y3Rvcih0LCBuKSB7XG4gICAgc3VwZXIodCwgbiksIHRoaXMubW9kZWwgPSBuZXcgbiQodGhpcy5zZXJ2aWNlcyksIHRoaXMubW9kZWwuc2V0T3B0aW9ucyhSdCh3dC5jaXJjbGVQYWNrQ2hhcnQsIG4ub3B0aW9ucykpLCB0aGlzLmluaXQodCwgbik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY29tcG9uZW50cyB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGdyYXBoIGZyYW1lLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcG9uZW50W119IEFuIGFycmF5IG9mIGNvbXBvbmVudHMgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBnZXRDb21wb25lbnRzKCkge1xuICAgIGNvbnN0IHQgPSBbbmV3IFJEKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpXTtcbiAgICByZXR1cm4gdGhpcy5nZXRDaGFydENvbXBvbmVudHModCk7XG4gIH1cbn1cbmNvbnN0IERwID0ge1xuICBbd2UuTElORV06IFtGciwgbm5dLFxuICBbd2UuU0NBVFRFUl06IFtubl0sXG4gIFt3ZS5BUkVBXTogW0V2LCBGciwgbm5dLFxuICBbd2UuU1RBQ0tFRF9BUkVBXTogW012LCBGciwgQXYsIFVhXSxcbiAgW3dlLlNJTVBMRV9CQVJdOiBbJHZdLFxuICBbd2UuR1JPVVBFRF9CQVJdOiBbd3YsIHNpXSxcbiAgW3dlLlNUQUNLRURfQkFSXTogW0N2LCBVYV1cbn07XG5jbGFzcyBkMyBleHRlbmRzIG1lIHtcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHN1cGVyKHQsIG4pO1xuICAgIGNvbnN0IHIgPSBSdCh3dC5jb21ib0NoYXJ0LCBuLm9wdGlvbnMpO1xuICAgIG4ub3B0aW9ucy5jb21ib0NoYXJ0VHlwZXMgfHwgKGNvbnNvbGUuZXJyb3IoXCJObyBjb21ib0NoYXJ0VHlwZXMgZGVmaW5lZCBmb3IgdGhlIENvbWJvIENoYXJ0IVwiKSwgci5jb21ib0NoYXJ0VHlwZXMgPSBbeyB0eXBlOiB3ZS5MSU5FLCBjb3JyZXNwb25kaW5nRGF0YXNldHM6IFtdIH1dKSwgdGhpcy5tb2RlbC5zZXRPcHRpb25zKHIpLCB0aGlzLmluaXQodCwgbik7XG4gIH1cbiAgZ2V0R3JhcGhDb21wb25lbnRzKCkge1xuICAgIGNvbnN0IHsgY29tYm9DaGFydFR5cGVzOiB0IH0gPSB0aGlzLm1vZGVsLmdldE9wdGlvbnMoKTtcbiAgICBsZXQgbiA9IDA7XG4gICAgY29uc3QgciA9IHQubWFwKChpKSA9PiB7XG4gICAgICBjb25zdCBzID0gaS50eXBlO1xuICAgICAgbGV0IGE7XG4gICAgICBpZiAodHlwZW9mIGkudHlwZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICghT2JqZWN0LmtleXMoRHApLmluY2x1ZGVzKGkudHlwZSkpXG4gICAgICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBgSW52YWxpZCBjaGFydCB0eXBlIFwiJHtpLnR5cGV9XCIgc3BlY2lmaWVkIGZvciBjb21ibyBjaGFydC4gUGxlYXNlIHJlZmVyIHRvIHRoZSBDb21ib0NoYXJ0IHR1dG9yaWFsIGZvciBtb3JlIGd1aWRhbmNlLmBcbiAgICAgICAgICApLCBudWxsO1xuICAgICAgICBsZXQgbyA9ICExO1xuICAgICAgICBjb25zdCBsID0gYCR7aTMoaS50eXBlKX1DaGFydGA7XG4gICAgICAgIHJldHVybiBhID0gYXQoe30sIHd0W2xdLCB0aGlzLm1vZGVsLmdldE9wdGlvbnMoKSwgaS5vcHRpb25zKSwgaS50eXBlID09PSB3ZS5TVEFDS0VEX0FSRUEgJiYgKG8gPSAhMCksIERwW2kudHlwZV0ubWFwKFxuICAgICAgICAgIChjKSA9PiBuZXcgYyh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzLCB7XG4gICAgICAgICAgICBncm91cHM6IGkuY29ycmVzcG9uZGluZ0RhdGFzZXRzLFxuICAgICAgICAgICAgaWQ6IG4rKyxcbiAgICAgICAgICAgIG9wdGlvbnM6IGEsXG4gICAgICAgICAgICBzdGFja2VkOiBvXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gYSA9IGF0KHt9LCB0aGlzLm1vZGVsLmdldE9wdGlvbnMoKSwgaS5vcHRpb25zKSwgbmV3IHModGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcywge1xuICAgICAgICAgIGdyb3VwczogaS5jb3JyZXNwb25kaW5nRGF0YXNldHMsXG4gICAgICAgICAgaWQ6IG4rKyxcbiAgICAgICAgICBvcHRpb25zOiBhXG4gICAgICAgIH0pO1xuICAgIH0pLmZpbHRlcigoaSkgPT4gaSAhPT0gbnVsbCk7XG4gICAgcmV0dXJuIGR1KHIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGNvbXBvbmVudHMgdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBncmFwaCBmcmFtZS5cbiAgICpcbiAgICogQHJldHVybnMge0NvbXBvbmVudFtdfSBBbiBhcnJheSBvZiBjb21wb25lbnRzIHRvIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgZ2V0Q29tcG9uZW50cygpIHtcbiAgICBjb25zdCB7IGNvbWJvQ2hhcnRUeXBlczogdCB9ID0gdGhpcy5tb2RlbC5nZXRPcHRpb25zKCksIG4gPSB0LnNvbWUoXG4gICAgICAoaSkgPT4gaS50eXBlID09PSB3ZS5TVEFDS0VEX0JBUiB8fCBpLnR5cGUgPT09IHdlLlNUQUNLRURfQVJFQVxuICAgICksIHIgPSBbXG4gICAgICBuZXcgZmUodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgT2UodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgY2UodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcywge1xuICAgICAgICBza2VsZXRvbjogenQuR1JJRFxuICAgICAgfSksXG4gICAgICAuLi5uID8gW10gOiBbbmV3IFZuKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpXSxcbiAgICAgIC4uLnRoaXMuZ2V0R3JhcGhDb21wb25lbnRzKClcbiAgICBdO1xuICAgIHJldHVybiB0aGlzLmdldEF4aXNDaGFydENvbXBvbmVudHMocik7XG4gIH1cbn1cbmNsYXNzIGUwIGV4dGVuZHMgWWUge1xuICAvLyBUT0RPIC0gT3B0aW1pemUgdGhlIHVzZSBvZiBcImV4dGVuZGluZ1wiXG4gIGNvbnN0cnVjdG9yKHQsIG4sIHIgPSAhMSkge1xuICAgIHN1cGVyKHQsIG4pLCB0aGlzLm1vZGVsID0gbmV3IHIkKHRoaXMuc2VydmljZXMpLCAhciAmJiAodGhpcy5tb2RlbC5zZXRPcHRpb25zKFJ0KHd0LnBpZUNoYXJ0LCBuLm9wdGlvbnMpKSwgdGhpcy5pbml0KHQsIG4pKTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBjb21wb25lbnRzIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgZ3JhcGggZnJhbWUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wb25lbnRbXX0gQW4gYXJyYXkgb2YgY29tcG9uZW50cyB0byBiZSByZW5kZXJlZC5cbiAgICovXG4gIGdldENvbXBvbmVudHMoKSB7XG4gICAgY29uc3QgdCA9IFtcbiAgICAgIG5ldyBUdih0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzKSxcbiAgICAgIG5ldyBjZSh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzLCB7XG4gICAgICAgIHNrZWxldG9uOiB6dC5QSUVcbiAgICAgIH0pXG4gICAgXTtcbiAgICByZXR1cm4gdGhpcy5nZXRDaGFydENvbXBvbmVudHModCk7XG4gIH1cbn1cbmNsYXNzIHAzIGV4dGVuZHMgZTAge1xuICBjb25zdHJ1Y3Rvcih0LCBuKSB7XG4gICAgc3VwZXIodCwgbiwgITApLCB0aGlzLm1vZGVsLnNldE9wdGlvbnMoUnQod3QuZG9udXRDaGFydCwgbi5vcHRpb25zKSksIHRoaXMuaW5pdCh0LCBuKTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBjb21wb25lbnRzIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgZ3JhcGggZnJhbWUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wb25lbnRbXX0gQW4gYXJyYXkgb2YgY29tcG9uZW50cyB0byBiZSByZW5kZXJlZC5cbiAgICovXG4gIGdldENvbXBvbmVudHMoKSB7XG4gICAgY29uc3QgdCA9IFtcbiAgICAgIG5ldyBORCh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzKSxcbiAgICAgIG5ldyBjZSh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzLCB7XG4gICAgICAgIHNrZWxldG9uOiB6dC5ET05VVFxuICAgICAgfSlcbiAgICBdO1xuICAgIHJldHVybiB0aGlzLmdldENoYXJ0Q29tcG9uZW50cyh0KTtcbiAgfVxufVxuY2xhc3MgZjMgZXh0ZW5kcyBZZSB7XG4gIGNvbnN0cnVjdG9yKHQsIG4pIHtcbiAgICBzdXBlcih0LCBuKSwgdGhpcy5tb2RlbCA9IG5ldyBpJCh0aGlzLnNlcnZpY2VzKSwgdGhpcy5tb2RlbC5zZXRPcHRpb25zKFJ0KHd0LmdhdWdlQ2hhcnQsIG4ub3B0aW9ucykpLCB0aGlzLmluaXQodCwgbik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY29tcG9uZW50cyB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGdyYXBoIGZyYW1lLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcG9uZW50W119IEFuIGFycmF5IG9mIGNvbXBvbmVudHMgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBnZXRDb21wb25lbnRzKCkge1xuICAgIGNvbnN0IHQgPSBbbmV3IFBEKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpXTtcbiAgICByZXR1cm4gdGhpcy5nZXRDaGFydENvbXBvbmVudHModCk7XG4gIH1cbn1cbmNsYXNzIG0zIGV4dGVuZHMgbWUge1xuICBjb25zdHJ1Y3Rvcih0LCBuKSB7XG4gICAgc3VwZXIodCwgbiksIHRoaXMubW9kZWwuc2V0T3B0aW9ucyhSdCh3dC5ncm91cGVkQmFyQ2hhcnQsIG4ub3B0aW9ucykpLCB0aGlzLmluaXQodCwgbik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY29tcG9uZW50cyB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGdyYXBoIGZyYW1lLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcG9uZW50W119IEFuIGFycmF5IG9mIGNvbXBvbmVudHMgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBnZXRDb21wb25lbnRzKCkge1xuICAgIGNvbnN0IHQgPSBbXG4gICAgICBuZXcgZmUodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgT2UodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgd3YodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgc2kodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgY2UodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcywge1xuICAgICAgICBza2VsZXRvbjogenQuVkVSVF9PUl9IT1JJWlxuICAgICAgfSlcbiAgICBdO1xuICAgIHJldHVybiB0aGlzLmdldEF4aXNDaGFydENvbXBvbmVudHModCk7XG4gIH1cbn1cbmNsYXNzIGczIGV4dGVuZHMgbWUge1xuICBjb25zdHJ1Y3Rvcih0LCBuKSB7XG4gICAgc3VwZXIodCwgbiksIHRoaXMubW9kZWwgPSBuZXcgcyQodGhpcy5zZXJ2aWNlcyksIHRoaXMubW9kZWwuc2V0T3B0aW9ucyhcbiAgICAgIFJ0KHd0LmhlYXRtYXBDaGFydCwgbi5vcHRpb25zKVxuICAgICksIHRoaXMuaW5pdCh0LCBuKTtcbiAgfVxuICAvLyBDdXN0b20gZ2V0Q2hhcnRDb21wb25lbnRzIC0gSW1wbGVtZW50cyBnZXRDaGFydENvbXBvbmVudHNcbiAgLy8gUmVtb3ZlcyB6b29tYmFyIHN1cHBvcnQgYW5kIGFkZGl0aW9uYWwgYGZlYXR1cmVzYCB0aGF0IGFyZSBub3Qgc3VwcG9ydGVkIGluIGhlYXRtYXBcbiAgZ2V0QXhpc0NoYXJ0Q29tcG9uZW50cyh0LCBuKSB7XG4gICAgY29uc3QgciA9IHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLCBpID0geShyLCBcInRvb2xiYXJcIiwgXCJlbmFibGVkXCIpO1xuICAgIHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmRldGVybWluZUF4aXNEdWFsaXR5KCksIHRoaXMuc2VydmljZXMuY2FydGVzaWFuU2NhbGVzLmZpbmREb21haW5BbmRSYW5nZUF4ZXMoKSwgdGhpcy5zZXJ2aWNlcy5jYXJ0ZXNpYW5TY2FsZXMuZGV0ZXJtaW5lT3JpZW50YXRpb24oKTtcbiAgICBjb25zdCBzID0gISF0aGlzLm1vZGVsLmdldE9wdGlvbnMoKS50aXRsZSwgYSA9IHtcbiAgICAgIGlkOiBcInRpdGxlXCIsXG4gICAgICBjb21wb25lbnRzOiBbbmV3IGJzKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpXSxcbiAgICAgIGdyb3d0aDogY3QuU1RSRVRDSFxuICAgIH0sIG8gPSB7XG4gICAgICBpZDogXCJ0b29sYmFyXCIsXG4gICAgICBjb21wb25lbnRzOiBbbmV3IHBvKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpXSxcbiAgICAgIGdyb3d0aDogY3QuUFJFRkVSUkVEXG4gICAgfSwgbCA9IHtcbiAgICAgIGlkOiBcImhlYWRlclwiLFxuICAgICAgY29tcG9uZW50czogW1xuICAgICAgICBuZXcgYmUoXG4gICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICB0aGlzLnNlcnZpY2VzLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIC8vIGFsd2F5cyBhZGQgdGl0bGUgdG8ga2VlcCBsYXlvdXQgY29ycmVjdFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIC4uLmkgPyBbb10gOiBbXVxuICAgICAgICAgIF0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGlyZWN0aW9uOiBBdC5ST1csXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiBuaS5DRU5URVJcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIF0sXG4gICAgICBncm93dGg6IGN0LlBSRUZFUlJFRFxuICAgIH0sIGMgPSB7XG4gICAgICBpZDogXCJsZWdlbmRcIixcbiAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgbmV3IFN2KHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMsIHtcbiAgICAgICAgICBjaGFydFR5cGU6IFwiaGVhdG1hcFwiXG4gICAgICAgIH0pXG4gICAgICBdLFxuICAgICAgZ3Jvd3RoOiBjdC5QUkVGRVJSRUQsXG4gICAgICByZW5kZXJUeXBlOiBydC5TVkdcbiAgICB9LCB1ID0ge1xuICAgICAgaWQ6IFwiZ3JhcGgtZnJhbWVcIixcbiAgICAgIGNvbXBvbmVudHM6IHQsXG4gICAgICBncm93dGg6IGN0LlNUUkVUQ0gsXG4gICAgICByZW5kZXJUeXBlOiBydC5TVkdcbiAgICB9LCBkID0geShuLCBcImxlZ2VuZFwiLCBcImVuYWJsZWRcIikgIT09ICExICYmIHRoaXMubW9kZWwuZ2V0T3B0aW9ucygpLmxlZ2VuZC5lbmFibGVkICE9PSAhMSAmJiB0aGlzLm1vZGVsLmdldERhdGEoKS5sZW5ndGggPiAwLCBoID0gQXQuQ09MVU1OX1JFVkVSU0UsIHAgPSB7XG4gICAgICBpZDogXCJzcGFjZXJcIixcbiAgICAgIGNvbXBvbmVudHM6IFtuZXcgQW4odGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcywgeyBzaXplOiAxNSB9KV0sXG4gICAgICBncm93dGg6IGN0LlBSRUZFUlJFRFxuICAgIH0sIGYgPSB7XG4gICAgICBpZDogXCJmdWxsLWZyYW1lXCIsXG4gICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgIG5ldyBiZShcbiAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgIHRoaXMuc2VydmljZXMsXG4gICAgICAgICAgW1xuICAgICAgICAgICAgLi4uZCA/IFtjXSA6IFtdLFxuICAgICAgICAgICAgLi4uZCA/IFtwXSA6IFtdLFxuICAgICAgICAgICAgdVxuICAgICAgICAgIF0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGlyZWN0aW9uOiBoXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICBdLFxuICAgICAgZ3Jvd3RoOiBjdC5TVFJFVENIXG4gICAgfSwgZyA9IFtdO1xuICAgIGlmIChzIHx8IGkpIHtcbiAgICAgIGcucHVzaChsKTtcbiAgICAgIGNvbnN0IG0gPSB7XG4gICAgICAgIGlkOiBcInNwYWNlclwiLFxuICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgbmV3IEFuKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMsIGkgPyB7IHNpemU6IDE1IH0gOiB2b2lkIDApXG4gICAgICAgIF0sXG4gICAgICAgIGdyb3d0aDogY3QuUFJFRkVSUkVEXG4gICAgICB9O1xuICAgICAgZy5wdXNoKG0pO1xuICAgIH1cbiAgICByZXR1cm4gZy5wdXNoKGYpLCBbXG4gICAgICBuZXcgeHYodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgZm8odGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgYmUodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcywgZywge1xuICAgICAgICBkaXJlY3Rpb246IEF0LkNPTFVNTlxuICAgICAgfSlcbiAgICBdO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGNvbXBvbmVudHMgdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBncmFwaCBmcmFtZS5cbiAgICpcbiAgICogQHJldHVybnMge0NvbXBvbmVudFtdfSBBbiBhcnJheSBvZiBjb21wb25lbnRzIHRvIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgZ2V0Q29tcG9uZW50cygpIHtcbiAgICBjb25zdCB0ID0gW1xuICAgICAgbmV3IGZlKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpLFxuICAgICAgbmV3IFVEKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpXG4gICAgXTtcbiAgICByZXR1cm4gdGhpcy5nZXRBeGlzQ2hhcnRDb21wb25lbnRzKHQpO1xuICB9XG59XG5jbGFzcyB2MyBleHRlbmRzIG1lIHtcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHN1cGVyKHQsIG4pLCB0aGlzLm1vZGVsID0gbmV3IGEkKHRoaXMuc2VydmljZXMpLCB0aGlzLm1vZGVsLnNldE9wdGlvbnMoUnQod3QuaGlzdG9ncmFtQ2hhcnQsIG4ub3B0aW9ucykpLCB0aGlzLmluaXQodCwgbiksIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY29tcG9uZW50cyB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGdyYXBoIGZyYW1lLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcG9uZW50W119IEFuIGFycmF5IG9mIGNvbXBvbmVudHMgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBnZXRDb21wb25lbnRzKCkge1xuICAgIGNvbnN0IHQgPSBbXG4gICAgICBuZXcgZmUodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgT2UodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgVEQodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgQkQodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcylcbiAgICBdO1xuICAgIHJldHVybiB0aGlzLmdldEF4aXNDaGFydENvbXBvbmVudHModCk7XG4gIH1cbn1cbmNsYXNzIHkzIGV4dGVuZHMgbWUge1xuICBjb25zdHJ1Y3Rvcih0LCBuKSB7XG4gICAgc3VwZXIodCwgbiksIHRoaXMubW9kZWwuc2V0T3B0aW9ucyhSdCh3dC5saW5lQ2hhcnQsIG4ub3B0aW9ucykpLCB0aGlzLmluaXQodCwgbik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY29tcG9uZW50cyB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGdyYXBoIGZyYW1lLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcG9uZW50W119IEFuIGFycmF5IG9mIGNvbXBvbmVudHMgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBnZXRDb21wb25lbnRzKCkge1xuICAgIGNvbnN0IHQgPSBbXG4gICAgICBuZXcgZmUodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgT2UodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgVm4odGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgRnIodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgbm4odGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcywgeyBoYW5kbGVUaHJlc2hvbGRzOiAhMCB9KSxcbiAgICAgIG5ldyB6RCh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzKSxcbiAgICAgIG5ldyBzaSh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzKVxuICAgIF07XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXhpc0NoYXJ0Q29tcG9uZW50cyh0KTtcbiAgfVxufVxuY2xhc3MgeDMgZXh0ZW5kcyBtZSB7XG4gIGNvbnN0cnVjdG9yKHQsIG4pIHtcbiAgICBzdXBlcih0LCBuKSwgdGhpcy5tb2RlbC5zZXRPcHRpb25zKFJ0KHd0LmxvbGxpcG9wQ2hhcnQsIG4ub3B0aW9ucykpLCB0aGlzLmluaXQodCwgbik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY29tcG9uZW50cyB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGdyYXBoIGZyYW1lLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcG9uZW50W119IEFuIGFycmF5IG9mIGNvbXBvbmVudHMgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBnZXRDb21wb25lbnRzKCkge1xuICAgIGNvbnN0IHQgPSBbXG4gICAgICBuZXcgZmUodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgT2UodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgVm4odGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgSEQodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgbm4odGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgY2UodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcywge1xuICAgICAgICBza2VsZXRvbjogenQuR1JJRFxuICAgICAgfSlcbiAgICBdO1xuICAgIHJldHVybiB0aGlzLmdldEF4aXNDaGFydENvbXBvbmVudHModCk7XG4gIH1cbn1cbmNsYXNzIGIzIGV4dGVuZHMgWWUge1xuICBjb25zdHJ1Y3Rvcih0LCBuKSB7XG4gICAgdmFyIHI7XG4gICAgc3VwZXIodCwgbiksIHRoaXMubW9kZWwgPSBuZXcgbyQodGhpcy5zZXJ2aWNlcyk7XG4gICAgY29uc3QgaSA9IChyID0gbi5vcHRpb25zLm1ldGVyKSAhPSBudWxsICYmIHIucHJvcG9ydGlvbmFsID8gYXQoU24od3QucHJvcG9ydGlvbmFsTWV0ZXJDaGFydCksIG4ub3B0aW9ucykgOiBhdChTbih3dC5tZXRlckNoYXJ0KSwgbi5vcHRpb25zKTtcbiAgICB0aGlzLm1vZGVsLnNldE9wdGlvbnMoaSksIHRoaXMuaW5pdCh0LCBuKTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBjb21wb25lbnRzIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgZ3JhcGggZnJhbWUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wb25lbnRbXX0gQW4gYXJyYXkgb2YgY29tcG9uZW50cyB0byBiZSByZW5kZXJlZC5cbiAgICovXG4gIGdldENvbXBvbmVudHMoKSB7XG4gICAgY29uc3QgdCA9IFtcbiAgICAgIC4uLnkodGhpcy5tb2RlbC5nZXRPcHRpb25zKCksIFwibWV0ZXJcIiwgXCJzaG93TGFiZWxzXCIpID8gW1xuICAgICAgICAvLyBNZXRlciBoYXMgYSB1bmlxdWUgZGF0YXNldCB0aXRsZSB3aXRoaW4gdGhlIGdyYXBoXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogXCJtZXRlci10aXRsZVwiLFxuICAgICAgICAgIGNvbXBvbmVudHM6IFtuZXcgREQodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyldLFxuICAgICAgICAgIGdyb3d0aDogY3QuU1RSRVRDSCxcbiAgICAgICAgICByZW5kZXJUeXBlOiBydC5TVkdcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSB0aXRsZSBzcGFjZXJcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBcInNwYWNlclwiLFxuICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgIG5ldyBBbih0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzLCB7XG4gICAgICAgICAgICAgIHNpemU6IDhcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgXSxcbiAgICAgICAgICBncm93dGg6IGN0LlNUUkVUQ0hcbiAgICAgICAgfVxuICAgICAgXSA6IFtdLFxuICAgICAgLy8gU3BlY2lmeSB3aGF0IHRvIHJlbmRlciBpbnNpZGUgdGhlIGdyYXBoIG9ubHlcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwibWV0ZXItZ3JhcGhcIixcbiAgICAgICAgY29tcG9uZW50czogW25ldyBWRCh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzKV0sXG4gICAgICAgIGdyb3d0aDogY3QuU1RSRVRDSCxcbiAgICAgICAgcmVuZGVyVHlwZTogcnQuU1ZHXG4gICAgICB9XG4gICAgXSwgbiA9IFtcbiAgICAgIG5ldyBiZSh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzLCB0LCB7XG4gICAgICAgIGRpcmVjdGlvbjogQXQuQ09MVU1OXG4gICAgICB9KVxuICAgIF07XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2hhcnRDb21wb25lbnRzKG4sIHtcbiAgICAgIGdyYXBoRnJhbWVSZW5kZXJUeXBlOiBydC5IVE1MXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIF8zIGV4dGVuZHMgWWUge1xuICBjb25zdHJ1Y3Rvcih0LCBuKSB7XG4gICAgc3VwZXIodCwgbiksIHRoaXMubW9kZWwgPSBuZXcgbCQodGhpcy5zZXJ2aWNlcyksIHRoaXMubW9kZWwuc2V0T3B0aW9ucyhSdCh3dC5yYWRhckNoYXJ0LCBuLm9wdGlvbnMpKSwgdGhpcy5pbml0KHQsIG4pO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGNvbXBvbmVudHMgdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBncmFwaCBmcmFtZS5cbiAgICpcbiAgICogQHJldHVybnMge0NvbXBvbmVudFtdfSBBbiBhcnJheSBvZiBjb21wb25lbnRzIHRvIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgZ2V0Q29tcG9uZW50cygpIHtcbiAgICBjb25zdCB0ID0gW25ldyBHRCh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzKV07XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2hhcnRDb21wb25lbnRzKHQpO1xuICB9XG59XG5jbGFzcyBFMyBleHRlbmRzIG1lIHtcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHN1cGVyKHQsIG4pLCB0aGlzLm1vZGVsLnNldE9wdGlvbnMoUnQod3Quc2NhdHRlckNoYXJ0LCBuLm9wdGlvbnMpKSwgdGhpcy5pbml0KHQsIG4pO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGNvbXBvbmVudHMgdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBncmFwaCBmcmFtZS5cbiAgICpcbiAgICogQHJldHVybnMge0NvbXBvbmVudFtdfSBBbiBhcnJheSBvZiBjb21wb25lbnRzIHRvIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgZ2V0Q29tcG9uZW50cygpIHtcbiAgICBjb25zdCB0ID0gW1xuICAgICAgbmV3IGZlKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpLFxuICAgICAgbmV3IE9lKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpLFxuICAgICAgbmV3IFZuKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpLFxuICAgICAgbmV3IG5uKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpLFxuICAgICAgbmV3IGNlKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMsIHtcbiAgICAgICAgc2tlbGV0b246IHp0LkdSSURcbiAgICAgIH0pXG4gICAgXTtcbiAgICByZXR1cm4gdGhpcy5nZXRBeGlzQ2hhcnRDb21wb25lbnRzKHQpO1xuICB9XG59XG5jbGFzcyBPMyBleHRlbmRzIFllIHtcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHN1cGVyKHQsIG4pLCB0aGlzLm1vZGVsID0gbmV3IGMkKHRoaXMuc2VydmljZXMpLCB0aGlzLm1vZGVsLnNldE9wdGlvbnMoUnQod3QudHJlZUNoYXJ0LCBuLm9wdGlvbnMpKSwgdGhpcy5pbml0KHQsIG4pO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGNvbXBvbmVudHMgdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBncmFwaCBmcmFtZS5cbiAgICpcbiAgICogQHJldHVybnMge0NvbXBvbmVudFtdfSBBbiBhcnJheSBvZiBjb21wb25lbnRzIHRvIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgZ2V0Q29tcG9uZW50cygpIHtcbiAgICBjb25zdCB0ID0gW25ldyBGRCh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzKV07XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2hhcnRDb21wb25lbnRzKHQsIHtcbiAgICAgIGV4Y2x1ZGVMZWdlbmQ6ICEwXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFMzIGV4dGVuZHMgWWUge1xuICBjb25zdHJ1Y3Rvcih0LCBuKSB7XG4gICAgc3VwZXIodCwgbiksIHRoaXMubW9kZWwgPSBuZXcgdSQodGhpcy5zZXJ2aWNlcyksIHRoaXMubW9kZWwuc2V0T3B0aW9ucyhSdCh3dC50cmVlbWFwQ2hhcnQsIG4ub3B0aW9ucykpLCB0aGlzLmluaXQodCwgbik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY29tcG9uZW50cyB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGdyYXBoIGZyYW1lLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcG9uZW50W119IEFuIGFycmF5IG9mIGNvbXBvbmVudHMgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBnZXRDb21wb25lbnRzKCkge1xuICAgIGNvbnN0IHQgPSBbbmV3IHhOKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpXTtcbiAgICByZXR1cm4gdGhpcy5nZXRDaGFydENvbXBvbmVudHModCk7XG4gIH1cbn1cbmNsYXNzIFQzIGV4dGVuZHMgbWUge1xuICBjb25zdHJ1Y3Rvcih0LCBuKSB7XG4gICAgc3VwZXIodCwgbiksIHRoaXMubW9kZWwuc2V0T3B0aW9ucyhSdCh3dC5zaW1wbGVCYXJDaGFydCwgbi5vcHRpb25zKSksIHRoaXMuaW5pdCh0LCBuKTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBjb21wb25lbnRzIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgZ3JhcGggZnJhbWUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wb25lbnRbXX0gQW4gYXJyYXkgb2YgY29tcG9uZW50cyB0byBiZSByZW5kZXJlZC5cbiAgICovXG4gIGdldENvbXBvbmVudHMoKSB7XG4gICAgY29uc3QgdCA9IFtcbiAgICAgIG5ldyBmZSh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzKSxcbiAgICAgIG5ldyBPZSh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzKSxcbiAgICAgIG5ldyAkdih0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzKSxcbiAgICAgIG5ldyBzaSh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzKSxcbiAgICAgIG5ldyBjZSh0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzLCB7XG4gICAgICAgIHNrZWxldG9uOiB6dC5WRVJUX09SX0hPUklaXG4gICAgICB9KVxuICAgIF07XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXhpc0NoYXJ0Q29tcG9uZW50cyh0KTtcbiAgfVxufVxuY2xhc3MgdzMgZXh0ZW5kcyBtZSB7XG4gIGNvbnN0cnVjdG9yKHQsIG4pIHtcbiAgICBzdXBlcih0LCBuKSwgdGhpcy5tb2RlbC5zZXRPcHRpb25zKFJ0KHd0LnN0YWNrZWRBcmVhQ2hhcnQsIG4ub3B0aW9ucykpLCB0aGlzLmluaXQodCwgbik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY29tcG9uZW50cyB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGdyYXBoIGZyYW1lLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcG9uZW50W119IEFuIGFycmF5IG9mIGNvbXBvbmVudHMgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBnZXRDb21wb25lbnRzKCkge1xuICAgIGNvbnN0IHQgPSBbXG4gICAgICBuZXcgZmUodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgT2UodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgVWEodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgTXYodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgRnIodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcywgeyBzdGFja2VkOiAhMCB9KSxcbiAgICAgIG5ldyBBdih0aGlzLm1vZGVsLCB0aGlzLnNlcnZpY2VzLCB7XG4gICAgICAgIGZhZGVJbk9uQ2hhcnRIb2xkZXJNb3VzZW92ZXI6ICEwLFxuICAgICAgICBoYW5kbGVUaHJlc2hvbGRzOiAhMCxcbiAgICAgICAgc3RhY2tlZDogITBcbiAgICAgIH0pLFxuICAgICAgbmV3IGNlKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMsIHtcbiAgICAgICAgc2tlbGV0b246IHp0LkdSSURcbiAgICAgIH0pXG4gICAgXTtcbiAgICByZXR1cm4gdGhpcy5nZXRBeGlzQ2hhcnRDb21wb25lbnRzKHQpO1xuICB9XG59XG5jbGFzcyAkMyBleHRlbmRzIG1lIHtcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHN1cGVyKHQsIG4pLCB0aGlzLm1vZGVsLnNldE9wdGlvbnMoUnQod3Quc3RhY2tlZEJhckNoYXJ0LCBuLm9wdGlvbnMpKSwgdGhpcy5pbml0KHQsIG4pO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGNvbXBvbmVudHMgdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBncmFwaCBmcmFtZS5cbiAgICpcbiAgICogQHJldHVybnMge0NvbXBvbmVudFtdfSBBbiBhcnJheSBvZiBjb21wb25lbnRzIHRvIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgZ2V0Q29tcG9uZW50cygpIHtcbiAgICBjb25zdCB0ID0gW1xuICAgICAgbmV3IGZlKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpLFxuICAgICAgbmV3IE9lKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpLFxuICAgICAgbmV3IFVhKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpLFxuICAgICAgbmV3IEN2KHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpLFxuICAgICAgbmV3IGNlKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMsIHtcbiAgICAgICAgc2tlbGV0b246IHp0LlZFUlRfT1JfSE9SSVpcbiAgICAgIH0pLFxuICAgICAgbmV3IHNpKHRoaXMubW9kZWwsIHRoaXMuc2VydmljZXMpXG4gICAgXTtcbiAgICByZXR1cm4gdGhpcy5nZXRBeGlzQ2hhcnRDb21wb25lbnRzKHQpO1xuICB9XG59XG5jbGFzcyBNMyBleHRlbmRzIFllIHtcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHN1cGVyKHQsIG4pLCB0aGlzLm1vZGVsID0gbmV3IGgkKHRoaXMuc2VydmljZXMpLCB0aGlzLm1vZGVsLnNldE9wdGlvbnMoUnQod3Qud29yZENsb3VkQ2hhcnQsIG4ub3B0aW9ucykpLCB0aGlzLmluaXQodCwgbik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY29tcG9uZW50cyB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGdyYXBoIGZyYW1lLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcG9uZW50W119IEFuIGFycmF5IG9mIGNvbXBvbmVudHMgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBnZXRDb21wb25lbnRzKCkge1xuICAgIGNvbnN0IHQgPSBbXG4gICAgICBuZXcgQU4odGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcyksXG4gICAgICBuZXcgY2UodGhpcy5tb2RlbCwgdGhpcy5zZXJ2aWNlcywge1xuICAgICAgICBza2VsZXRvbjogenQuUElFXG4gICAgICB9KVxuICAgIF07XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2hhcnRDb21wb25lbnRzKHQpO1xuICB9XG59XG5jbGFzcyBrdCBleHRlbmRzIEN0LlB1cmVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIFNvKHRoaXMsIFwiY2hhcnRcIik7XG4gICAgU28odGhpcywgXCJjaGFydFJlZlwiLCBDdC5jcmVhdGVSZWYoKSk7XG4gIH1cbiAgLy8gVE9ETzogYWRkIGFic3RyYWN0IGtleXdvcmQgb25jZSBSZWFjdCAxNiBzdXBwb3J0IG5vIGxvbmdlciBuZWVkZWQgdGhlbiByZW1vdmUgdGhlIG5leHQgMyBjb21tZW50c1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gIC8vIEB0cy1pZ25vcmVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBjcmVhdGVDaGFydChuLCByLCBpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5jaGFydFJlZi5jdXJyZW50ICYmICF0aGlzLmNoYXJ0ICYmICh0aGlzLmNoYXJ0ID0gdGhpcy5jcmVhdGVDaGFydCh0aGlzLmNoYXJ0UmVmLmN1cnJlbnQsIHRoaXMucHJvcHMuZGF0YSwgdGhpcy5wcm9wcy5vcHRpb25zKSk7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKG4pIHtcbiAgICB2YXIgciwgaTtcbiAgICB0aGlzLnByb3BzLmRhdGEgIT09IG4uZGF0YSAmJiAoKHIgPSB0aGlzLmNoYXJ0KSA9PSBudWxsIHx8IHIubW9kZWwuc2V0RGF0YSh0aGlzLnByb3BzLmRhdGEpKSwgdGhpcy5wcm9wcy5vcHRpb25zICE9PSBuLm9wdGlvbnMgJiYgKChpID0gdGhpcy5jaGFydCkgPT0gbnVsbCB8fCBpLm1vZGVsLnNldE9wdGlvbnModGhpcy5wcm9wcy5vcHRpb25zKSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBDdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLmNoYXJ0UmVmLCBjbGFzc05hbWU6IFwiY2hhcnQtaG9sZGVyXCIgfSk7XG4gIH1cbn1cbmNsYXNzIFozIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyBzMyh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIEszIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyBhMyh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIFEzIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyBvMyh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIEozIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyBsMyh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIHRVIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyBjMyh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIGVVIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyB1Myh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIG5VIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyBoMyh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIHJVIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyBkMyh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIGlVIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyBwMyh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIHNVIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyBmMyh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIGFVIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyBtMyh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIG9VIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyBnMyh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIGxVIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyB2Myh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIGNVIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyB5Myh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIHVVIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyB4Myh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIGhVIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyBiMyh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIGRVIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyBlMCh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIHBVIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyBfMyh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIGZVIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyBFMyh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIG1VIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyBUMyh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIGdVIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyB3Myh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIHZVIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyAkMyh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIHlVIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyBPMyh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIHhVIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyBTMyh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmNsYXNzIGJVIGV4dGVuZHMga3Qge1xuICBjcmVhdGVDaGFydCh0LCBuLCByKSB7XG4gICAgcmV0dXJuIG5ldyBNMyh0LCB7IGRhdGE6IG4sIG9wdGlvbnM6IHIgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIEMzKGUpIHtcbiAgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCBcImRlZmF1bHRcIikgPyBlLmRlZmF1bHQgOiBlO1xufVxudmFyIGRsID0geyBleHBvcnRzOiB7fSB9O1xuLyohXG5cdENvcHlyaWdodCAoYykgMjAxOCBKZWQgV2F0c29uLlxuXHRMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuXHRodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xudmFyIFJwO1xuZnVuY3Rpb24gQTMoKSB7XG4gIHJldHVybiBScCB8fCAoUnAgPSAxLCBmdW5jdGlvbihlKSB7XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHQgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgIGZ1bmN0aW9uIG4oKSB7XG4gICAgICAgIGZvciAodmFyIHMgPSBcIlwiLCBhID0gMDsgYSA8IGFyZ3VtZW50cy5sZW5ndGg7IGErKykge1xuICAgICAgICAgIHZhciBvID0gYXJndW1lbnRzW2FdO1xuICAgICAgICAgIG8gJiYgKHMgPSBpKHMsIHIobykpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHIocykge1xuICAgICAgICBpZiAodHlwZW9mIHMgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgcyA9PSBcIm51bWJlclwiKVxuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICBpZiAodHlwZW9mIHMgIT0gXCJvYmplY3RcIilcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocykpXG4gICAgICAgICAgcmV0dXJuIG4uYXBwbHkobnVsbCwgcyk7XG4gICAgICAgIGlmIChzLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nICYmICFzLnRvU3RyaW5nLnRvU3RyaW5nKCkuaW5jbHVkZXMoXCJbbmF0aXZlIGNvZGVdXCIpKVxuICAgICAgICAgIHJldHVybiBzLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBhID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgbyBpbiBzKVxuICAgICAgICAgIHQuY2FsbChzLCBvKSAmJiBzW29dICYmIChhID0gaShhLCBvKSk7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaShzLCBhKSB7XG4gICAgICAgIHJldHVybiBhID8gcyA/IHMgKyBcIiBcIiArIGEgOiBzICsgYSA6IHM7XG4gICAgICB9XG4gICAgICBlLmV4cG9ydHMgPyAobi5kZWZhdWx0ID0gbiwgZS5leHBvcnRzID0gbikgOiB3aW5kb3cuY2xhc3NOYW1lcyA9IG47XG4gICAgfSkoKTtcbiAgfShkbCkpLCBkbC5leHBvcnRzO1xufVxudmFyIEwzID0gQTMoKTtcbmNvbnN0IEduID0gLyogQF9fUFVSRV9fICovIEMzKEwzKSwgem4gPSBcImNkc1wiLCBfVSA9ICh7IHRhZzogZSA9IFwiZGl2XCIsIGNsYXNzTmFtZTogdCwgY2hpbGRyZW46IG4sIGNvbG9yOiByLCBocmVmOiBpLCBwb3NpdGlvbjogcyA9IFwic3RhdGljXCIsIHN0YWNrZWQ6IGEsIC4uLm8gfSkgPT4ge1xuICBjb25zdCBsID0gaSA/IFwiYVwiIDogby5vbkNsaWNrID8gXCJidXR0b25cIiA6IGUsIGMgPSBgJHt6bn0tLWNjLS1jYXJkLW5vZGVgLCB1ID0gR24oYywge1xuICAgIFtgJHtjfS0tc3RhY2tlZGBdOiBhLFxuICAgIFtgJHtjfS0tJHtsfWBdOiBsLFxuICAgIFt0XTogdFxuICB9KTtcbiAgcmV0dXJuIEN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgbCxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IHUsXG4gICAgICBzdHlsZTogeyBib3JkZXJDb2xvcjogciwgcG9zaXRpb246IHMgfSxcbiAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgLi4ub1xuICAgIH0sXG4gICAgblxuICApO1xufSwgRVUgPSAoe1xuICBjaGlsZHJlbjogZSxcbiAgZmFyc2lkZUNvbHVtbjogdCA9ICExLFxuICAuLi5uXG59KSA9PiB7XG4gIGNvbnN0IHIgPSBgJHt6bn0tLWNjLS1jYXJkLW5vZGVgLCBpID0gR24oYCR7cn1fX2NvbHVtbmAsIHtcbiAgICBbYCR7cn1fX2NvbHVtbi0tZmFyc2lkZWBdOiB0LFxuICAgIC4uLm4uY2xhc3NOYW1lID8geyBbbi5jbGFzc05hbWVdOiAhMCB9IDoge31cbiAgfSk7XG4gIHJldHVybiBDdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBpLCAuLi5uIH0sIGUpO1xufSwgT1UgPSAoe1xuICBjaGlsZHJlbjogZSxcbiAgLi4udFxufSkgPT4ge1xuICBjb25zdCBuID0gYCR7em59LS1jYy0tY2FyZC1ub2RlYCwgciA9IEduKGAke259X19sYWJlbGAsIHtcbiAgICAuLi50LmNsYXNzTmFtZSA/IHsgW3QuY2xhc3NOYW1lXTogITAgfSA6IHt9XG4gIH0pO1xuICByZXR1cm4gQ3QuY3JlYXRlRWxlbWVudChcImxhYmVsXCIsIHsgY2xhc3NOYW1lOiByLCAuLi50IH0sIGUpO1xufSwgU1UgPSAoe1xuICBjaGlsZHJlbjogZSxcbiAgLi4udFxufSkgPT4ge1xuICBjb25zdCBuID0gYCR7em59LS1jYy0tY2FyZC1ub2RlYCwgciA9IEduKGAke259X19zdWJ0aXRsZWAsIHtcbiAgICAuLi50LmNsYXNzTmFtZSA/IHsgW3QuY2xhc3NOYW1lXTogITAgfSA6IHt9XG4gIH0pO1xuICByZXR1cm4gQ3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogciwgLi4udCB9LCBlKTtcbn0sIFRVID0gKHtcbiAgY2hpbGRyZW46IGUsXG4gIC4uLnRcbn0pID0+IHtcbiAgY29uc3QgbiA9IGAke3pufS0tY2MtLWNhcmQtbm9kZWAsIHIgPSBHbihgJHtufV9fdGl0bGVgLCB7XG4gICAgLi4udC5jbGFzc05hbWUgPyB7IFt0LmNsYXNzTmFtZV06ICEwIH0gOiB7fVxuICB9KTtcbiAgcmV0dXJuIEN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IHIsIC4uLnQgfSwgZSk7XG59LCB3VSA9ICh7XG4gIGNvbG9yOiBlLFxuICBtYXJrZXJFbmQ6IHQsXG4gIG1hcmtlclN0YXJ0OiBuLFxuICBwYXRoOiByLFxuICBzb3VyY2U6IGksXG4gIHRhcmdldDogcyxcbiAgdmFyaWFudDogYSA9IG51bGwsXG4gIC4uLm9cbn0pID0+IHtcbiAgY29uc3QgbCA9IGAke3pufS0tY2MtLWVkZ2VgLCBjID0gR24obCwge1xuICAgIFtgJHtsfS0tJHthfWBdOiBhLFxuICAgIC4uLm8uY2xhc3NOYW1lID8geyBbby5jbGFzc05hbWVdOiAhMCB9IDoge31cbiAgfSk7XG4gIGxldCB1ID0gcjtcbiAgaWYgKCF1ICYmIGkgJiYgcyAmJiAodSA9IHdEKGksIHMpKSwgIXUpIHRocm93IEVycm9yKFwiTWlzc2luZyBwYXJhbWV0ZXJzIGZvciBFZGdlIGNvbXBvbmVudDogcGF0aCBvciBzb3VyY2UgYW5kIHRhcmdldC5cIik7XG4gIHJldHVybiBDdC5jcmVhdGVFbGVtZW50KFxuICAgIFwiZ1wiLFxuICAgIHsgY2xhc3NOYW1lOiBjLCAuLi5vIH0sXG4gICAgQ3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiB1LCBjbGFzc05hbWU6IGAke2x9X19jb250YWluZXJgIH0pLFxuICAgIEN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogdSwgY2xhc3NOYW1lOiBgJHtsfV9fb3V0ZXJgIH0pLFxuICAgIEN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgIGQ6IHUsXG4gICAgICBjbGFzc05hbWU6IGAke2x9X19pbm5lcmAsXG4gICAgICBtYXJrZXJFbmQ6IGB1cmwoIyR7dH0pYCxcbiAgICAgIG1hcmtlclN0YXJ0OiBgdXJsKCMke259KWAsXG4gICAgICBzdHlsZTogeyBzdHJva2U6IGUgfVxuICAgIH0pXG4gICk7XG59LCBhaSA9ICh7XG4gIGNvbG9yOiBlLFxuICBkOiB0LFxuICBpZDogbixcbiAgb3JpZW50OiByID0gXCJhdXRvXCIsXG4gIGhlaWdodDogaSxcbiAgd2lkdGg6IHMsXG4gIHBvc2l0aW9uOiBhID0gXCJlbmRcIixcbiAgY2xhc3NOYW1lOiBvLFxuICByZWZYOiBsLFxuICByZWZZOiBjLFxuICAuLi51XG59KSA9PiB7XG4gIGNvbnN0IGQgPSBgJHt6bn0tLWNjLS1tYXJrZXJgLCBoID0gR24oZCwgbyksIHAgPSBhID09PSBcImVuZFwiID8gKHMgfHwgMCkgLyAyICsgMC41IDogMC41LCBmID0gKGkgfHwgMCkgLyAyO1xuICByZXR1cm4gQ3QuY3JlYXRlRWxlbWVudChcbiAgICBcIm1hcmtlclwiLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogaCxcbiAgICAgIG1hcmtlckhlaWdodDogaSxcbiAgICAgIG1hcmtlcldpZHRoOiBzLFxuICAgICAgb3JpZW50OiByLFxuICAgICAgaWQ6IG4sXG4gICAgICByZWZYOiBsIHx8IHAsXG4gICAgICByZWZZOiBjIHx8IGYsXG4gICAgICBtYXJrZXJVbml0czogXCJ1c2VyU3BhY2VPblVzZVwiLFxuICAgICAgLi4udVxuICAgIH0sXG4gICAgQ3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiB0LCBzdHlsZTogeyBmaWxsOiBlIH0gfSlcbiAgKTtcbn0sICRVID0gKGUpID0+IEN0LmNyZWF0ZUVsZW1lbnQoYWksIHsgZDogJEQuZCwgLi4uZSB9KSwgTVUgPSAoZSkgPT4gQ3QuY3JlYXRlRWxlbWVudChhaSwgeyBkOiBNRC5kLCAuLi5lIH0pLCBDVSA9IChlKSA9PiBDdC5jcmVhdGVFbGVtZW50KGFpLCB7IGQ6IENELmQsIC4uLmUgfSksIEFVID0gKGUpID0+IEN0LmNyZWF0ZUVsZW1lbnQoYWksIHsgZDogQUQuZCwgLi4uZSB9KSwgTFUgPSAoZSkgPT4gQ3QuY3JlYXRlRWxlbWVudChhaSwgeyBkOiBMRC5kLCAuLi5lIH0pLCBrVSA9IChlKSA9PiBDdC5jcmVhdGVFbGVtZW50KGFpLCB7IGQ6IGtELmQsIC4uLmUgfSksIERVID0gKHtcbiAgc2hhcGU6IGUgPSBcImNpcmNsZVwiLFxuICB0YWc6IHQgPSBcImRpdlwiLFxuICB0aXRsZTogbiA9IFwiVGl0bGVcIixcbiAgY2xhc3NOYW1lOiByLFxuICBzdWJ0aXRsZTogaSxcbiAgZGVzY3JpcHRpb246IHMsXG4gIHJlbmRlckljb246IGEsXG4gIGhyZWY6IG8sXG4gIHNpemU6IGwgPSA0OCxcbiAgc3RhY2tlZDogYyxcbiAgcG9zaXRpb246IHUgPSBcImZpeGVkXCIsXG4gIGJvZHlQb3NpdGlvbjogZCA9IFwiYWJzb2x1dGVcIixcbiAgLi4uaFxufSkgPT4ge1xuICBjb25zdCBwID0gbyA/IFwiYVwiIDogaC5vbkNsaWNrID8gXCJidXR0b25cIiA6IHQsIGYgPSBgJHt6bn0tLWNjLS1zaGFwZS1ub2RlYCwgZyA9IEduKGYsIHtcbiAgICBbYCR7Zn0tLXN0YWNrZWRgXTogYyxcbiAgICBbYCR7Zn0tLSR7ZX1gXTogZSxcbiAgICBbYCR7Zn0tLSR7cH1gXTogcCxcbiAgICBbcl06IHJcbiAgfSksIG0gPSBuID8gQ3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogYCR7Zn1fX3RpdGxlYCB9LCBuKSA6IG51bGwsIHYgPSBpID8gQ3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogYCR7Zn1fX3N1YnRpdGxlYCB9LCBpKSA6IG51bGwsIHggPSBzID8gQ3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogYCR7Zn1fX2Rlc2NyaXB0aW9uYCB9LCBzKSA6IG51bGw7XG4gIHJldHVybiBDdC5jcmVhdGVFbGVtZW50KFxuICAgIHAsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBnLFxuICAgICAgc3R5bGU6IHsgaGVpZ2h0OiBsLCB3aWR0aDogbCwgcG9zaXRpb246IHUgfSxcbiAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgLi4uaFxuICAgIH0sXG4gICAgQ3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogYCR7Zn1fX2ljb25gIH0sIGEpLFxuICAgIEN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcImRpdlwiLFxuICAgICAgeyBjbGFzc05hbWU6IGAke2Z9X19ib2R5YCwgc3R5bGU6IHsgcG9zaXRpb246IGQgfSB9LFxuICAgICAgbSxcbiAgICAgIHYsXG4gICAgICB4XG4gICAgKVxuICApO1xufTtcbmV4cG9ydCB7XG4gIGp0IGFzIEFsaWdubWVudHMsXG4gIFozIGFzIEFsbHV2aWFsQ2hhcnQsXG4gIEszIGFzIEFyZWFDaGFydCxcbiAgenAgYXMgQXJlYUV2ZW50LFxuICBwbCBhcyBBcnJvd0RpcmVjdGlvbnMsXG4gICRVIGFzIEFycm93TGVmdE1hcmtlcixcbiAgTVUgYXMgQXJyb3dSaWdodE1hcmtlcixcbiAgR3AgYXMgQXhpc0V2ZW50LFxuICBHYSBhcyBBeGlzRmxhdm9yLFxuICBHIGFzIEF4aXNQb3NpdGlvbnMsXG4gIGZsIGFzIEF4aXNUaXRsZU9yaWVudGF0aW9ucyxcbiAgcXAgYXMgQmFyRXZlbnQsXG4gIFEzIGFzIEJveHBsb3RDaGFydCxcbiAgWXAgYXMgQm94cGxvdEV2ZW50LFxuICBKMyBhcyBCdWJibGVDaGFydCxcbiAgdFUgYXMgQnVsbGV0Q2hhcnQsXG4gIEZzIGFzIENhbGxvdXREaXJlY3Rpb25zLFxuICBWcCBhcyBDYW52YXNab29tRXZlbnQsXG4gIF9VIGFzIENhcmROb2RlLFxuICBFVSBhcyBDYXJkTm9kZUNvbHVtbixcbiAgT1UgYXMgQ2FyZE5vZGVMYWJlbCxcbiAgU1UgYXMgQ2FyZE5vZGVTdWJ0aXRsZSxcbiAgVFUgYXMgQ2FyZE5vZGVUaXRsZSxcbiAgRnQgYXMgQ2FydGVzaWFuT3JpZW50YXRpb25zLFxuICBJcCBhcyBDaGFydEV2ZW50LFxuICBvZiBhcyBDaGFydFRoZW1lLFxuICB3ZSBhcyBDaGFydFR5cGVzLFxuICBlVSBhcyBDaG9yb3BsZXRoQ2hhcnQsXG4gIENVIGFzIENpcmNsZU1hcmtlcixcbiAgblUgYXMgQ2lyY2xlUGFja0NoYXJ0LFxuICBpdCBhcyBDb2xvckNsYXNzTmFtZVR5cGVzLFxuICBxcyBhcyBDb2xvckxlZ2VuZFR5cGUsXG4gIHJVIGFzIENvbWJvQ2hhcnQsXG4gIEFVIGFzIERpYW1vbmRNYXJrZXIsXG4gIFBpIGFzIERpdmlkZXJTdGF0dXMsXG4gIHBuIGFzIERvbWluYW50QmFzZWxpbmUsXG4gIGlVIGFzIERvbnV0Q2hhcnQsXG4gIHdVIGFzIEVkZ2UsXG4gIGVVIGFzIEV4cGVyaW1lbnRhbENob3JvcGxldGhDaGFydCxcbiAgc1UgYXMgR2F1Z2VDaGFydCxcbiAgV3AgYXMgR2F1Z2VFdmVudCxcbiAgUnIgYXMgR2F1Z2VUeXBlcyxcbiAgYVUgYXMgR3JvdXBlZEJhckNoYXJ0LFxuICBvVSBhcyBIZWF0bWFwQ2hhcnQsXG4gIGxVIGFzIEhpc3RvZ3JhbUNoYXJ0LFxuICBuaSBhcyBMYXlvdXRBbGlnbkl0ZW1zLFxuICBBdCBhcyBMYXlvdXREaXJlY3Rpb24sXG4gIGN0IGFzIExheW91dEdyb3d0aCxcbiAgR3QgYXMgTGVnZW5kSXRlbVR5cGUsXG4gIGppIGFzIExlZ2VuZE9yaWVudGF0aW9ucyxcbiAgTmkgYXMgTGVnZW5kUG9zaXRpb25zLFxuICBjVSBhcyBMaW5lQ2hhcnQsXG4gIFpwIGFzIExpbmVFdmVudCxcbiAgdVUgYXMgTG9sbGlwb3BDaGFydCxcbiAgYWkgYXMgTWFya2VyLFxuICBoVSBhcyBNZXRlckNoYXJ0LFxuICBOcCBhcyBNb2RhbEV2ZW50LFxuICBQcCBhcyBNb2RlbEV2ZW50LFxuICBkVSBhcyBQaWVDaGFydCxcbiAganAgYXMgUGllRXZlbnQsXG4gIGduIGFzIFByb2plY3Rpb24sXG4gIHBVIGFzIFJhZGFyQ2hhcnQsXG4gIEtwIGFzIFJhZGFyRXZlbnQsXG4gIHJ0IGFzIFJlbmRlclR5cGVzLFxuICBldCBhcyBTY2FsZVR5cGVzLFxuICBmVSBhcyBTY2F0dGVyQ2hhcnQsXG4gIFhwIGFzIFNjYXR0ZXJFdmVudCxcbiAgRFUgYXMgU2hhcGVOb2RlLFxuICBtVSBhcyBTaW1wbGVCYXJDaGFydCxcbiAgenQgYXMgU2tlbGV0b25zLFxuICBMVSBhcyBTcXVhcmVNYXJrZXIsXG4gIGdVIGFzIFN0YWNrZWRBcmVhQ2hhcnQsXG4gIHZVIGFzIFN0YWNrZWRCYXJDaGFydCxcbiAganMgYXMgU3RhdHVzZXMsXG4gIGtVIGFzIFRlZU1hcmtlcixcbiAgZG4gYXMgVGV4dEFuY2hvcixcbiAgdGYgYXMgVGhyZXNob2xkRXZlbnQsXG4gIFdzIGFzIFRpY2tSb3RhdGlvbnMsXG4gIF90IGFzIFRvb2xiYXJDb250cm9sVHlwZXMsXG4gIElpIGFzIFRvb2x0aXBFdmVudCxcbiAgeVUgYXMgVHJlZUNoYXJ0LFxuICBRcCBhcyBUcmVlRXZlbnQsXG4gIHBjIGFzIFRyZWVUeXBlcyxcbiAgeFUgYXMgVHJlZW1hcENoYXJ0LFxuICBKcCBhcyBUcmVlbWFwRXZlbnQsXG4gIFZlIGFzIFRydW5jYXRpb25UeXBlcyxcbiAgYlUgYXMgV29yZENsb3VkQ2hhcnQsXG4gIEZwIGFzIFdvcmRDbG91ZEV2ZW50LFxuICBLZSBhcyBab29tQmFyVHlwZXMsXG4gIEhwIGFzIFpvb21Eb21haW5FdmVudCxcbiAgQnAgYXMgWm9vbWJhckV2ZW50XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8645\n')}}]);